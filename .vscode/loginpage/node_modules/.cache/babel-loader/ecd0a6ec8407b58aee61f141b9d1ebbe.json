{"ast":null,"code":"var debug = require('debug')('eventstore'),\n    util = require('util'),\n    EventEmitter = require('events').EventEmitter,\n    _ = require('lodash'),\n    async = require('async'),\n    tolerate = require('tolerance'),\n    EventDispatcher = require('./eventDispatcher'),\n    EventStream = require('./eventStream'),\n    Snapshot = require('./snapshot');\n/**\n * Eventstore constructor\n * @param {Object} options The options.\n * @param {Store}  store   The db implementation.\n * @constructor\n */\n\n\nfunction Eventstore(options, store) {\n  this.options = options || {};\n  this.store = store;\n  this.eventMappings = {};\n  EventEmitter.call(this);\n}\n\nutil.inherits(Eventstore, EventEmitter);\n\n_.extend(Eventstore.prototype, {\n  /**\n   * Inject function for event publishing.\n   * @param {Function} fn the function to be injected\n   * @returns {Eventstore}  to be able to chain...\n   */\n  useEventPublisher: function (fn) {\n    if (fn.length === 1) {\n      fn = _.wrap(fn, function (func, evt, callback) {\n        func(evt);\n        callback(null);\n      });\n    }\n\n    this.publisher = fn;\n    return this;\n  },\n\n  /**\n   * Define which values should be mapped/copied to the payload event. [optional]\n   * @param {Object} mappings the mappings in dotty notation\n   *                          {\n   *                            id: 'id',\n   *                            commitId: 'commitId',\n   *                            commitSequence: 'commitSequence',\n   *                            commitStamp: 'commitStamp',\n   *                            streamRevision: 'streamRevision'\n   *                          }\n   * @returns {Eventstore}  to be able to chain...\n   */\n  defineEventMappings: function (mappings) {\n    if (!mappings || !_.isObject(mappings)) {\n      var err = new Error('Please pass a valid mapping values!');\n      debug(err);\n      throw err;\n    }\n\n    this.eventMappings = mappings;\n    return this;\n  },\n\n  /**\n   * Call this function to initialize the eventstore.\n   * If an event publisher function was injected it will additionally initialize an event dispatcher.\n   * @param {Function} callback the function that will be called when this action has finished [optional]\n   */\n  init: function (callback) {\n    var self = this;\n\n    function initDispatcher() {\n      debug('init event dispatcher');\n      self.dispatcher = new EventDispatcher(self.publisher, self);\n      self.dispatcher.start(callback);\n    }\n\n    this.store.on('connect', function () {\n      self.emit('connect');\n    });\n    this.store.on('disconnect', function () {\n      self.emit('disconnect');\n    });\n    process.nextTick(function () {\n      tolerate(function (callback) {\n        self.store.connect(callback);\n      }, self.options.timeout || 0, function (err) {\n        if (err) {\n          debug(err);\n          if (callback) callback(err);\n          return;\n        }\n\n        if (!self.publisher) {\n          debug('no publisher defined');\n          if (callback) callback(null);\n          return;\n        }\n\n        initDispatcher();\n      });\n    });\n  },\n  // streaming api\n\n  /**\n   * streams the events\n   * @param {Object || String} query    the query object [optional]\n   * @param {Number}           skip     how many events should be skipped? [optional]\n   * @param {Number}           limit    how many events do you want in the result? [optional]\n   * @returns {Stream} a stream with the events\n   */\n  streamEvents: function (query, skip, limit) {\n    if (!this.store.streamEvents) {\n      throw new Error('Streaming API is not suppoted by ' + (this.options.type || 'inmemory') + ' db implementation.');\n    }\n\n    if (typeof query === 'number') {\n      limit = skip;\n      skip = query;\n      query = {};\n    }\n\n    ;\n\n    if (typeof query === 'string') {\n      query = {\n        aggregateId: query\n      };\n    }\n\n    return this.store.streamEvents(query, skip, limit);\n  },\n\n  /**\n   * streams all the events since passed commitStamp\n   * @param {Date}     commitStamp the date object\n   * @param {Number}   skip        how many events should be skipped? [optional]\n   * @param {Number}   limit       how many events do you want in the result? [optional]\n   * @returns {Stream} a stream with the events\n   */\n  streamEventsSince: function (commitStamp, skip, limit) {\n    if (!this.store.streamEvents) {\n      throw new Error('Streaming API is not suppoted by ' + (this.options.type || 'inmemory') + ' db implementation.');\n    }\n\n    if (!commitStamp) {\n      var err = new Error('Please pass in a date object!');\n      debug(err);\n      throw err;\n    }\n\n    var self = this;\n    commitStamp = new Date(commitStamp);\n    return this.store.streamEventsSince(commitStamp, skip, limit);\n  },\n\n  /**\n   * stream events by revision\n   * @param {Object || String} query    the query object\n   * @param {Number}           revMin   revision start point [optional]\n   * @param {Number}           revMax   revision end point (hint: -1 = to end) [optional]\n   * @returns {Stream} a stream with the events\n   */\n  streamEventsByRevision: function (query, revMin, revMax) {\n    if (typeof query === 'string') {\n      query = {\n        aggregateId: query\n      };\n    }\n\n    if (!query.aggregateId) {\n      var err = new Error('An aggregateId should be passed!');\n      debug(err);\n      if (callback) callback(err);\n      return;\n    }\n\n    return this.store.streamEventsByRevision(query, revMin, revMax);\n  },\n\n  /**\n   * loads the events\n   * @param {Object || String} query    the query object [optional]\n   * @param {Number}           skip     how many events should be skipped? [optional]\n   * @param {Number}           limit    how many events do you want in the result? [optional]\n   * @param {Function}         callback the function that will be called when this action has finished\n   *                                    `function(err, events){}`\n   */\n  getEvents: function (query, skip, limit, callback) {\n    if (typeof query === 'function') {\n      callback = query;\n      skip = 0;\n      limit = -1;\n      query = {};\n    } else if (typeof skip === 'function') {\n      callback = skip;\n      skip = 0;\n      limit = -1;\n\n      if (typeof query === 'number') {\n        skip = query;\n        query = {};\n      }\n    } else if (typeof limit === 'function') {\n      callback = limit;\n      limit = -1;\n\n      if (typeof query === 'number') {\n        limit = skip;\n        skip = query;\n        query = {};\n      }\n    }\n\n    if (typeof query === 'string') {\n      query = {\n        aggregateId: query\n      };\n    }\n\n    var self = this;\n\n    function nextFn(callback) {\n      if (limit < 0) {\n        var resEvts = [];\n        resEvts.next = nextFn;\n        return process.nextTick(function () {\n          callback(null, resEvts);\n        });\n      }\n\n      skip += limit;\n\n      _getEvents(query, skip, limit, callback);\n    }\n\n    function _getEvents(query, skip, limit, callback) {\n      self.store.getEvents(query, skip, limit, function (err, evts) {\n        if (err) return callback(err);\n        evts.next = nextFn;\n        callback(null, evts);\n      });\n    }\n\n    _getEvents(query, skip, limit, callback);\n  },\n\n  /**\n   * loads all the events since passed commitStamp\n   * @param {Date}     commitStamp the date object\n   * @param {Number}   skip        how many events should be skipped? [optional]\n   * @param {Number}   limit       how many events do you want in the result? [optional]\n   * @param {Function} callback    the function that will be called when this action has finished\n   *                               `function(err, events){}`\n   */\n  getEventsSince: function (commitStamp, skip, limit, callback) {\n    if (!commitStamp) {\n      var err = new Error('Please pass in a date object!');\n      debug(err);\n      throw err;\n    }\n\n    if (typeof skip === 'function') {\n      callback = skip;\n      skip = 0;\n      limit = -1;\n    } else if (typeof limit === 'function') {\n      callback = limit;\n      limit = -1;\n    }\n\n    var self = this;\n\n    function nextFn(callback) {\n      if (limit < 0) {\n        var resEvts = [];\n        resEvts.next = nextFn;\n        return process.nextTick(function () {\n          callback(null, resEvts);\n        });\n      }\n\n      skip += limit;\n\n      _getEventsSince(commitStamp, skip, limit, callback);\n    }\n\n    commitStamp = new Date(commitStamp);\n\n    function _getEventsSince(commitStamp, skip, limit, callback) {\n      self.store.getEventsSince(commitStamp, skip, limit, function (err, evts) {\n        if (err) return callback(err);\n        evts.next = nextFn;\n        callback(null, evts);\n      });\n    }\n\n    _getEventsSince(commitStamp, skip, limit, callback);\n  },\n\n  /**\n   * loads the events\n   * @param {Object || String} query    the query object\n   * @param {Number}           revMin   revision start point [optional]\n   * @param {Number}           revMax   revision end point (hint: -1 = to end) [optional]\n   * @param {Function}         callback the function that will be called when this action has finished\n   *                                    `function(err, events){}`\n   */\n  getEventsByRevision: function (query, revMin, revMax, callback) {\n    if (typeof revMin === 'function') {\n      callback = revMin;\n      revMin = 0;\n      revMax = -1;\n    } else if (typeof revMax === 'function') {\n      callback = revMax;\n      revMax = -1;\n    }\n\n    if (typeof query === 'string') {\n      query = {\n        aggregateId: query\n      };\n    }\n\n    if (!query.aggregateId) {\n      var err = new Error('An aggregateId should be passed!');\n      debug(err);\n      if (callback) callback(err);\n      return;\n    }\n\n    this.store.getEventsByRevision(query, revMin, revMax, callback);\n  },\n\n  /**\n   * loads the event stream\n   * @param {Object || String} query    the query object\n   * @param {Number}           revMin   revision start point [optional]\n   * @param {Number}           revMax   revision end point (hint: -1 = to end) [optional]\n   * @param {Function}         callback the function that will be called when this action has finished\n   *                                    `function(err, eventstream){}`\n   */\n  getEventStream: function (query, revMin, revMax, callback) {\n    if (typeof revMin === 'function') {\n      callback = revMin;\n      revMin = 0;\n      revMax = -1;\n    } else if (typeof revMax === 'function') {\n      callback = revMax;\n      revMax = -1;\n    }\n\n    if (typeof query === 'string') {\n      query = {\n        aggregateId: query\n      };\n    }\n\n    if (!query.aggregateId) {\n      var err = new Error('An aggregateId should be passed!');\n      debug(err);\n      if (callback) callback(err);\n      return;\n    }\n\n    var self = this;\n    this.getEventsByRevision(query, revMin, revMax, function (err, evts) {\n      if (err) {\n        return callback(err);\n      }\n\n      callback(null, new EventStream(self, query, evts));\n    });\n  },\n\n  /**\n   * loads the next snapshot back from given max revision\n   * @param {Object || String} query    the query object\n   * @param {Number}           revMax   revision end point (hint: -1 = to end) [optional]\n   * @param {Function}         callback the function that will be called when this action has finished\n   *                                    `function(err, snapshot, eventstream){}`\n   */\n  getFromSnapshot: function (query, revMax, callback) {\n    if (typeof revMax === 'function') {\n      callback = revMax;\n      revMax = -1;\n    }\n\n    if (typeof query === 'string') {\n      query = {\n        aggregateId: query\n      };\n    }\n\n    if (!query.aggregateId) {\n      var err = new Error('An aggregateId should be passed!');\n      debug(err);\n      if (callback) callback(err);\n      return;\n    }\n\n    var self = this;\n    async.waterfall([function getSnapshot(callback) {\n      self.store.getSnapshot(query, revMax, callback);\n    }, function getEventStream(snap, callback) {\n      var rev = 0;\n\n      if (snap && snap.revision !== undefined && snap.revision !== null) {\n        rev = snap.revision + 1;\n      }\n\n      self.getEventStream(query, rev, revMax, function (err, stream) {\n        if (err) {\n          return callback(err);\n        }\n\n        if (rev > 0 && stream.lastRevision == -1) {\n          stream.lastRevision = snap.revision;\n        }\n\n        callback(null, snap, stream);\n      });\n    }], callback);\n  },\n\n  /**\n   * stores a new snapshot\n   * @param {Object}   obj      the snapshot data\n   * @param {Function} callback the function that will be called when this action has finished [optional]\n   */\n  createSnapshot: function (obj, callback) {\n    if (obj.streamId && !obj.aggregateId) {\n      obj.aggregateId = obj.streamId;\n    }\n\n    if (!obj.aggregateId) {\n      var err = new Error('An aggregateId should be passed!');\n      debug(err);\n      if (callback) callback(err);\n      return;\n    }\n\n    obj.streamId = obj.aggregateId;\n\n    if (obj.revision) {\n      if (typeof obj.revision === 'string') {\n        const castedRevision = parseFloat(obj.revision);\n\n        if (castedRevision && castedRevision.toString() === obj.revision) {\n          // Determines if the revision was parsed correctly, for the cases where user using custom typed revisions that's not in valid float format like: obj.revision = '1,2,3'\n          obj.revision = castedRevision;\n        }\n      }\n    }\n\n    var self = this;\n    async.waterfall([function getNewIdFromStorage(callback) {\n      self.getNewId(callback);\n    }, function commit(id, callback) {\n      try {\n        var snap = new Snapshot(id, obj);\n        snap.commitStamp = new Date();\n      } catch (err) {\n        return callback(err);\n      }\n\n      self.store.addSnapshot(snap, function (error) {\n        if (self.options.maxSnapshotsCount) {\n          self.store.cleanSnapshots(_.pick(obj, 'aggregateId', 'aggregate', 'context'), callback);\n        } else {\n          callback(error);\n        }\n      });\n    }], callback);\n  },\n\n  /**\n   * commits all uncommittedEvents in the eventstream\n   * @param eventstream the eventstream that should be saved (hint: directly use the commit function on eventstream)\n   * @param {Function}  callback the function that will be called when this action has finished\n   *                             `function(err, eventstream){}` (hint: eventstream.eventsToDispatch)\n   */\n  commit: function (eventstream, callback) {\n    var self = this;\n    async.waterfall([function getNewCommitId(callback) {\n      self.getNewId(callback);\n    }, function commitEvents(id, callback) {\n      // start committing.\n      var event,\n          currentRevision = eventstream.currentRevision(),\n          uncommittedEvents = [].concat(eventstream.uncommittedEvents);\n      eventstream.uncommittedEvents = [];\n      self.store.getNextPositions(uncommittedEvents.length, function (err, positions) {\n        if (err) return callback(err);\n\n        for (var i = 0, len = uncommittedEvents.length; i < len; i++) {\n          event = uncommittedEvents[i];\n          event.id = id + i.toString();\n          event.commitId = id;\n          event.commitSequence = i;\n          event.restInCommitStream = len - 1 - i;\n          event.commitStamp = new Date();\n          currentRevision++;\n          event.streamRevision = currentRevision;\n          if (positions) event.position = positions[i];\n          event.applyMappings();\n        }\n\n        self.store.addEvents(uncommittedEvents, function (err) {\n          if (err) {\n            // add uncommitted events back to eventstream\n            eventstream.uncommittedEvents = uncommittedEvents.concat(eventstream.uncommittedEvents);\n            return callback(err);\n          }\n\n          if (self.publisher && self.dispatcher) {\n            // push to undispatchedQueue\n            self.dispatcher.addUndispatchedEvents(uncommittedEvents);\n          } else {\n            eventstream.eventsToDispatch = [].concat(uncommittedEvents);\n          } // move uncommitted events to events\n\n\n          eventstream.events = eventstream.events.concat(uncommittedEvents);\n          eventstream.currentRevision();\n          callback(null, eventstream);\n        });\n      });\n    }], callback);\n  },\n\n  /**\n   * loads all undispatched events\n   * @param {Object || String} query    the query object [optional]\n   * @param {Function}         callback the function that will be called when this action has finished\n   *                                    `function(err, events){}`\n   */\n  getUndispatchedEvents: function (query, callback) {\n    if (!callback) {\n      callback = query;\n      query = null;\n    }\n\n    if (typeof query === 'string') {\n      query = {\n        aggregateId: query\n      };\n    }\n\n    this.store.getUndispatchedEvents(query, callback);\n  },\n\n  /**\n   * loads the last event\n   * @param {Object || String} query    the query object [optional]\n   * @param {Function}         callback the function that will be called when this action has finished\n   *                                    `function(err, event){}`\n   */\n  getLastEvent: function (query, callback) {\n    if (!callback) {\n      callback = query;\n      query = null;\n    }\n\n    if (typeof query === 'string') {\n      query = {\n        aggregateId: query\n      };\n    }\n\n    this.store.getLastEvent(query, callback);\n  },\n\n  /**\n   * loads the last event in a stream\n   * @param {Object || String} query    the query object [optional]\n   * @param {Function}         callback the function that will be called when this action has finished\n   *                                    `function(err, eventstream){}`\n   */\n  getLastEventAsStream: function (query, callback) {\n    if (!callback) {\n      callback = query;\n      query = null;\n    }\n\n    if (typeof query === 'string') {\n      query = {\n        aggregateId: query\n      };\n    }\n\n    var self = this;\n    this.store.getLastEvent(query, function (err, evt) {\n      if (err) return callback(err);\n      callback(null, new EventStream(self, query, evt ? [evt] : []));\n    });\n  },\n\n  /**\n   * Sets the given event to dispatched.\n   * @param {Object || String} evtOrId  the event object or its id\n   * @param {Function}         callback the function that will be called when this action has finished [optional]\n   */\n  setEventToDispatched: function (evtOrId, callback) {\n    if (typeof evtOrId === 'object') {\n      evtOrId = evtOrId.id;\n    }\n\n    this.store.setEventToDispatched(evtOrId, callback);\n  },\n\n  /**\n   * loads a new id from store\n   * @param {Function} callback the function that will be called when this action has finished\n   */\n  getNewId: function (callback) {\n    this.store.getNewId(callback);\n  }\n});\n\nmodule.exports = Eventstore;","map":{"version":3,"names":["debug","require","util","EventEmitter","_","async","tolerate","EventDispatcher","EventStream","Snapshot","Eventstore","options","store","eventMappings","call","inherits","extend","prototype","useEventPublisher","fn","length","wrap","func","evt","callback","publisher","defineEventMappings","mappings","isObject","err","Error","init","self","initDispatcher","dispatcher","start","on","emit","process","nextTick","connect","timeout","streamEvents","query","skip","limit","type","aggregateId","streamEventsSince","commitStamp","Date","streamEventsByRevision","revMin","revMax","getEvents","nextFn","resEvts","next","_getEvents","evts","getEventsSince","_getEventsSince","getEventsByRevision","getEventStream","getFromSnapshot","waterfall","getSnapshot","snap","rev","revision","undefined","stream","lastRevision","createSnapshot","obj","streamId","castedRevision","parseFloat","toString","getNewIdFromStorage","getNewId","commit","id","addSnapshot","error","maxSnapshotsCount","cleanSnapshots","pick","eventstream","getNewCommitId","commitEvents","event","currentRevision","uncommittedEvents","concat","getNextPositions","positions","i","len","commitId","commitSequence","restInCommitStream","streamRevision","position","applyMappings","addEvents","addUndispatchedEvents","eventsToDispatch","events","getUndispatchedEvents","getLastEvent","getLastEventAsStream","setEventToDispatched","evtOrId","module","exports"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/eventstore/lib/eventstore.js"],"sourcesContent":["var debug = require('debug')('eventstore'),\n  util = require('util'),\n  EventEmitter = require('events').EventEmitter,\n  _ = require('lodash'),\n  async = require('async'),\n  tolerate = require('tolerance'),\n  EventDispatcher = require('./eventDispatcher'),\n  EventStream = require('./eventStream'),\n  Snapshot = require('./snapshot');\n\n/**\n * Eventstore constructor\n * @param {Object} options The options.\n * @param {Store}  store   The db implementation.\n * @constructor\n */\nfunction Eventstore(options, store) {\n  this.options = options || {};\n  this.store = store;\n\n  this.eventMappings = {};\n\n  EventEmitter.call(this);\n}\n\nutil.inherits(Eventstore, EventEmitter);\n\n_.extend(Eventstore.prototype, {\n\n  /**\n   * Inject function for event publishing.\n   * @param {Function} fn the function to be injected\n   * @returns {Eventstore}  to be able to chain...\n   */\n  useEventPublisher: function (fn) {\n    if (fn.length === 1) {\n      fn = _.wrap(fn, function(func, evt, callback) {\n        func(evt);\n        callback(null);\n      });\n    }\n\n    this.publisher = fn;\n\n    return this;\n  },\n\n  /**\n   * Define which values should be mapped/copied to the payload event. [optional]\n   * @param {Object} mappings the mappings in dotty notation\n   *                          {\n   *                            id: 'id',\n   *                            commitId: 'commitId',\n   *                            commitSequence: 'commitSequence',\n   *                            commitStamp: 'commitStamp',\n   *                            streamRevision: 'streamRevision'\n   *                          }\n   * @returns {Eventstore}  to be able to chain...\n   */\n  defineEventMappings: function (mappings) {\n    if (!mappings || !_.isObject(mappings)) {\n      var err = new Error('Please pass a valid mapping values!');\n      debug(err);\n      throw err;\n    }\n\n    this.eventMappings = mappings;\n\n    return this;\n  },\n\n  /**\n   * Call this function to initialize the eventstore.\n   * If an event publisher function was injected it will additionally initialize an event dispatcher.\n   * @param {Function} callback the function that will be called when this action has finished [optional]\n   */\n  init: function (callback) {\n    var self = this;\n\n    function initDispatcher() {\n      debug('init event dispatcher');\n      self.dispatcher = new EventDispatcher(self.publisher, self);\n      self.dispatcher.start(callback);\n    }\n\n    this.store.on('connect', function () {\n      self.emit('connect');\n    });\n\n    this.store.on('disconnect', function () {\n      self.emit('disconnect');\n    });\n\n    process.nextTick(function() {\n      tolerate(function(callback) {\n        self.store.connect(callback);\n      }, self.options.timeout || 0, function (err) {\n        if (err) {\n          debug(err);\n          if (callback) callback(err);\n          return;\n        }\n        if (!self.publisher) {\n          debug('no publisher defined');\n          if (callback) callback(null);\n          return;\n        }\n        initDispatcher();\n      });\n    });\n  },\n\n\n  // streaming api\n\n  /**\n   * streams the events\n   * @param {Object || String} query    the query object [optional]\n   * @param {Number}           skip     how many events should be skipped? [optional]\n   * @param {Number}           limit    how many events do you want in the result? [optional]\n   * @returns {Stream} a stream with the events\n   */\n  streamEvents: function (query, skip, limit) {\n    if (!this.store.streamEvents) {\n      throw new Error('Streaming API is not suppoted by '+(this.options.type || 'inmemory') +' db implementation.');\n    }\n\n    if (typeof query === 'number') {\n      limit = skip;\n      skip = query;\n      query = {};      \n    };\n\n    if (typeof query === 'string') {\n      query = { aggregateId: query };\n    }\n\n    return this.store.streamEvents(query, skip, limit);\n  },\n\n  /**\n   * streams all the events since passed commitStamp\n   * @param {Date}     commitStamp the date object\n   * @param {Number}   skip        how many events should be skipped? [optional]\n   * @param {Number}   limit       how many events do you want in the result? [optional]\n   * @returns {Stream} a stream with the events\n   */\n  streamEventsSince: function (commitStamp, skip, limit) {\n    if (!this.store.streamEvents) {\n      throw new Error('Streaming API is not suppoted by '+(this.options.type || 'inmemory') +' db implementation.');\n    }\n\n    if (!commitStamp) {\n      var err = new Error('Please pass in a date object!');\n      debug(err);\n      throw err;\n    }\n\n    var self = this;\n    commitStamp = new Date(commitStamp);\n\n    return this.store.streamEventsSince(commitStamp, skip, limit);\n  },\n\n\n  /**\n   * stream events by revision\n   * @param {Object || String} query    the query object\n   * @param {Number}           revMin   revision start point [optional]\n   * @param {Number}           revMax   revision end point (hint: -1 = to end) [optional]\n   * @returns {Stream} a stream with the events\n   */\n  streamEventsByRevision: function (query, revMin, revMax) {\n    if (typeof query === 'string') {\n      query = { aggregateId: query };\n    }\n\n    if (!query.aggregateId) {\n      var err = new Error('An aggregateId should be passed!');\n      debug(err);\n      if (callback) callback(err);\n      return;\n    }\n\n    return this.store.streamEventsByRevision(query, revMin, revMax);\n  },\n\n  /**\n   * loads the events\n   * @param {Object || String} query    the query object [optional]\n   * @param {Number}           skip     how many events should be skipped? [optional]\n   * @param {Number}           limit    how many events do you want in the result? [optional]\n   * @param {Function}         callback the function that will be called when this action has finished\n   *                                    `function(err, events){}`\n   */\n  getEvents: function (query, skip, limit, callback) {\n    if (typeof query === 'function') {\n      callback = query;\n      skip = 0;\n      limit = -1;\n      query = {};\n    } else if (typeof skip === 'function') {\n      callback = skip;\n      skip = 0;\n      limit = -1;\n      if (typeof query === 'number') {\n        skip = query;\n        query = {};\n      }\n    } else if (typeof limit === 'function') {\n      callback = limit;\n      limit = -1;\n      if (typeof query === 'number') {\n        limit = skip;\n        skip = query;\n        query = {};\n      }\n    }\n\n    if (typeof query === 'string') {\n      query = { aggregateId: query };\n    }\n\n    var self = this;\n\n    function nextFn(callback) {\n      if (limit < 0) {\n        var resEvts = [];\n        resEvts.next = nextFn;\n        return process.nextTick(function () { callback(null, resEvts) });\n      }\n      skip += limit;\n      _getEvents(query, skip, limit, callback);\n    }\n\n    function _getEvents(query, skip, limit, callback) {\n      self.store.getEvents(query, skip, limit, function (err, evts) {\n        if (err) return callback(err);\n        evts.next = nextFn;\n        callback(null, evts);\n      });\n    }\n\n    _getEvents(query, skip, limit, callback);\n  },\n\n  /**\n   * loads all the events since passed commitStamp\n   * @param {Date}     commitStamp the date object\n   * @param {Number}   skip        how many events should be skipped? [optional]\n   * @param {Number}   limit       how many events do you want in the result? [optional]\n   * @param {Function} callback    the function that will be called when this action has finished\n   *                               `function(err, events){}`\n   */\n  getEventsSince: function (commitStamp, skip, limit, callback) {\n    if (!commitStamp) {\n      var err = new Error('Please pass in a date object!');\n      debug(err);\n      throw err;\n    }\n\n    if (typeof skip === 'function') {\n      callback = skip;\n      skip = 0;\n      limit = -1;\n    } else if (typeof limit === 'function') {\n      callback = limit;\n      limit = -1;\n    }\n\n    var self = this;\n\n    function nextFn(callback) {\n      if (limit < 0) {\n        var resEvts = [];\n        resEvts.next = nextFn;\n        return process.nextTick(function () { callback(null, resEvts) });\n      }\n      skip += limit;\n      _getEventsSince(commitStamp, skip, limit, callback);\n    }\n\n    commitStamp = new Date(commitStamp);\n\n    function _getEventsSince(commitStamp, skip, limit, callback) {\n      self.store.getEventsSince(commitStamp, skip, limit, function (err, evts) {\n        if (err) return callback(err);\n        evts.next = nextFn;\n        callback(null, evts);\n      });\n    }\n\n    _getEventsSince(commitStamp, skip, limit, callback);\n  },\n\n  /**\n   * loads the events\n   * @param {Object || String} query    the query object\n   * @param {Number}           revMin   revision start point [optional]\n   * @param {Number}           revMax   revision end point (hint: -1 = to end) [optional]\n   * @param {Function}         callback the function that will be called when this action has finished\n   *                                    `function(err, events){}`\n   */\n  getEventsByRevision: function (query, revMin, revMax, callback) {\n    if (typeof revMin === 'function') {\n      callback = revMin;\n      revMin = 0;\n      revMax = -1;\n    } else if (typeof revMax === 'function') {\n      callback = revMax;\n      revMax = -1;\n    }\n\n    if (typeof query === 'string') {\n      query = { aggregateId: query };\n    }\n\n    if (!query.aggregateId) {\n      var err = new Error('An aggregateId should be passed!');\n      debug(err);\n      if (callback) callback(err);\n      return;\n    }\n\n    this.store.getEventsByRevision(query, revMin, revMax, callback);\n  },\n\n  /**\n   * loads the event stream\n   * @param {Object || String} query    the query object\n   * @param {Number}           revMin   revision start point [optional]\n   * @param {Number}           revMax   revision end point (hint: -1 = to end) [optional]\n   * @param {Function}         callback the function that will be called when this action has finished\n   *                                    `function(err, eventstream){}`\n   */\n  getEventStream: function (query, revMin, revMax, callback) {\n    if (typeof revMin === 'function') {\n      callback = revMin;\n      revMin = 0;\n      revMax = -1;\n    } else if (typeof revMax === 'function') {\n      callback = revMax;\n      revMax = -1;\n    }\n\n    if (typeof query === 'string') {\n      query = { aggregateId: query };\n    }\n\n    if (!query.aggregateId) {\n      var err = new Error('An aggregateId should be passed!');\n      debug(err);\n      if (callback) callback(err);\n      return;\n    }\n\n    var self = this;\n\n    this.getEventsByRevision(query, revMin, revMax, function(err, evts) {\n      if (err) {\n        return callback(err);\n      }\n      callback(null, new EventStream(self, query, evts));\n    });\n  },\n\n  /**\n   * loads the next snapshot back from given max revision\n   * @param {Object || String} query    the query object\n   * @param {Number}           revMax   revision end point (hint: -1 = to end) [optional]\n   * @param {Function}         callback the function that will be called when this action has finished\n   *                                    `function(err, snapshot, eventstream){}`\n   */\n  getFromSnapshot: function (query, revMax, callback) {\n    if (typeof revMax === 'function') {\n      callback = revMax;\n      revMax = -1;\n    }\n\n    if (typeof query === 'string') {\n      query = { aggregateId: query };\n    }\n\n    if (!query.aggregateId) {\n      var err = new Error('An aggregateId should be passed!');\n      debug(err);\n      if (callback) callback(err);\n      return;\n    }\n\n    var self = this;\n\n    async.waterfall([\n\n      function getSnapshot(callback) {\n        self.store.getSnapshot(query, revMax, callback);\n      },\n\n      function getEventStream(snap, callback) {\n        var rev = 0;\n\n        if (snap && (snap.revision !== undefined && snap.revision !== null)) {\n          rev = snap.revision + 1;\n        }\n\n        self.getEventStream(query, rev, revMax, function(err, stream) {\n          if (err) {\n            return callback(err);\n          }\n\n          if (rev > 0 && stream.lastRevision == -1) {\n            stream.lastRevision = snap.revision;\n          }\n\n          callback(null, snap, stream);\n        });\n      }],\n\n      callback\n    );\n  },\n\n  /**\n   * stores a new snapshot\n   * @param {Object}   obj      the snapshot data\n   * @param {Function} callback the function that will be called when this action has finished [optional]\n   */\n  createSnapshot: function(obj, callback) {\n    if (obj.streamId && !obj.aggregateId) {\n      obj.aggregateId = obj.streamId;\n    }\n\n    if (!obj.aggregateId) {\n      var err = new Error('An aggregateId should be passed!');\n      debug(err);\n      if (callback) callback(err);\n      return;\n    }\n\n    obj.streamId = obj.aggregateId;\n\n    if (obj.revision) {\n      if (typeof (obj.revision) === 'string') {\n        const castedRevision = parseFloat(obj.revision);\n\n        if (castedRevision && castedRevision.toString() === obj.revision) { // Determines if the revision was parsed correctly, for the cases where user using custom typed revisions that's not in valid float format like: obj.revision = '1,2,3'\n          obj.revision = castedRevision;\n        }\n      }\n    }\n\n    var self = this;\n\n    async.waterfall([\n        function getNewIdFromStorage(callback) {\n          self.getNewId(callback);\n        },\n        function commit(id, callback) {\n          try {\n            var snap = new Snapshot(id, obj);\n            snap.commitStamp = new Date();\n          } catch (err) {\n            return callback(err);\n          }\n\n          self.store.addSnapshot(snap, function(error) {\n            if (self.options.maxSnapshotsCount) {\n              self.store.cleanSnapshots(_.pick(obj, 'aggregateId', 'aggregate', 'context'), callback);\n            } else {\n              callback(error);\n            }\n          });\n        }],\n      callback\n    );\n  },\n\n  /**\n   * commits all uncommittedEvents in the eventstream\n   * @param eventstream the eventstream that should be saved (hint: directly use the commit function on eventstream)\n   * @param {Function}  callback the function that will be called when this action has finished\n   *                             `function(err, eventstream){}` (hint: eventstream.eventsToDispatch)\n   */\n  commit: function(eventstream, callback) {\n\n    var self = this;\n\n    async.waterfall([\n\n      function getNewCommitId(callback) {\n        self.getNewId(callback);\n      },\n\n      function commitEvents(id, callback) {\n        // start committing.\n        var event,\n          currentRevision = eventstream.currentRevision(),\n          uncommittedEvents = [].concat(eventstream.uncommittedEvents);\n        eventstream.uncommittedEvents = [];\n\n        self.store.getNextPositions(uncommittedEvents.length, function(err, positions) {\n          if (err)\n            return callback(err)\n\n          for (var i = 0, len = uncommittedEvents.length; i < len; i++) {\n            event = uncommittedEvents[i];\n            event.id = id + i.toString();\n            event.commitId = id;\n            event.commitSequence = i;\n            event.restInCommitStream = len - 1 - i;\n            event.commitStamp = new Date();\n            currentRevision++;\n            event.streamRevision = currentRevision;\n            if (positions)\n              event.position = positions[i];\n\n            event.applyMappings();\n          }\n\n          self.store.addEvents(uncommittedEvents, function(err) {\n            if (err) {\n              // add uncommitted events back to eventstream\n              eventstream.uncommittedEvents = uncommittedEvents.concat(eventstream.uncommittedEvents);\n              return callback(err);\n            }\n\n            if (self.publisher && self.dispatcher) {\n              // push to undispatchedQueue\n              self.dispatcher.addUndispatchedEvents(uncommittedEvents);\n            } else {\n              eventstream.eventsToDispatch = [].concat(uncommittedEvents);\n            }\n\n            // move uncommitted events to events\n            eventstream.events = eventstream.events.concat(uncommittedEvents);\n            eventstream.currentRevision();\n\n            callback(null, eventstream);\n          });\n        });\n      }],\n\n      callback\n    );\n  },\n\n  /**\n   * loads all undispatched events\n   * @param {Object || String} query    the query object [optional]\n   * @param {Function}         callback the function that will be called when this action has finished\n   *                                    `function(err, events){}`\n   */\n  getUndispatchedEvents: function (query, callback) {\n    if (!callback) {\n      callback = query;\n      query = null;\n    }\n\n    if (typeof query === 'string') {\n      query = { aggregateId: query };\n    }\n\n    this.store.getUndispatchedEvents(query, callback);\n  },\n\n  /**\n   * loads the last event\n   * @param {Object || String} query    the query object [optional]\n   * @param {Function}         callback the function that will be called when this action has finished\n   *                                    `function(err, event){}`\n   */\n  getLastEvent: function (query, callback) {\n    if (!callback) {\n      callback = query;\n      query = null;\n    }\n\n    if (typeof query === 'string') {\n      query = { aggregateId: query };\n    }\n\n    this.store.getLastEvent(query, callback);\n  },\n\n  /**\n   * loads the last event in a stream\n   * @param {Object || String} query    the query object [optional]\n   * @param {Function}         callback the function that will be called when this action has finished\n   *                                    `function(err, eventstream){}`\n   */\n  getLastEventAsStream: function (query, callback) {\n    if (!callback) {\n      callback = query;\n      query = null;\n    }\n\n    if (typeof query === 'string') {\n      query = { aggregateId: query };\n    }\n\n    var self = this;\n\n    this.store.getLastEvent(query, function (err, evt) {\n      if (err) return callback(err);\n\n      callback(null, new EventStream(self, query, evt ? [evt] : []));\n    });\n  },\n\n  /**\n   * Sets the given event to dispatched.\n   * @param {Object || String} evtOrId  the event object or its id\n   * @param {Function}         callback the function that will be called when this action has finished [optional]\n   */\n  setEventToDispatched: function (evtOrId, callback) {\n    if (typeof evtOrId === 'object') {\n      evtOrId = evtOrId.id;\n    }\n    this.store.setEventToDispatched(evtOrId, callback);\n  },\n\n  /**\n   * loads a new id from store\n   * @param {Function} callback the function that will be called when this action has finished\n   */\n  getNewId: function (callback) {\n    this.store.getNewId(callback);\n  }\n\n});\n\nmodule.exports = Eventstore;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}