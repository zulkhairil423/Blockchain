{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTsConfigDefaults = exports.ComputeAsCommonRootOfFiles = exports.loadCompiler = exports.resolveAndLoadCompiler = exports.readConfig = exports.findAndReadConfig = void 0;\n\nconst path_1 = require(\"path\");\n\nconst index_1 = require(\"./index\");\n\nconst ts_internals_1 = require(\"./ts-internals\");\n\nconst tsconfigs_1 = require(\"./tsconfigs\");\n\nconst util_1 = require(\"./util\");\n/**\n * TypeScript compiler option values required by `ts-node` which cannot be overridden.\n */\n\n\nconst TS_NODE_COMPILER_OPTIONS = {\n  sourceMap: true,\n  inlineSourceMap: false,\n  inlineSources: true,\n  declaration: false,\n  noEmit: false,\n  outDir: '.ts-node'\n};\n/*\n * Do post-processing on config options to support `ts-node`.\n */\n\nfunction fixConfig(ts, config) {\n  // Delete options that *should not* be passed through.\n  delete config.options.out;\n  delete config.options.outFile;\n  delete config.options.composite;\n  delete config.options.declarationDir;\n  delete config.options.declarationMap;\n  delete config.options.emitDeclarationOnly; // Target ES5 output by default (instead of ES3).\n\n  if (config.options.target === undefined) {\n    config.options.target = ts.ScriptTarget.ES5;\n  } // Target CommonJS modules by default (instead of magically switching to ES6 when the target is ES6).\n\n\n  if (config.options.module === undefined) {\n    config.options.module = ts.ModuleKind.CommonJS;\n  }\n\n  return config;\n}\n/** @internal */\n\n\nfunction findAndReadConfig(rawOptions) {\n  var _a, _b, _c, _d, _e;\n\n  const cwd = (0, path_1.resolve)((_c = (_b = (_a = rawOptions.cwd) !== null && _a !== void 0 ? _a : rawOptions.dir) !== null && _b !== void 0 ? _b : index_1.DEFAULTS.cwd) !== null && _c !== void 0 ? _c : process.cwd());\n  const compilerName = (_d = rawOptions.compiler) !== null && _d !== void 0 ? _d : index_1.DEFAULTS.compiler; // Compute minimum options to read the config file.\n\n  let projectLocalResolveDir = (0, util_1.getBasePathForProjectLocalDependencyResolution)(undefined, rawOptions.projectSearchDir, rawOptions.project, cwd);\n  let {\n    compiler,\n    ts\n  } = resolveAndLoadCompiler(compilerName, projectLocalResolveDir); // Read config file and merge new options between env and CLI options.\n\n  const {\n    configFilePath,\n    config,\n    tsNodeOptionsFromTsconfig,\n    optionBasePaths\n  } = readConfig(cwd, ts, rawOptions);\n  const options = (0, util_1.assign)({}, index_1.DEFAULTS, tsNodeOptionsFromTsconfig || {}, {\n    optionBasePaths\n  }, rawOptions);\n  options.require = [...(tsNodeOptionsFromTsconfig.require || []), ...(rawOptions.require || [])]; // Re-resolve the compiler in case it has changed.\n  // Compiler is loaded relative to tsconfig.json, so tsconfig discovery may cause us to load a\n  // different compiler than we did above, even if the name has not changed.\n\n  if (configFilePath) {\n    projectLocalResolveDir = (0, util_1.getBasePathForProjectLocalDependencyResolution)(configFilePath, rawOptions.projectSearchDir, rawOptions.project, cwd);\n    ({\n      compiler\n    } = resolveCompiler(options.compiler, (_e = optionBasePaths.compiler) !== null && _e !== void 0 ? _e : projectLocalResolveDir));\n  }\n\n  return {\n    options,\n    config,\n    projectLocalResolveDir,\n    optionBasePaths,\n    configFilePath,\n    cwd,\n    compiler\n  };\n}\n\nexports.findAndReadConfig = findAndReadConfig;\n/**\n * Load TypeScript configuration. Returns the parsed TypeScript config and\n * any `ts-node` options specified in the config file.\n *\n * Even when a tsconfig.json is not loaded, this function still handles merging\n * compilerOptions from various sources: API, environment variables, etc.\n *\n * @internal\n */\n\nfunction readConfig(cwd, ts, rawApiOptions) {\n  var _a, _b, _c; // Ordered [a, b, c] where config a extends b extends c\n\n\n  const configChain = [];\n  let config = {\n    compilerOptions: {}\n  };\n  let basePath = cwd;\n  let configFilePath = undefined;\n  const projectSearchDir = (0, path_1.resolve)(cwd, (_a = rawApiOptions.projectSearchDir) !== null && _a !== void 0 ? _a : cwd);\n  const {\n    fileExists = ts.sys.fileExists,\n    readFile = ts.sys.readFile,\n    skipProject = index_1.DEFAULTS.skipProject,\n    project = index_1.DEFAULTS.project,\n    tsTrace = index_1.DEFAULTS.tsTrace\n  } = rawApiOptions; // Read project configuration when available.\n\n  if (!skipProject) {\n    if (project) {\n      const resolved = (0, path_1.resolve)(cwd, project);\n      const nested = (0, path_1.join)(resolved, 'tsconfig.json');\n      configFilePath = fileExists(nested) ? nested : resolved;\n    } else {\n      configFilePath = ts.findConfigFile(projectSearchDir, fileExists);\n    }\n\n    if (configFilePath) {\n      let pathToNextConfigInChain = configFilePath;\n      const tsInternals = (0, ts_internals_1.createTsInternals)(ts);\n      const errors = []; // Follow chain of \"extends\"\n\n      while (true) {\n        const result = ts.readConfigFile(pathToNextConfigInChain, readFile); // Return diagnostics.\n\n        if (result.error) {\n          return {\n            configFilePath,\n            config: {\n              errors: [result.error],\n              fileNames: [],\n              options: {}\n            },\n            tsNodeOptionsFromTsconfig: {},\n            optionBasePaths: {}\n          };\n        }\n\n        const c = result.config;\n        const bp = (0, path_1.dirname)(pathToNextConfigInChain);\n        configChain.push({\n          config: c,\n          basePath: bp,\n          configPath: pathToNextConfigInChain\n        });\n        if (c.extends == null) break;\n        const resolvedExtendedConfigPath = tsInternals.getExtendsConfigPath(c.extends, {\n          fileExists,\n          readDirectory: ts.sys.readDirectory,\n          readFile,\n          useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames,\n          trace: tsTrace\n        }, bp, errors, ts.createCompilerDiagnostic);\n\n        if (errors.length) {\n          return {\n            configFilePath,\n            config: {\n              errors,\n              fileNames: [],\n              options: {}\n            },\n            tsNodeOptionsFromTsconfig: {},\n            optionBasePaths: {}\n          };\n        }\n\n        if (resolvedExtendedConfigPath == null) break;\n        pathToNextConfigInChain = resolvedExtendedConfigPath;\n      }\n\n      ({\n        config,\n        basePath\n      } = configChain[0]);\n    }\n  } // Merge and fix ts-node options that come from tsconfig.json(s)\n\n\n  const tsNodeOptionsFromTsconfig = {};\n  const optionBasePaths = {};\n\n  for (let i = configChain.length - 1; i >= 0; i--) {\n    const {\n      config,\n      basePath,\n      configPath\n    } = configChain[i];\n    const options = filterRecognizedTsConfigTsNodeOptions(config['ts-node']).recognized; // Some options are relative to the config file, so must be converted to absolute paths here\n\n    if (options.require) {\n      // Modules are found relative to the tsconfig file, not the `dir` option\n      const tsconfigRelativeResolver = (0, util_1.createProjectLocalResolveHelper)((0, path_1.dirname)(configPath));\n      options.require = options.require.map(path => tsconfigRelativeResolver(path, false));\n    }\n\n    if (options.scopeDir) {\n      options.scopeDir = (0, path_1.resolve)(basePath, options.scopeDir);\n    } // Downstream code uses the basePath; we do not do that here.\n\n\n    if (options.moduleTypes) {\n      optionBasePaths.moduleTypes = basePath;\n    }\n\n    if (options.transpiler != null) {\n      optionBasePaths.transpiler = basePath;\n    }\n\n    if (options.compiler != null) {\n      optionBasePaths.compiler = basePath;\n    }\n\n    if (options.swc != null) {\n      optionBasePaths.swc = basePath;\n    }\n\n    (0, util_1.assign)(tsNodeOptionsFromTsconfig, options);\n  } // Remove resolution of \"files\".\n\n\n  const files = (_c = (_b = rawApiOptions.files) !== null && _b !== void 0 ? _b : tsNodeOptionsFromTsconfig.files) !== null && _c !== void 0 ? _c : index_1.DEFAULTS.files; // Only if a config file is *not* loaded, load an implicit configuration from @tsconfig/bases\n\n  const skipDefaultCompilerOptions = configFilePath != null;\n  const defaultCompilerOptionsForNodeVersion = skipDefaultCompilerOptions ? undefined : { ...(0, tsconfigs_1.getDefaultTsconfigJsonForNodeVersion)(ts).compilerOptions,\n    types: ['node']\n  }; // Merge compilerOptions from all sources\n\n  config.compilerOptions = Object.assign({}, // automatically-applied options from @tsconfig/bases\n  defaultCompilerOptionsForNodeVersion, // tsconfig.json \"compilerOptions\"\n  config.compilerOptions, // from env var\n  index_1.DEFAULTS.compilerOptions, // tsconfig.json \"ts-node\": \"compilerOptions\"\n  tsNodeOptionsFromTsconfig.compilerOptions, // passed programmatically\n  rawApiOptions.compilerOptions, // overrides required by ts-node, cannot be changed\n  TS_NODE_COMPILER_OPTIONS);\n  const fixedConfig = fixConfig(ts, ts.parseJsonConfigFileContent(config, {\n    fileExists,\n    readFile,\n    // Only used for globbing \"files\", \"include\", \"exclude\"\n    // When `files` option disabled, we want to avoid the fs calls\n    readDirectory: files ? ts.sys.readDirectory : () => [],\n    useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames\n  }, basePath, undefined, configFilePath));\n  return {\n    configFilePath,\n    config: fixedConfig,\n    tsNodeOptionsFromTsconfig,\n    optionBasePaths\n  };\n}\n\nexports.readConfig = readConfig;\n/**\n * Load the typescript compiler. It is required to load the tsconfig but might\n * be changed by the tsconfig, so we have to do this twice.\n * @internal\n */\n\nfunction resolveAndLoadCompiler(name, relativeToPath) {\n  const {\n    compiler\n  } = resolveCompiler(name, relativeToPath);\n  const ts = loadCompiler(compiler);\n  return {\n    compiler,\n    ts\n  };\n}\n\nexports.resolveAndLoadCompiler = resolveAndLoadCompiler;\n\nfunction resolveCompiler(name, relativeToPath) {\n  const projectLocalResolveHelper = (0, util_1.createProjectLocalResolveHelper)(relativeToPath);\n  const compiler = projectLocalResolveHelper(name || 'typescript', true);\n  return {\n    compiler\n  };\n}\n/** @internal */\n\n\nfunction loadCompiler(compiler) {\n  return (0, util_1.attemptRequireWithV8CompileCache)(require, compiler);\n}\n\nexports.loadCompiler = loadCompiler;\n/**\n * Given the raw \"ts-node\" sub-object from a tsconfig, return an object with only the properties\n * recognized by \"ts-node\"\n */\n\nfunction filterRecognizedTsConfigTsNodeOptions(jsonObject) {\n  if (jsonObject == null) return {\n    recognized: {},\n    unrecognized: {}\n  };\n  const {\n    compiler,\n    compilerHost,\n    compilerOptions,\n    emit,\n    files,\n    ignore,\n    ignoreDiagnostics,\n    logError,\n    preferTsExts,\n    pretty,\n    require,\n    skipIgnore,\n    transpileOnly,\n    typeCheck,\n    transpiler,\n    scope,\n    scopeDir,\n    moduleTypes,\n    experimentalReplAwait,\n    swc,\n    experimentalResolver,\n    esm,\n    experimentalSpecifierResolution,\n    experimentalTsImportSpecifiers,\n    ...unrecognized\n  } = jsonObject;\n  const filteredTsConfigOptions = {\n    compiler,\n    compilerHost,\n    compilerOptions,\n    emit,\n    experimentalReplAwait,\n    files,\n    ignore,\n    ignoreDiagnostics,\n    logError,\n    preferTsExts,\n    pretty,\n    require,\n    skipIgnore,\n    transpileOnly,\n    typeCheck,\n    transpiler,\n    scope,\n    scopeDir,\n    moduleTypes,\n    swc,\n    experimentalResolver,\n    esm,\n    experimentalSpecifierResolution,\n    experimentalTsImportSpecifiers\n  }; // Use the typechecker to make sure this implementation has the correct set of properties\n\n  const catchExtraneousProps = null;\n  const catchMissingProps = null;\n  return {\n    recognized: filteredTsConfigOptions,\n    unrecognized\n  };\n}\n/** @internal */\n\n\nexports.ComputeAsCommonRootOfFiles = Symbol();\n/**\n * Some TS compiler options have defaults which are not provided by TS's config parsing functions.\n * This function centralizes the logic for computing those defaults.\n * @internal\n */\n\nfunction getTsConfigDefaults(config, basePath, _files, _include, _exclude) {\n  const {\n    composite = false\n  } = config.options;\n  let rootDir = config.options.rootDir;\n\n  if (rootDir == null) {\n    if (composite) rootDir = basePath; // Return this symbol to avoid computing from `files`, which would require fs calls\n    else rootDir = exports.ComputeAsCommonRootOfFiles;\n  }\n\n  const {\n    outDir = rootDir\n  } = config.options; // Docs are wrong: https://www.typescriptlang.org/tsconfig#include\n  // Docs say **, but it's actually **/*; compiler throws error for **\n\n  const include = _files ? [] : ['**/*'];\n  const files = _files !== null && _files !== void 0 ? _files : []; // Docs are misleading: https://www.typescriptlang.org/tsconfig#exclude\n  // Docs say it excludes node_modules, bower_components, jspm_packages, but actually those are excluded via behavior of \"include\"\n\n  const exclude = _exclude !== null && _exclude !== void 0 ? _exclude : [outDir]; // TODO technically, outDir is absolute path, but exclude should be relative glob pattern?\n  // TODO compute baseUrl\n\n  return {\n    rootDir,\n    outDir,\n    include,\n    files,\n    exclude,\n    composite\n  };\n}\n\nexports.getTsConfigDefaults = getTsConfigDefaults;","map":{"version":3,"mappings":"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","names":["TS_NODE_COMPILER_OPTIONS","sourceMap","inlineSourceMap","inlineSources","declaration","noEmit","outDir","fixConfig","ts","config","options","out","outFile","composite","declarationDir","declarationMap","emitDeclarationOnly","target","undefined","ScriptTarget","ES5","module","ModuleKind","CommonJS","findAndReadConfig","rawOptions","cwd","_a","dir","_b","index_1","_c","process","compilerName","compiler","_d","projectLocalResolveDir","projectSearchDir","project","resolveAndLoadCompiler","configFilePath","tsNodeOptionsFromTsconfig","optionBasePaths","readConfig","require","resolveCompiler","_e","exports","rawApiOptions","configChain","compilerOptions","basePath","fileExists","sys","readFile","skipProject","tsTrace","resolved","nested","findConfigFile","pathToNextConfigInChain","tsInternals","errors","result","readConfigFile","error","fileNames","c","bp","push","configPath","extends","resolvedExtendedConfigPath","getExtendsConfigPath","readDirectory","useCaseSensitiveFileNames","trace","createCompilerDiagnostic","length","i","filterRecognizedTsConfigTsNodeOptions","recognized","tsconfigRelativeResolver","map","path","scopeDir","moduleTypes","transpiler","swc","files","skipDefaultCompilerOptions","defaultCompilerOptionsForNodeVersion","types","Object","assign","fixedConfig","parseJsonConfigFileContent","name","relativeToPath","loadCompiler","projectLocalResolveHelper","jsonObject","unrecognized","compilerHost","emit","ignore","ignoreDiagnostics","logError","preferTsExts","pretty","skipIgnore","transpileOnly","typeCheck","scope","experimentalReplAwait","experimentalResolver","esm","experimentalSpecifierResolution","experimentalTsImportSpecifiers","filteredTsConfigOptions","catchExtraneousProps","catchMissingProps","Symbol","getTsConfigDefaults","_files","_include","_exclude","rootDir","include","exclude"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\ts-node\\src\\configuration.ts"],"sourcesContent":["import { resolve, dirname, join } from 'path';\nimport type * as _ts from 'typescript';\nimport {\n  CreateOptions,\n  DEFAULTS,\n  OptionBasePaths,\n  RegisterOptions,\n  TSCommon,\n  TsConfigOptions,\n} from './index';\nimport type { TSInternal } from './ts-compiler-types';\nimport { createTsInternals } from './ts-internals';\nimport { getDefaultTsconfigJsonForNodeVersion } from './tsconfigs';\nimport {\n  assign,\n  attemptRequireWithV8CompileCache,\n  createProjectLocalResolveHelper,\n  getBasePathForProjectLocalDependencyResolution,\n} from './util';\n\n/**\n * TypeScript compiler option values required by `ts-node` which cannot be overridden.\n */\nconst TS_NODE_COMPILER_OPTIONS = {\n  sourceMap: true,\n  inlineSourceMap: false,\n  inlineSources: true,\n  declaration: false,\n  noEmit: false,\n  outDir: '.ts-node',\n};\n\n/*\n * Do post-processing on config options to support `ts-node`.\n */\nfunction fixConfig(ts: TSCommon, config: _ts.ParsedCommandLine) {\n  // Delete options that *should not* be passed through.\n  delete config.options.out;\n  delete config.options.outFile;\n  delete config.options.composite;\n  delete config.options.declarationDir;\n  delete config.options.declarationMap;\n  delete config.options.emitDeclarationOnly;\n\n  // Target ES5 output by default (instead of ES3).\n  if (config.options.target === undefined) {\n    config.options.target = ts.ScriptTarget.ES5;\n  }\n\n  // Target CommonJS modules by default (instead of magically switching to ES6 when the target is ES6).\n  if (config.options.module === undefined) {\n    config.options.module = ts.ModuleKind.CommonJS;\n  }\n\n  return config;\n}\n\n/** @internal */\nexport function findAndReadConfig(rawOptions: CreateOptions) {\n  const cwd = resolve(\n    rawOptions.cwd ?? rawOptions.dir ?? DEFAULTS.cwd ?? process.cwd()\n  );\n  const compilerName = rawOptions.compiler ?? DEFAULTS.compiler;\n\n  // Compute minimum options to read the config file.\n  let projectLocalResolveDir = getBasePathForProjectLocalDependencyResolution(\n    undefined,\n    rawOptions.projectSearchDir,\n    rawOptions.project,\n    cwd\n  );\n  let { compiler, ts } = resolveAndLoadCompiler(\n    compilerName,\n    projectLocalResolveDir\n  );\n\n  // Read config file and merge new options between env and CLI options.\n  const { configFilePath, config, tsNodeOptionsFromTsconfig, optionBasePaths } =\n    readConfig(cwd, ts, rawOptions);\n\n  const options = assign<RegisterOptions>(\n    {},\n    DEFAULTS,\n    tsNodeOptionsFromTsconfig || {},\n    { optionBasePaths },\n    rawOptions\n  );\n  options.require = [\n    ...(tsNodeOptionsFromTsconfig.require || []),\n    ...(rawOptions.require || []),\n  ];\n\n  // Re-resolve the compiler in case it has changed.\n  // Compiler is loaded relative to tsconfig.json, so tsconfig discovery may cause us to load a\n  // different compiler than we did above, even if the name has not changed.\n  if (configFilePath) {\n    projectLocalResolveDir = getBasePathForProjectLocalDependencyResolution(\n      configFilePath,\n      rawOptions.projectSearchDir,\n      rawOptions.project,\n      cwd\n    );\n    ({ compiler } = resolveCompiler(\n      options.compiler,\n      optionBasePaths.compiler ?? projectLocalResolveDir\n    ));\n  }\n\n  return {\n    options,\n    config,\n    projectLocalResolveDir,\n    optionBasePaths,\n    configFilePath,\n    cwd,\n    compiler,\n  };\n}\n\n/**\n * Load TypeScript configuration. Returns the parsed TypeScript config and\n * any `ts-node` options specified in the config file.\n *\n * Even when a tsconfig.json is not loaded, this function still handles merging\n * compilerOptions from various sources: API, environment variables, etc.\n *\n * @internal\n */\nexport function readConfig(\n  cwd: string,\n  ts: TSCommon,\n  rawApiOptions: CreateOptions\n): {\n  /**\n   * Path of tsconfig file if one was loaded\n   */\n  configFilePath: string | undefined;\n  /**\n   * Parsed TypeScript configuration with compilerOptions merged from all other sources (env vars, etc)\n   */\n  config: _ts.ParsedCommandLine;\n  /**\n   * ts-node options pulled from `tsconfig.json`, NOT merged with any other sources.  Merging must happen outside\n   * this function.\n   */\n  tsNodeOptionsFromTsconfig: TsConfigOptions;\n  optionBasePaths: OptionBasePaths;\n} {\n  // Ordered [a, b, c] where config a extends b extends c\n  const configChain: Array<{\n    config: any;\n    basePath: string;\n    configPath: string;\n  }> = [];\n  let config: any = { compilerOptions: {} };\n  let basePath = cwd;\n  let configFilePath: string | undefined = undefined;\n  const projectSearchDir = resolve(cwd, rawApiOptions.projectSearchDir ?? cwd);\n\n  const {\n    fileExists = ts.sys.fileExists,\n    readFile = ts.sys.readFile,\n    skipProject = DEFAULTS.skipProject,\n    project = DEFAULTS.project,\n    tsTrace = DEFAULTS.tsTrace,\n  } = rawApiOptions;\n\n  // Read project configuration when available.\n  if (!skipProject) {\n    if (project) {\n      const resolved = resolve(cwd, project);\n      const nested = join(resolved, 'tsconfig.json');\n      configFilePath = fileExists(nested) ? nested : resolved;\n    } else {\n      configFilePath = ts.findConfigFile(projectSearchDir, fileExists);\n    }\n\n    if (configFilePath) {\n      let pathToNextConfigInChain = configFilePath;\n      const tsInternals = createTsInternals(ts);\n      const errors: Array<_ts.Diagnostic> = [];\n\n      // Follow chain of \"extends\"\n      while (true) {\n        const result = ts.readConfigFile(pathToNextConfigInChain, readFile);\n\n        // Return diagnostics.\n        if (result.error) {\n          return {\n            configFilePath,\n            config: { errors: [result.error], fileNames: [], options: {} },\n            tsNodeOptionsFromTsconfig: {},\n            optionBasePaths: {},\n          };\n        }\n\n        const c = result.config;\n        const bp = dirname(pathToNextConfigInChain);\n        configChain.push({\n          config: c,\n          basePath: bp,\n          configPath: pathToNextConfigInChain,\n        });\n\n        if (c.extends == null) break;\n        const resolvedExtendedConfigPath = tsInternals.getExtendsConfigPath(\n          c.extends,\n          {\n            fileExists,\n            readDirectory: ts.sys.readDirectory,\n            readFile,\n            useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames,\n            trace: tsTrace,\n          },\n          bp,\n          errors,\n          (ts as unknown as TSInternal).createCompilerDiagnostic\n        );\n        if (errors.length) {\n          return {\n            configFilePath,\n            config: { errors, fileNames: [], options: {} },\n            tsNodeOptionsFromTsconfig: {},\n            optionBasePaths: {},\n          };\n        }\n        if (resolvedExtendedConfigPath == null) break;\n        pathToNextConfigInChain = resolvedExtendedConfigPath;\n      }\n\n      ({ config, basePath } = configChain[0]);\n    }\n  }\n\n  // Merge and fix ts-node options that come from tsconfig.json(s)\n  const tsNodeOptionsFromTsconfig: TsConfigOptions = {};\n  const optionBasePaths: OptionBasePaths = {};\n  for (let i = configChain.length - 1; i >= 0; i--) {\n    const { config, basePath, configPath } = configChain[i];\n    const options = filterRecognizedTsConfigTsNodeOptions(\n      config['ts-node']\n    ).recognized;\n\n    // Some options are relative to the config file, so must be converted to absolute paths here\n    if (options.require) {\n      // Modules are found relative to the tsconfig file, not the `dir` option\n      const tsconfigRelativeResolver = createProjectLocalResolveHelper(\n        dirname(configPath)\n      );\n      options.require = options.require.map((path: string) =>\n        tsconfigRelativeResolver(path, false)\n      );\n    }\n    if (options.scopeDir) {\n      options.scopeDir = resolve(basePath, options.scopeDir!);\n    }\n\n    // Downstream code uses the basePath; we do not do that here.\n    if (options.moduleTypes) {\n      optionBasePaths.moduleTypes = basePath;\n    }\n    if (options.transpiler != null) {\n      optionBasePaths.transpiler = basePath;\n    }\n    if (options.compiler != null) {\n      optionBasePaths.compiler = basePath;\n    }\n    if (options.swc != null) {\n      optionBasePaths.swc = basePath;\n    }\n\n    assign(tsNodeOptionsFromTsconfig, options);\n  }\n\n  // Remove resolution of \"files\".\n  const files =\n    rawApiOptions.files ?? tsNodeOptionsFromTsconfig.files ?? DEFAULTS.files;\n\n  // Only if a config file is *not* loaded, load an implicit configuration from @tsconfig/bases\n  const skipDefaultCompilerOptions = configFilePath != null;\n  const defaultCompilerOptionsForNodeVersion = skipDefaultCompilerOptions\n    ? undefined\n    : {\n        ...getDefaultTsconfigJsonForNodeVersion(ts).compilerOptions,\n        types: ['node'],\n      };\n\n  // Merge compilerOptions from all sources\n  config.compilerOptions = Object.assign(\n    {},\n    // automatically-applied options from @tsconfig/bases\n    defaultCompilerOptionsForNodeVersion,\n    // tsconfig.json \"compilerOptions\"\n    config.compilerOptions,\n    // from env var\n    DEFAULTS.compilerOptions,\n    // tsconfig.json \"ts-node\": \"compilerOptions\"\n    tsNodeOptionsFromTsconfig.compilerOptions,\n    // passed programmatically\n    rawApiOptions.compilerOptions,\n    // overrides required by ts-node, cannot be changed\n    TS_NODE_COMPILER_OPTIONS\n  );\n\n  const fixedConfig = fixConfig(\n    ts,\n    ts.parseJsonConfigFileContent(\n      config,\n      {\n        fileExists,\n        readFile,\n        // Only used for globbing \"files\", \"include\", \"exclude\"\n        // When `files` option disabled, we want to avoid the fs calls\n        readDirectory: files ? ts.sys.readDirectory : () => [],\n        useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames,\n      },\n      basePath,\n      undefined,\n      configFilePath\n    )\n  );\n\n  return {\n    configFilePath,\n    config: fixedConfig,\n    tsNodeOptionsFromTsconfig,\n    optionBasePaths,\n  };\n}\n\n/**\n * Load the typescript compiler. It is required to load the tsconfig but might\n * be changed by the tsconfig, so we have to do this twice.\n * @internal\n */\nexport function resolveAndLoadCompiler(\n  name: string | undefined,\n  relativeToPath: string\n) {\n  const { compiler } = resolveCompiler(name, relativeToPath);\n  const ts = loadCompiler(compiler);\n  return { compiler, ts };\n}\n\nfunction resolveCompiler(name: string | undefined, relativeToPath: string) {\n  const projectLocalResolveHelper =\n    createProjectLocalResolveHelper(relativeToPath);\n  const compiler = projectLocalResolveHelper(name || 'typescript', true);\n  return { compiler };\n}\n\n/** @internal */\nexport function loadCompiler(compiler: string): TSCommon {\n  return attemptRequireWithV8CompileCache(require, compiler);\n}\n\n/**\n * Given the raw \"ts-node\" sub-object from a tsconfig, return an object with only the properties\n * recognized by \"ts-node\"\n */\nfunction filterRecognizedTsConfigTsNodeOptions(jsonObject: any): {\n  recognized: TsConfigOptions;\n  unrecognized: any;\n} {\n  if (jsonObject == null) return { recognized: {}, unrecognized: {} };\n  const {\n    compiler,\n    compilerHost,\n    compilerOptions,\n    emit,\n    files,\n    ignore,\n    ignoreDiagnostics,\n    logError,\n    preferTsExts,\n    pretty,\n    require,\n    skipIgnore,\n    transpileOnly,\n    typeCheck,\n    transpiler,\n    scope,\n    scopeDir,\n    moduleTypes,\n    experimentalReplAwait,\n    swc,\n    experimentalResolver,\n    esm,\n    experimentalSpecifierResolution,\n    experimentalTsImportSpecifiers,\n    ...unrecognized\n  } = jsonObject as TsConfigOptions;\n  const filteredTsConfigOptions = {\n    compiler,\n    compilerHost,\n    compilerOptions,\n    emit,\n    experimentalReplAwait,\n    files,\n    ignore,\n    ignoreDiagnostics,\n    logError,\n    preferTsExts,\n    pretty,\n    require,\n    skipIgnore,\n    transpileOnly,\n    typeCheck,\n    transpiler,\n    scope,\n    scopeDir,\n    moduleTypes,\n    swc,\n    experimentalResolver,\n    esm,\n    experimentalSpecifierResolution,\n    experimentalTsImportSpecifiers,\n  };\n  // Use the typechecker to make sure this implementation has the correct set of properties\n  const catchExtraneousProps: keyof TsConfigOptions =\n    null as any as keyof typeof filteredTsConfigOptions;\n  const catchMissingProps: keyof typeof filteredTsConfigOptions =\n    null as any as keyof TsConfigOptions;\n  return { recognized: filteredTsConfigOptions, unrecognized };\n}\n\n/** @internal */\nexport const ComputeAsCommonRootOfFiles = Symbol();\n\n/**\n * Some TS compiler options have defaults which are not provided by TS's config parsing functions.\n * This function centralizes the logic for computing those defaults.\n * @internal\n */\nexport function getTsConfigDefaults(\n  config: _ts.ParsedCommandLine,\n  basePath: string,\n  _files: string[] | undefined,\n  _include: string[] | undefined,\n  _exclude: string[] | undefined\n) {\n  const { composite = false } = config.options;\n  let rootDir: string | typeof ComputeAsCommonRootOfFiles =\n    config.options.rootDir!;\n  if (rootDir == null) {\n    if (composite) rootDir = basePath;\n    // Return this symbol to avoid computing from `files`, which would require fs calls\n    else rootDir = ComputeAsCommonRootOfFiles;\n  }\n  const { outDir = rootDir } = config.options;\n  // Docs are wrong: https://www.typescriptlang.org/tsconfig#include\n  // Docs say **, but it's actually **/*; compiler throws error for **\n  const include = _files ? [] : ['**/*'];\n  const files = _files ?? [];\n  // Docs are misleading: https://www.typescriptlang.org/tsconfig#exclude\n  // Docs say it excludes node_modules, bower_components, jspm_packages, but actually those are excluded via behavior of \"include\"\n  const exclude = _exclude ?? [outDir]; // TODO technically, outDir is absolute path, but exclude should be relative glob pattern?\n\n  // TODO compute baseUrl\n\n  return { rootDir, outDir, include, files, exclude, composite };\n}\n"]},"metadata":{},"sourceType":"script"}