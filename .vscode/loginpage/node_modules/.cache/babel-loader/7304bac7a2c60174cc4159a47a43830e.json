{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.replaceBackslashes = exports.isAbsolutePathSourceName = exports.normalizeSourceName = exports.localSourceNameToPath = exports.localPathToSourceName = exports.validateSourceNameExistenceAndCasing = exports.isLocalSourceName = exports.validateSourceNameFormat = void 0;\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst errors_1 = require(\"../internal/core/errors\");\n\nconst errors_list_1 = require(\"../internal/core/errors-list\");\n\nconst fs_utils_1 = require(\"../internal/util/fs-utils\");\n\nconst NODE_MODULES = \"node_modules\";\n/**\n * This function validates the source name's format.\n *\n * It throws if the format is invalid.\n * If it doesn't throw all you know is that the format is valid.\n */\n\nfunction validateSourceNameFormat(sourceName) {\n  if (isAbsolutePathSourceName(sourceName)) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_ABSOLUTE_PATH, {\n      name: sourceName\n    });\n  }\n\n  if (isExplicitRelativePath(sourceName)) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_RELATIVE_PATH, {\n      name: sourceName\n    });\n  } // We check this before normalizing so we are sure that the difference\n  // comes from slash vs backslash\n\n\n  if (replaceBackslashes(sourceName) !== sourceName) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_BACKSLASHES, {\n      name: sourceName\n    });\n  }\n\n  if (normalizeSourceName(sourceName) !== sourceName) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.INVALID_SOURCE_NOT_NORMALIZED, {\n      name: sourceName\n    });\n  }\n}\n\nexports.validateSourceNameFormat = validateSourceNameFormat;\n/**\n * This function returns true if the sourceName is, potentially, from a local\n * file. It doesn't validate that the file actually exists.\n *\n * The source name must be in a valid format.\n */\n\nasync function isLocalSourceName(projectRoot, sourceName) {\n  // Note that we consider \"hardhat/console.sol\" as a special case here.\n  // This lets someone have a \"hardhat\" directory within their project without\n  // it impacting their use of `console.log`.\n  // See issue https://github.com/nomiclabs/hardhat/issues/998\n  if (sourceName.includes(NODE_MODULES) || sourceName === \"hardhat/console.sol\") {\n    return false;\n  }\n\n  const slashIndex = sourceName.indexOf(\"/\");\n  const firstDirOrFileName = slashIndex !== -1 ? sourceName.substring(0, slashIndex) : sourceName;\n\n  try {\n    await (0, fs_utils_1.getFileTrueCase)(projectRoot, firstDirOrFileName);\n  } catch (error) {\n    if (error instanceof fs_utils_1.FileNotFoundError) {\n      return false;\n    } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n    throw error;\n  }\n\n  return true;\n}\n\nexports.isLocalSourceName = isLocalSourceName;\n/**\n * Validates that a source name exists, starting from `fromDir`, and has the\n * right casing.\n *\n * The source name must be in a valid format.\n */\n\nasync function validateSourceNameExistenceAndCasing(fromDir, sourceName) {\n  const trueCaseSourceName = await getSourceNameTrueCase(fromDir, sourceName);\n\n  if (trueCaseSourceName !== sourceName) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.WRONG_CASING, {\n      incorrect: sourceName,\n      correct: trueCaseSourceName\n    });\n  }\n}\n\nexports.validateSourceNameExistenceAndCasing = validateSourceNameExistenceAndCasing;\n/**\n * Returns the source name of an existing local file's absolute path.\n *\n * Throws is the file doesn't exist, it's not inside the project, or belongs\n * to a library.\n */\n\nasync function localPathToSourceName(projectRoot, localFileAbsolutePath) {\n  const relativePath = path_1.default.relative(projectRoot, localFileAbsolutePath);\n  const normalized = normalizeSourceName(relativePath);\n\n  if (normalized.startsWith(\"..\")) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.EXTERNAL_AS_LOCAL, {\n      path: localFileAbsolutePath\n    });\n  }\n\n  if (normalized.includes(NODE_MODULES)) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.NODE_MODULES_AS_LOCAL, {\n      path: localFileAbsolutePath\n    });\n  }\n\n  return getSourceNameTrueCase(projectRoot, relativePath);\n}\n\nexports.localPathToSourceName = localPathToSourceName;\n/**\n * This function takes a valid local source name and returns its path. The\n * source name doesn't need to point to an existing file.\n */\n\nfunction localSourceNameToPath(projectRoot, sourceName) {\n  return path_1.default.join(projectRoot, sourceName);\n}\n\nexports.localSourceNameToPath = localSourceNameToPath;\n/**\n * Normalizes the source name, for example, by replacing `a/./b` with `a/b`.\n *\n * The sourceName param doesn't have to be a valid source name. It can,\n * for example, be denormalized.\n */\n\nfunction normalizeSourceName(sourceName) {\n  return replaceBackslashes(path_1.default.normalize(sourceName));\n}\n\nexports.normalizeSourceName = normalizeSourceName;\n/**\n * This function returns true if the sourceName is a unix absolute path or a\n * platform-dependent one.\n *\n * This function is used instead of just `path.isAbsolute` to ensure that\n * source names never start with `/`, even on Windows.\n */\n\nfunction isAbsolutePathSourceName(sourceName) {\n  return path_1.default.isAbsolute(sourceName) || sourceName.startsWith(\"/\");\n}\n\nexports.isAbsolutePathSourceName = isAbsolutePathSourceName;\n/**\n * This function returns true if the sourceName is a unix path that is based on\n * the current directory `./`.\n */\n\nfunction isExplicitRelativePath(sourceName) {\n  const [base] = sourceName.split(\"/\", 1);\n  return base === \".\" || base === \"..\";\n}\n/**\n * This function replaces backslashes (\\\\) with slashes (/).\n *\n * Note that a source name must not contain backslashes.\n */\n\n\nfunction replaceBackslashes(str) {\n  // Based in the npm module slash\n  const isExtendedLengthPath = /^\\\\\\\\\\?\\\\/.test(str);\n  const hasNonAscii = /[^\\u0000-\\u0080]+/.test(str);\n\n  if (isExtendedLengthPath || hasNonAscii) {\n    return str;\n  }\n\n  return str.replace(/\\\\/g, \"/\");\n}\n\nexports.replaceBackslashes = replaceBackslashes;\n\nfunction slashesToPathSeparator(str) {\n  if (path_1.default.sep === \"/\") {\n    return str;\n  }\n\n  return str.replace(/\\//g, path_1.default.sep);\n}\n/**\n * Returns the true casing of `p` as a relative path from `fromDir`. Throws if\n * `p` doesn't exist. `p` MUST be in source name format.\n */\n\n\nasync function getSourceNameTrueCase(fromDir, p) {\n  try {\n    const realCase = await (0, fs_utils_1.getFileTrueCase)(fromDir, slashesToPathSeparator(p));\n    return normalizeSourceName(realCase);\n  } catch (error) {\n    if (error instanceof fs_utils_1.FileNotFoundError) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.FILE_NOT_FOUND, {\n        name: p\n      }, error);\n    } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n    throw error;\n  }\n}","map":{"version":3,"mappings":"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","names":["NODE_MODULES","validateSourceNameFormat","sourceName","isAbsolutePathSourceName","errors_1","errors_list_1","SOURCE_NAMES","INVALID_SOURCE_NAME_ABSOLUTE_PATH","name","isExplicitRelativePath","INVALID_SOURCE_NAME_RELATIVE_PATH","replaceBackslashes","INVALID_SOURCE_NAME_BACKSLASHES","normalizeSourceName","INVALID_SOURCE_NOT_NORMALIZED","exports","isLocalSourceName","projectRoot","includes","slashIndex","indexOf","firstDirOrFileName","substring","error","fs_utils_1","validateSourceNameExistenceAndCasing","fromDir","trueCaseSourceName","getSourceNameTrueCase","WRONG_CASING","incorrect","correct","localPathToSourceName","localFileAbsolutePath","relativePath","path_1","relative","normalized","startsWith","EXTERNAL_AS_LOCAL","path","NODE_MODULES_AS_LOCAL","localSourceNameToPath","join","normalize","isAbsolute","base","split","str","isExtendedLengthPath","test","hasNonAscii","replace","slashesToPathSeparator","sep","p","realCase","FILE_NOT_FOUND"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\hardhat\\src\\utils\\source-names.ts"],"sourcesContent":["import path from \"path\";\n\nimport { HardhatError } from \"../internal/core/errors\";\nimport { ERRORS } from \"../internal/core/errors-list\";\nimport { FileNotFoundError, getFileTrueCase } from \"../internal/util/fs-utils\";\n\nconst NODE_MODULES = \"node_modules\";\n\n/**\n * This function validates the source name's format.\n *\n * It throws if the format is invalid.\n * If it doesn't throw all you know is that the format is valid.\n */\nexport function validateSourceNameFormat(sourceName: string) {\n  if (isAbsolutePathSourceName(sourceName)) {\n    throw new HardhatError(\n      ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_ABSOLUTE_PATH,\n      {\n        name: sourceName,\n      }\n    );\n  }\n\n  if (isExplicitRelativePath(sourceName)) {\n    throw new HardhatError(\n      ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_RELATIVE_PATH,\n      {\n        name: sourceName,\n      }\n    );\n  }\n\n  // We check this before normalizing so we are sure that the difference\n  // comes from slash vs backslash\n  if (replaceBackslashes(sourceName) !== sourceName) {\n    throw new HardhatError(\n      ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_BACKSLASHES,\n      {\n        name: sourceName,\n      }\n    );\n  }\n\n  if (normalizeSourceName(sourceName) !== sourceName) {\n    throw new HardhatError(ERRORS.SOURCE_NAMES.INVALID_SOURCE_NOT_NORMALIZED, {\n      name: sourceName,\n    });\n  }\n}\n\n/**\n * This function returns true if the sourceName is, potentially, from a local\n * file. It doesn't validate that the file actually exists.\n *\n * The source name must be in a valid format.\n */\nexport async function isLocalSourceName(\n  projectRoot: string,\n  sourceName: string\n): Promise<boolean> {\n  // Note that we consider \"hardhat/console.sol\" as a special case here.\n  // This lets someone have a \"hardhat\" directory within their project without\n  // it impacting their use of `console.log`.\n  // See issue https://github.com/nomiclabs/hardhat/issues/998\n  if (\n    sourceName.includes(NODE_MODULES) ||\n    sourceName === \"hardhat/console.sol\"\n  ) {\n    return false;\n  }\n\n  const slashIndex = sourceName.indexOf(\"/\");\n  const firstDirOrFileName =\n    slashIndex !== -1 ? sourceName.substring(0, slashIndex) : sourceName;\n\n  try {\n    await getFileTrueCase(projectRoot, firstDirOrFileName);\n  } catch (error) {\n    if (error instanceof FileNotFoundError) {\n      return false;\n    }\n\n    // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n\n  return true;\n}\n\n/**\n * Validates that a source name exists, starting from `fromDir`, and has the\n * right casing.\n *\n * The source name must be in a valid format.\n */\nexport async function validateSourceNameExistenceAndCasing(\n  fromDir: string,\n  sourceName: string\n) {\n  const trueCaseSourceName = await getSourceNameTrueCase(fromDir, sourceName);\n\n  if (trueCaseSourceName !== sourceName) {\n    throw new HardhatError(ERRORS.SOURCE_NAMES.WRONG_CASING, {\n      incorrect: sourceName,\n      correct: trueCaseSourceName,\n    });\n  }\n}\n\n/**\n * Returns the source name of an existing local file's absolute path.\n *\n * Throws is the file doesn't exist, it's not inside the project, or belongs\n * to a library.\n */\nexport async function localPathToSourceName(\n  projectRoot: string,\n  localFileAbsolutePath: string\n): Promise<string> {\n  const relativePath = path.relative(projectRoot, localFileAbsolutePath);\n  const normalized = normalizeSourceName(relativePath);\n\n  if (normalized.startsWith(\"..\")) {\n    throw new HardhatError(ERRORS.SOURCE_NAMES.EXTERNAL_AS_LOCAL, {\n      path: localFileAbsolutePath,\n    });\n  }\n\n  if (normalized.includes(NODE_MODULES)) {\n    throw new HardhatError(ERRORS.SOURCE_NAMES.NODE_MODULES_AS_LOCAL, {\n      path: localFileAbsolutePath,\n    });\n  }\n\n  return getSourceNameTrueCase(projectRoot, relativePath);\n}\n\n/**\n * This function takes a valid local source name and returns its path. The\n * source name doesn't need to point to an existing file.\n */\nexport function localSourceNameToPath(\n  projectRoot: string,\n  sourceName: string\n): string {\n  return path.join(projectRoot, sourceName);\n}\n\n/**\n * Normalizes the source name, for example, by replacing `a/./b` with `a/b`.\n *\n * The sourceName param doesn't have to be a valid source name. It can,\n * for example, be denormalized.\n */\nexport function normalizeSourceName(sourceName: string): string {\n  return replaceBackslashes(path.normalize(sourceName));\n}\n\n/**\n * This function returns true if the sourceName is a unix absolute path or a\n * platform-dependent one.\n *\n * This function is used instead of just `path.isAbsolute` to ensure that\n * source names never start with `/`, even on Windows.\n */\nexport function isAbsolutePathSourceName(sourceName: string): boolean {\n  return path.isAbsolute(sourceName) || sourceName.startsWith(\"/\");\n}\n\n/**\n * This function returns true if the sourceName is a unix path that is based on\n * the current directory `./`.\n */\nfunction isExplicitRelativePath(sourceName: string): boolean {\n  const [base] = sourceName.split(\"/\", 1);\n  return base === \".\" || base === \"..\";\n}\n\n/**\n * This function replaces backslashes (\\\\) with slashes (/).\n *\n * Note that a source name must not contain backslashes.\n */\nexport function replaceBackslashes(str: string): string {\n  // Based in the npm module slash\n  const isExtendedLengthPath = /^\\\\\\\\\\?\\\\/.test(str);\n  const hasNonAscii = /[^\\u0000-\\u0080]+/.test(str);\n\n  if (isExtendedLengthPath || hasNonAscii) {\n    return str;\n  }\n\n  return str.replace(/\\\\/g, \"/\");\n}\n\nfunction slashesToPathSeparator(str: string): string {\n  if (path.sep === \"/\") {\n    return str;\n  }\n\n  return str.replace(/\\//g, path.sep);\n}\n\n/**\n * Returns the true casing of `p` as a relative path from `fromDir`. Throws if\n * `p` doesn't exist. `p` MUST be in source name format.\n */\nasync function getSourceNameTrueCase(\n  fromDir: string,\n  p: string\n): Promise<string> {\n  try {\n    const realCase = await getFileTrueCase(fromDir, slashesToPathSeparator(p));\n    return normalizeSourceName(realCase);\n  } catch (error) {\n    if (error instanceof FileNotFoundError) {\n      throw new HardhatError(\n        ERRORS.SOURCE_NAMES.FILE_NOT_FOUND,\n        {\n          name: p,\n        },\n        error\n      );\n    }\n\n    // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}