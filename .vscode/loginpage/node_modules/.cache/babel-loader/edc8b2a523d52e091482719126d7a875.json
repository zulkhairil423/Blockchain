{"ast":null,"code":"// https://github.com/Ethan-Arrowood/undici-fetch\n'use strict';\n\nconst {\n  Response,\n  makeNetworkError,\n  makeAppropriateNetworkError,\n  filterResponse,\n  makeResponse\n} = require('./response');\n\nconst {\n  Headers\n} = require('./headers');\n\nconst {\n  Request,\n  makeRequest\n} = require('./request');\n\nconst zlib = require('zlib');\n\nconst {\n  bytesMatch,\n  makePolicyContainer,\n  clonePolicyContainer,\n  requestBadPort,\n  TAOCheck,\n  appendRequestOriginHeader,\n  responseLocationURL,\n  requestCurrentURL,\n  setRequestReferrerPolicyOnRedirect,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  createOpaqueTimingInfo,\n  appendFetchMetadata,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  determineRequestsReferrer,\n  coarsenedSharedCurrentTime,\n  createDeferredPromise,\n  isBlobLike,\n  sameOrigin,\n  isCancelled,\n  isAborted,\n  isErrorLike,\n  fullyReadBody\n} = require('./util');\n\nconst {\n  kState,\n  kHeaders,\n  kGuard,\n  kRealm\n} = require('./symbols');\n\nconst assert = require('assert');\n\nconst {\n  safelyExtractBody,\n  extractBody\n} = require('./body');\n\nconst {\n  redirectStatus,\n  nullBodyStatus,\n  safeMethods,\n  requestBodyHeader,\n  subresource,\n  DOMException\n} = require('./constants');\n\nconst {\n  kHeadersList\n} = require('../core/symbols');\n\nconst EE = require('events');\n\nconst {\n  Readable,\n  pipeline\n} = require('stream');\n\nconst {\n  isErrored,\n  isReadable\n} = require('../core/util');\n\nconst {\n  dataURLProcessor,\n  serializeAMimeType\n} = require('./dataURL');\n\nconst {\n  TransformStream\n} = require('stream/web');\n/** @type {import('buffer').resolveObjectURL} */\n\n\nlet resolveObjectURL;\nlet ReadableStream;\nconst nodeVersion = process.versions.node.split('.');\nconst nodeMajor = Number(nodeVersion[0]);\nconst nodeMinor = Number(nodeVersion[1]);\n\nclass Fetch extends EE {\n  constructor(dispatcher) {\n    super();\n    this.dispatcher = dispatcher;\n    this.connection = null;\n    this.dump = false;\n    this.state = 'ongoing';\n  }\n\n  terminate(reason) {\n    if (this.state !== 'ongoing') {\n      return;\n    }\n\n    this.state = 'terminated';\n    this.connection?.destroy(reason);\n    this.emit('terminated', reason);\n  }\n\n  abort() {\n    if (this.state !== 'ongoing') {\n      return;\n    }\n\n    const reason = new DOMException('The operation was aborted.', 'AbortError');\n    this.state = 'aborted';\n    this.connection?.destroy(reason);\n    this.emit('terminated', reason);\n  }\n\n} // https://fetch.spec.whatwg.org/#fetch-method\n\n\nasync function fetch(input) {\n  let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (arguments.length < 1) {\n    throw new TypeError(`Failed to execute 'fetch' on 'Window': 1 argument required, but only ${arguments.length} present.`);\n  } // 1. Let p be a new promise.\n\n\n  const p = createDeferredPromise(); // 2. Let requestObject be the result of invoking the initial value of\n  // Request as constructor with input and init as arguments. If this throws\n  // an exception, reject p with it and return p.\n\n  let requestObject;\n\n  try {\n    requestObject = new Request(input, init);\n  } catch (e) {\n    p.reject(e);\n    return p.promise;\n  } // 3. Let request be requestObject’s request.\n\n\n  const request = requestObject[kState]; // 4. If requestObject’s signal’s aborted flag is set, then:\n\n  if (requestObject.signal.aborted) {\n    // 1. Abort fetch with p, request, and null.\n    abortFetch(p, request, null); // 2. Return p.\n\n    return p.promise;\n  } // 5. Let globalObject be request’s client’s global object.\n\n\n  const globalObject = request.client.globalObject; // 6. If globalObject is a ServiceWorkerGlobalScope object, then set\n  // request’s service-workers mode to \"none\".\n\n  if (globalObject?.constructor?.name === 'ServiceWorkerGlobalScope') {\n    request.serviceWorkers = 'none';\n  } // 7. Let responseObject be null.\n\n\n  let responseObject = null; // 8. Let relevantRealm be this’s relevant Realm.\n\n  const relevantRealm = null; // 9. Let locallyAborted be false.\n\n  let locallyAborted = false; // 10. Let controller be null.\n\n  let controller = null; // 11. Add the following abort steps to requestObject’s signal:\n\n  requestObject.signal.addEventListener('abort', () => {\n    // 1. Set locallyAborted to true.\n    locallyAborted = true; // 2. Abort fetch with p, request, and responseObject.\n\n    abortFetch(p, request, responseObject); // 3. If controller is not null, then abort controller.\n\n    if (controller != null) {\n      controller.abort();\n    }\n  }, {\n    once: true\n  }); // 12. Let handleFetchDone given response response be to finalize and\n  // report timing with response, globalObject, and \"fetch\".\n\n  const handleFetchDone = response => finalizeAndReportTiming(response, 'fetch'); // 13. Set controller to the result of calling fetch given request,\n  // with processResponseEndOfBody set to handleFetchDone, and processResponse\n  // given response being these substeps:\n\n\n  const processResponse = response => {\n    // 1. If locallyAborted is true, terminate these substeps.\n    if (locallyAborted) {\n      return;\n    } // 2. If response’s aborted flag is set, then abort fetch with p,\n    // request, and responseObject, and terminate these substeps.\n\n\n    if (response.aborted) {\n      abortFetch(p, request, responseObject);\n      return;\n    } // 3. If response is a network error, then reject p with a TypeError\n    // and terminate these substeps.\n\n\n    if (response.type === 'error') {\n      p.reject(Object.assign(new TypeError('fetch failed'), {\n        cause: response.error\n      }));\n      return;\n    } // 4. Set responseObject to the result of creating a Response object,\n    // given response, \"immutable\", and relevantRealm.\n\n\n    responseObject = new Response();\n    responseObject[kState] = response;\n    responseObject[kRealm] = relevantRealm;\n    responseObject[kHeaders][kHeadersList] = response.headersList;\n    responseObject[kHeaders][kGuard] = 'immutable';\n    responseObject[kHeaders][kRealm] = relevantRealm; // 5. Resolve p with responseObject.\n\n    p.resolve(responseObject);\n  };\n\n  controller = fetching({\n    request,\n    processResponseEndOfBody: handleFetchDone,\n    processResponse,\n    dispatcher: this // undici\n\n  }); // 14. Return p.\n\n  return p.promise;\n} // https://fetch.spec.whatwg.org/#finalize-and-report-timing\n\n\nfunction finalizeAndReportTiming(response) {\n  let initiatorType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'other';\n\n  // 1. If response is an aborted network error, then return.\n  if (response.type === 'error' && response.aborted) {\n    return;\n  } // 2. If response’s URL list is null or empty, then return.\n\n\n  if (!response.urlList?.length) {\n    return;\n  } // 3. Let originalURL be response’s URL list[0].\n\n\n  const originalURL = response.urlList[0]; // 4. Let timingInfo be response’s timing info.\n\n  let timingInfo = response.timingInfo; // 5. Let cacheState be response’s cache state.\n\n  let cacheState = response.cacheState; // 6. If originalURL’s scheme is not an HTTP(S) scheme, then return.\n\n  if (!/^https?:/.test(originalURL.protocol)) {\n    return;\n  } // 7. If timingInfo is null, then return.\n\n\n  if (timingInfo === null) {\n    return;\n  } // 8. If response’s timing allow passed flag is not set, then:\n\n\n  if (!timingInfo.timingAllowPassed) {\n    //  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.\n    timingInfo = createOpaqueTimingInfo({\n      startTime: timingInfo.startTime\n    }); //  2. Set cacheState to the empty string.\n\n    cacheState = '';\n  } // 9. Set timingInfo’s end time to the coarsened shared current time\n  // given global’s relevant settings object’s cross-origin isolated\n  // capability.\n  // TODO: given global’s relevant settings object’s cross-origin isolated\n  // capability?\n\n\n  response.timingInfo.endTime = coarsenedSharedCurrentTime(); // 10. Set response’s timing info to timingInfo.\n\n  response.timingInfo = timingInfo; // 11. Mark resource timing for timingInfo, originalURL, initiatorType,\n  // global, and cacheState.\n\n  markResourceTiming(timingInfo, originalURL, initiatorType, globalThis, cacheState);\n} // https://w3c.github.io/resource-timing/#dfn-mark-resource-timing\n\n\nfunction markResourceTiming(timingInfo, originalURL, initiatorType, globalThis, cacheState) {\n  if (nodeMajor >= 18 && nodeMinor >= 2) {\n    performance.markResourceTiming(timingInfo, originalURL, initiatorType, globalThis, cacheState);\n  }\n} // https://fetch.spec.whatwg.org/#abort-fetch\n\n\nfunction abortFetch(p, request, responseObject) {\n  // 1. Let error be an \"AbortError\" DOMException.\n  const error = new DOMException('The operation was aborted.', 'AbortError'); // 2. Reject promise with error.\n\n  p.reject(error); // 3. If request’s body is not null and is readable, then cancel request’s\n  // body with error.\n\n  if (request.body != null && isReadable(request.body?.stream)) {\n    request.body.stream.cancel(error).catch(err => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return;\n      }\n\n      throw err;\n    });\n  } // 4. If responseObject is null, then return.\n\n\n  if (responseObject == null) {\n    return;\n  } // 5. Let response be responseObject’s response.\n\n\n  const response = responseObject[kState]; // 6. If response’s body is not null and is readable, then error response’s\n  // body with error.\n\n  if (response.body != null && isReadable(response.body?.stream)) {\n    response.body.stream.cancel(error).catch(err => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return;\n      }\n\n      throw err;\n    });\n  }\n} // https://fetch.spec.whatwg.org/#fetching\n\n\nfunction fetching(_ref) {\n  let {\n    request,\n    processRequestBodyChunkLength,\n    processRequestEndOfBody,\n    processResponse,\n    processResponseEndOfBody,\n    processResponseConsumeBody,\n    useParallelQueue = false,\n    dispatcher // undici\n\n  } = _ref;\n  // 1. Let taskDestination be null.\n  let taskDestination = null; // 2. Let crossOriginIsolatedCapability be false.\n\n  let crossOriginIsolatedCapability = false; // 3. If request’s client is non-null, then:\n\n  if (request.client != null) {\n    // 1. Set taskDestination to request’s client’s global object.\n    taskDestination = request.client.globalObject; // 2. Set crossOriginIsolatedCapability to request’s client’s cross-origin\n    // isolated capability.\n\n    crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;\n  } // 4. If useParallelQueue is true, then set taskDestination to the result of\n  // starting a new parallel queue.\n  // TODO\n  // 5. Let timingInfo be a new fetch timing info whose start time and\n  // post-redirect start time are the coarsened shared current time given\n  // crossOriginIsolatedCapability.\n\n\n  const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);\n  const timingInfo = createOpaqueTimingInfo({\n    startTime: currenTime\n  }); // 6. Let fetchParams be a new fetch params whose\n  // request is request,\n  // timing info is timingInfo,\n  // process request body chunk length is processRequestBodyChunkLength,\n  // process request end-of-body is processRequestEndOfBody,\n  // process response is processResponse,\n  // process response consume body is processResponseConsumeBody,\n  // process response end-of-body is processResponseEndOfBody,\n  // task destination is taskDestination,\n  // and cross-origin isolated capability is crossOriginIsolatedCapability.\n\n  const fetchParams = {\n    controller: new Fetch(dispatcher),\n    request,\n    timingInfo,\n    processRequestBodyChunkLength,\n    processRequestEndOfBody,\n    processResponse,\n    processResponseConsumeBody,\n    processResponseEndOfBody,\n    taskDestination,\n    crossOriginIsolatedCapability\n  }; // 7. If request’s body is a byte sequence, then set request’s body to the\n  // first return value of safely extracting request’s body.\n  // NOTE: Since fetching is only called from fetch, body should already be\n  // extracted.\n\n  assert(!request.body || request.body.stream); // 8. If request’s window is \"client\", then set request’s window to request’s\n  // client, if request’s client’s global object is a Window object; otherwise\n  // \"no-window\".\n\n  if (request.window === 'client') {\n    // TODO: What if request.client is null?\n    request.window = request.client?.globalObject?.constructor?.name === 'Window' ? request.client : 'no-window';\n  } // 9. If request’s origin is \"client\", then set request’s origin to request’s\n  // client’s origin.\n\n\n  if (request.origin === 'client') {\n    // TODO: What if request.client is null?\n    request.origin = request.client?.origin;\n  } // 10. If all of the following conditions are true:\n  // TODO\n  // 11. If request’s policy container is \"client\", then:\n\n\n  if (request.policyContainer === 'client') {\n    // 1. If request’s client is non-null, then set request’s policy\n    // container to a clone of request’s client’s policy container. [HTML]\n    if (request.client != null) {\n      request.policyContainer = clonePolicyContainer(request.client.policyContainer);\n    } else {\n      // 2. Otherwise, set request’s policy container to a new policy\n      // container.\n      request.policyContainer = makePolicyContainer();\n    }\n  } // 12. If request’s header list does not contain `Accept`, then:\n\n\n  if (!request.headersList.has('accept')) {\n    // 1. Let value be `*/*`.\n    const value = '*/*'; // 2. A user agent should set value to the first matching statement, if\n    // any, switching on request’s destination:\n    // \"document\"\n    // \"frame\"\n    // \"iframe\"\n    // `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`\n    // \"image\"\n    // `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`\n    // \"style\"\n    // `text/css,*/*;q=0.1`\n    // TODO\n    // 3. Append `Accept`/value to request’s header list.\n\n    request.headersList.append('accept', value);\n  } // 13. If request’s header list does not contain `Accept-Language`, then\n  // user agents should append `Accept-Language`/an appropriate value to\n  // request’s header list.\n\n\n  if (!request.headersList.has('accept-language')) {\n    request.headersList.append('accept-language', '*');\n  } // 14. If request’s priority is null, then use request’s initiator and\n  // destination appropriately in setting request’s priority to a\n  // user-agent-defined object.\n\n\n  if (request.priority === null) {// TODO\n  } // 15. If request is a subresource request, then:\n\n\n  if (subresource.includes(request.destination)) {// TODO\n  } // 16. Run main fetch given fetchParams.\n\n\n  mainFetch(fetchParams).catch(err => {\n    fetchParams.controller.terminate(err);\n  }); // 17. Return fetchParam's controller\n\n  return fetchParams.controller;\n} // https://fetch.spec.whatwg.org/#concept-main-fetch\n\n\nasync function mainFetch(fetchParams) {\n  let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request; // 2. Let response be null.\n\n  let response = null; // 3. If request’s local-URLs-only flag is set and request’s current URL is\n  // not local, then set response to a network error.\n\n  if (request.localURLsOnly && !/^(about|blob|data):/.test(requestCurrentURL(request).protocol)) {\n    response = makeNetworkError('local URLs only');\n  } // 4. Run report Content Security Policy violations for request.\n  // TODO\n  // 5. Upgrade request to a potentially trustworthy URL, if appropriate.\n\n\n  tryUpgradeRequestToAPotentiallyTrustworthyURL(request); // 6. If should request be blocked due to a bad port, should fetching request\n  // be blocked as mixed content, or should request be blocked by Content\n  // Security Policy returns blocked, then set response to a network error.\n\n  if (requestBadPort(request) === 'blocked') {\n    response = makeNetworkError('bad port');\n  } // TODO: should fetching request be blocked as mixed content?\n  // TODO: should request be blocked by Content Security Policy?\n  // 7. If request’s referrer policy is the empty string, then set request’s\n  // referrer policy to request’s policy container’s referrer policy.\n\n\n  if (request.referrerPolicy === '') {\n    request.referrerPolicy = request.policyContainer.referrerPolicy;\n  } // 8. If request’s referrer is not \"no-referrer\", then set request’s\n  // referrer to the result of invoking determine request’s referrer.\n\n\n  if (request.referrer !== 'no-referrer') {\n    request.referrer = determineRequestsReferrer(request);\n  } // 9. Set request’s current URL’s scheme to \"https\" if all of the following\n  // conditions are true:\n  // - request’s current URL’s scheme is \"http\"\n  // - request’s current URL’s host is a domain\n  // - Matching request’s current URL’s host per Known HSTS Host Domain Name\n  //   Matching results in either a superdomain match with an asserted\n  //   includeSubDomains directive or a congruent match (with or without an\n  //   asserted includeSubDomains directive). [HSTS]\n  // TODO\n  // 10. If recursive is false, then run the remaining steps in parallel.\n  // TODO\n  // 11. If response is null, then set response to the result of running\n  // the steps corresponding to the first matching statement:\n\n\n  if (response === null) {\n    response = await (async () => {\n      const currentURL = requestCurrentURL(request);\n\n      if ( // - request’s current URL’s origin is same origin with request’s origin,\n      //   and request’s response tainting is \"basic\"\n      sameOrigin(currentURL, request.url) && request.responseTainting === 'basic' || // request’s current URL’s scheme is \"data\"\n      currentURL.protocol === 'data:' || // - request’s mode is \"navigate\" or \"websocket\"\n      request.mode === 'navigate' || request.mode === 'websocket') {\n        // 1. Set request’s response tainting to \"basic\".\n        request.responseTainting = 'basic'; // 2. Return the result of running scheme fetch given fetchParams.\n\n        return await schemeFetch(fetchParams);\n      } // request’s mode is \"same-origin\"\n\n\n      if (request.mode === 'same-origin') {\n        // 1. Return a network error.\n        return makeNetworkError('request mode cannot be \"same-origin\"');\n      } // request’s mode is \"no-cors\"\n\n\n      if (request.mode === 'no-cors') {\n        // 1. If request’s redirect mode is not \"follow\", then return a network\n        // error.\n        if (request.redirect !== 'follow') {\n          return makeNetworkError('redirect mode cannot be \"follow\" for \"no-cors\" request');\n        } // 2. Set request’s response tainting to \"opaque\".\n\n\n        request.responseTainting = 'opaque'; // 3. Return the result of running scheme fetch given fetchParams.\n\n        return await schemeFetch(fetchParams);\n      } // request’s current URL’s scheme is not an HTTP(S) scheme\n\n\n      if (!/^https?:/.test(requestCurrentURL(request).protocol)) {\n        // Return a network error.\n        return makeNetworkError('URL scheme must be a HTTP(S) scheme');\n      } // - request’s use-CORS-preflight flag is set\n      // - request’s unsafe-request flag is set and either request’s method is\n      //   not a CORS-safelisted method or CORS-unsafe request-header names with\n      //   request’s header list is not empty\n      //    1. Set request’s response tainting to \"cors\".\n      //    2. Let corsWithPreflightResponse be the result of running HTTP fetch\n      //    given fetchParams and true.\n      //    3. If corsWithPreflightResponse is a network error, then clear cache\n      //    entries using request.\n      //    4. Return corsWithPreflightResponse.\n      // TODO\n      // Otherwise\n      //    1. Set request’s response tainting to \"cors\".\n\n\n      request.responseTainting = 'cors'; //    2. Return the result of running HTTP fetch given fetchParams.\n\n      return await httpFetch(fetchParams);\n    })();\n  } // 12. If recursive is true, then return response.\n\n\n  if (recursive) {\n    return response;\n  } // 13. If response is not a network error and response is not a filtered\n  // response, then:\n\n\n  if (response.status !== 0 && !response.internalResponse) {\n    // If request’s response tainting is \"cors\", then:\n    if (request.responseTainting === 'cors') {// 1. Let headerNames be the result of extracting header list values\n      // given `Access-Control-Expose-Headers` and response’s header list.\n      // TODO\n      // 2. If request’s credentials mode is not \"include\" and headerNames\n      // contains `*`, then set response’s CORS-exposed header-name list to\n      // all unique header names in response’s header list.\n      // TODO\n      // 3. Otherwise, if headerNames is not null or failure, then set\n      // response’s CORS-exposed header-name list to headerNames.\n      // TODO\n    } // Set response to the following filtered response with response as its\n    // internal response, depending on request’s response tainting:\n\n\n    if (request.responseTainting === 'basic') {\n      response = filterResponse(response, 'basic');\n    } else if (request.responseTainting === 'cors') {\n      response = filterResponse(response, 'cors');\n    } else if (request.responseTainting === 'opaque') {\n      response = filterResponse(response, 'opaque');\n    } else {\n      assert(false);\n    }\n  } // 14. Let internalResponse be response, if response is a network error,\n  // and response’s internal response otherwise.\n\n\n  let internalResponse = response.status === 0 ? response : response.internalResponse; // 15. If internalResponse’s URL list is empty, then set it to a clone of\n  // request’s URL list.\n\n  if (internalResponse.urlList.length === 0) {\n    internalResponse.urlList.push(...request.urlList);\n  } // 16. If request’s timing allow failed flag is unset, then set\n  // internalResponse’s timing allow passed flag.\n\n\n  if (!request.timingAllowFailed) {\n    response.timingAllowPassed = true;\n  } // 17. If response is not a network error and any of the following returns\n  // blocked\n  // - should internalResponse to request be blocked as mixed content\n  // - should internalResponse to request be blocked by Content Security Policy\n  // - should internalResponse to request be blocked due to its MIME type\n  // - should internalResponse to request be blocked due to nosniff\n  // TODO\n  // 18. If response’s type is \"opaque\", internalResponse’s status is 206,\n  // internalResponse’s range-requested flag is set, and request’s header\n  // list does not contain `Range`, then set response and internalResponse\n  // to a network error.\n\n\n  if (response.type === 'opaque' && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.has('range')) {\n    response = internalResponse = makeNetworkError();\n  } // 19. If response is not a network error and either request’s method is\n  // `HEAD` or `CONNECT`, or internalResponse’s status is a null body status,\n  // set internalResponse’s body to null and disregard any enqueuing toward\n  // it (if any).\n\n\n  if (response.status !== 0 && (request.method === 'HEAD' || request.method === 'CONNECT' || nullBodyStatus.includes(internalResponse.status))) {\n    internalResponse.body = null;\n    fetchParams.controller.dump = true;\n  } // 20. If request’s integrity metadata is not the empty string, then:\n\n\n  if (request.integrity) {\n    // 1. Let processBodyError be this step: run fetch finale given fetchParams\n    // and a network error.\n    const processBodyError = reason => fetchFinale(fetchParams, makeNetworkError(reason)); // 2. If request’s response tainting is \"opaque\", or response’s body is null,\n    // then run processBodyError and abort these steps.\n\n\n    if (request.responseTainting === 'opaque' || response.body == null) {\n      processBodyError(response.error);\n      return;\n    } // 3. Let processBody given bytes be these steps:\n\n\n    const processBody = bytes => {\n      // 1. If bytes do not match request’s integrity metadata,\n      // then run processBodyError and abort these steps. [SRI]\n      if (!bytesMatch(bytes, request.integrity)) {\n        processBodyError('integrity mismatch');\n        return;\n      } // 2. Set response’s body to the first return value of safely\n      // extracting bytes.\n\n\n      response.body = safelyExtractBody(bytes)[0]; // 3. Run fetch finale given fetchParams and response.\n\n      fetchFinale(fetchParams, response);\n    }; // 4. Fully read response’s body given processBody and processBodyError.\n\n\n    await fullyReadBody(response.body, processBody, processBodyError);\n  } else {\n    // 21. Otherwise, run fetch finale given fetchParams and response.\n    fetchFinale(fetchParams, response);\n  }\n} // https://fetch.spec.whatwg.org/#concept-scheme-fetch\n// given a fetch params fetchParams\n\n\nasync function schemeFetch(fetchParams) {\n  // let request be fetchParams’s request\n  const {\n    request\n  } = fetchParams;\n  const {\n    protocol: scheme,\n    pathname: path\n  } = requestCurrentURL(request); // switch on request’s current URL’s scheme, and run the associated steps:\n\n  switch (scheme) {\n    case 'about:':\n      {\n        // If request’s current URL’s path is the string \"blank\", then return a new response\n        // whose status message is `OK`, header list is « (`Content-Type`, `text/html;charset=utf-8`) »,\n        // and body is the empty byte sequence.\n        if (path === 'blank') {\n          const resp = makeResponse({\n            statusText: 'OK',\n            headersList: [['content-type', 'text/html;charset=utf-8']]\n          });\n          resp.urlList = [new URL('about:blank')];\n          return resp;\n        } // Otherwise, return a network error.\n\n\n        return makeNetworkError('invalid path called');\n      }\n\n    case 'blob:':\n      {\n        resolveObjectURL = resolveObjectURL || require('buffer').resolveObjectURL; // 1. Run these steps, but abort when the ongoing fetch is terminated:\n        //    1. Let blob be request’s current URL’s blob URL entry’s object.\n        //       https://w3c.github.io/FileAPI/#blob-url-entry\n        //       P.S. Thank God this method is available in node.\n\n        const currentURL = requestCurrentURL(request); // https://github.com/web-platform-tests/wpt/blob/7b0ebaccc62b566a1965396e5be7bb2bc06f841f/FileAPI/url/resources/fetch-tests.js#L52-L56\n        // Buffer.resolveObjectURL does not ignore URL queries.\n\n        if (currentURL.search.length !== 0) {\n          return makeNetworkError('NetworkError when attempting to fetch resource.');\n        }\n\n        const blob = resolveObjectURL(currentURL.toString()); //    2. If request’s method is not `GET` or blob is not a Blob object, then return a network error. [FILEAPI]\n\n        if (request.method !== 'GET' || !isBlobLike(blob)) {\n          return makeNetworkError('invalid method');\n        } //    3. Let response be a new response whose status message is `OK`.\n\n\n        const response = makeResponse({\n          statusText: 'OK',\n          urlList: [currentURL]\n        }); //    4. Append (`Content-Length`, blob’s size attribute value) to response’s header list.\n\n        response.headersList.set('content-length', `${blob.size}`); //    5. Append (`Content-Type`, blob’s type attribute value) to response’s header list.\n\n        response.headersList.set('content-type', blob.type); //    6. Set response’s body to the result of performing the read operation on blob.\n        // TODO (fix): This needs to read?\n\n        response.body = extractBody(blob)[0]; //    7. Return response.\n\n        return response; // 2. If aborted, then return the appropriate network error for fetchParams.\n        // TODO\n      }\n\n    case 'data:':\n      {\n        // 1. Let dataURLStruct be the result of running the\n        //    data: URL processor on request’s current URL.\n        const currentURL = requestCurrentURL(request);\n        const dataURLStruct = dataURLProcessor(currentURL); // 2. If dataURLStruct is failure, then return a\n        //    network error.\n\n        if (dataURLStruct === 'failure') {\n          return makeNetworkError('failed to fetch the data URL');\n        } // 3. Let mimeType be dataURLStruct’s MIME type, serialized.\n\n\n        const mimeType = serializeAMimeType(dataURLStruct.mimeType); // 4. Return a response whose status message is `OK`,\n        //    header list is « (`Content-Type`, mimeType) »,\n        //    and body is dataURLStruct’s body.\n\n        return makeResponse({\n          statusText: 'OK',\n          headersList: [['content-type', mimeType]],\n          body: extractBody(dataURLStruct.body)[0]\n        });\n      }\n\n    case 'file:':\n      {\n        // For now, unfortunate as it is, file URLs are left as an exercise for the reader.\n        // When in doubt, return a network error.\n        return makeNetworkError('not implemented... yet...');\n      }\n\n    case 'http:':\n    case 'https:':\n      {\n        // Return the result of running HTTP fetch given fetchParams.\n        return await httpFetch(fetchParams).catch(err => makeNetworkError(err));\n      }\n\n    default:\n      {\n        return makeNetworkError('unknown scheme');\n      }\n  }\n} // https://fetch.spec.whatwg.org/#finalize-response\n\n\nfunction finalizeResponse(fetchParams, response) {\n  // 1. Set fetchParams’s request’s done flag.\n  fetchParams.request.done = true; // 2, If fetchParams’s process response done is not null, then queue a fetch\n  // task to run fetchParams’s process response done given response, with\n  // fetchParams’s task destination.\n\n  if (fetchParams.processResponseDone != null) {\n    queueMicrotask(() => fetchParams.processResponseDone(response));\n  }\n} // https://fetch.spec.whatwg.org/#fetch-finale\n\n\nasync function fetchFinale(fetchParams, response) {\n  // 1. If response is a network error, then:\n  if (response.type === 'error') {\n    // 1. Set response’s URL list to « fetchParams’s request’s URL list[0] ».\n    response.urlList = [fetchParams.request.urlList[0]]; // 2. Set response’s timing info to the result of creating an opaque timing\n    // info for fetchParams’s timing info.\n\n    response.timingInfo = createOpaqueTimingInfo({\n      startTime: fetchParams.timingInfo.startTime\n    });\n  } // 2. Let processResponseEndOfBody be the following steps:\n\n\n  const processResponseEndOfBody = () => {\n    // 1. Set fetchParams’s request’s done flag.\n    fetchParams.request.done = true; // If fetchParams’s process response end-of-body is not null,\n    // then queue a fetch task to run fetchParams’s process response\n    // end-of-body given response with fetchParams’s task destination.\n\n    if (fetchParams.processResponseEndOfBody != null) {\n      queueMicrotask(() => fetchParams.processResponseEndOfBody(response));\n    }\n  }; // 3. If fetchParams’s process response is non-null, then queue a fetch task\n  // to run fetchParams’s process response given response, with fetchParams’s\n  // task destination.\n\n\n  if (fetchParams.processResponse != null) {\n    queueMicrotask(() => fetchParams.processResponse(response));\n  } // 4. If response’s body is null, then run processResponseEndOfBody.\n\n\n  if (response.body == null) {\n    processResponseEndOfBody();\n  } else {\n    // 5. Otherwise:\n    // 1. Let transformStream be a new a TransformStream.\n    // 2. Let identityTransformAlgorithm be an algorithm which, given chunk,\n    // enqueues chunk in transformStream.\n    const identityTransformAlgorithm = (chunk, controller) => {\n      controller.enqueue(chunk);\n    }; // 3. Set up transformStream with transformAlgorithm set to identityTransformAlgorithm\n    // and flushAlgorithm set to processResponseEndOfBody.\n\n\n    const transformStream = new TransformStream({\n      start() {},\n\n      transform: identityTransformAlgorithm,\n      flush: processResponseEndOfBody\n    }); // 4. Set response’s body to the result of piping response’s body through transformStream.\n\n    response.body = {\n      stream: response.body.stream.pipeThrough(transformStream)\n    };\n  } // 6. If fetchParams’s process response consume body is non-null, then:\n\n\n  if (fetchParams.processResponseConsumeBody != null) {\n    // 1. Let processBody given nullOrBytes be this step: run fetchParams’s\n    // process response consume body given response and nullOrBytes.\n    const processBody = nullOrBytes => fetchParams.processResponseConsumeBody(response, nullOrBytes); // 2. Let processBodyError be this step: run fetchParams’s process\n    // response consume body given response and failure.\n\n\n    const processBodyError = failure => fetchParams.processResponseConsumeBody(response, failure); // 3. If response’s body is null, then queue a fetch task to run processBody\n    // given null, with fetchParams’s task destination.\n\n\n    if (response.body == null) {\n      queueMicrotask(() => processBody(null));\n    } else {\n      // 4. Otherwise, fully read response’s body given processBody, processBodyError,\n      // and fetchParams’s task destination.\n      await fullyReadBody(response.body, processBody, processBodyError);\n    }\n  }\n} // https://fetch.spec.whatwg.org/#http-fetch\n\n\nasync function httpFetch(fetchParams) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request; // 2. Let response be null.\n\n  let response = null; // 3. Let actualResponse be null.\n\n  let actualResponse = null; // 4. Let timingInfo be fetchParams’s timing info.\n\n  const timingInfo = fetchParams.timingInfo; // 5. If request’s service-workers mode is \"all\", then:\n\n  if (request.serviceWorkers === 'all') {// TODO\n  } // 6. If response is null, then:\n\n\n  if (response === null) {\n    // 1. If makeCORSPreflight is true and one of these conditions is true:\n    // TODO\n    // 2. If request’s redirect mode is \"follow\", then set request’s\n    // service-workers mode to \"none\".\n    if (request.redirect === 'follow') {\n      request.serviceWorkers = 'none';\n    } // 3. Set response and actualResponse to the result of running\n    // HTTP-network-or-cache fetch given fetchParams.\n\n\n    actualResponse = response = await httpNetworkOrCacheFetch(fetchParams); // 4. If request’s response tainting is \"cors\" and a CORS check\n    // for request and response returns failure, then return a network error.\n\n    if (request.responseTainting === 'cors' && corsCheck(request, response) === 'failure') {\n      return makeNetworkError('cors failure');\n    } // 5. If the TAO check for request and response returns failure, then set\n    // request’s timing allow failed flag.\n\n\n    if (TAOCheck(request, response) === 'failure') {\n      request.timingAllowFailed = true;\n    }\n  } // 7. If either request’s response tainting or response’s type\n  // is \"opaque\", and the cross-origin resource policy check with\n  // request’s origin, request’s client, request’s destination,\n  // and actualResponse returns blocked, then return a network error.\n\n\n  if ((request.responseTainting === 'opaque' || response.type === 'opaque') && crossOriginResourcePolicyCheck(request.origin, request.client, request.destination, actualResponse) === 'blocked') {\n    return makeNetworkError('blocked');\n  } // 8. If actualResponse’s status is a redirect status, then:\n\n\n  if (redirectStatus.includes(actualResponse.status)) {\n    // 1. If actualResponse’s status is not 303, request’s body is not null,\n    // and the connection uses HTTP/2, then user agents may, and are even\n    // encouraged to, transmit an RST_STREAM frame.\n    // See, https://github.com/whatwg/fetch/issues/1288\n    if (request.redirect !== 'manual') {\n      fetchParams.controller.connection.destroy();\n    } // 2. Switch on request’s redirect mode:\n\n\n    if (request.redirect === 'error') {\n      // Set response to a network error.\n      response = makeNetworkError('unexpected redirect');\n    } else if (request.redirect === 'manual') {\n      // Set response to an opaque-redirect filtered response whose internal\n      // response is actualResponse.\n      // NOTE(spec): On the web this would return an `opaqueredirect` response,\n      // but that doesn't make sense server side.\n      // See https://github.com/nodejs/undici/issues/1193.\n      response = actualResponse;\n    } else if (request.redirect === 'follow') {\n      // Set response to the result of running HTTP-redirect fetch given\n      // fetchParams and response.\n      response = await httpRedirectFetch(fetchParams, response);\n    } else {\n      assert(false);\n    }\n  } // 9. Set response’s timing info to timingInfo.\n\n\n  response.timingInfo = timingInfo; // 10. Return response.\n\n  return response;\n} // https://fetch.spec.whatwg.org/#http-redirect-fetch\n\n\nasync function httpRedirectFetch(fetchParams, response) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request; // 2. Let actualResponse be response, if response is not a filtered response,\n  // and response’s internal response otherwise.\n\n  const actualResponse = response.internalResponse ? response.internalResponse : response; // 3. Let locationURL be actualResponse’s location URL given request’s current\n  // URL’s fragment.\n\n  let locationURL;\n\n  try {\n    locationURL = responseLocationURL(actualResponse, requestCurrentURL(request).hash); // 4. If locationURL is null, then return response.\n\n    if (locationURL == null) {\n      return response;\n    }\n  } catch (err) {\n    // 5. If locationURL is failure, then return a network error.\n    return makeNetworkError(err);\n  } // 6. If locationURL’s scheme is not an HTTP(S) scheme, then return a network\n  // error.\n\n\n  if (!/^https?:/.test(locationURL.protocol)) {\n    return makeNetworkError('URL scheme must be a HTTP(S) scheme');\n  } // 7. If request’s redirect count is twenty, return a network error.\n\n\n  if (request.redirectCount === 20) {\n    return makeNetworkError('redirect count exceeded');\n  } // 8. Increase request’s redirect count by one.\n\n\n  request.redirectCount += 1; // 9. If request’s mode is \"cors\", locationURL includes credentials, and\n  // request’s origin is not same origin with locationURL’s origin, then return\n  //  a network error.\n\n  if (request.mode === 'cors' && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {\n    return makeNetworkError('cross origin not allowed for request mode \"cors\"');\n  } // 10. If request’s response tainting is \"cors\" and locationURL includes\n  // credentials, then return a network error.\n\n\n  if (request.responseTainting === 'cors' && (locationURL.username || locationURL.password)) {\n    return makeNetworkError('URL cannot contain credentials for request mode \"cors\"');\n  } // 11. If actualResponse’s status is not 303, request’s body is non-null,\n  // and request’s body’s source is null, then return a network error.\n\n\n  if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {\n    return makeNetworkError();\n  } // 12. If one of the following is true\n  // - actualResponse’s status is 301 or 302 and request’s method is `POST`\n  // - actualResponse’s status is 303 and request’s method is not `GET` or `HEAD`\n\n\n  if ([301, 302].includes(actualResponse.status) && request.method === 'POST' || actualResponse.status === 303 && !['GET', 'HEAD'].includes(request.method)) {\n    // then:\n    // 1. Set request’s method to `GET` and request’s body to null.\n    request.method = 'GET';\n    request.body = null; // 2. For each headerName of request-body-header name, delete headerName from\n    // request’s header list.\n\n    for (const headerName of requestBodyHeader) {\n      request.headersList.delete(headerName);\n    }\n  } // 13. If request’s body is non-null, then set request’s body to the first return\n  // value of safely extracting request’s body’s source.\n\n\n  if (request.body != null) {\n    assert(request.body.source);\n    request.body = safelyExtractBody(request.body.source)[0];\n  } // 14. Let timingInfo be fetchParams’s timing info.\n\n\n  const timingInfo = fetchParams.timingInfo; // 15. Set timingInfo’s redirect end time and post-redirect start time to the\n  // coarsened shared current time given fetchParams’s cross-origin isolated\n  // capability.\n\n  timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability); // 16. If timingInfo’s redirect start time is 0, then set timingInfo’s\n  //  redirect start time to timingInfo’s start time.\n\n  if (timingInfo.redirectStartTime === 0) {\n    timingInfo.redirectStartTime = timingInfo.startTime;\n  } // 17. Append locationURL to request’s URL list.\n\n\n  request.urlList.push(locationURL); // 18. Invoke set request’s referrer policy on redirect on request and\n  // actualResponse.\n\n  setRequestReferrerPolicyOnRedirect(request, actualResponse); // 19. Return the result of running main fetch given fetchParams and true.\n\n  return mainFetch(fetchParams, true);\n} // https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\n\n\nasync function httpNetworkOrCacheFetch(fetchParams) {\n  let isAuthenticationFetch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let isNewConnectionFetch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request; // 2. Let httpFetchParams be null.\n\n  let httpFetchParams = null; // 3. Let httpRequest be null.\n\n  let httpRequest = null; // 4. Let response be null.\n\n  let response = null; // 5. Let storedResponse be null.\n  // TODO: cache\n  // 6. Let httpCache be null.\n\n  const httpCache = null; // 7. Let the revalidatingFlag be unset.\n\n  const revalidatingFlag = false; // 8. Run these steps, but abort when the ongoing fetch is terminated:\n  //    1. If request’s window is \"no-window\" and request’s redirect mode is\n  //    \"error\", then set httpFetchParams to fetchParams and httpRequest to\n  //    request.\n\n  if (request.window === 'no-window' && request.redirect === 'error') {\n    httpFetchParams = fetchParams;\n    httpRequest = request;\n  } else {\n    // Otherwise:\n    // 1. Set httpRequest to a clone of request.\n    httpRequest = makeRequest(request); // 2. Set httpFetchParams to a copy of fetchParams.\n\n    httpFetchParams = { ...fetchParams\n    }; // 3. Set httpFetchParams’s request to httpRequest.\n\n    httpFetchParams.request = httpRequest;\n  } //    3. Let includeCredentials be true if one of\n\n\n  const includeCredentials = request.credentials === 'include' || request.credentials === 'same-origin' && request.responseTainting === 'basic'; //    4. Let contentLength be httpRequest’s body’s length, if httpRequest’s\n  //    body is non-null; otherwise null.\n\n  const contentLength = httpRequest.body ? httpRequest.body.length : null; //    5. Let contentLengthHeaderValue be null.\n\n  let contentLengthHeaderValue = null; //    6. If httpRequest’s body is null and httpRequest’s method is `POST` or\n  //    `PUT`, then set contentLengthHeaderValue to `0`.\n\n  if (httpRequest.body == null && ['POST', 'PUT'].includes(httpRequest.method)) {\n    contentLengthHeaderValue = '0';\n  } //    7. If contentLength is non-null, then set contentLengthHeaderValue to\n  //    contentLength, serialized and isomorphic encoded.\n\n\n  if (contentLength != null) {\n    // TODO: isomorphic encoded\n    contentLengthHeaderValue = String(contentLength);\n  } //    8. If contentLengthHeaderValue is non-null, then append\n  //    `Content-Length`/contentLengthHeaderValue to httpRequest’s header\n  //    list.\n\n\n  if (contentLengthHeaderValue != null) {\n    httpRequest.headersList.append('content-length', contentLengthHeaderValue);\n  } //    9. If contentLengthHeaderValue is non-null, then append (`Content-Length`,\n  //    contentLengthHeaderValue) to httpRequest’s header list.\n  //    10. If contentLength is non-null and httpRequest’s keepalive is true,\n  //    then:\n\n\n  if (contentLength != null && httpRequest.keepalive) {// NOTE: keepalive is a noop outside of browser context.\n  } //    11. If httpRequest’s referrer is a URL, then append\n  //    `Referer`/httpRequest’s referrer, serialized and isomorphic encoded,\n  //     to httpRequest’s header list.\n\n\n  if (httpRequest.referrer instanceof URL) {\n    // TODO: isomorphic encoded\n    httpRequest.headersList.append('referer', httpRequest.referrer.href);\n  } //    12. Append a request `Origin` header for httpRequest.\n\n\n  appendRequestOriginHeader(httpRequest); //    13. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]\n\n  appendFetchMetadata(httpRequest); //    14. If httpRequest’s header list does not contain `User-Agent`, then\n  //    user agents should append `User-Agent`/default `User-Agent` value to\n  //    httpRequest’s header list.\n\n  if (!httpRequest.headersList.has('user-agent')) {\n    httpRequest.headersList.append('user-agent', 'undici');\n  } //    15. If httpRequest’s cache mode is \"default\" and httpRequest’s header\n  //    list contains `If-Modified-Since`, `If-None-Match`,\n  //    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set\n  //    httpRequest’s cache mode to \"no-store\".\n\n\n  if (httpRequest.cache === 'default' && (httpRequest.headersList.has('if-modified-since') || httpRequest.headersList.has('if-none-match') || httpRequest.headersList.has('if-unmodified-since') || httpRequest.headersList.has('if-match') || httpRequest.headersList.has('if-range'))) {\n    httpRequest.cache = 'no-store';\n  } //    16. If httpRequest’s cache mode is \"no-cache\", httpRequest’s prevent\n  //    no-cache cache-control header modification flag is unset, and\n  //    httpRequest’s header list does not contain `Cache-Control`, then append\n  //    `Cache-Control`/`max-age=0` to httpRequest’s header list.\n\n\n  if (httpRequest.cache === 'no-cache' && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.has('cache-control')) {\n    httpRequest.headersList.append('cache-control', 'max-age=0');\n  } //    17. If httpRequest’s cache mode is \"no-store\" or \"reload\", then:\n\n\n  if (httpRequest.cache === 'no-store' || httpRequest.cache === 'reload') {\n    // 1. If httpRequest’s header list does not contain `Pragma`, then append\n    // `Pragma`/`no-cache` to httpRequest’s header list.\n    if (!httpRequest.headersList.has('pragma')) {\n      httpRequest.headersList.append('pragma', 'no-cache');\n    } // 2. If httpRequest’s header list does not contain `Cache-Control`,\n    // then append `Cache-Control`/`no-cache` to httpRequest’s header list.\n\n\n    if (!httpRequest.headersList.has('cache-control')) {\n      httpRequest.headersList.append('cache-control', 'no-cache');\n    }\n  } //    18. If httpRequest’s header list contains `Range`, then append\n  //    `Accept-Encoding`/`identity` to httpRequest’s header list.\n\n\n  if (httpRequest.headersList.has('range')) {\n    httpRequest.headersList.append('accept-encoding', 'identity');\n  } //    19. Modify httpRequest’s header list per HTTP. Do not append a given\n  //    header if httpRequest’s header list contains that header’s name.\n  //    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129\n\n\n  if (!httpRequest.headersList.has('accept-encoding')) {\n    if (/^https:/.test(requestCurrentURL(httpRequest).protocol)) {\n      httpRequest.headersList.append('accept-encoding', 'br, gzip, deflate');\n    } else {\n      httpRequest.headersList.append('accept-encoding', 'gzip, deflate');\n    }\n  } //    20. If includeCredentials is true, then:\n\n\n  if (includeCredentials) {// 1. If the user agent is not configured to block cookies for httpRequest\n    // (see section 7 of [COOKIES]), then:\n    // TODO: credentials\n    // 2. If httpRequest’s header list does not contain `Authorization`, then:\n    // TODO: credentials\n  } //    21. If there’s a proxy-authentication entry, use it as appropriate.\n  //    TODO: proxy-authentication\n  //    22. Set httpCache to the result of determining the HTTP cache\n  //    partition, given httpRequest.\n  //    TODO: cache\n  //    23. If httpCache is null, then set httpRequest’s cache mode to\n  //    \"no-store\".\n\n\n  if (httpCache == null) {\n    httpRequest.cache = 'no-store';\n  } //    24. If httpRequest’s cache mode is neither \"no-store\" nor \"reload\",\n  //    then:\n\n\n  if (httpRequest.mode !== 'no-store' && httpRequest.mode !== 'reload') {// TODO: cache\n  } // 9. If aborted, then return the appropriate network error for fetchParams.\n  // TODO\n  // 10. If response is null, then:\n\n\n  if (response == null) {\n    // 1. If httpRequest’s cache mode is \"only-if-cached\", then return a\n    // network error.\n    if (httpRequest.mode === 'only-if-cached') {\n      return makeNetworkError('only if cached');\n    } // 2. Let forwardResponse be the result of running HTTP-network fetch\n    // given httpFetchParams, includeCredentials, and isNewConnectionFetch.\n\n\n    const forwardResponse = await httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch); // 3. If httpRequest’s method is unsafe and forwardResponse’s status is\n    // in the range 200 to 399, inclusive, invalidate appropriate stored\n    // responses in httpCache, as per the \"Invalidation\" chapter of HTTP\n    // Caching, and set storedResponse to null. [HTTP-CACHING]\n\n    if (!safeMethods.includes(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {// TODO: cache\n    } // 4. If the revalidatingFlag is set and forwardResponse’s status is 304,\n    // then:\n\n\n    if (revalidatingFlag && forwardResponse.status === 304) {// TODO: cache\n    } // 5. If response is null, then:\n\n\n    if (response == null) {\n      // 1. Set response to forwardResponse.\n      response = forwardResponse; // 2. Store httpRequest and forwardResponse in httpCache, as per the\n      // \"Storing Responses in Caches\" chapter of HTTP Caching. [HTTP-CACHING]\n      // TODO: cache\n    }\n  } // 11. Set response’s URL list to a clone of httpRequest’s URL list.\n\n\n  response.urlList = [...httpRequest.urlList]; // 12. If httpRequest’s header list contains `Range`, then set response’s\n  // range-requested flag.\n\n  if (httpRequest.headersList.has('range')) {\n    response.rangeRequested = true;\n  } // 13. Set response’s request-includes-credentials to includeCredentials.\n\n\n  response.requestIncludesCredentials = includeCredentials; // 14. If response’s status is 401, httpRequest’s response tainting is not\n  // \"cors\", includeCredentials is true, and request’s window is an environment\n  // settings object, then:\n  // TODO\n  // 15. If response’s status is 407, then:\n\n  if (response.status === 407) {\n    // 1. If request’s window is \"no-window\", then return a network error.\n    if (request.window === 'no-window') {\n      return makeNetworkError();\n    } // 2. ???\n    // 3. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n\n\n    if (isCancelled(fetchParams)) {\n      return makeAppropriateNetworkError(fetchParams);\n    } // 4. Prompt the end user as appropriate in request’s window and store\n    // the result as a proxy-authentication entry. [HTTP-AUTH]\n    // TODO: Invoke some kind of callback?\n    // 5. Set response to the result of running HTTP-network-or-cache fetch given\n    // fetchParams.\n    // TODO\n\n\n    return makeNetworkError('proxy authentication required');\n  } // 16. If all of the following are true\n\n\n  if ( // response’s status is 421\n  response.status === 421 && // isNewConnectionFetch is false\n  !isNewConnectionFetch && ( // request’s body is null, or request’s body is non-null and request’s body’s source is non-null\n  request.body == null || request.body.source != null)) {\n    // then:\n    // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if (isCancelled(fetchParams)) {\n      return makeAppropriateNetworkError(fetchParams);\n    } // 2. Set response to the result of running HTTP-network-or-cache\n    // fetch given fetchParams, isAuthenticationFetch, and true.\n    // TODO (spec): The spec doesn't specify this but we need to cancel\n    // the active response before we can start a new one.\n    // https://github.com/whatwg/fetch/issues/1293\n\n\n    fetchParams.controller.connection.destroy();\n    response = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, true);\n  } // 17. If isAuthenticationFetch is true, then create an authentication entry\n\n\n  if (isAuthenticationFetch) {// TODO\n  } // 18. Return response.\n\n\n  return response;\n} // https://fetch.spec.whatwg.org/#http-network-fetch\n\n\nasync function httpNetworkFetch(fetchParams) {\n  let includeCredentials = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let forceNewConnection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);\n  fetchParams.controller.connection = {\n    abort: null,\n    destroyed: false,\n\n    destroy(err) {\n      if (!this.destroyed) {\n        this.destroyed = true;\n        this.abort?.(err ?? new DOMException('The operation was aborted.', 'AbortError'));\n      }\n    }\n\n  }; // 1. Let request be fetchParams’s request.\n\n  const request = fetchParams.request; // 2. Let response be null.\n\n  let response = null; // 3. Let timingInfo be fetchParams’s timing info.\n\n  const timingInfo = fetchParams.timingInfo; // 4. Let httpCache be the result of determining the HTTP cache partition,\n  // given request.\n  // TODO: cache\n\n  const httpCache = null; // 5. If httpCache is null, then set request’s cache mode to \"no-store\".\n\n  if (httpCache == null) {\n    request.cache = 'no-store';\n  } // 6. Let networkPartitionKey be the result of determining the network\n  // partition key given request.\n  // TODO\n  // 7. Let newConnection be \"yes\" if forceNewConnection is true; otherwise\n  // \"no\".\n\n\n  const newConnection = forceNewConnection ? 'yes' : 'no'; // eslint-disable-line no-unused-vars\n  // 8. Switch on request’s mode:\n\n  if (request.mode === 'websocket') {// Let connection be the result of obtaining a WebSocket connection,\n    // given request’s current URL.\n    // TODO\n  } else {// Let connection be the result of obtaining a connection, given\n    // networkPartitionKey, request’s current URL’s origin,\n    // includeCredentials, and forceNewConnection.\n    // TODO\n  } // 9. Run these steps, but abort when the ongoing fetch is terminated:\n  //    1. If connection is failure, then return a network error.\n  //    2. Set timingInfo’s final connection timing info to the result of\n  //    calling clamp and coarsen connection timing info with connection’s\n  //    timing info, timingInfo’s post-redirect start time, and fetchParams’s\n  //    cross-origin isolated capability.\n  //    3. If connection is not an HTTP/2 connection, request’s body is non-null,\n  //    and request’s body’s source is null, then append (`Transfer-Encoding`,\n  //    `chunked`) to request’s header list.\n  //    4. Set timingInfo’s final network-request start time to the coarsened\n  //    shared current time given fetchParams’s cross-origin isolated\n  //    capability.\n  //    5. Set response to the result of making an HTTP request over connection\n  //    using request with the following caveats:\n  //        - Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]\n  //        [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]\n  //        - If request’s body is non-null, and request’s body’s source is null,\n  //        then the user agent may have a buffer of up to 64 kibibytes and store\n  //        a part of request’s body in that buffer. If the user agent reads from\n  //        request’s body beyond that buffer’s size and the user agent needs to\n  //        resend request, then instead return a network error.\n  //        - Set timingInfo’s final network-response start time to the coarsened\n  //        shared current time given fetchParams’s cross-origin isolated capability,\n  //        immediately after the user agent’s HTTP parser receives the first byte\n  //        of the response (e.g., frame header bytes for HTTP/2 or response status\n  //        line for HTTP/1.x).\n  //        - Wait until all the headers are transmitted.\n  //        - Any responses whose status is in the range 100 to 199, inclusive,\n  //        and is not 101, are to be ignored, except for the purposes of setting\n  //        timingInfo’s final network-response start time above.\n  //    - If request’s header list contains `Transfer-Encoding`/`chunked` and\n  //    response is transferred via HTTP/1.0 or older, then return a network\n  //    error.\n  //    - If the HTTP request results in a TLS client certificate dialog, then:\n  //        1. If request’s window is an environment settings object, make the\n  //        dialog available in request’s window.\n  //        2. Otherwise, return a network error.\n  // To transmit request’s body body, run these steps:\n\n\n  let requestBody = null; // 1. If body is null and fetchParams’s process request end-of-body is\n  // non-null, then queue a fetch task given fetchParams’s process request\n  // end-of-body and fetchParams’s task destination.\n\n  if (request.body == null && fetchParams.processRequestEndOfBody) {\n    queueMicrotask(() => fetchParams.processRequestEndOfBody());\n  } else if (request.body != null) {\n    // 2. Otherwise, if body is non-null:\n    //    1. Let processBodyChunk given bytes be these steps:\n    const processBodyChunk = async function* (bytes) {\n      // 1. If the ongoing fetch is terminated, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return;\n      } // 2. Run this step in parallel: transmit bytes.\n\n\n      yield bytes; // 3. If fetchParams’s process request body is non-null, then run\n      // fetchParams’s process request body given bytes’s length.\n\n      fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);\n    }; // 2. Let processEndOfBody be these steps:\n\n\n    const processEndOfBody = () => {\n      // 1. If fetchParams is canceled, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return;\n      } // 2. If fetchParams’s process request end-of-body is non-null,\n      // then run fetchParams’s process request end-of-body.\n\n\n      if (fetchParams.processRequestEndOfBody) {\n        fetchParams.processRequestEndOfBody();\n      }\n    }; // 3. Let processBodyError given e be these steps:\n\n\n    const processBodyError = e => {\n      // 1. If fetchParams is canceled, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return;\n      } // 2. If e is an \"AbortError\" DOMException, then abort fetchParams’s controller.\n\n\n      if (e.name === 'AbortError') {\n        fetchParams.controller.abort();\n      } else {\n        fetchParams.controller.terminate(e);\n      }\n    }; // 4. Incrementally read request’s body given processBodyChunk, processEndOfBody,\n    // processBodyError, and fetchParams’s task destination.\n\n\n    requestBody = async function* () {\n      try {\n        for await (const bytes of request.body.stream) {\n          yield* processBodyChunk(bytes);\n        }\n\n        processEndOfBody();\n      } catch (err) {\n        processBodyError(err);\n      }\n    }();\n  }\n\n  try {\n    const {\n      body,\n      status,\n      statusText,\n      headersList\n    } = await dispatch({\n      body: requestBody\n    });\n    const iterator = body[Symbol.asyncIterator]();\n\n    fetchParams.controller.next = () => iterator.next();\n\n    response = makeResponse({\n      status,\n      statusText,\n      headersList\n    });\n  } catch (err) {\n    // 10. If aborted, then:\n    if (err.name === 'AbortError') {\n      // 1. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n      fetchParams.controller.connection.destroy(); // 2. Return the appropriate network error for fetchParams.\n\n      return makeAppropriateNetworkError(fetchParams);\n    }\n\n    return makeNetworkError(err);\n  } // 11. Let pullAlgorithm be an action that resumes the ongoing fetch\n  // if it is suspended.\n\n\n  const pullAlgorithm = () => {\n    fetchParams.controller.resume();\n  }; // 12. Let cancelAlgorithm be an algorithm that aborts fetchParams’s\n  // controller.\n\n\n  const cancelAlgorithm = () => {\n    fetchParams.controller.abort();\n  }; // 13. Let highWaterMark be a non-negative, non-NaN number, chosen by\n  // the user agent.\n  // TODO\n  // 14. Let sizeAlgorithm be an algorithm that accepts a chunk object\n  // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.\n  // TODO\n  // 15. Let stream be a new ReadableStream.\n  // 16. Set up stream with pullAlgorithm set to pullAlgorithm,\n  // cancelAlgorithm set to cancelAlgorithm, highWaterMark set to\n  // highWaterMark, and sizeAlgorithm set to sizeAlgorithm.\n\n\n  if (!ReadableStream) {\n    ReadableStream = require('stream/web').ReadableStream;\n  }\n\n  const stream = new ReadableStream({\n    async start(controller) {\n      fetchParams.controller.controller = controller;\n    },\n\n    async pull(controller) {\n      await pullAlgorithm(controller);\n    },\n\n    async cancel(reason) {\n      await cancelAlgorithm(reason);\n    }\n\n  }, {\n    highWaterMark: 0\n  }); // 17. Run these steps, but abort when the ongoing fetch is terminated:\n  //    1. Set response’s body to a new body whose stream is stream.\n\n  response.body = {\n    stream\n  }; //    2. If response is not a network error and request’s cache mode is\n  //    not \"no-store\", then update response in httpCache for request.\n  //    TODO\n  //    3. If includeCredentials is true and the user agent is not configured\n  //    to block cookies for request (see section 7 of [COOKIES]), then run the\n  //    \"set-cookie-string\" parsing algorithm (see section 5.2 of [COOKIES]) on\n  //    the value of each header whose name is a byte-case-insensitive match for\n  //    `Set-Cookie` in response’s header list, if any, and request’s current URL.\n  //    TODO\n  // 18. If aborted, then:\n  // TODO\n  // 19. Run these steps in parallel:\n  //    1. Run these steps, but abort when fetchParams is canceled:\n\n  fetchParams.controller.on('terminated', onAborted);\n\n  fetchParams.controller.resume = async () => {\n    // 1. While true\n    while (true) {\n      // 1-3. See onData...\n      // 4. Set bytes to the result of handling content codings given\n      // codings and bytes.\n      let bytes;\n\n      try {\n        const {\n          done,\n          value\n        } = await fetchParams.controller.next();\n\n        if (isAborted(fetchParams)) {\n          break;\n        }\n\n        bytes = done ? undefined : value;\n      } catch (err) {\n        if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {\n          // zlib doesn't like empty streams.\n          bytes = undefined;\n        } else {\n          bytes = err;\n        }\n      }\n\n      if (bytes === undefined) {\n        // 2. Otherwise, if the bytes transmission for response’s message\n        // body is done normally and stream is readable, then close\n        // stream, finalize response for fetchParams and response, and\n        // abort these in-parallel steps.\n        try {\n          fetchParams.controller.controller.close();\n        } catch (err) {\n          // TODO (fix): How/Why can this happen? Do we have a bug?\n          if (!/Controller is already closed/.test(err)) {\n            throw err;\n          }\n        }\n\n        finalizeResponse(fetchParams, response);\n        return;\n      } // 5. Increase timingInfo’s decoded body size by bytes’s length.\n\n\n      timingInfo.decodedBodySize += bytes?.byteLength ?? 0; // 6. If bytes is failure, then terminate fetchParams’s controller.\n\n      if (isErrorLike(bytes)) {\n        fetchParams.controller.terminate(bytes);\n        return;\n      } // 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes\n      // into stream.\n\n\n      fetchParams.controller.controller.enqueue(new Uint8Array(bytes)); // 8. If stream is errored, then terminate the ongoing fetch.\n\n      if (isErrored(stream)) {\n        fetchParams.controller.terminate();\n        return;\n      } // 9. If stream doesn’t need more data ask the user agent to suspend\n      // the ongoing fetch.\n\n\n      if (!fetchParams.controller.controller.desiredSize) {\n        return;\n      }\n    }\n  }; //    2. If aborted, then:\n\n\n  function onAborted(reason) {\n    // 2. If fetchParams is aborted, then:\n    if (isAborted(fetchParams)) {\n      // 1. Set response’s aborted flag.\n      response.aborted = true; // 2. If stream is readable, error stream with an \"AbortError\" DOMException.\n\n      if (isReadable(stream)) {\n        fetchParams.controller.controller.error(new DOMException('The operation was aborted.', 'AbortError'));\n      }\n    } else {\n      // 3. Otherwise, if stream is readable, error stream with a TypeError.\n      if (isReadable(stream)) {\n        fetchParams.controller.controller.error(new TypeError('terminated', {\n          cause: isErrorLike(reason) ? reason : undefined\n        }));\n      }\n    } // 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n    // 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.\n\n\n    fetchParams.controller.connection.destroy();\n  } // 20. Return response.\n\n\n  return response;\n\n  async function dispatch(_ref2) {\n    let {\n      body\n    } = _ref2;\n    const url = requestCurrentURL(request);\n    return new Promise((resolve, reject) => fetchParams.controller.dispatcher.dispatch({\n      path: url.pathname + url.search,\n      origin: url.origin,\n      method: request.method,\n      body: fetchParams.controller.dispatcher.isMockActive ? request.body && request.body.source : body,\n      headers: [...request.headersList].flat(),\n      maxRedirections: 0,\n      bodyTimeout: 300_000,\n      headersTimeout: 300_000\n    }, {\n      body: null,\n      abort: null,\n\n      onConnect(abort) {\n        // TODO (fix): Do we need connection here?\n        const {\n          connection\n        } = fetchParams.controller;\n\n        if (connection.destroyed) {\n          abort(new DOMException('The operation was aborted.', 'AbortError'));\n        } else {\n          fetchParams.controller.on('terminated', abort);\n          this.abort = connection.abort = abort;\n        }\n      },\n\n      onHeaders(status, headersList, resume, statusText) {\n        if (status < 200) {\n          return;\n        }\n\n        let codings = [];\n        let location = '';\n        const headers = new Headers();\n\n        for (let n = 0; n < headersList.length; n += 2) {\n          const key = headersList[n + 0].toString('latin1');\n          const val = headersList[n + 1].toString('latin1');\n\n          if (key.toLowerCase() === 'content-encoding') {\n            codings = val.split(',').map(x => x.trim());\n          } else if (key.toLowerCase() === 'location') {\n            location = val;\n          }\n\n          headers.append(key, val);\n        }\n\n        this.body = new Readable({\n          read: resume\n        });\n        const decoders = [];\n        const willFollow = request.redirect === 'follow' && location && redirectStatus.includes(status); // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding\n\n        if (request.method !== 'HEAD' && request.method !== 'CONNECT' && !nullBodyStatus.includes(status) && !willFollow) {\n          for (const coding of codings) {\n            if (/(x-)?gzip/.test(coding)) {\n              decoders.push(zlib.createGunzip());\n            } else if (/(x-)?deflate/.test(coding)) {\n              decoders.push(zlib.createInflate());\n            } else if (coding === 'br') {\n              decoders.push(zlib.createBrotliDecompress());\n            } else {\n              decoders.length = 0;\n              break;\n            }\n          }\n        }\n\n        resolve({\n          status,\n          statusText,\n          headersList: headers[kHeadersList],\n          body: decoders.length ? pipeline(this.body, ...decoders, () => {}) : this.body.on('error', () => {})\n        });\n        return true;\n      },\n\n      onData(chunk) {\n        if (fetchParams.controller.dump) {\n          return;\n        } // 1. If one or more bytes have been transmitted from response’s\n        // message body, then:\n        //  1. Let bytes be the transmitted bytes.\n\n\n        const bytes = chunk; //  2. Let codings be the result of extracting header list values\n        //  given `Content-Encoding` and response’s header list.\n        //  See pullAlgorithm.\n        //  3. Increase timingInfo’s encoded body size by bytes’s length.\n\n        timingInfo.encodedBodySize += bytes.byteLength; //  4. See pullAlgorithm...\n\n        return this.body.push(bytes);\n      },\n\n      onComplete() {\n        if (this.abort) {\n          fetchParams.controller.off('terminated', this.abort);\n        }\n\n        fetchParams.controller.ended = true;\n        this.body.push(null);\n      },\n\n      onError(error) {\n        if (this.abort) {\n          fetchParams.controller.off('terminated', this.abort);\n        }\n\n        this.body?.destroy(error);\n        fetchParams.controller.terminate(error);\n        reject(error);\n      }\n\n    }));\n  }\n}\n\nmodule.exports = {\n  fetch,\n  Fetch,\n  fetching,\n  finalizeAndReportTiming\n};","map":{"version":3,"names":["Response","makeNetworkError","makeAppropriateNetworkError","filterResponse","makeResponse","require","Headers","Request","makeRequest","zlib","bytesMatch","makePolicyContainer","clonePolicyContainer","requestBadPort","TAOCheck","appendRequestOriginHeader","responseLocationURL","requestCurrentURL","setRequestReferrerPolicyOnRedirect","tryUpgradeRequestToAPotentiallyTrustworthyURL","createOpaqueTimingInfo","appendFetchMetadata","corsCheck","crossOriginResourcePolicyCheck","determineRequestsReferrer","coarsenedSharedCurrentTime","createDeferredPromise","isBlobLike","sameOrigin","isCancelled","isAborted","isErrorLike","fullyReadBody","kState","kHeaders","kGuard","kRealm","assert","safelyExtractBody","extractBody","redirectStatus","nullBodyStatus","safeMethods","requestBodyHeader","subresource","DOMException","kHeadersList","EE","Readable","pipeline","isErrored","isReadable","dataURLProcessor","serializeAMimeType","TransformStream","resolveObjectURL","ReadableStream","nodeVersion","process","versions","node","split","nodeMajor","Number","nodeMinor","Fetch","constructor","dispatcher","connection","dump","state","terminate","reason","destroy","emit","abort","fetch","input","init","arguments","length","TypeError","p","requestObject","e","reject","promise","request","signal","aborted","abortFetch","globalObject","client","name","serviceWorkers","responseObject","relevantRealm","locallyAborted","controller","addEventListener","once","handleFetchDone","response","finalizeAndReportTiming","processResponse","type","Object","assign","cause","error","headersList","resolve","fetching","processResponseEndOfBody","initiatorType","urlList","originalURL","timingInfo","cacheState","test","protocol","timingAllowPassed","startTime","endTime","markResourceTiming","globalThis","performance","body","stream","cancel","catch","err","code","processRequestBodyChunkLength","processRequestEndOfBody","processResponseConsumeBody","useParallelQueue","taskDestination","crossOriginIsolatedCapability","currenTime","fetchParams","window","origin","policyContainer","has","value","append","priority","includes","destination","mainFetch","recursive","localURLsOnly","referrerPolicy","referrer","currentURL","url","responseTainting","mode","schemeFetch","redirect","httpFetch","status","internalResponse","push","timingAllowFailed","rangeRequested","headers","method","integrity","processBodyError","fetchFinale","processBody","bytes","scheme","pathname","path","resp","statusText","URL","search","blob","toString","set","size","dataURLStruct","mimeType","finalizeResponse","done","processResponseDone","queueMicrotask","identityTransformAlgorithm","chunk","enqueue","transformStream","start","transform","flush","pipeThrough","nullOrBytes","failure","actualResponse","httpNetworkOrCacheFetch","httpRedirectFetch","locationURL","hash","redirectCount","username","password","source","headerName","delete","redirectEndTime","postRedirectStartTime","redirectStartTime","isAuthenticationFetch","isNewConnectionFetch","httpFetchParams","httpRequest","httpCache","revalidatingFlag","includeCredentials","credentials","contentLength","contentLengthHeaderValue","String","keepalive","href","cache","preventNoCacheCacheControlHeaderModification","forwardResponse","httpNetworkFetch","requestIncludesCredentials","forceNewConnection","destroyed","newConnection","requestBody","processBodyChunk","byteLength","processEndOfBody","dispatch","iterator","Symbol","asyncIterator","next","pullAlgorithm","resume","cancelAlgorithm","pull","highWaterMark","on","onAborted","undefined","ended","encodedBodySize","close","decodedBodySize","Uint8Array","desiredSize","Promise","isMockActive","flat","maxRedirections","bodyTimeout","headersTimeout","onConnect","onHeaders","codings","location","n","key","val","toLowerCase","map","x","trim","read","decoders","willFollow","coding","createGunzip","createInflate","createBrotliDecompress","onData","onComplete","off","onError","module","exports"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/undici/lib/fetch/index.js"],"sourcesContent":["// https://github.com/Ethan-Arrowood/undici-fetch\n\n'use strict'\n\nconst {\n  Response,\n  makeNetworkError,\n  makeAppropriateNetworkError,\n  filterResponse,\n  makeResponse\n} = require('./response')\nconst { Headers } = require('./headers')\nconst { Request, makeRequest } = require('./request')\nconst zlib = require('zlib')\nconst {\n  bytesMatch,\n  makePolicyContainer,\n  clonePolicyContainer,\n  requestBadPort,\n  TAOCheck,\n  appendRequestOriginHeader,\n  responseLocationURL,\n  requestCurrentURL,\n  setRequestReferrerPolicyOnRedirect,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  createOpaqueTimingInfo,\n  appendFetchMetadata,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  determineRequestsReferrer,\n  coarsenedSharedCurrentTime,\n  createDeferredPromise,\n  isBlobLike,\n  sameOrigin,\n  isCancelled,\n  isAborted,\n  isErrorLike,\n  fullyReadBody\n} = require('./util')\nconst { kState, kHeaders, kGuard, kRealm } = require('./symbols')\nconst assert = require('assert')\nconst { safelyExtractBody, extractBody } = require('./body')\nconst {\n  redirectStatus,\n  nullBodyStatus,\n  safeMethods,\n  requestBodyHeader,\n  subresource,\n  DOMException\n} = require('./constants')\nconst { kHeadersList } = require('../core/symbols')\nconst EE = require('events')\nconst { Readable, pipeline } = require('stream')\nconst { isErrored, isReadable } = require('../core/util')\nconst { dataURLProcessor, serializeAMimeType } = require('./dataURL')\nconst { TransformStream } = require('stream/web')\n\n/** @type {import('buffer').resolveObjectURL} */\nlet resolveObjectURL\nlet ReadableStream\n\nconst nodeVersion = process.versions.node.split('.')\nconst nodeMajor = Number(nodeVersion[0])\nconst nodeMinor = Number(nodeVersion[1])\n\nclass Fetch extends EE {\n  constructor (dispatcher) {\n    super()\n\n    this.dispatcher = dispatcher\n    this.connection = null\n    this.dump = false\n    this.state = 'ongoing'\n  }\n\n  terminate (reason) {\n    if (this.state !== 'ongoing') {\n      return\n    }\n\n    this.state = 'terminated'\n    this.connection?.destroy(reason)\n    this.emit('terminated', reason)\n  }\n\n  abort () {\n    if (this.state !== 'ongoing') {\n      return\n    }\n\n    const reason = new DOMException('The operation was aborted.', 'AbortError')\n\n    this.state = 'aborted'\n    this.connection?.destroy(reason)\n    this.emit('terminated', reason)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetch-method\nasync function fetch (input, init = {}) {\n  if (arguments.length < 1) {\n    throw new TypeError(\n      `Failed to execute 'fetch' on 'Window': 1 argument required, but only ${arguments.length} present.`\n    )\n  }\n\n  // 1. Let p be a new promise.\n  const p = createDeferredPromise()\n\n  // 2. Let requestObject be the result of invoking the initial value of\n  // Request as constructor with input and init as arguments. If this throws\n  // an exception, reject p with it and return p.\n  let requestObject\n\n  try {\n    requestObject = new Request(input, init)\n  } catch (e) {\n    p.reject(e)\n    return p.promise\n  }\n\n  // 3. Let request be requestObject’s request.\n  const request = requestObject[kState]\n\n  // 4. If requestObject’s signal’s aborted flag is set, then:\n  if (requestObject.signal.aborted) {\n    // 1. Abort fetch with p, request, and null.\n    abortFetch(p, request, null)\n\n    // 2. Return p.\n    return p.promise\n  }\n\n  // 5. Let globalObject be request’s client’s global object.\n  const globalObject = request.client.globalObject\n\n  // 6. If globalObject is a ServiceWorkerGlobalScope object, then set\n  // request’s service-workers mode to \"none\".\n  if (globalObject?.constructor?.name === 'ServiceWorkerGlobalScope') {\n    request.serviceWorkers = 'none'\n  }\n\n  // 7. Let responseObject be null.\n  let responseObject = null\n\n  // 8. Let relevantRealm be this’s relevant Realm.\n  const relevantRealm = null\n\n  // 9. Let locallyAborted be false.\n  let locallyAborted = false\n\n  // 10. Let controller be null.\n  let controller = null\n\n  // 11. Add the following abort steps to requestObject’s signal:\n  requestObject.signal.addEventListener(\n    'abort',\n    () => {\n      // 1. Set locallyAborted to true.\n      locallyAborted = true\n\n      // 2. Abort fetch with p, request, and responseObject.\n      abortFetch(p, request, responseObject)\n\n      // 3. If controller is not null, then abort controller.\n      if (controller != null) {\n        controller.abort()\n      }\n    },\n    { once: true }\n  )\n\n  // 12. Let handleFetchDone given response response be to finalize and\n  // report timing with response, globalObject, and \"fetch\".\n  const handleFetchDone = (response) =>\n    finalizeAndReportTiming(response, 'fetch')\n\n  // 13. Set controller to the result of calling fetch given request,\n  // with processResponseEndOfBody set to handleFetchDone, and processResponse\n  // given response being these substeps:\n\n  const processResponse = (response) => {\n    // 1. If locallyAborted is true, terminate these substeps.\n    if (locallyAborted) {\n      return\n    }\n\n    // 2. If response’s aborted flag is set, then abort fetch with p,\n    // request, and responseObject, and terminate these substeps.\n    if (response.aborted) {\n      abortFetch(p, request, responseObject)\n      return\n    }\n\n    // 3. If response is a network error, then reject p with a TypeError\n    // and terminate these substeps.\n    if (response.type === 'error') {\n      p.reject(\n        Object.assign(new TypeError('fetch failed'), { cause: response.error })\n      )\n      return\n    }\n\n    // 4. Set responseObject to the result of creating a Response object,\n    // given response, \"immutable\", and relevantRealm.\n    responseObject = new Response()\n    responseObject[kState] = response\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kHeadersList] = response.headersList\n    responseObject[kHeaders][kGuard] = 'immutable'\n    responseObject[kHeaders][kRealm] = relevantRealm\n\n    // 5. Resolve p with responseObject.\n    p.resolve(responseObject)\n  }\n\n  controller = fetching({\n    request,\n    processResponseEndOfBody: handleFetchDone,\n    processResponse,\n    dispatcher: this // undici\n  })\n\n  // 14. Return p.\n  return p.promise\n}\n\n// https://fetch.spec.whatwg.org/#finalize-and-report-timing\nfunction finalizeAndReportTiming (response, initiatorType = 'other') {\n  // 1. If response is an aborted network error, then return.\n  if (response.type === 'error' && response.aborted) {\n    return\n  }\n\n  // 2. If response’s URL list is null or empty, then return.\n  if (!response.urlList?.length) {\n    return\n  }\n\n  // 3. Let originalURL be response’s URL list[0].\n  const originalURL = response.urlList[0]\n\n  // 4. Let timingInfo be response’s timing info.\n  let timingInfo = response.timingInfo\n\n  // 5. Let cacheState be response’s cache state.\n  let cacheState = response.cacheState\n\n  // 6. If originalURL’s scheme is not an HTTP(S) scheme, then return.\n  if (!/^https?:/.test(originalURL.protocol)) {\n    return\n  }\n\n  // 7. If timingInfo is null, then return.\n  if (timingInfo === null) {\n    return\n  }\n\n  // 8. If response’s timing allow passed flag is not set, then:\n  if (!timingInfo.timingAllowPassed) {\n    //  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.\n    timingInfo = createOpaqueTimingInfo({\n      startTime: timingInfo.startTime\n    })\n\n    //  2. Set cacheState to the empty string.\n    cacheState = ''\n  }\n\n  // 9. Set timingInfo’s end time to the coarsened shared current time\n  // given global’s relevant settings object’s cross-origin isolated\n  // capability.\n  // TODO: given global’s relevant settings object’s cross-origin isolated\n  // capability?\n  response.timingInfo.endTime = coarsenedSharedCurrentTime()\n\n  // 10. Set response’s timing info to timingInfo.\n  response.timingInfo = timingInfo\n\n  // 11. Mark resource timing for timingInfo, originalURL, initiatorType,\n  // global, and cacheState.\n  markResourceTiming(\n    timingInfo,\n    originalURL,\n    initiatorType,\n    globalThis,\n    cacheState\n  )\n}\n\n// https://w3c.github.io/resource-timing/#dfn-mark-resource-timing\nfunction markResourceTiming (timingInfo, originalURL, initiatorType, globalThis, cacheState) {\n  if (nodeMajor >= 18 && nodeMinor >= 2) {\n    performance.markResourceTiming(timingInfo, originalURL, initiatorType, globalThis, cacheState)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#abort-fetch\nfunction abortFetch (p, request, responseObject) {\n  // 1. Let error be an \"AbortError\" DOMException.\n  const error = new DOMException('The operation was aborted.', 'AbortError')\n\n  // 2. Reject promise with error.\n  p.reject(error)\n\n  // 3. If request’s body is not null and is readable, then cancel request’s\n  // body with error.\n  if (request.body != null && isReadable(request.body?.stream)) {\n    request.body.stream.cancel(error).catch((err) => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return\n      }\n      throw err\n    })\n  }\n\n  // 4. If responseObject is null, then return.\n  if (responseObject == null) {\n    return\n  }\n\n  // 5. Let response be responseObject’s response.\n  const response = responseObject[kState]\n\n  // 6. If response’s body is not null and is readable, then error response’s\n  // body with error.\n  if (response.body != null && isReadable(response.body?.stream)) {\n    response.body.stream.cancel(error).catch((err) => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return\n      }\n      throw err\n    })\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetching\nfunction fetching ({\n  request,\n  processRequestBodyChunkLength,\n  processRequestEndOfBody,\n  processResponse,\n  processResponseEndOfBody,\n  processResponseConsumeBody,\n  useParallelQueue = false,\n  dispatcher // undici\n}) {\n  // 1. Let taskDestination be null.\n  let taskDestination = null\n\n  // 2. Let crossOriginIsolatedCapability be false.\n  let crossOriginIsolatedCapability = false\n\n  // 3. If request’s client is non-null, then:\n  if (request.client != null) {\n    // 1. Set taskDestination to request’s client’s global object.\n    taskDestination = request.client.globalObject\n\n    // 2. Set crossOriginIsolatedCapability to request’s client’s cross-origin\n    // isolated capability.\n    crossOriginIsolatedCapability =\n      request.client.crossOriginIsolatedCapability\n  }\n\n  // 4. If useParallelQueue is true, then set taskDestination to the result of\n  // starting a new parallel queue.\n  // TODO\n\n  // 5. Let timingInfo be a new fetch timing info whose start time and\n  // post-redirect start time are the coarsened shared current time given\n  // crossOriginIsolatedCapability.\n  const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability)\n  const timingInfo = createOpaqueTimingInfo({\n    startTime: currenTime\n  })\n\n  // 6. Let fetchParams be a new fetch params whose\n  // request is request,\n  // timing info is timingInfo,\n  // process request body chunk length is processRequestBodyChunkLength,\n  // process request end-of-body is processRequestEndOfBody,\n  // process response is processResponse,\n  // process response consume body is processResponseConsumeBody,\n  // process response end-of-body is processResponseEndOfBody,\n  // task destination is taskDestination,\n  // and cross-origin isolated capability is crossOriginIsolatedCapability.\n  const fetchParams = {\n    controller: new Fetch(dispatcher),\n    request,\n    timingInfo,\n    processRequestBodyChunkLength,\n    processRequestEndOfBody,\n    processResponse,\n    processResponseConsumeBody,\n    processResponseEndOfBody,\n    taskDestination,\n    crossOriginIsolatedCapability\n  }\n\n  // 7. If request’s body is a byte sequence, then set request’s body to the\n  // first return value of safely extracting request’s body.\n  // NOTE: Since fetching is only called from fetch, body should already be\n  // extracted.\n  assert(!request.body || request.body.stream)\n\n  // 8. If request’s window is \"client\", then set request’s window to request’s\n  // client, if request’s client’s global object is a Window object; otherwise\n  // \"no-window\".\n  if (request.window === 'client') {\n    // TODO: What if request.client is null?\n    request.window =\n      request.client?.globalObject?.constructor?.name === 'Window'\n        ? request.client\n        : 'no-window'\n  }\n\n  // 9. If request’s origin is \"client\", then set request’s origin to request’s\n  // client’s origin.\n  if (request.origin === 'client') {\n    // TODO: What if request.client is null?\n    request.origin = request.client?.origin\n  }\n\n  // 10. If all of the following conditions are true:\n  // TODO\n\n  // 11. If request’s policy container is \"client\", then:\n  if (request.policyContainer === 'client') {\n    // 1. If request’s client is non-null, then set request’s policy\n    // container to a clone of request’s client’s policy container. [HTML]\n    if (request.client != null) {\n      request.policyContainer = clonePolicyContainer(\n        request.client.policyContainer\n      )\n    } else {\n      // 2. Otherwise, set request’s policy container to a new policy\n      // container.\n      request.policyContainer = makePolicyContainer()\n    }\n  }\n\n  // 12. If request’s header list does not contain `Accept`, then:\n  if (!request.headersList.has('accept')) {\n    // 1. Let value be `*/*`.\n    const value = '*/*'\n\n    // 2. A user agent should set value to the first matching statement, if\n    // any, switching on request’s destination:\n    // \"document\"\n    // \"frame\"\n    // \"iframe\"\n    // `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`\n    // \"image\"\n    // `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`\n    // \"style\"\n    // `text/css,*/*;q=0.1`\n    // TODO\n\n    // 3. Append `Accept`/value to request’s header list.\n    request.headersList.append('accept', value)\n  }\n\n  // 13. If request’s header list does not contain `Accept-Language`, then\n  // user agents should append `Accept-Language`/an appropriate value to\n  // request’s header list.\n  if (!request.headersList.has('accept-language')) {\n    request.headersList.append('accept-language', '*')\n  }\n\n  // 14. If request’s priority is null, then use request’s initiator and\n  // destination appropriately in setting request’s priority to a\n  // user-agent-defined object.\n  if (request.priority === null) {\n    // TODO\n  }\n\n  // 15. If request is a subresource request, then:\n  if (subresource.includes(request.destination)) {\n    // TODO\n  }\n\n  // 16. Run main fetch given fetchParams.\n  mainFetch(fetchParams)\n    .catch(err => {\n      fetchParams.controller.terminate(err)\n    })\n\n  // 17. Return fetchParam's controller\n  return fetchParams.controller\n}\n\n// https://fetch.spec.whatwg.org/#concept-main-fetch\nasync function mainFetch (fetchParams, recursive = false) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. If request’s local-URLs-only flag is set and request’s current URL is\n  // not local, then set response to a network error.\n  if (\n    request.localURLsOnly &&\n    !/^(about|blob|data):/.test(requestCurrentURL(request).protocol)\n  ) {\n    response = makeNetworkError('local URLs only')\n  }\n\n  // 4. Run report Content Security Policy violations for request.\n  // TODO\n\n  // 5. Upgrade request to a potentially trustworthy URL, if appropriate.\n  tryUpgradeRequestToAPotentiallyTrustworthyURL(request)\n\n  // 6. If should request be blocked due to a bad port, should fetching request\n  // be blocked as mixed content, or should request be blocked by Content\n  // Security Policy returns blocked, then set response to a network error.\n  if (requestBadPort(request) === 'blocked') {\n    response = makeNetworkError('bad port')\n  }\n  // TODO: should fetching request be blocked as mixed content?\n  // TODO: should request be blocked by Content Security Policy?\n\n  // 7. If request’s referrer policy is the empty string, then set request’s\n  // referrer policy to request’s policy container’s referrer policy.\n  if (request.referrerPolicy === '') {\n    request.referrerPolicy = request.policyContainer.referrerPolicy\n  }\n\n  // 8. If request’s referrer is not \"no-referrer\", then set request’s\n  // referrer to the result of invoking determine request’s referrer.\n  if (request.referrer !== 'no-referrer') {\n    request.referrer = determineRequestsReferrer(request)\n  }\n\n  // 9. Set request’s current URL’s scheme to \"https\" if all of the following\n  // conditions are true:\n  // - request’s current URL’s scheme is \"http\"\n  // - request’s current URL’s host is a domain\n  // - Matching request’s current URL’s host per Known HSTS Host Domain Name\n  //   Matching results in either a superdomain match with an asserted\n  //   includeSubDomains directive or a congruent match (with or without an\n  //   asserted includeSubDomains directive). [HSTS]\n  // TODO\n\n  // 10. If recursive is false, then run the remaining steps in parallel.\n  // TODO\n\n  // 11. If response is null, then set response to the result of running\n  // the steps corresponding to the first matching statement:\n  if (response === null) {\n    response = await (async () => {\n      const currentURL = requestCurrentURL(request)\n\n      if (\n        // - request’s current URL’s origin is same origin with request’s origin,\n        //   and request’s response tainting is \"basic\"\n        (sameOrigin(currentURL, request.url) && request.responseTainting === 'basic') ||\n        // request’s current URL’s scheme is \"data\"\n        (currentURL.protocol === 'data:') ||\n        // - request’s mode is \"navigate\" or \"websocket\"\n        (request.mode === 'navigate' || request.mode === 'websocket')\n      ) {\n        // 1. Set request’s response tainting to \"basic\".\n        request.responseTainting = 'basic'\n\n        // 2. Return the result of running scheme fetch given fetchParams.\n        return await schemeFetch(fetchParams)\n      }\n\n      // request’s mode is \"same-origin\"\n      if (request.mode === 'same-origin') {\n        // 1. Return a network error.\n        return makeNetworkError('request mode cannot be \"same-origin\"')\n      }\n\n      // request’s mode is \"no-cors\"\n      if (request.mode === 'no-cors') {\n        // 1. If request’s redirect mode is not \"follow\", then return a network\n        // error.\n        if (request.redirect !== 'follow') {\n          return makeNetworkError(\n            'redirect mode cannot be \"follow\" for \"no-cors\" request'\n          )\n        }\n\n        // 2. Set request’s response tainting to \"opaque\".\n        request.responseTainting = 'opaque'\n\n        // 3. Return the result of running scheme fetch given fetchParams.\n        return await schemeFetch(fetchParams)\n      }\n\n      // request’s current URL’s scheme is not an HTTP(S) scheme\n      if (!/^https?:/.test(requestCurrentURL(request).protocol)) {\n        // Return a network error.\n        return makeNetworkError('URL scheme must be a HTTP(S) scheme')\n      }\n\n      // - request’s use-CORS-preflight flag is set\n      // - request’s unsafe-request flag is set and either request’s method is\n      //   not a CORS-safelisted method or CORS-unsafe request-header names with\n      //   request’s header list is not empty\n      //    1. Set request’s response tainting to \"cors\".\n      //    2. Let corsWithPreflightResponse be the result of running HTTP fetch\n      //    given fetchParams and true.\n      //    3. If corsWithPreflightResponse is a network error, then clear cache\n      //    entries using request.\n      //    4. Return corsWithPreflightResponse.\n      // TODO\n\n      // Otherwise\n      //    1. Set request’s response tainting to \"cors\".\n      request.responseTainting = 'cors'\n\n      //    2. Return the result of running HTTP fetch given fetchParams.\n      return await httpFetch(fetchParams)\n    })()\n  }\n\n  // 12. If recursive is true, then return response.\n  if (recursive) {\n    return response\n  }\n\n  // 13. If response is not a network error and response is not a filtered\n  // response, then:\n  if (response.status !== 0 && !response.internalResponse) {\n    // If request’s response tainting is \"cors\", then:\n    if (request.responseTainting === 'cors') {\n      // 1. Let headerNames be the result of extracting header list values\n      // given `Access-Control-Expose-Headers` and response’s header list.\n      // TODO\n      // 2. If request’s credentials mode is not \"include\" and headerNames\n      // contains `*`, then set response’s CORS-exposed header-name list to\n      // all unique header names in response’s header list.\n      // TODO\n      // 3. Otherwise, if headerNames is not null or failure, then set\n      // response’s CORS-exposed header-name list to headerNames.\n      // TODO\n    }\n\n    // Set response to the following filtered response with response as its\n    // internal response, depending on request’s response tainting:\n    if (request.responseTainting === 'basic') {\n      response = filterResponse(response, 'basic')\n    } else if (request.responseTainting === 'cors') {\n      response = filterResponse(response, 'cors')\n    } else if (request.responseTainting === 'opaque') {\n      response = filterResponse(response, 'opaque')\n    } else {\n      assert(false)\n    }\n  }\n\n  // 14. Let internalResponse be response, if response is a network error,\n  // and response’s internal response otherwise.\n  let internalResponse =\n    response.status === 0 ? response : response.internalResponse\n\n  // 15. If internalResponse’s URL list is empty, then set it to a clone of\n  // request’s URL list.\n  if (internalResponse.urlList.length === 0) {\n    internalResponse.urlList.push(...request.urlList)\n  }\n\n  // 16. If request’s timing allow failed flag is unset, then set\n  // internalResponse’s timing allow passed flag.\n  if (!request.timingAllowFailed) {\n    response.timingAllowPassed = true\n  }\n\n  // 17. If response is not a network error and any of the following returns\n  // blocked\n  // - should internalResponse to request be blocked as mixed content\n  // - should internalResponse to request be blocked by Content Security Policy\n  // - should internalResponse to request be blocked due to its MIME type\n  // - should internalResponse to request be blocked due to nosniff\n  // TODO\n\n  // 18. If response’s type is \"opaque\", internalResponse’s status is 206,\n  // internalResponse’s range-requested flag is set, and request’s header\n  // list does not contain `Range`, then set response and internalResponse\n  // to a network error.\n  if (\n    response.type === 'opaque' &&\n    internalResponse.status === 206 &&\n    internalResponse.rangeRequested &&\n    !request.headers.has('range')\n  ) {\n    response = internalResponse = makeNetworkError()\n  }\n\n  // 19. If response is not a network error and either request’s method is\n  // `HEAD` or `CONNECT`, or internalResponse’s status is a null body status,\n  // set internalResponse’s body to null and disregard any enqueuing toward\n  // it (if any).\n  if (\n    response.status !== 0 &&\n    (request.method === 'HEAD' ||\n      request.method === 'CONNECT' ||\n      nullBodyStatus.includes(internalResponse.status))\n  ) {\n    internalResponse.body = null\n    fetchParams.controller.dump = true\n  }\n\n  // 20. If request’s integrity metadata is not the empty string, then:\n  if (request.integrity) {\n    // 1. Let processBodyError be this step: run fetch finale given fetchParams\n    // and a network error.\n    const processBodyError = (reason) =>\n      fetchFinale(fetchParams, makeNetworkError(reason))\n\n    // 2. If request’s response tainting is \"opaque\", or response’s body is null,\n    // then run processBodyError and abort these steps.\n    if (request.responseTainting === 'opaque' || response.body == null) {\n      processBodyError(response.error)\n      return\n    }\n\n    // 3. Let processBody given bytes be these steps:\n    const processBody = (bytes) => {\n      // 1. If bytes do not match request’s integrity metadata,\n      // then run processBodyError and abort these steps. [SRI]\n      if (!bytesMatch(bytes, request.integrity)) {\n        processBodyError('integrity mismatch')\n        return\n      }\n\n      // 2. Set response’s body to the first return value of safely\n      // extracting bytes.\n      response.body = safelyExtractBody(bytes)[0]\n\n      // 3. Run fetch finale given fetchParams and response.\n      fetchFinale(fetchParams, response)\n    }\n\n    // 4. Fully read response’s body given processBody and processBodyError.\n    await fullyReadBody(response.body, processBody, processBodyError)\n  } else {\n    // 21. Otherwise, run fetch finale given fetchParams and response.\n    fetchFinale(fetchParams, response)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#concept-scheme-fetch\n// given a fetch params fetchParams\nasync function schemeFetch (fetchParams) {\n  // let request be fetchParams’s request\n  const { request } = fetchParams\n\n  const {\n    protocol: scheme,\n    pathname: path\n  } = requestCurrentURL(request)\n\n  // switch on request’s current URL’s scheme, and run the associated steps:\n  switch (scheme) {\n    case 'about:': {\n      // If request’s current URL’s path is the string \"blank\", then return a new response\n      // whose status message is `OK`, header list is « (`Content-Type`, `text/html;charset=utf-8`) »,\n      // and body is the empty byte sequence.\n      if (path === 'blank') {\n        const resp = makeResponse({\n          statusText: 'OK',\n          headersList: [\n            ['content-type', 'text/html;charset=utf-8']\n          ]\n        })\n\n        resp.urlList = [new URL('about:blank')]\n        return resp\n      }\n\n      // Otherwise, return a network error.\n      return makeNetworkError('invalid path called')\n    }\n    case 'blob:': {\n      resolveObjectURL = resolveObjectURL || require('buffer').resolveObjectURL\n\n      // 1. Run these steps, but abort when the ongoing fetch is terminated:\n      //    1. Let blob be request’s current URL’s blob URL entry’s object.\n      //       https://w3c.github.io/FileAPI/#blob-url-entry\n      //       P.S. Thank God this method is available in node.\n      const currentURL = requestCurrentURL(request)\n\n      // https://github.com/web-platform-tests/wpt/blob/7b0ebaccc62b566a1965396e5be7bb2bc06f841f/FileAPI/url/resources/fetch-tests.js#L52-L56\n      // Buffer.resolveObjectURL does not ignore URL queries.\n      if (currentURL.search.length !== 0) {\n        return makeNetworkError('NetworkError when attempting to fetch resource.')\n      }\n\n      const blob = resolveObjectURL(currentURL.toString())\n\n      //    2. If request’s method is not `GET` or blob is not a Blob object, then return a network error. [FILEAPI]\n      if (request.method !== 'GET' || !isBlobLike(blob)) {\n        return makeNetworkError('invalid method')\n      }\n\n      //    3. Let response be a new response whose status message is `OK`.\n      const response = makeResponse({ statusText: 'OK', urlList: [currentURL] })\n\n      //    4. Append (`Content-Length`, blob’s size attribute value) to response’s header list.\n      response.headersList.set('content-length', `${blob.size}`)\n\n      //    5. Append (`Content-Type`, blob’s type attribute value) to response’s header list.\n      response.headersList.set('content-type', blob.type)\n\n      //    6. Set response’s body to the result of performing the read operation on blob.\n      // TODO (fix): This needs to read?\n      response.body = extractBody(blob)[0]\n\n      //    7. Return response.\n      return response\n\n      // 2. If aborted, then return the appropriate network error for fetchParams.\n      // TODO\n    }\n    case 'data:': {\n      // 1. Let dataURLStruct be the result of running the\n      //    data: URL processor on request’s current URL.\n      const currentURL = requestCurrentURL(request)\n      const dataURLStruct = dataURLProcessor(currentURL)\n\n      // 2. If dataURLStruct is failure, then return a\n      //    network error.\n      if (dataURLStruct === 'failure') {\n        return makeNetworkError('failed to fetch the data URL')\n      }\n\n      // 3. Let mimeType be dataURLStruct’s MIME type, serialized.\n      const mimeType = serializeAMimeType(dataURLStruct.mimeType)\n\n      // 4. Return a response whose status message is `OK`,\n      //    header list is « (`Content-Type`, mimeType) »,\n      //    and body is dataURLStruct’s body.\n      return makeResponse({\n        statusText: 'OK',\n        headersList: [\n          ['content-type', mimeType]\n        ],\n        body: extractBody(dataURLStruct.body)[0]\n      })\n    }\n    case 'file:': {\n      // For now, unfortunate as it is, file URLs are left as an exercise for the reader.\n      // When in doubt, return a network error.\n      return makeNetworkError('not implemented... yet...')\n    }\n    case 'http:':\n    case 'https:': {\n      // Return the result of running HTTP fetch given fetchParams.\n\n      return await httpFetch(fetchParams)\n        .catch((err) => makeNetworkError(err))\n    }\n    default: {\n      return makeNetworkError('unknown scheme')\n    }\n  }\n}\n\n// https://fetch.spec.whatwg.org/#finalize-response\nfunction finalizeResponse (fetchParams, response) {\n  // 1. Set fetchParams’s request’s done flag.\n  fetchParams.request.done = true\n\n  // 2, If fetchParams’s process response done is not null, then queue a fetch\n  // task to run fetchParams’s process response done given response, with\n  // fetchParams’s task destination.\n  if (fetchParams.processResponseDone != null) {\n    queueMicrotask(() => fetchParams.processResponseDone(response))\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetch-finale\nasync function fetchFinale (fetchParams, response) {\n  // 1. If response is a network error, then:\n  if (response.type === 'error') {\n    // 1. Set response’s URL list to « fetchParams’s request’s URL list[0] ».\n    response.urlList = [fetchParams.request.urlList[0]]\n\n    // 2. Set response’s timing info to the result of creating an opaque timing\n    // info for fetchParams’s timing info.\n    response.timingInfo = createOpaqueTimingInfo({\n      startTime: fetchParams.timingInfo.startTime\n    })\n  }\n\n  // 2. Let processResponseEndOfBody be the following steps:\n  const processResponseEndOfBody = () => {\n    // 1. Set fetchParams’s request’s done flag.\n    fetchParams.request.done = true\n\n    // If fetchParams’s process response end-of-body is not null,\n    // then queue a fetch task to run fetchParams’s process response\n    // end-of-body given response with fetchParams’s task destination.\n    if (fetchParams.processResponseEndOfBody != null) {\n      queueMicrotask(() => fetchParams.processResponseEndOfBody(response))\n    }\n  }\n\n  // 3. If fetchParams’s process response is non-null, then queue a fetch task\n  // to run fetchParams’s process response given response, with fetchParams’s\n  // task destination.\n  if (fetchParams.processResponse != null) {\n    queueMicrotask(() => fetchParams.processResponse(response))\n  }\n\n  // 4. If response’s body is null, then run processResponseEndOfBody.\n  if (response.body == null) {\n    processResponseEndOfBody()\n  } else {\n  // 5. Otherwise:\n\n    // 1. Let transformStream be a new a TransformStream.\n\n    // 2. Let identityTransformAlgorithm be an algorithm which, given chunk,\n    // enqueues chunk in transformStream.\n    const identityTransformAlgorithm = (chunk, controller) => {\n      controller.enqueue(chunk)\n    }\n\n    // 3. Set up transformStream with transformAlgorithm set to identityTransformAlgorithm\n    // and flushAlgorithm set to processResponseEndOfBody.\n    const transformStream = new TransformStream({\n      start () {},\n      transform: identityTransformAlgorithm,\n      flush: processResponseEndOfBody\n    })\n\n    // 4. Set response’s body to the result of piping response’s body through transformStream.\n    response.body = { stream: response.body.stream.pipeThrough(transformStream) }\n  }\n\n  // 6. If fetchParams’s process response consume body is non-null, then:\n  if (fetchParams.processResponseConsumeBody != null) {\n    // 1. Let processBody given nullOrBytes be this step: run fetchParams’s\n    // process response consume body given response and nullOrBytes.\n    const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes)\n\n    // 2. Let processBodyError be this step: run fetchParams’s process\n    // response consume body given response and failure.\n    const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure)\n\n    // 3. If response’s body is null, then queue a fetch task to run processBody\n    // given null, with fetchParams’s task destination.\n    if (response.body == null) {\n      queueMicrotask(() => processBody(null))\n    } else {\n      // 4. Otherwise, fully read response’s body given processBody, processBodyError,\n      // and fetchParams’s task destination.\n      await fullyReadBody(response.body, processBody, processBodyError)\n    }\n  }\n}\n\n// https://fetch.spec.whatwg.org/#http-fetch\nasync function httpFetch (fetchParams) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. Let actualResponse be null.\n  let actualResponse = null\n\n  // 4. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 5. If request’s service-workers mode is \"all\", then:\n  if (request.serviceWorkers === 'all') {\n    // TODO\n  }\n\n  // 6. If response is null, then:\n  if (response === null) {\n    // 1. If makeCORSPreflight is true and one of these conditions is true:\n    // TODO\n\n    // 2. If request’s redirect mode is \"follow\", then set request’s\n    // service-workers mode to \"none\".\n    if (request.redirect === 'follow') {\n      request.serviceWorkers = 'none'\n    }\n\n    // 3. Set response and actualResponse to the result of running\n    // HTTP-network-or-cache fetch given fetchParams.\n    actualResponse = response = await httpNetworkOrCacheFetch(fetchParams)\n\n    // 4. If request’s response tainting is \"cors\" and a CORS check\n    // for request and response returns failure, then return a network error.\n    if (\n      request.responseTainting === 'cors' &&\n      corsCheck(request, response) === 'failure'\n    ) {\n      return makeNetworkError('cors failure')\n    }\n\n    // 5. If the TAO check for request and response returns failure, then set\n    // request’s timing allow failed flag.\n    if (TAOCheck(request, response) === 'failure') {\n      request.timingAllowFailed = true\n    }\n  }\n\n  // 7. If either request’s response tainting or response’s type\n  // is \"opaque\", and the cross-origin resource policy check with\n  // request’s origin, request’s client, request’s destination,\n  // and actualResponse returns blocked, then return a network error.\n  if (\n    (request.responseTainting === 'opaque' || response.type === 'opaque') &&\n    crossOriginResourcePolicyCheck(\n      request.origin,\n      request.client,\n      request.destination,\n      actualResponse\n    ) === 'blocked'\n  ) {\n    return makeNetworkError('blocked')\n  }\n\n  // 8. If actualResponse’s status is a redirect status, then:\n  if (redirectStatus.includes(actualResponse.status)) {\n    // 1. If actualResponse’s status is not 303, request’s body is not null,\n    // and the connection uses HTTP/2, then user agents may, and are even\n    // encouraged to, transmit an RST_STREAM frame.\n    // See, https://github.com/whatwg/fetch/issues/1288\n    if (request.redirect !== 'manual') {\n      fetchParams.controller.connection.destroy()\n    }\n\n    // 2. Switch on request’s redirect mode:\n    if (request.redirect === 'error') {\n      // Set response to a network error.\n      response = makeNetworkError('unexpected redirect')\n    } else if (request.redirect === 'manual') {\n      // Set response to an opaque-redirect filtered response whose internal\n      // response is actualResponse.\n      // NOTE(spec): On the web this would return an `opaqueredirect` response,\n      // but that doesn't make sense server side.\n      // See https://github.com/nodejs/undici/issues/1193.\n      response = actualResponse\n    } else if (request.redirect === 'follow') {\n      // Set response to the result of running HTTP-redirect fetch given\n      // fetchParams and response.\n      response = await httpRedirectFetch(fetchParams, response)\n    } else {\n      assert(false)\n    }\n  }\n\n  // 9. Set response’s timing info to timingInfo.\n  response.timingInfo = timingInfo\n\n  // 10. Return response.\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#http-redirect-fetch\nasync function httpRedirectFetch (fetchParams, response) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let actualResponse be response, if response is not a filtered response,\n  // and response’s internal response otherwise.\n  const actualResponse = response.internalResponse\n    ? response.internalResponse\n    : response\n\n  // 3. Let locationURL be actualResponse’s location URL given request’s current\n  // URL’s fragment.\n  let locationURL\n\n  try {\n    locationURL = responseLocationURL(\n      actualResponse,\n      requestCurrentURL(request).hash\n    )\n\n    // 4. If locationURL is null, then return response.\n    if (locationURL == null) {\n      return response\n    }\n  } catch (err) {\n    // 5. If locationURL is failure, then return a network error.\n    return makeNetworkError(err)\n  }\n\n  // 6. If locationURL’s scheme is not an HTTP(S) scheme, then return a network\n  // error.\n  if (!/^https?:/.test(locationURL.protocol)) {\n    return makeNetworkError('URL scheme must be a HTTP(S) scheme')\n  }\n\n  // 7. If request’s redirect count is twenty, return a network error.\n  if (request.redirectCount === 20) {\n    return makeNetworkError('redirect count exceeded')\n  }\n\n  // 8. Increase request’s redirect count by one.\n  request.redirectCount += 1\n\n  // 9. If request’s mode is \"cors\", locationURL includes credentials, and\n  // request’s origin is not same origin with locationURL’s origin, then return\n  //  a network error.\n  if (\n    request.mode === 'cors' &&\n    (locationURL.username || locationURL.password) &&\n    !sameOrigin(request, locationURL)\n  ) {\n    return makeNetworkError('cross origin not allowed for request mode \"cors\"')\n  }\n\n  // 10. If request’s response tainting is \"cors\" and locationURL includes\n  // credentials, then return a network error.\n  if (\n    request.responseTainting === 'cors' &&\n    (locationURL.username || locationURL.password)\n  ) {\n    return makeNetworkError(\n      'URL cannot contain credentials for request mode \"cors\"'\n    )\n  }\n\n  // 11. If actualResponse’s status is not 303, request’s body is non-null,\n  // and request’s body’s source is null, then return a network error.\n  if (\n    actualResponse.status !== 303 &&\n    request.body != null &&\n    request.body.source == null\n  ) {\n    return makeNetworkError()\n  }\n\n  // 12. If one of the following is true\n  // - actualResponse’s status is 301 or 302 and request’s method is `POST`\n  // - actualResponse’s status is 303 and request’s method is not `GET` or `HEAD`\n  if (\n    ([301, 302].includes(actualResponse.status) && request.method === 'POST') ||\n    (actualResponse.status === 303 &&\n      !['GET', 'HEAD'].includes(request.method))\n  ) {\n    // then:\n    // 1. Set request’s method to `GET` and request’s body to null.\n    request.method = 'GET'\n    request.body = null\n\n    // 2. For each headerName of request-body-header name, delete headerName from\n    // request’s header list.\n    for (const headerName of requestBodyHeader) {\n      request.headersList.delete(headerName)\n    }\n  }\n\n  // 13. If request’s body is non-null, then set request’s body to the first return\n  // value of safely extracting request’s body’s source.\n  if (request.body != null) {\n    assert(request.body.source)\n    request.body = safelyExtractBody(request.body.source)[0]\n  }\n\n  // 14. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 15. Set timingInfo’s redirect end time and post-redirect start time to the\n  // coarsened shared current time given fetchParams’s cross-origin isolated\n  // capability.\n  timingInfo.redirectEndTime = timingInfo.postRedirectStartTime =\n    coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)\n\n  // 16. If timingInfo’s redirect start time is 0, then set timingInfo’s\n  //  redirect start time to timingInfo’s start time.\n  if (timingInfo.redirectStartTime === 0) {\n    timingInfo.redirectStartTime = timingInfo.startTime\n  }\n\n  // 17. Append locationURL to request’s URL list.\n  request.urlList.push(locationURL)\n\n  // 18. Invoke set request’s referrer policy on redirect on request and\n  // actualResponse.\n  setRequestReferrerPolicyOnRedirect(request, actualResponse)\n\n  // 19. Return the result of running main fetch given fetchParams and true.\n  return mainFetch(fetchParams, true)\n}\n\n// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\nasync function httpNetworkOrCacheFetch (\n  fetchParams,\n  isAuthenticationFetch = false,\n  isNewConnectionFetch = false\n) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let httpFetchParams be null.\n  let httpFetchParams = null\n\n  // 3. Let httpRequest be null.\n  let httpRequest = null\n\n  // 4. Let response be null.\n  let response = null\n\n  // 5. Let storedResponse be null.\n  // TODO: cache\n\n  // 6. Let httpCache be null.\n  const httpCache = null\n\n  // 7. Let the revalidatingFlag be unset.\n  const revalidatingFlag = false\n\n  // 8. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. If request’s window is \"no-window\" and request’s redirect mode is\n  //    \"error\", then set httpFetchParams to fetchParams and httpRequest to\n  //    request.\n  if (request.window === 'no-window' && request.redirect === 'error') {\n    httpFetchParams = fetchParams\n    httpRequest = request\n  } else {\n    // Otherwise:\n\n    // 1. Set httpRequest to a clone of request.\n    httpRequest = makeRequest(request)\n\n    // 2. Set httpFetchParams to a copy of fetchParams.\n    httpFetchParams = { ...fetchParams }\n\n    // 3. Set httpFetchParams’s request to httpRequest.\n    httpFetchParams.request = httpRequest\n  }\n\n  //    3. Let includeCredentials be true if one of\n  const includeCredentials =\n    request.credentials === 'include' ||\n    (request.credentials === 'same-origin' &&\n      request.responseTainting === 'basic')\n\n  //    4. Let contentLength be httpRequest’s body’s length, if httpRequest’s\n  //    body is non-null; otherwise null.\n  const contentLength = httpRequest.body ? httpRequest.body.length : null\n\n  //    5. Let contentLengthHeaderValue be null.\n  let contentLengthHeaderValue = null\n\n  //    6. If httpRequest’s body is null and httpRequest’s method is `POST` or\n  //    `PUT`, then set contentLengthHeaderValue to `0`.\n  if (\n    httpRequest.body == null &&\n    ['POST', 'PUT'].includes(httpRequest.method)\n  ) {\n    contentLengthHeaderValue = '0'\n  }\n\n  //    7. If contentLength is non-null, then set contentLengthHeaderValue to\n  //    contentLength, serialized and isomorphic encoded.\n  if (contentLength != null) {\n    // TODO: isomorphic encoded\n    contentLengthHeaderValue = String(contentLength)\n  }\n\n  //    8. If contentLengthHeaderValue is non-null, then append\n  //    `Content-Length`/contentLengthHeaderValue to httpRequest’s header\n  //    list.\n  if (contentLengthHeaderValue != null) {\n    httpRequest.headersList.append('content-length', contentLengthHeaderValue)\n  }\n\n  //    9. If contentLengthHeaderValue is non-null, then append (`Content-Length`,\n  //    contentLengthHeaderValue) to httpRequest’s header list.\n\n  //    10. If contentLength is non-null and httpRequest’s keepalive is true,\n  //    then:\n  if (contentLength != null && httpRequest.keepalive) {\n    // NOTE: keepalive is a noop outside of browser context.\n  }\n\n  //    11. If httpRequest’s referrer is a URL, then append\n  //    `Referer`/httpRequest’s referrer, serialized and isomorphic encoded,\n  //     to httpRequest’s header list.\n  if (httpRequest.referrer instanceof URL) {\n    // TODO: isomorphic encoded\n    httpRequest.headersList.append('referer', httpRequest.referrer.href)\n  }\n\n  //    12. Append a request `Origin` header for httpRequest.\n  appendRequestOriginHeader(httpRequest)\n\n  //    13. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]\n  appendFetchMetadata(httpRequest)\n\n  //    14. If httpRequest’s header list does not contain `User-Agent`, then\n  //    user agents should append `User-Agent`/default `User-Agent` value to\n  //    httpRequest’s header list.\n  if (!httpRequest.headersList.has('user-agent')) {\n    httpRequest.headersList.append('user-agent', 'undici')\n  }\n\n  //    15. If httpRequest’s cache mode is \"default\" and httpRequest’s header\n  //    list contains `If-Modified-Since`, `If-None-Match`,\n  //    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set\n  //    httpRequest’s cache mode to \"no-store\".\n  if (\n    httpRequest.cache === 'default' &&\n    (httpRequest.headersList.has('if-modified-since') ||\n      httpRequest.headersList.has('if-none-match') ||\n      httpRequest.headersList.has('if-unmodified-since') ||\n      httpRequest.headersList.has('if-match') ||\n      httpRequest.headersList.has('if-range'))\n  ) {\n    httpRequest.cache = 'no-store'\n  }\n\n  //    16. If httpRequest’s cache mode is \"no-cache\", httpRequest’s prevent\n  //    no-cache cache-control header modification flag is unset, and\n  //    httpRequest’s header list does not contain `Cache-Control`, then append\n  //    `Cache-Control`/`max-age=0` to httpRequest’s header list.\n  if (\n    httpRequest.cache === 'no-cache' &&\n    !httpRequest.preventNoCacheCacheControlHeaderModification &&\n    !httpRequest.headersList.has('cache-control')\n  ) {\n    httpRequest.headersList.append('cache-control', 'max-age=0')\n  }\n\n  //    17. If httpRequest’s cache mode is \"no-store\" or \"reload\", then:\n  if (httpRequest.cache === 'no-store' || httpRequest.cache === 'reload') {\n    // 1. If httpRequest’s header list does not contain `Pragma`, then append\n    // `Pragma`/`no-cache` to httpRequest’s header list.\n    if (!httpRequest.headersList.has('pragma')) {\n      httpRequest.headersList.append('pragma', 'no-cache')\n    }\n\n    // 2. If httpRequest’s header list does not contain `Cache-Control`,\n    // then append `Cache-Control`/`no-cache` to httpRequest’s header list.\n    if (!httpRequest.headersList.has('cache-control')) {\n      httpRequest.headersList.append('cache-control', 'no-cache')\n    }\n  }\n\n  //    18. If httpRequest’s header list contains `Range`, then append\n  //    `Accept-Encoding`/`identity` to httpRequest’s header list.\n  if (httpRequest.headersList.has('range')) {\n    httpRequest.headersList.append('accept-encoding', 'identity')\n  }\n\n  //    19. Modify httpRequest’s header list per HTTP. Do not append a given\n  //    header if httpRequest’s header list contains that header’s name.\n  //    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129\n  if (!httpRequest.headersList.has('accept-encoding')) {\n    if (/^https:/.test(requestCurrentURL(httpRequest).protocol)) {\n      httpRequest.headersList.append('accept-encoding', 'br, gzip, deflate')\n    } else {\n      httpRequest.headersList.append('accept-encoding', 'gzip, deflate')\n    }\n  }\n\n  //    20. If includeCredentials is true, then:\n  if (includeCredentials) {\n    // 1. If the user agent is not configured to block cookies for httpRequest\n    // (see section 7 of [COOKIES]), then:\n    // TODO: credentials\n    // 2. If httpRequest’s header list does not contain `Authorization`, then:\n    // TODO: credentials\n  }\n\n  //    21. If there’s a proxy-authentication entry, use it as appropriate.\n  //    TODO: proxy-authentication\n\n  //    22. Set httpCache to the result of determining the HTTP cache\n  //    partition, given httpRequest.\n  //    TODO: cache\n\n  //    23. If httpCache is null, then set httpRequest’s cache mode to\n  //    \"no-store\".\n  if (httpCache == null) {\n    httpRequest.cache = 'no-store'\n  }\n\n  //    24. If httpRequest’s cache mode is neither \"no-store\" nor \"reload\",\n  //    then:\n  if (httpRequest.mode !== 'no-store' && httpRequest.mode !== 'reload') {\n    // TODO: cache\n  }\n\n  // 9. If aborted, then return the appropriate network error for fetchParams.\n  // TODO\n\n  // 10. If response is null, then:\n  if (response == null) {\n    // 1. If httpRequest’s cache mode is \"only-if-cached\", then return a\n    // network error.\n    if (httpRequest.mode === 'only-if-cached') {\n      return makeNetworkError('only if cached')\n    }\n\n    // 2. Let forwardResponse be the result of running HTTP-network fetch\n    // given httpFetchParams, includeCredentials, and isNewConnectionFetch.\n    const forwardResponse = await httpNetworkFetch(\n      httpFetchParams,\n      includeCredentials,\n      isNewConnectionFetch\n    )\n\n    // 3. If httpRequest’s method is unsafe and forwardResponse’s status is\n    // in the range 200 to 399, inclusive, invalidate appropriate stored\n    // responses in httpCache, as per the \"Invalidation\" chapter of HTTP\n    // Caching, and set storedResponse to null. [HTTP-CACHING]\n    if (\n      !safeMethods.includes(httpRequest.method) &&\n      forwardResponse.status >= 200 &&\n      forwardResponse.status <= 399\n    ) {\n      // TODO: cache\n    }\n\n    // 4. If the revalidatingFlag is set and forwardResponse’s status is 304,\n    // then:\n    if (revalidatingFlag && forwardResponse.status === 304) {\n      // TODO: cache\n    }\n\n    // 5. If response is null, then:\n    if (response == null) {\n      // 1. Set response to forwardResponse.\n      response = forwardResponse\n\n      // 2. Store httpRequest and forwardResponse in httpCache, as per the\n      // \"Storing Responses in Caches\" chapter of HTTP Caching. [HTTP-CACHING]\n      // TODO: cache\n    }\n  }\n\n  // 11. Set response’s URL list to a clone of httpRequest’s URL list.\n  response.urlList = [...httpRequest.urlList]\n\n  // 12. If httpRequest’s header list contains `Range`, then set response’s\n  // range-requested flag.\n  if (httpRequest.headersList.has('range')) {\n    response.rangeRequested = true\n  }\n\n  // 13. Set response’s request-includes-credentials to includeCredentials.\n  response.requestIncludesCredentials = includeCredentials\n\n  // 14. If response’s status is 401, httpRequest’s response tainting is not\n  // \"cors\", includeCredentials is true, and request’s window is an environment\n  // settings object, then:\n  // TODO\n\n  // 15. If response’s status is 407, then:\n  if (response.status === 407) {\n    // 1. If request’s window is \"no-window\", then return a network error.\n    if (request.window === 'no-window') {\n      return makeNetworkError()\n    }\n\n    // 2. ???\n\n    // 3. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if (isCancelled(fetchParams)) {\n      return makeAppropriateNetworkError(fetchParams)\n    }\n\n    // 4. Prompt the end user as appropriate in request’s window and store\n    // the result as a proxy-authentication entry. [HTTP-AUTH]\n    // TODO: Invoke some kind of callback?\n\n    // 5. Set response to the result of running HTTP-network-or-cache fetch given\n    // fetchParams.\n    // TODO\n    return makeNetworkError('proxy authentication required')\n  }\n\n  // 16. If all of the following are true\n  if (\n    // response’s status is 421\n    response.status === 421 &&\n    // isNewConnectionFetch is false\n    !isNewConnectionFetch &&\n    // request’s body is null, or request’s body is non-null and request’s body’s source is non-null\n    (request.body == null || request.body.source != null)\n  ) {\n    // then:\n\n    // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if (isCancelled(fetchParams)) {\n      return makeAppropriateNetworkError(fetchParams)\n    }\n\n    // 2. Set response to the result of running HTTP-network-or-cache\n    // fetch given fetchParams, isAuthenticationFetch, and true.\n\n    // TODO (spec): The spec doesn't specify this but we need to cancel\n    // the active response before we can start a new one.\n    // https://github.com/whatwg/fetch/issues/1293\n    fetchParams.controller.connection.destroy()\n\n    response = await httpNetworkOrCacheFetch(\n      fetchParams,\n      isAuthenticationFetch,\n      true\n    )\n  }\n\n  // 17. If isAuthenticationFetch is true, then create an authentication entry\n  if (isAuthenticationFetch) {\n    // TODO\n  }\n\n  // 18. Return response.\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#http-network-fetch\nasync function httpNetworkFetch (\n  fetchParams,\n  includeCredentials = false,\n  forceNewConnection = false\n) {\n  assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed)\n\n  fetchParams.controller.connection = {\n    abort: null,\n    destroyed: false,\n    destroy (err) {\n      if (!this.destroyed) {\n        this.destroyed = true\n        this.abort?.(err ?? new DOMException('The operation was aborted.', 'AbortError'))\n      }\n    }\n  }\n\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 4. Let httpCache be the result of determining the HTTP cache partition,\n  // given request.\n  // TODO: cache\n  const httpCache = null\n\n  // 5. If httpCache is null, then set request’s cache mode to \"no-store\".\n  if (httpCache == null) {\n    request.cache = 'no-store'\n  }\n\n  // 6. Let networkPartitionKey be the result of determining the network\n  // partition key given request.\n  // TODO\n\n  // 7. Let newConnection be \"yes\" if forceNewConnection is true; otherwise\n  // \"no\".\n  const newConnection = forceNewConnection ? 'yes' : 'no' // eslint-disable-line no-unused-vars\n\n  // 8. Switch on request’s mode:\n  if (request.mode === 'websocket') {\n    // Let connection be the result of obtaining a WebSocket connection,\n    // given request’s current URL.\n    // TODO\n  } else {\n    // Let connection be the result of obtaining a connection, given\n    // networkPartitionKey, request’s current URL’s origin,\n    // includeCredentials, and forceNewConnection.\n    // TODO\n  }\n\n  // 9. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. If connection is failure, then return a network error.\n\n  //    2. Set timingInfo’s final connection timing info to the result of\n  //    calling clamp and coarsen connection timing info with connection’s\n  //    timing info, timingInfo’s post-redirect start time, and fetchParams’s\n  //    cross-origin isolated capability.\n\n  //    3. If connection is not an HTTP/2 connection, request’s body is non-null,\n  //    and request’s body’s source is null, then append (`Transfer-Encoding`,\n  //    `chunked`) to request’s header list.\n\n  //    4. Set timingInfo’s final network-request start time to the coarsened\n  //    shared current time given fetchParams’s cross-origin isolated\n  //    capability.\n\n  //    5. Set response to the result of making an HTTP request over connection\n  //    using request with the following caveats:\n\n  //        - Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]\n  //        [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]\n\n  //        - If request’s body is non-null, and request’s body’s source is null,\n  //        then the user agent may have a buffer of up to 64 kibibytes and store\n  //        a part of request’s body in that buffer. If the user agent reads from\n  //        request’s body beyond that buffer’s size and the user agent needs to\n  //        resend request, then instead return a network error.\n\n  //        - Set timingInfo’s final network-response start time to the coarsened\n  //        shared current time given fetchParams’s cross-origin isolated capability,\n  //        immediately after the user agent’s HTTP parser receives the first byte\n  //        of the response (e.g., frame header bytes for HTTP/2 or response status\n  //        line for HTTP/1.x).\n\n  //        - Wait until all the headers are transmitted.\n\n  //        - Any responses whose status is in the range 100 to 199, inclusive,\n  //        and is not 101, are to be ignored, except for the purposes of setting\n  //        timingInfo’s final network-response start time above.\n\n  //    - If request’s header list contains `Transfer-Encoding`/`chunked` and\n  //    response is transferred via HTTP/1.0 or older, then return a network\n  //    error.\n\n  //    - If the HTTP request results in a TLS client certificate dialog, then:\n\n  //        1. If request’s window is an environment settings object, make the\n  //        dialog available in request’s window.\n\n  //        2. Otherwise, return a network error.\n\n  // To transmit request’s body body, run these steps:\n  let requestBody = null\n  // 1. If body is null and fetchParams’s process request end-of-body is\n  // non-null, then queue a fetch task given fetchParams’s process request\n  // end-of-body and fetchParams’s task destination.\n  if (request.body == null && fetchParams.processRequestEndOfBody) {\n    queueMicrotask(() => fetchParams.processRequestEndOfBody())\n  } else if (request.body != null) {\n    // 2. Otherwise, if body is non-null:\n\n    //    1. Let processBodyChunk given bytes be these steps:\n    const processBodyChunk = async function * (bytes) {\n      // 1. If the ongoing fetch is terminated, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. Run this step in parallel: transmit bytes.\n      yield bytes\n\n      // 3. If fetchParams’s process request body is non-null, then run\n      // fetchParams’s process request body given bytes’s length.\n      fetchParams.processRequestBodyChunkLength?.(bytes.byteLength)\n    }\n\n    // 2. Let processEndOfBody be these steps:\n    const processEndOfBody = () => {\n      // 1. If fetchParams is canceled, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. If fetchParams’s process request end-of-body is non-null,\n      // then run fetchParams’s process request end-of-body.\n      if (fetchParams.processRequestEndOfBody) {\n        fetchParams.processRequestEndOfBody()\n      }\n    }\n\n    // 3. Let processBodyError given e be these steps:\n    const processBodyError = (e) => {\n      // 1. If fetchParams is canceled, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. If e is an \"AbortError\" DOMException, then abort fetchParams’s controller.\n      if (e.name === 'AbortError') {\n        fetchParams.controller.abort()\n      } else {\n        fetchParams.controller.terminate(e)\n      }\n    }\n\n    // 4. Incrementally read request’s body given processBodyChunk, processEndOfBody,\n    // processBodyError, and fetchParams’s task destination.\n    requestBody = (async function * () {\n      try {\n        for await (const bytes of request.body.stream) {\n          yield * processBodyChunk(bytes)\n        }\n        processEndOfBody()\n      } catch (err) {\n        processBodyError(err)\n      }\n    })()\n  }\n\n  try {\n    const { body, status, statusText, headersList } = await dispatch({ body: requestBody })\n\n    const iterator = body[Symbol.asyncIterator]()\n    fetchParams.controller.next = () => iterator.next()\n\n    response = makeResponse({ status, statusText, headersList })\n  } catch (err) {\n    // 10. If aborted, then:\n    if (err.name === 'AbortError') {\n      // 1. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n      fetchParams.controller.connection.destroy()\n\n      // 2. Return the appropriate network error for fetchParams.\n      return makeAppropriateNetworkError(fetchParams)\n    }\n\n    return makeNetworkError(err)\n  }\n\n  // 11. Let pullAlgorithm be an action that resumes the ongoing fetch\n  // if it is suspended.\n  const pullAlgorithm = () => {\n    fetchParams.controller.resume()\n  }\n\n  // 12. Let cancelAlgorithm be an algorithm that aborts fetchParams’s\n  // controller.\n  const cancelAlgorithm = () => {\n    fetchParams.controller.abort()\n  }\n\n  // 13. Let highWaterMark be a non-negative, non-NaN number, chosen by\n  // the user agent.\n  // TODO\n\n  // 14. Let sizeAlgorithm be an algorithm that accepts a chunk object\n  // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.\n  // TODO\n\n  // 15. Let stream be a new ReadableStream.\n  // 16. Set up stream with pullAlgorithm set to pullAlgorithm,\n  // cancelAlgorithm set to cancelAlgorithm, highWaterMark set to\n  // highWaterMark, and sizeAlgorithm set to sizeAlgorithm.\n  if (!ReadableStream) {\n    ReadableStream = require('stream/web').ReadableStream\n  }\n\n  const stream = new ReadableStream(\n    {\n      async start (controller) {\n        fetchParams.controller.controller = controller\n      },\n      async pull (controller) {\n        await pullAlgorithm(controller)\n      },\n      async cancel (reason) {\n        await cancelAlgorithm(reason)\n      }\n    },\n    { highWaterMark: 0 }\n  )\n\n  // 17. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. Set response’s body to a new body whose stream is stream.\n  response.body = { stream }\n\n  //    2. If response is not a network error and request’s cache mode is\n  //    not \"no-store\", then update response in httpCache for request.\n  //    TODO\n\n  //    3. If includeCredentials is true and the user agent is not configured\n  //    to block cookies for request (see section 7 of [COOKIES]), then run the\n  //    \"set-cookie-string\" parsing algorithm (see section 5.2 of [COOKIES]) on\n  //    the value of each header whose name is a byte-case-insensitive match for\n  //    `Set-Cookie` in response’s header list, if any, and request’s current URL.\n  //    TODO\n\n  // 18. If aborted, then:\n  // TODO\n\n  // 19. Run these steps in parallel:\n\n  //    1. Run these steps, but abort when fetchParams is canceled:\n  fetchParams.controller.on('terminated', onAborted)\n  fetchParams.controller.resume = async () => {\n    // 1. While true\n    while (true) {\n      // 1-3. See onData...\n\n      // 4. Set bytes to the result of handling content codings given\n      // codings and bytes.\n      let bytes\n      try {\n        const { done, value } = await fetchParams.controller.next()\n\n        if (isAborted(fetchParams)) {\n          break\n        }\n\n        bytes = done ? undefined : value\n      } catch (err) {\n        if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {\n          // zlib doesn't like empty streams.\n          bytes = undefined\n        } else {\n          bytes = err\n        }\n      }\n\n      if (bytes === undefined) {\n        // 2. Otherwise, if the bytes transmission for response’s message\n        // body is done normally and stream is readable, then close\n        // stream, finalize response for fetchParams and response, and\n        // abort these in-parallel steps.\n        try {\n          fetchParams.controller.controller.close()\n        } catch (err) {\n          // TODO (fix): How/Why can this happen? Do we have a bug?\n          if (!/Controller is already closed/.test(err)) {\n            throw err\n          }\n        }\n\n        finalizeResponse(fetchParams, response)\n\n        return\n      }\n\n      // 5. Increase timingInfo’s decoded body size by bytes’s length.\n      timingInfo.decodedBodySize += bytes?.byteLength ?? 0\n\n      // 6. If bytes is failure, then terminate fetchParams’s controller.\n      if (isErrorLike(bytes)) {\n        fetchParams.controller.terminate(bytes)\n        return\n      }\n\n      // 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes\n      // into stream.\n      fetchParams.controller.controller.enqueue(new Uint8Array(bytes))\n\n      // 8. If stream is errored, then terminate the ongoing fetch.\n      if (isErrored(stream)) {\n        fetchParams.controller.terminate()\n        return\n      }\n\n      // 9. If stream doesn’t need more data ask the user agent to suspend\n      // the ongoing fetch.\n      if (!fetchParams.controller.controller.desiredSize) {\n        return\n      }\n    }\n  }\n\n  //    2. If aborted, then:\n  function onAborted (reason) {\n    // 2. If fetchParams is aborted, then:\n    if (isAborted(fetchParams)) {\n      // 1. Set response’s aborted flag.\n      response.aborted = true\n\n      // 2. If stream is readable, error stream with an \"AbortError\" DOMException.\n      if (isReadable(stream)) {\n        fetchParams.controller.controller.error(\n          new DOMException('The operation was aborted.', 'AbortError')\n        )\n      }\n    } else {\n      // 3. Otherwise, if stream is readable, error stream with a TypeError.\n      if (isReadable(stream)) {\n        fetchParams.controller.controller.error(new TypeError('terminated', {\n          cause: isErrorLike(reason) ? reason : undefined\n        }))\n      }\n    }\n\n    // 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n    // 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.\n    fetchParams.controller.connection.destroy()\n  }\n\n  // 20. Return response.\n  return response\n\n  async function dispatch ({ body }) {\n    const url = requestCurrentURL(request)\n    return new Promise((resolve, reject) => fetchParams.controller.dispatcher.dispatch(\n      {\n        path: url.pathname + url.search,\n        origin: url.origin,\n        method: request.method,\n        body: fetchParams.controller.dispatcher.isMockActive ? request.body && request.body.source : body,\n        headers: [...request.headersList].flat(),\n        maxRedirections: 0,\n        bodyTimeout: 300_000,\n        headersTimeout: 300_000\n      },\n      {\n        body: null,\n        abort: null,\n\n        onConnect (abort) {\n          // TODO (fix): Do we need connection here?\n          const { connection } = fetchParams.controller\n\n          if (connection.destroyed) {\n            abort(new DOMException('The operation was aborted.', 'AbortError'))\n          } else {\n            fetchParams.controller.on('terminated', abort)\n            this.abort = connection.abort = abort\n          }\n        },\n\n        onHeaders (status, headersList, resume, statusText) {\n          if (status < 200) {\n            return\n          }\n\n          let codings = []\n          let location = ''\n\n          const headers = new Headers()\n          for (let n = 0; n < headersList.length; n += 2) {\n            const key = headersList[n + 0].toString('latin1')\n            const val = headersList[n + 1].toString('latin1')\n\n            if (key.toLowerCase() === 'content-encoding') {\n              codings = val.split(',').map((x) => x.trim())\n            } else if (key.toLowerCase() === 'location') {\n              location = val\n            }\n\n            headers.append(key, val)\n          }\n\n          this.body = new Readable({ read: resume })\n\n          const decoders = []\n\n          const willFollow = request.redirect === 'follow' &&\n            location &&\n            redirectStatus.includes(status)\n\n          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding\n          if (request.method !== 'HEAD' && request.method !== 'CONNECT' && !nullBodyStatus.includes(status) && !willFollow) {\n            for (const coding of codings) {\n              if (/(x-)?gzip/.test(coding)) {\n                decoders.push(zlib.createGunzip())\n              } else if (/(x-)?deflate/.test(coding)) {\n                decoders.push(zlib.createInflate())\n              } else if (coding === 'br') {\n                decoders.push(zlib.createBrotliDecompress())\n              } else {\n                decoders.length = 0\n                break\n              }\n            }\n          }\n\n          resolve({\n            status,\n            statusText,\n            headersList: headers[kHeadersList],\n            body: decoders.length\n              ? pipeline(this.body, ...decoders, () => { })\n              : this.body.on('error', () => {})\n          })\n\n          return true\n        },\n\n        onData (chunk) {\n          if (fetchParams.controller.dump) {\n            return\n          }\n\n          // 1. If one or more bytes have been transmitted from response’s\n          // message body, then:\n\n          //  1. Let bytes be the transmitted bytes.\n          const bytes = chunk\n\n          //  2. Let codings be the result of extracting header list values\n          //  given `Content-Encoding` and response’s header list.\n          //  See pullAlgorithm.\n\n          //  3. Increase timingInfo’s encoded body size by bytes’s length.\n          timingInfo.encodedBodySize += bytes.byteLength\n\n          //  4. See pullAlgorithm...\n\n          return this.body.push(bytes)\n        },\n\n        onComplete () {\n          if (this.abort) {\n            fetchParams.controller.off('terminated', this.abort)\n          }\n\n          fetchParams.controller.ended = true\n\n          this.body.push(null)\n        },\n\n        onError (error) {\n          if (this.abort) {\n            fetchParams.controller.off('terminated', this.abort)\n          }\n\n          this.body?.destroy(error)\n\n          fetchParams.controller.terminate(error)\n\n          reject(error)\n        }\n      }\n    ))\n  }\n}\n\nmodule.exports = {\n  fetch,\n  Fetch,\n  fetching,\n  finalizeAndReportTiming\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}