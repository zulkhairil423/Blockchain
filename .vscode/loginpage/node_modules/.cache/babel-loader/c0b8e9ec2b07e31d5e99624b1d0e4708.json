{"ast":null,"code":"'use strict';\n\nconst {\n  kClients\n} = require('../core/symbols');\n\nconst Agent = require('../agent');\n\nconst {\n  kAgent,\n  kMockAgentSet,\n  kMockAgentGet,\n  kDispatches,\n  kIsMockActive,\n  kNetConnect,\n  kGetNetConnect,\n  kOptions,\n  kFactory\n} = require('./mock-symbols');\n\nconst MockClient = require('./mock-client');\n\nconst MockPool = require('./mock-pool');\n\nconst {\n  matchValue,\n  buildMockOptions\n} = require('./mock-utils');\n\nconst {\n  InvalidArgumentError,\n  UndiciError\n} = require('../core/errors');\n\nconst Dispatcher = require('../dispatcher');\n\nconst Pluralizer = require('./pluralizer');\n\nconst PendingInterceptorsFormatter = require('./pending-interceptors-formatter');\n\nclass FakeWeakRef {\n  constructor(value) {\n    this.value = value;\n  }\n\n  deref() {\n    return this.value;\n  }\n\n}\n\nclass MockAgent extends Dispatcher {\n  constructor(opts) {\n    super(opts);\n    this[kNetConnect] = true;\n    this[kIsMockActive] = true; // Instantiate Agent and encapsulate\n\n    if (opts && opts.agent && typeof opts.agent.dispatch !== 'function') {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent');\n    }\n\n    const agent = opts && opts.agent ? opts.agent : new Agent(opts);\n    this[kAgent] = agent;\n    this[kClients] = agent[kClients];\n    this[kOptions] = buildMockOptions(opts);\n  }\n\n  get(origin) {\n    let dispatcher = this[kMockAgentGet](origin);\n\n    if (!dispatcher) {\n      dispatcher = this[kFactory](origin);\n      this[kMockAgentSet](origin, dispatcher);\n    }\n\n    return dispatcher;\n  }\n\n  dispatch(opts, handler) {\n    // Call MockAgent.get to perform additional setup before dispatching as normal\n    this.get(opts.origin);\n    return this[kAgent].dispatch(opts, handler);\n  }\n\n  async close() {\n    await this[kAgent].close();\n    this[kClients].clear();\n  }\n\n  deactivate() {\n    this[kIsMockActive] = false;\n  }\n\n  activate() {\n    this[kIsMockActive] = true;\n  }\n\n  enableNetConnect(matcher) {\n    if (typeof matcher === 'string' || typeof matcher === 'function' || matcher instanceof RegExp) {\n      if (Array.isArray(this[kNetConnect])) {\n        this[kNetConnect].push(matcher);\n      } else {\n        this[kNetConnect] = [matcher];\n      }\n    } else if (typeof matcher === 'undefined') {\n      this[kNetConnect] = true;\n    } else {\n      throw new InvalidArgumentError('Unsupported matcher. Must be one of String|Function|RegExp.');\n    }\n  }\n\n  disableNetConnect() {\n    this[kNetConnect] = false;\n  } // This is required to bypass issues caused by using global symbols - see:\n  // https://github.com/nodejs/undici/issues/1447\n\n\n  get isMockActive() {\n    return this[kIsMockActive];\n  }\n\n  [kMockAgentSet](origin, dispatcher) {\n    this[kClients].set(origin, new FakeWeakRef(dispatcher));\n  }\n\n  [kFactory](origin) {\n    const mockOptions = Object.assign({\n      agent: this\n    }, this[kOptions]);\n    return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);\n  }\n\n  [kMockAgentGet](origin) {\n    // First check if we can immediately find it\n    const ref = this[kClients].get(origin);\n\n    if (ref) {\n      return ref.deref();\n    } // If the origin is not a string create a dummy parent pool and return to user\n\n\n    if (typeof origin !== 'string') {\n      const dispatcher = this[kFactory]('http://localhost:9999');\n      this[kMockAgentSet](origin, dispatcher);\n      return dispatcher;\n    } // If we match, create a pool and assign the same dispatches\n\n\n    for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {\n      const nonExplicitDispatcher = nonExplicitRef.deref();\n\n      if (nonExplicitDispatcher && typeof keyMatcher !== 'string' && matchValue(keyMatcher, origin)) {\n        const dispatcher = this[kFactory](origin);\n        this[kMockAgentSet](origin, dispatcher);\n        dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];\n        return dispatcher;\n      }\n    }\n  }\n\n  [kGetNetConnect]() {\n    return this[kNetConnect];\n  }\n\n  pendingInterceptors() {\n    const mockAgentClients = this[kClients];\n    return Array.from(mockAgentClients.entries()).flatMap(_ref => {\n      let [origin, scope] = _ref;\n      return scope.deref()[kDispatches].map(dispatch => ({ ...dispatch,\n        origin\n      }));\n    }).filter(_ref2 => {\n      let {\n        pending\n      } = _ref2;\n      return pending;\n    });\n  }\n\n  assertNoPendingInterceptors() {\n    let {\n      pendingInterceptorsFormatter = new PendingInterceptorsFormatter()\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const pending = this.pendingInterceptors();\n\n    if (pending.length === 0) {\n      return;\n    }\n\n    const pluralizer = new Pluralizer('interceptor', 'interceptors').pluralize(pending.length);\n    throw new UndiciError(`\n${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:\n\n${pendingInterceptorsFormatter.format(pending)}\n`.trim());\n  }\n\n}\n\nmodule.exports = MockAgent;","map":{"version":3,"names":["kClients","require","Agent","kAgent","kMockAgentSet","kMockAgentGet","kDispatches","kIsMockActive","kNetConnect","kGetNetConnect","kOptions","kFactory","MockClient","MockPool","matchValue","buildMockOptions","InvalidArgumentError","UndiciError","Dispatcher","Pluralizer","PendingInterceptorsFormatter","FakeWeakRef","constructor","value","deref","MockAgent","opts","agent","dispatch","get","origin","dispatcher","handler","close","clear","deactivate","activate","enableNetConnect","matcher","RegExp","Array","isArray","push","disableNetConnect","isMockActive","set","mockOptions","Object","assign","connections","ref","keyMatcher","nonExplicitRef","from","nonExplicitDispatcher","pendingInterceptors","mockAgentClients","entries","flatMap","scope","map","filter","pending","assertNoPendingInterceptors","pendingInterceptorsFormatter","length","pluralizer","pluralize","count","noun","is","format","trim","module","exports"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/undici/lib/mock/mock-agent.js"],"sourcesContent":["'use strict'\n\nconst { kClients } = require('../core/symbols')\nconst Agent = require('../agent')\nconst {\n  kAgent,\n  kMockAgentSet,\n  kMockAgentGet,\n  kDispatches,\n  kIsMockActive,\n  kNetConnect,\n  kGetNetConnect,\n  kOptions,\n  kFactory\n} = require('./mock-symbols')\nconst MockClient = require('./mock-client')\nconst MockPool = require('./mock-pool')\nconst { matchValue, buildMockOptions } = require('./mock-utils')\nconst { InvalidArgumentError, UndiciError } = require('../core/errors')\nconst Dispatcher = require('../dispatcher')\nconst Pluralizer = require('./pluralizer')\nconst PendingInterceptorsFormatter = require('./pending-interceptors-formatter')\n\nclass FakeWeakRef {\n  constructor (value) {\n    this.value = value\n  }\n\n  deref () {\n    return this.value\n  }\n}\n\nclass MockAgent extends Dispatcher {\n  constructor (opts) {\n    super(opts)\n\n    this[kNetConnect] = true\n    this[kIsMockActive] = true\n\n    // Instantiate Agent and encapsulate\n    if ((opts && opts.agent && typeof opts.agent.dispatch !== 'function')) {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n    const agent = opts && opts.agent ? opts.agent : new Agent(opts)\n    this[kAgent] = agent\n\n    this[kClients] = agent[kClients]\n    this[kOptions] = buildMockOptions(opts)\n  }\n\n  get (origin) {\n    let dispatcher = this[kMockAgentGet](origin)\n\n    if (!dispatcher) {\n      dispatcher = this[kFactory](origin)\n      this[kMockAgentSet](origin, dispatcher)\n    }\n    return dispatcher\n  }\n\n  dispatch (opts, handler) {\n    // Call MockAgent.get to perform additional setup before dispatching as normal\n    this.get(opts.origin)\n    return this[kAgent].dispatch(opts, handler)\n  }\n\n  async close () {\n    await this[kAgent].close()\n    this[kClients].clear()\n  }\n\n  deactivate () {\n    this[kIsMockActive] = false\n  }\n\n  activate () {\n    this[kIsMockActive] = true\n  }\n\n  enableNetConnect (matcher) {\n    if (typeof matcher === 'string' || typeof matcher === 'function' || matcher instanceof RegExp) {\n      if (Array.isArray(this[kNetConnect])) {\n        this[kNetConnect].push(matcher)\n      } else {\n        this[kNetConnect] = [matcher]\n      }\n    } else if (typeof matcher === 'undefined') {\n      this[kNetConnect] = true\n    } else {\n      throw new InvalidArgumentError('Unsupported matcher. Must be one of String|Function|RegExp.')\n    }\n  }\n\n  disableNetConnect () {\n    this[kNetConnect] = false\n  }\n\n  // This is required to bypass issues caused by using global symbols - see:\n  // https://github.com/nodejs/undici/issues/1447\n  get isMockActive () {\n    return this[kIsMockActive]\n  }\n\n  [kMockAgentSet] (origin, dispatcher) {\n    this[kClients].set(origin, new FakeWeakRef(dispatcher))\n  }\n\n  [kFactory] (origin) {\n    const mockOptions = Object.assign({ agent: this }, this[kOptions])\n    return this[kOptions] && this[kOptions].connections === 1\n      ? new MockClient(origin, mockOptions)\n      : new MockPool(origin, mockOptions)\n  }\n\n  [kMockAgentGet] (origin) {\n    // First check if we can immediately find it\n    const ref = this[kClients].get(origin)\n    if (ref) {\n      return ref.deref()\n    }\n\n    // If the origin is not a string create a dummy parent pool and return to user\n    if (typeof origin !== 'string') {\n      const dispatcher = this[kFactory]('http://localhost:9999')\n      this[kMockAgentSet](origin, dispatcher)\n      return dispatcher\n    }\n\n    // If we match, create a pool and assign the same dispatches\n    for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {\n      const nonExplicitDispatcher = nonExplicitRef.deref()\n      if (nonExplicitDispatcher && typeof keyMatcher !== 'string' && matchValue(keyMatcher, origin)) {\n        const dispatcher = this[kFactory](origin)\n        this[kMockAgentSet](origin, dispatcher)\n        dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches]\n        return dispatcher\n      }\n    }\n  }\n\n  [kGetNetConnect] () {\n    return this[kNetConnect]\n  }\n\n  pendingInterceptors () {\n    const mockAgentClients = this[kClients]\n\n    return Array.from(mockAgentClients.entries())\n      .flatMap(([origin, scope]) => scope.deref()[kDispatches].map(dispatch => ({ ...dispatch, origin })))\n      .filter(({ pending }) => pending)\n  }\n\n  assertNoPendingInterceptors ({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {\n    const pending = this.pendingInterceptors()\n\n    if (pending.length === 0) {\n      return\n    }\n\n    const pluralizer = new Pluralizer('interceptor', 'interceptors').pluralize(pending.length)\n\n    throw new UndiciError(`\n${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:\n\n${pendingInterceptorsFormatter.format(pending)}\n`.trim())\n  }\n}\n\nmodule.exports = MockAgent\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}