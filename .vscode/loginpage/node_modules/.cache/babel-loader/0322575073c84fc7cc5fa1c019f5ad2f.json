{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Resolver = exports.ResolvedFile = void 0;\n\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst resolve_1 = __importDefault(require(\"resolve\"));\n\nconst source_names_1 = require(\"../../utils/source-names\");\n\nconst errors_1 = require(\"../core/errors\");\n\nconst errors_list_1 = require(\"../core/errors-list\");\n\nconst hash_1 = require(\"../util/hash\");\n\nconst fs_utils_1 = require(\"../util/fs-utils\");\n\nconst NODE_MODULES = \"node_modules\";\n\nclass ResolvedFile {\n  constructor(sourceName, absolutePath, content, contentHash, lastModificationDate, libraryName, libraryVersion) {\n    this.sourceName = sourceName;\n    this.absolutePath = absolutePath;\n    this.content = content;\n    this.contentHash = contentHash;\n    this.lastModificationDate = lastModificationDate;\n    (0, errors_1.assertHardhatInvariant)(libraryName === undefined && libraryVersion === undefined || libraryName !== undefined && libraryVersion !== undefined, \"Libraries should have both name and version, or neither one\");\n\n    if (libraryName !== undefined && libraryVersion !== undefined) {\n      this.library = {\n        name: libraryName,\n        version: libraryVersion\n      };\n    }\n  }\n\n  getVersionedName() {\n    return this.sourceName + (this.library !== undefined ? `@v${this.library.version}` : \"\");\n  }\n\n}\n\nexports.ResolvedFile = ResolvedFile;\n\nclass Resolver {\n  constructor(_projectRoot, _parser, _readFile) {\n    this._projectRoot = _projectRoot;\n    this._parser = _parser;\n    this._readFile = _readFile;\n    this._cache = new Map();\n  }\n  /**\n   * Resolves a source name into a ResolvedFile.\n   *\n   * @param sourceName The source name as it would be provided to solc.\n   */\n\n\n  async resolveSourceName(sourceName) {\n    const cached = this._cache.get(sourceName);\n\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    (0, source_names_1.validateSourceNameFormat)(sourceName);\n    let resolvedFile;\n\n    if (await (0, source_names_1.isLocalSourceName)(this._projectRoot, sourceName)) {\n      resolvedFile = await this._resolveLocalSourceName(sourceName);\n    } else {\n      resolvedFile = await this._resolveLibrarySourceName(sourceName);\n    }\n\n    this._cache.set(sourceName, resolvedFile);\n\n    return resolvedFile;\n  }\n  /**\n   * Resolves an import from an already resolved file.\n   * @param from The file were the import statement is present.\n   * @param imported The path in the import statement.\n   */\n\n\n  async resolveImport(from, imported) {\n    const scheme = this._getUriScheme(imported);\n\n    if (scheme !== undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_PROTOCOL, {\n        from: from.sourceName,\n        imported,\n        protocol: scheme\n      });\n    }\n\n    if ((0, source_names_1.replaceBackslashes)(imported) !== imported) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_BACKSLASH, {\n        from: from.sourceName,\n        imported\n      });\n    }\n\n    if ((0, source_names_1.isAbsolutePathSourceName)(imported)) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_ABSOLUTE_PATH, {\n        from: from.sourceName,\n        imported\n      });\n    }\n\n    try {\n      let sourceName;\n\n      const isRelativeImport = this._isRelativeImport(imported);\n\n      if (isRelativeImport) {\n        sourceName = await this._relativeImportToSourceName(from, imported);\n      } else {\n        sourceName = (0, source_names_1.normalizeSourceName)(imported);\n      }\n\n      const cached = this._cache.get(sourceName);\n\n      if (cached !== undefined) {\n        return cached;\n      }\n\n      let resolvedFile; // We have this special case here, because otherwise local relative\n      // imports can be treated as library imports. For example if\n      // `contracts/c.sol` imports `../non-existent/a.sol`\n\n      if (from.library === undefined && isRelativeImport && !this._isRelativeImportToLibrary(from, imported)) {\n        resolvedFile = await this._resolveLocalSourceName(sourceName);\n      } else {\n        resolvedFile = await this.resolveSourceName(sourceName);\n      }\n\n      this._cache.set(sourceName, resolvedFile);\n\n      return resolvedFile;\n    } catch (error) {\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.RESOLVER.FILE_NOT_FOUND) || errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.RESOLVER.LIBRARY_FILE_NOT_FOUND)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.IMPORTED_FILE_NOT_FOUND, {\n          imported,\n          from: from.sourceName\n        }, error);\n      }\n\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.RESOLVER.WRONG_SOURCE_NAME_CASING)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_WRONG_CASING, {\n          imported,\n          from: from.sourceName\n        }, error);\n      }\n\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.RESOLVER.LIBRARY_NOT_INSTALLED)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.IMPORTED_LIBRARY_NOT_INSTALLED, {\n          library: error.messageArguments.library,\n          from: from.sourceName\n        }, error);\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw error;\n    }\n  }\n\n  async _resolveLocalSourceName(sourceName) {\n    await this._validateSourceNameExistenceAndCasing(this._projectRoot, sourceName, false);\n    const absolutePath = path_1.default.join(this._projectRoot, sourceName);\n    return this._resolveFile(sourceName, absolutePath);\n  }\n\n  async _resolveLibrarySourceName(sourceName) {\n    const libraryName = this._getLibraryName(sourceName);\n\n    let packageJsonPath;\n\n    try {\n      packageJsonPath = this._resolveNodeModulesFileFromProjectRoot(path_1.default.join(libraryName, \"package.json\"));\n    } catch (error) {\n      // if the project is using a dependency from hardhat itself but it can't\n      // be found, this means that a global installation is being used, so we\n      // resolve the dependency relative to this file\n      if (libraryName === \"hardhat\") {\n        const hardhatCoreDir = path_1.default.join(__dirname, \"..\", \"..\");\n        packageJsonPath = path_1.default.join(hardhatCoreDir, \"package.json\");\n      } else {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.LIBRARY_NOT_INSTALLED, {\n          library: libraryName\n        }, error);\n      }\n    }\n\n    let nodeModulesPath = path_1.default.dirname(path_1.default.dirname(packageJsonPath));\n\n    if (this._isScopedPackage(sourceName)) {\n      nodeModulesPath = path_1.default.dirname(nodeModulesPath);\n    }\n\n    await this._validateSourceNameExistenceAndCasing(nodeModulesPath, sourceName, true);\n    const packageInfo = await fs_extra_1.default.readJson(packageJsonPath);\n    const libraryVersion = packageInfo.version;\n    return this._resolveFile(sourceName, // We resolve to the real path here, as we may be resolving a linked library\n    await (0, fs_utils_1.getRealPath)(path_1.default.join(nodeModulesPath, sourceName)), libraryName, libraryVersion);\n  }\n\n  async _relativeImportToSourceName(from, imported) {\n    // This is a special case, were we turn relative imports from local files\n    // into library imports if necessary. The reason for this is that many\n    // users just do `import \"../node_modules/lib/a.sol\";`.\n    if (this._isRelativeImportToLibrary(from, imported)) {\n      return this._relativeImportToLibraryToSourceName(from, imported);\n    }\n\n    const sourceName = (0, source_names_1.normalizeSourceName)(path_1.default.join(path_1.default.dirname(from.sourceName), imported)); // If the file with the import is local, and the normalized version\n    // starts with ../ means that it's trying to get outside of the project.\n\n    if (from.library === undefined && sourceName.startsWith(\"../\")) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_OUTSIDE_OF_PROJECT, {\n        from: from.sourceName,\n        imported\n      });\n    }\n\n    if (from.library !== undefined && !this._isInsideSameDir(from.sourceName, sourceName)) {\n      // If the file is being imported from a library, this means that it's\n      // trying to reach another one.\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.ILLEGAL_IMPORT, {\n        from: from.sourceName,\n        imported\n      });\n    }\n\n    return sourceName;\n  }\n\n  async _resolveFile(sourceName, absolutePath, libraryName, libraryVersion) {\n    const rawContent = await this._readFile(absolutePath);\n    const stats = await fs_extra_1.default.stat(absolutePath);\n    const lastModificationDate = new Date(stats.ctime);\n    const contentHash = (0, hash_1.createNonCryptographicHashBasedIdentifier)(Buffer.from(rawContent)).toString(\"hex\");\n\n    const parsedContent = this._parser.parse(rawContent, absolutePath, contentHash);\n\n    const content = {\n      rawContent,\n      ...parsedContent\n    };\n    return new ResolvedFile(sourceName, absolutePath, content, contentHash, lastModificationDate, libraryName, libraryVersion);\n  }\n\n  _isRelativeImport(imported) {\n    return imported.startsWith(\"./\") || imported.startsWith(\"../\");\n  }\n\n  _resolveNodeModulesFileFromProjectRoot(fileName) {\n    return resolve_1.default.sync(fileName, {\n      basedir: this._projectRoot,\n      preserveSymlinks: true\n    });\n  }\n\n  _getLibraryName(sourceName) {\n    let endIndex;\n\n    if (this._isScopedPackage(sourceName)) {\n      endIndex = sourceName.indexOf(\"/\", sourceName.indexOf(\"/\") + 1);\n    } else if (sourceName.indexOf(\"/\") === -1) {\n      endIndex = sourceName.length;\n    } else {\n      endIndex = sourceName.indexOf(\"/\");\n    }\n\n    return sourceName.slice(0, endIndex);\n  }\n\n  _getUriScheme(s) {\n    const re = /([a-zA-Z]+):\\/\\//;\n    const match = re.exec(s);\n\n    if (match === null) {\n      return undefined;\n    }\n\n    return match[1];\n  }\n\n  _isInsideSameDir(sourceNameInDir, sourceNameToTest) {\n    const firstSlash = sourceNameInDir.indexOf(\"/\");\n    const dir = firstSlash !== -1 ? sourceNameInDir.substring(0, firstSlash) : sourceNameInDir;\n    return sourceNameToTest.startsWith(dir);\n  }\n\n  _isScopedPackage(packageOrPackageFile) {\n    return packageOrPackageFile.startsWith(\"@\");\n  }\n\n  _isRelativeImportToLibrary(from, imported) {\n    return this._isRelativeImport(imported) && from.library === undefined && imported.includes(`${NODE_MODULES}/`);\n  }\n\n  _relativeImportToLibraryToSourceName(from, imported) {\n    const sourceName = (0, source_names_1.normalizeSourceName)(path_1.default.join(path_1.default.dirname(from.sourceName), imported));\n    const nmIndex = sourceName.indexOf(`${NODE_MODULES}/`);\n    return sourceName.substr(nmIndex + NODE_MODULES.length + 1);\n  }\n\n  async _validateSourceNameExistenceAndCasing(fromDir, sourceName, isLibrary) {\n    try {\n      await (0, source_names_1.validateSourceNameExistenceAndCasing)(fromDir, sourceName);\n    } catch (error) {\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.SOURCE_NAMES.FILE_NOT_FOUND)) {\n        throw new errors_1.HardhatError(isLibrary ? errors_list_1.ERRORS.RESOLVER.LIBRARY_FILE_NOT_FOUND : errors_list_1.ERRORS.RESOLVER.FILE_NOT_FOUND, {\n          file: sourceName\n        }, error);\n      }\n\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.SOURCE_NAMES.WRONG_CASING)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.WRONG_SOURCE_NAME_CASING, {\n          incorrect: sourceName,\n          correct: error.messageArguments.correct\n        }, error);\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw error;\n    }\n  }\n\n}\n\nexports.Resolver = Resolver;","map":{"version":3,"mappings":"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","names":["NODE_MODULES","ResolvedFile","constructor","sourceName","absolutePath","content","contentHash","lastModificationDate","libraryName","libraryVersion","undefined","library","name","version","getVersionedName","exports","Resolver","_projectRoot","_parser","_readFile","Map","resolveSourceName","cached","_cache","get","resolvedFile","_resolveLocalSourceName","_resolveLibrarySourceName","set","resolveImport","from","imported","scheme","_getUriScheme","errors_1","errors_list_1","RESOLVER","INVALID_IMPORT_PROTOCOL","protocol","INVALID_IMPORT_BACKSLASH","INVALID_IMPORT_ABSOLUTE_PATH","isRelativeImport","_isRelativeImport","_relativeImportToSourceName","_isRelativeImportToLibrary","error","isHardhatErrorType","FILE_NOT_FOUND","LIBRARY_FILE_NOT_FOUND","IMPORTED_FILE_NOT_FOUND","WRONG_SOURCE_NAME_CASING","INVALID_IMPORT_WRONG_CASING","LIBRARY_NOT_INSTALLED","IMPORTED_LIBRARY_NOT_INSTALLED","messageArguments","_validateSourceNameExistenceAndCasing","path_1","join","_resolveFile","_getLibraryName","packageJsonPath","_resolveNodeModulesFileFromProjectRoot","hardhatCoreDir","__dirname","nodeModulesPath","dirname","_isScopedPackage","packageInfo","fs_extra_1","readJson","_relativeImportToLibraryToSourceName","startsWith","INVALID_IMPORT_OUTSIDE_OF_PROJECT","_isInsideSameDir","ILLEGAL_IMPORT","rawContent","stats","stat","Date","ctime","Buffer","toString","parsedContent","parse","fileName","resolve_1","sync","basedir","preserveSymlinks","endIndex","indexOf","length","slice","s","re","match","exec","sourceNameInDir","sourceNameToTest","firstSlash","dir","substring","packageOrPackageFile","includes","nmIndex","substr","fromDir","isLibrary","SOURCE_NAMES","file","WRONG_CASING","incorrect","correct"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\hardhat\\src\\internal\\solidity\\resolver.ts"],"sourcesContent":["import fsExtra from \"fs-extra\";\nimport path from \"path\";\nimport resolve from \"resolve\";\n\nimport {\n  FileContent,\n  LibraryInfo,\n  ResolvedFile as IResolvedFile,\n} from \"../../types/builtin-tasks\";\nimport {\n  isAbsolutePathSourceName,\n  isLocalSourceName,\n  normalizeSourceName,\n  replaceBackslashes,\n  validateSourceNameExistenceAndCasing,\n  validateSourceNameFormat,\n} from \"../../utils/source-names\";\nimport { assertHardhatInvariant, HardhatError } from \"../core/errors\";\nimport { ERRORS } from \"../core/errors-list\";\nimport { createNonCryptographicHashBasedIdentifier } from \"../util/hash\";\n\nimport { getRealPath } from \"../util/fs-utils\";\nimport { Parser } from \"./parse\";\n\nexport interface ResolvedFilesMap {\n  [sourceName: string]: ResolvedFile;\n}\n\nconst NODE_MODULES = \"node_modules\";\n\nexport class ResolvedFile implements IResolvedFile {\n  public readonly library?: LibraryInfo;\n\n  constructor(\n    public readonly sourceName: string,\n    public readonly absolutePath: string,\n    public readonly content: FileContent,\n    public readonly contentHash: string,\n    public readonly lastModificationDate: Date,\n    libraryName?: string,\n    libraryVersion?: string\n  ) {\n    assertHardhatInvariant(\n      (libraryName === undefined && libraryVersion === undefined) ||\n        (libraryName !== undefined && libraryVersion !== undefined),\n      \"Libraries should have both name and version, or neither one\"\n    );\n\n    if (libraryName !== undefined && libraryVersion !== undefined) {\n      this.library = {\n        name: libraryName,\n        version: libraryVersion,\n      };\n    }\n  }\n\n  public getVersionedName() {\n    return (\n      this.sourceName +\n      (this.library !== undefined ? `@v${this.library.version}` : \"\")\n    );\n  }\n}\n\nexport class Resolver {\n  private readonly _cache: Map<string, ResolvedFile> = new Map();\n\n  constructor(\n    private readonly _projectRoot: string,\n    private readonly _parser: Parser,\n    private readonly _readFile: (absolutePath: string) => Promise<string>\n  ) {}\n\n  /**\n   * Resolves a source name into a ResolvedFile.\n   *\n   * @param sourceName The source name as it would be provided to solc.\n   */\n  public async resolveSourceName(sourceName: string): Promise<ResolvedFile> {\n    const cached = this._cache.get(sourceName);\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    validateSourceNameFormat(sourceName);\n\n    let resolvedFile: ResolvedFile;\n\n    if (await isLocalSourceName(this._projectRoot, sourceName)) {\n      resolvedFile = await this._resolveLocalSourceName(sourceName);\n    } else {\n      resolvedFile = await this._resolveLibrarySourceName(sourceName);\n    }\n\n    this._cache.set(sourceName, resolvedFile);\n    return resolvedFile;\n  }\n\n  /**\n   * Resolves an import from an already resolved file.\n   * @param from The file were the import statement is present.\n   * @param imported The path in the import statement.\n   */\n  public async resolveImport(\n    from: ResolvedFile,\n    imported: string\n  ): Promise<ResolvedFile> {\n    const scheme = this._getUriScheme(imported);\n    if (scheme !== undefined) {\n      throw new HardhatError(ERRORS.RESOLVER.INVALID_IMPORT_PROTOCOL, {\n        from: from.sourceName,\n        imported,\n        protocol: scheme,\n      });\n    }\n\n    if (replaceBackslashes(imported) !== imported) {\n      throw new HardhatError(ERRORS.RESOLVER.INVALID_IMPORT_BACKSLASH, {\n        from: from.sourceName,\n        imported,\n      });\n    }\n\n    if (isAbsolutePathSourceName(imported)) {\n      throw new HardhatError(ERRORS.RESOLVER.INVALID_IMPORT_ABSOLUTE_PATH, {\n        from: from.sourceName,\n        imported,\n      });\n    }\n\n    try {\n      let sourceName: string;\n\n      const isRelativeImport = this._isRelativeImport(imported);\n\n      if (isRelativeImport) {\n        sourceName = await this._relativeImportToSourceName(from, imported);\n      } else {\n        sourceName = normalizeSourceName(imported);\n      }\n\n      const cached = this._cache.get(sourceName);\n      if (cached !== undefined) {\n        return cached;\n      }\n\n      let resolvedFile: ResolvedFile;\n\n      // We have this special case here, because otherwise local relative\n      // imports can be treated as library imports. For example if\n      // `contracts/c.sol` imports `../non-existent/a.sol`\n      if (\n        from.library === undefined &&\n        isRelativeImport &&\n        !this._isRelativeImportToLibrary(from, imported)\n      ) {\n        resolvedFile = await this._resolveLocalSourceName(sourceName);\n      } else {\n        resolvedFile = await this.resolveSourceName(sourceName);\n      }\n\n      this._cache.set(sourceName, resolvedFile);\n      return resolvedFile;\n    } catch (error) {\n      if (\n        HardhatError.isHardhatErrorType(\n          error,\n          ERRORS.RESOLVER.FILE_NOT_FOUND\n        ) ||\n        HardhatError.isHardhatErrorType(\n          error,\n          ERRORS.RESOLVER.LIBRARY_FILE_NOT_FOUND\n        )\n      ) {\n        throw new HardhatError(\n          ERRORS.RESOLVER.IMPORTED_FILE_NOT_FOUND,\n          {\n            imported,\n            from: from.sourceName,\n          },\n          error\n        );\n      }\n\n      if (\n        HardhatError.isHardhatErrorType(\n          error,\n          ERRORS.RESOLVER.WRONG_SOURCE_NAME_CASING\n        )\n      ) {\n        throw new HardhatError(\n          ERRORS.RESOLVER.INVALID_IMPORT_WRONG_CASING,\n          {\n            imported,\n            from: from.sourceName,\n          },\n          error\n        );\n      }\n\n      if (\n        HardhatError.isHardhatErrorType(\n          error,\n          ERRORS.RESOLVER.LIBRARY_NOT_INSTALLED\n        )\n      ) {\n        throw new HardhatError(\n          ERRORS.RESOLVER.IMPORTED_LIBRARY_NOT_INSTALLED,\n          {\n            library: error.messageArguments.library,\n            from: from.sourceName,\n          },\n          error\n        );\n      }\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  }\n\n  private async _resolveLocalSourceName(\n    sourceName: string\n  ): Promise<ResolvedFile> {\n    await this._validateSourceNameExistenceAndCasing(\n      this._projectRoot,\n      sourceName,\n      false\n    );\n\n    const absolutePath = path.join(this._projectRoot, sourceName);\n    return this._resolveFile(sourceName, absolutePath);\n  }\n\n  private async _resolveLibrarySourceName(\n    sourceName: string\n  ): Promise<ResolvedFile> {\n    const libraryName = this._getLibraryName(sourceName);\n\n    let packageJsonPath;\n    try {\n      packageJsonPath = this._resolveNodeModulesFileFromProjectRoot(\n        path.join(libraryName, \"package.json\")\n      );\n    } catch (error) {\n      // if the project is using a dependency from hardhat itself but it can't\n      // be found, this means that a global installation is being used, so we\n      // resolve the dependency relative to this file\n      if (libraryName === \"hardhat\") {\n        const hardhatCoreDir = path.join(__dirname, \"..\", \"..\");\n        packageJsonPath = path.join(hardhatCoreDir, \"package.json\");\n      } else {\n        throw new HardhatError(\n          ERRORS.RESOLVER.LIBRARY_NOT_INSTALLED,\n          {\n            library: libraryName,\n          },\n          error as Error\n        );\n      }\n    }\n\n    let nodeModulesPath = path.dirname(path.dirname(packageJsonPath));\n    if (this._isScopedPackage(sourceName)) {\n      nodeModulesPath = path.dirname(nodeModulesPath);\n    }\n\n    await this._validateSourceNameExistenceAndCasing(\n      nodeModulesPath,\n      sourceName,\n      true\n    );\n\n    const packageInfo: {\n      name: string;\n      version: string;\n    } = await fsExtra.readJson(packageJsonPath);\n    const libraryVersion = packageInfo.version;\n\n    return this._resolveFile(\n      sourceName,\n      // We resolve to the real path here, as we may be resolving a linked library\n      await getRealPath(path.join(nodeModulesPath, sourceName)),\n      libraryName,\n      libraryVersion\n    );\n  }\n\n  private async _relativeImportToSourceName(\n    from: ResolvedFile,\n    imported: string\n  ): Promise<string> {\n    // This is a special case, were we turn relative imports from local files\n    // into library imports if necessary. The reason for this is that many\n    // users just do `import \"../node_modules/lib/a.sol\";`.\n    if (this._isRelativeImportToLibrary(from, imported)) {\n      return this._relativeImportToLibraryToSourceName(from, imported);\n    }\n\n    const sourceName = normalizeSourceName(\n      path.join(path.dirname(from.sourceName), imported)\n    );\n\n    // If the file with the import is local, and the normalized version\n    // starts with ../ means that it's trying to get outside of the project.\n    if (from.library === undefined && sourceName.startsWith(\"../\")) {\n      throw new HardhatError(\n        ERRORS.RESOLVER.INVALID_IMPORT_OUTSIDE_OF_PROJECT,\n        { from: from.sourceName, imported }\n      );\n    }\n\n    if (\n      from.library !== undefined &&\n      !this._isInsideSameDir(from.sourceName, sourceName)\n    ) {\n      // If the file is being imported from a library, this means that it's\n      // trying to reach another one.\n      throw new HardhatError(ERRORS.RESOLVER.ILLEGAL_IMPORT, {\n        from: from.sourceName,\n        imported,\n      });\n    }\n\n    return sourceName;\n  }\n\n  private async _resolveFile(\n    sourceName: string,\n    absolutePath: string,\n    libraryName?: string,\n    libraryVersion?: string\n  ): Promise<ResolvedFile> {\n    const rawContent = await this._readFile(absolutePath);\n    const stats = await fsExtra.stat(absolutePath);\n    const lastModificationDate = new Date(stats.ctime);\n\n    const contentHash = createNonCryptographicHashBasedIdentifier(\n      Buffer.from(rawContent)\n    ).toString(\"hex\");\n\n    const parsedContent = this._parser.parse(\n      rawContent,\n      absolutePath,\n      contentHash\n    );\n\n    const content = {\n      rawContent,\n      ...parsedContent,\n    };\n\n    return new ResolvedFile(\n      sourceName,\n      absolutePath,\n      content,\n      contentHash,\n      lastModificationDate,\n      libraryName,\n      libraryVersion\n    );\n  }\n\n  private _isRelativeImport(imported: string): boolean {\n    return imported.startsWith(\"./\") || imported.startsWith(\"../\");\n  }\n\n  private _resolveNodeModulesFileFromProjectRoot(fileName: string) {\n    return resolve.sync(fileName, {\n      basedir: this._projectRoot,\n      preserveSymlinks: true,\n    });\n  }\n\n  private _getLibraryName(sourceName: string): string {\n    let endIndex: number;\n    if (this._isScopedPackage(sourceName)) {\n      endIndex = sourceName.indexOf(\"/\", sourceName.indexOf(\"/\") + 1);\n    } else if (sourceName.indexOf(\"/\") === -1) {\n      endIndex = sourceName.length;\n    } else {\n      endIndex = sourceName.indexOf(\"/\");\n    }\n\n    return sourceName.slice(0, endIndex);\n  }\n\n  private _getUriScheme(s: string): string | undefined {\n    const re = /([a-zA-Z]+):\\/\\//;\n    const match = re.exec(s);\n    if (match === null) {\n      return undefined;\n    }\n\n    return match[1];\n  }\n\n  private _isInsideSameDir(sourceNameInDir: string, sourceNameToTest: string) {\n    const firstSlash = sourceNameInDir.indexOf(\"/\");\n    const dir =\n      firstSlash !== -1\n        ? sourceNameInDir.substring(0, firstSlash)\n        : sourceNameInDir;\n\n    return sourceNameToTest.startsWith(dir);\n  }\n\n  private _isScopedPackage(packageOrPackageFile: string): boolean {\n    return packageOrPackageFile.startsWith(\"@\");\n  }\n\n  private _isRelativeImportToLibrary(\n    from: ResolvedFile,\n    imported: string\n  ): boolean {\n    return (\n      this._isRelativeImport(imported) &&\n      from.library === undefined &&\n      imported.includes(`${NODE_MODULES}/`)\n    );\n  }\n\n  private _relativeImportToLibraryToSourceName(\n    from: ResolvedFile,\n    imported: string\n  ): string {\n    const sourceName = normalizeSourceName(\n      path.join(path.dirname(from.sourceName), imported)\n    );\n\n    const nmIndex = sourceName.indexOf(`${NODE_MODULES}/`);\n    return sourceName.substr(nmIndex + NODE_MODULES.length + 1);\n  }\n\n  private async _validateSourceNameExistenceAndCasing(\n    fromDir: string,\n    sourceName: string,\n    isLibrary: boolean\n  ) {\n    try {\n      await validateSourceNameExistenceAndCasing(fromDir, sourceName);\n    } catch (error) {\n      if (\n        HardhatError.isHardhatErrorType(\n          error,\n          ERRORS.SOURCE_NAMES.FILE_NOT_FOUND\n        )\n      ) {\n        throw new HardhatError(\n          isLibrary\n            ? ERRORS.RESOLVER.LIBRARY_FILE_NOT_FOUND\n            : ERRORS.RESOLVER.FILE_NOT_FOUND,\n          { file: sourceName },\n          error\n        );\n      }\n\n      if (\n        HardhatError.isHardhatErrorType(error, ERRORS.SOURCE_NAMES.WRONG_CASING)\n      ) {\n        throw new HardhatError(\n          ERRORS.RESOLVER.WRONG_SOURCE_NAME_CASING,\n          {\n            incorrect: sourceName,\n            correct: error.messageArguments.correct,\n          },\n          error\n        );\n      }\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}