{"ast":null,"code":"/*istanbul ignore start*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.structuredPatch = structuredPatch;\nexports.formatPatch = formatPatch;\nexports.createTwoFilesPatch = createTwoFilesPatch;\nexports.createPatch = createPatch;\n/*istanbul ignore end*/\n\nvar\n/*istanbul ignore start*/\n_line = require(\"../diff/line\")\n/*istanbul ignore end*/\n;\n/*istanbul ignore start*/\n\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n/*istanbul ignore end*/\n\n\nfunction structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (typeof options.context === 'undefined') {\n    options.context = 4;\n  }\n\n  var diff =\n  /*istanbul ignore start*/\n  (0,\n  /*istanbul ignore end*/\n\n  /*istanbul ignore start*/\n  _line\n  /*istanbul ignore end*/\n  .\n  /*istanbul ignore start*/\n  diffLines\n  /*istanbul ignore end*/\n  )(oldStr, newStr, options);\n  diff.push({\n    value: '',\n    lines: []\n  }); // Append an empty value to make cleanup easier\n\n  function contextLines(lines) {\n    return lines.map(function (entry) {\n      return ' ' + entry;\n    });\n  }\n\n  var hunks = [];\n  var oldRangeStart = 0,\n      newRangeStart = 0,\n      curRange = [],\n      oldLine = 1,\n      newLine = 1;\n  /*istanbul ignore start*/\n\n  var _loop = function _loop(\n  /*istanbul ignore end*/\n  i) {\n    var current = diff[i],\n        lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n    current.lines = lines;\n\n    if (current.added || current.removed) {\n      /*istanbul ignore start*/\n      var _curRange;\n      /*istanbul ignore end*/\n      // If we have previous context, start with that\n\n\n      if (!oldRangeStart) {\n        var prev = diff[i - 1];\n        oldRangeStart = oldLine;\n        newRangeStart = newLine;\n\n        if (prev) {\n          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n          oldRangeStart -= curRange.length;\n          newRangeStart -= curRange.length;\n        }\n      } // Output our changes\n\n      /*istanbul ignore start*/\n\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n\n\n      (_curRange =\n      /*istanbul ignore end*/\n      curRange).push.apply(\n      /*istanbul ignore start*/\n      _curRange\n      /*istanbul ignore end*/\n      ,\n      /*istanbul ignore start*/\n      _toConsumableArray(\n      /*istanbul ignore end*/\n      lines.map(function (entry) {\n        return (current.added ? '+' : '-') + entry;\n      }))); // Track the updated file position\n\n\n      if (current.added) {\n        newLine += lines.length;\n      } else {\n        oldLine += lines.length;\n      }\n    } else {\n      // Identical context lines. Track line changes\n      if (oldRangeStart) {\n        // Close out any changes that have been output (or join overlapping)\n        if (lines.length <= options.context * 2 && i < diff.length - 2) {\n          /*istanbul ignore start*/\n          var _curRange2;\n          /*istanbul ignore end*/\n          // Overlapping\n\n          /*istanbul ignore start*/\n\n          /*istanbul ignore end*/\n\n          /*istanbul ignore start*/\n\n\n          (_curRange2 =\n          /*istanbul ignore end*/\n          curRange).push.apply(\n          /*istanbul ignore start*/\n          _curRange2\n          /*istanbul ignore end*/\n          ,\n          /*istanbul ignore start*/\n          _toConsumableArray(\n          /*istanbul ignore end*/\n          contextLines(lines)));\n        } else {\n          /*istanbul ignore start*/\n          var _curRange3;\n          /*istanbul ignore end*/\n          // end the range and output\n\n\n          var contextSize = Math.min(lines.length, options.context);\n          /*istanbul ignore start*/\n\n          /*istanbul ignore end*/\n\n          /*istanbul ignore start*/\n\n          (_curRange3 =\n          /*istanbul ignore end*/\n          curRange).push.apply(\n          /*istanbul ignore start*/\n          _curRange3\n          /*istanbul ignore end*/\n          ,\n          /*istanbul ignore start*/\n          _toConsumableArray(\n          /*istanbul ignore end*/\n          contextLines(lines.slice(0, contextSize))));\n\n          var hunk = {\n            oldStart: oldRangeStart,\n            oldLines: oldLine - oldRangeStart + contextSize,\n            newStart: newRangeStart,\n            newLines: newLine - newRangeStart + contextSize,\n            lines: curRange\n          };\n\n          if (i >= diff.length - 2 && lines.length <= options.context) {\n            // EOF is inside this hunk\n            var oldEOFNewline = /\\n$/.test(oldStr);\n            var newEOFNewline = /\\n$/.test(newStr);\n            var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n\n            if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {\n              // special case: old has no eol and no trailing context; no-nl can end up before adds\n              // however, if the old file is empty, do not output the no-nl line\n              curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n            }\n\n            if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {\n              curRange.push('\\\\ No newline at end of file');\n            }\n          }\n\n          hunks.push(hunk);\n          oldRangeStart = 0;\n          newRangeStart = 0;\n          curRange = [];\n        }\n      }\n\n      oldLine += lines.length;\n      newLine += lines.length;\n    }\n  };\n\n  for (var i = 0; i < diff.length; i++) {\n    /*istanbul ignore start*/\n    _loop(\n    /*istanbul ignore end*/\n    i);\n  }\n\n  return {\n    oldFileName: oldFileName,\n    newFileName: newFileName,\n    oldHeader: oldHeader,\n    newHeader: newHeader,\n    hunks: hunks\n  };\n}\n\nfunction formatPatch(diff) {\n  var ret = [];\n\n  if (diff.oldFileName == diff.newFileName) {\n    ret.push('Index: ' + diff.oldFileName);\n  }\n\n  ret.push('===================================================================');\n  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n  for (var i = 0; i < diff.hunks.length; i++) {\n    var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n    if (hunk.oldLines === 0) {\n      hunk.oldStart -= 1;\n    }\n\n    if (hunk.newLines === 0) {\n      hunk.newStart -= 1;\n    }\n\n    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n    ret.push.apply(ret, hunk.lines);\n  }\n\n  return ret.join('\\n') + '\\n';\n}\n\nfunction createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\n}\n\nfunction createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}","map":{"version":3,"mappings":";;;;;;;;;;;;AAAA;AAAA;AAAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEO,SAASC,eAAT,CAAyBC,WAAzB,EAAsCC,WAAtC,EAAmDC,MAAnD,EAA2DC,MAA3D,EAAmEC,SAAnE,EAA8EC,SAA9E,EAAyFC,OAAzF,EAAkG;EACvG,IAAI,CAACA,OAAL,EAAc;IACZA,OAAO,GAAG,EAAVA;EACD;;EACD,IAAI,OAAOA,OAAO,CAACC,OAAf,KAA2B,WAA/B,EAA4C;IAC1CD,OAAO,CAACC,OAARD,GAAkB,CAAlBA;EACD;;EAED,IAAME,IAAI;EAAG;EAAA;EAAA;;EAAAC;EAAAA;EAAAA;EAAAA;EAAAA;EAAAA;EAAA;EAAA,EAAUP,MAAV,EAAkBC,MAAlB,EAA0BG,OAA1B,CAAb;EACAE,IAAI,CAACE,IAALF,CAAU;IAACG,KAAK,EAAE,EAAR;IAAYC,KAAK,EAAE;EAAnB,CAAVJ,EATuG,CASpE;;EAEnC,SAASK,YAAT,CAAsBD,KAAtB,EAA6B;IAC3B,OAAOA,KAAK,CAACE,GAANF,CAAU,UAASG,KAAT,EAAgB;MAAE,OAAO,MAAMA,KAAb;IAA5B,EAAP;EACD;;EAED,IAAIC,KAAK,GAAG,EAAZ;EACA,IAAIC,aAAa,GAAG,CAApB;EAAA,IAAuBC,aAAa,GAAG,CAAvC;EAAA,IAA0CC,QAAQ,GAAG,EAArD;EAAA,IACIC,OAAO,GAAG,CADd;EAAA,IACiBC,OAAO,GAAG,CAD3B;EAhBuG;;EAAA;EAAA;EAkB9FC,CAlB8F;IAmBrG,IAAMC,OAAO,GAAGf,IAAI,CAACc,CAAD,CAApB;IAAA,IACMV,KAAK,GAAGW,OAAO,CAACX,KAARW,IAAiBA,OAAO,CAACZ,KAARY,CAAcC,OAAdD,CAAsB,KAAtBA,EAA6B,EAA7BA,EAAiCE,KAAjCF,CAAuC,IAAvCA,CAD/B;IAEAA,OAAO,CAACX,KAARW,GAAgBX,KAAhBW;;IAEA,IAAIA,OAAO,CAACG,KAARH,IAAiBA,OAAO,CAACI,OAA7B,EAAsC;MAAA;MAAA;MAAA;MACpC;;;MACA,IAAI,CAACV,aAAL,EAAoB;QAClB,IAAMW,IAAI,GAAGpB,IAAI,CAACc,CAAC,GAAG,CAAL,CAAjB;QACAL,aAAa,GAAGG,OAAhBH;QACAC,aAAa,GAAGG,OAAhBH;;QAEA,IAAIU,IAAJ,EAAU;UACRT,QAAQ,GAAGb,OAAO,CAACC,OAARD,GAAkB,CAAlBA,GAAsBO,YAAY,CAACe,IAAI,CAAChB,KAALgB,CAAWC,KAAXD,CAAiB,CAACtB,OAAO,CAACC,OAA1BqB,CAAD,CAAlCtB,GAAyE,EAApFa;UACAF,aAAa,IAAIE,QAAQ,CAACW,MAA1Bb;UACAC,aAAa,IAAIC,QAAQ,CAACW,MAA1BZ;QACD;MAXiC,EAcpC;;MACA;;MAAA;;MAAA;;;MAAA;MAAA;MAAAC,UAAST,IAAT;MAAA;MAAAqB;MAAA;MAAA;MAAA;MAAAC;MAAA;MAAkBpB,KAAK,CAACE,GAANF,CAAU,UAASG,KAAT,EAAgB;QAC1C,OAAO,CAACQ,OAAO,CAACG,KAARH,GAAgB,GAAhBA,GAAsB,GAAvB,IAA8BR,KAArC;MADgB,EAAlB,GAfoC,CAmBpC;;;MACA,IAAIQ,OAAO,CAACG,KAAZ,EAAmB;QACjBL,OAAO,IAAIT,KAAK,CAACkB,MAAjBT;MADF,OAEO;QACLD,OAAO,IAAIR,KAAK,CAACkB,MAAjBV;MACD;IAxBH,OAyBO;MACL;MACA,IAAIH,aAAJ,EAAmB;QACjB;QACA,IAAIL,KAAK,CAACkB,MAANlB,IAAgBN,OAAO,CAACC,OAARD,GAAkB,CAAlCM,IAAuCU,CAAC,GAAGd,IAAI,CAACsB,MAALtB,GAAc,CAA7D,EAAgE;UAAA;UAAA;UAAA;UAC9D;;UACA;;UAAA;;UAAA;;;UAAA;UAAA;UAAAW,UAAST,IAAT;UAAA;UAAAuB;UAAA;UAAA;UAAA;UAAAD;UAAA;UAAkBnB,YAAY,CAACD,KAAD,CAA9B;QAFF,OAGO;UAAA;UAAA;UAAA;UACL;;;UACA,IAAIsB,WAAW,GAAGC,IAAI,CAACC,GAALD,CAASvB,KAAK,CAACkB,MAAfK,EAAuB7B,OAAO,CAACC,OAA/B4B,CAAlB;UACA;;UAAA;;UAAA;;UAAA;UAAA;UAAAhB,UAAST,IAAT;UAAA;UAAA2B;UAAA;UAAA;UAAA;UAAAL;UAAA;UAAkBnB,YAAY,CAACD,KAAK,CAACiB,KAANjB,CAAY,CAAZA,EAAesB,WAAftB,CAAD,CAA9B;;UAEA,IAAI0B,IAAI,GAAG;YACTC,QAAQ,EAAEtB,aADD;YAETuB,QAAQ,EAAGpB,OAAO,GAAGH,aAAVG,GAA0Bc,WAF5B;YAGTO,QAAQ,EAAEvB,aAHD;YAITwB,QAAQ,EAAGrB,OAAO,GAAGH,aAAVG,GAA0Ba,WAJ5B;YAKTtB,KAAK,EAAEO;UALE,CAAX;;UAOA,IAAIG,CAAC,IAAId,IAAI,CAACsB,MAALtB,GAAc,CAAnBc,IAAwBV,KAAK,CAACkB,MAANlB,IAAgBN,OAAO,CAACC,OAApD,EAA6D;YAC3D;YACA,IAAIoC,aAAa,GAAK,MAAOC,IAAP,CAAY1C,MAAZ,CAAtB;YACA,IAAI2C,aAAa,GAAK,MAAOD,IAAP,CAAYzC,MAAZ,CAAtB;YACA,IAAI2C,cAAc,GAAGlC,KAAK,CAACkB,MAANlB,IAAgB,CAAhBA,IAAqBO,QAAQ,CAACW,MAATX,GAAkBmB,IAAI,CAACE,QAAjE;;YACA,IAAI,CAACG,aAAD,IAAkBG,cAAlB,IAAoC5C,MAAM,CAAC4B,MAAP5B,GAAgB,CAAxD,EAA2D;cACzD;cACA;cACAiB,QAAQ,CAAC4B,MAAT5B,CAAgBmB,IAAI,CAACE,QAArBrB,EAA+B,CAA/BA,EAAkC,8BAAlCA;YACD;;YACD,IAAK,CAACwB,aAAD,IAAkB,CAACG,cAAnB,IAAsC,CAACD,aAA5C,EAA2D;cACzD1B,QAAQ,CAACT,IAATS,CAAc,8BAAdA;YACD;UACF;;UACDH,KAAK,CAACN,IAANM,CAAWsB,IAAXtB;UAEAC,aAAa,GAAG,CAAhBA;UACAC,aAAa,GAAG,CAAhBA;UACAC,QAAQ,GAAG,EAAXA;QACD;MACF;;MACDC,OAAO,IAAIR,KAAK,CAACkB,MAAjBV;MACAC,OAAO,IAAIT,KAAK,CAACkB,MAAjBT;IACD;EA1FoG;;EAkBvG,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGd,IAAI,CAACsB,MAAzB,EAAiCR,CAAC,EAAlC,EAAsC;IAAA;IAAA0B;IAAA;IAA7B1B,CAA6B;EAyErC;;EAED,OAAO;IACLtB,WAAW,EAAEA,WADR;IACqBC,WAAW,EAAEA,WADlC;IAELG,SAAS,EAAEA,SAFN;IAEiBC,SAAS,EAAEA,SAF5B;IAGLW,KAAK,EAAEA;EAHF,CAAP;AAKD;;AAEM,SAASiC,WAAT,CAAqBzC,IAArB,EAA2B;EAChC,IAAM0C,GAAG,GAAG,EAAZ;;EACA,IAAI1C,IAAI,CAACR,WAALQ,IAAoBA,IAAI,CAACP,WAA7B,EAA0C;IACxCiD,GAAG,CAACxC,IAAJwC,CAAS,YAAY1C,IAAI,CAACR,WAA1BkD;EACD;;EACDA,GAAG,CAACxC,IAAJwC,CAAS,qEAATA;EACAA,GAAG,CAACxC,IAAJwC,CAAS,SAAS1C,IAAI,CAACR,WAAd,IAA6B,OAAOQ,IAAI,CAACJ,SAAZ,KAA0B,WAA1B,GAAwC,EAAxC,GAA6C,OAAOI,IAAI,CAACJ,SAAtF,CAAT8C;EACAA,GAAG,CAACxC,IAAJwC,CAAS,SAAS1C,IAAI,CAACP,WAAd,IAA6B,OAAOO,IAAI,CAACH,SAAZ,KAA0B,WAA1B,GAAwC,EAAxC,GAA6C,OAAOG,IAAI,CAACH,SAAtF,CAAT6C;;EAEA,KAAK,IAAI5B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGd,IAAI,CAACQ,KAALR,CAAWsB,MAA/B,EAAuCR,CAAC,EAAxC,EAA4C;IAC1C,IAAMgB,IAAI,GAAG9B,IAAI,CAACQ,KAALR,CAAWc,CAAXd,CAAb,CAD0C,CAE1C;IACA;IACA;;IACA,IAAI8B,IAAI,CAACE,QAALF,KAAkB,CAAtB,EAAyB;MACvBA,IAAI,CAACC,QAALD,IAAiB,CAAjBA;IACD;;IACD,IAAIA,IAAI,CAACI,QAALJ,KAAkB,CAAtB,EAAyB;MACvBA,IAAI,CAACG,QAALH,IAAiB,CAAjBA;IACD;;IACDY,GAAG,CAACxC,IAAJwC,CACE,SAASZ,IAAI,CAACC,QAAd,GAAyB,GAAzB,GAA+BD,IAAI,CAACE,QAApC,GACE,IADF,GACSF,IAAI,CAACG,QADd,GACyB,GADzB,GAC+BH,IAAI,CAACI,QADpC,GAEE,KAHJQ;IAKAA,GAAG,CAACxC,IAAJwC,CAASC,KAATD,CAAeA,GAAfA,EAAoBZ,IAAI,CAAC1B,KAAzBsC;EACD;;EAED,OAAOA,GAAG,CAACE,IAAJF,CAAS,IAATA,IAAiB,IAAxB;AACD;;AAEM,SAASG,mBAAT,CAA6BrD,WAA7B,EAA0CC,WAA1C,EAAuDC,MAAvD,EAA+DC,MAA/D,EAAuEC,SAAvE,EAAkFC,SAAlF,EAA6FC,OAA7F,EAAsG;EAC3G,OAAO2C,WAAW,CAAClD,eAAe,CAACC,WAAD,EAAcC,WAAd,EAA2BC,MAA3B,EAAmCC,MAAnC,EAA2CC,SAA3C,EAAsDC,SAAtD,EAAiEC,OAAjE,CAAhB,CAAlB;AACD;;AAEM,SAASgD,WAAT,CAAqBC,QAArB,EAA+BrD,MAA/B,EAAuCC,MAAvC,EAA+CC,SAA/C,EAA0DC,SAA1D,EAAqEC,OAArE,EAA8E;EACnF,OAAO+C,mBAAmB,CAACE,QAAD,EAAWA,QAAX,EAAqBrD,MAArB,EAA6BC,MAA7B,EAAqCC,SAArC,EAAgDC,SAAhD,EAA2DC,OAA3D,CAA1B;AACD","names":["_line","structuredPatch","oldFileName","newFileName","oldStr","newStr","oldHeader","newHeader","options","context","diff","diffLines","push","value","lines","contextLines","map","entry","hunks","oldRangeStart","newRangeStart","curRange","oldLine","newLine","i","current","replace","split","added","removed","prev","slice","length","_curRange","_toConsumableArray","_curRange2","contextSize","Math","min","_curRange3","hunk","oldStart","oldLines","newStart","newLines","oldEOFNewline","test","newEOFNewline","noNlBeforeAdds","splice","_loop","formatPatch","ret","apply","join","createTwoFilesPatch","createPatch","fileName"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\diff\\src\\patch\\create.js"],"sourcesContent":["import {diffLines} from '../diff/line';\n\nexport function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  if (!options) {\n    options = {};\n  }\n  if (typeof options.context === 'undefined') {\n    options.context = 4;\n  }\n\n  const diff = diffLines(oldStr, newStr, options);\n  diff.push({value: '', lines: []}); // Append an empty value to make cleanup easier\n\n  function contextLines(lines) {\n    return lines.map(function(entry) { return ' ' + entry; });\n  }\n\n  let hunks = [];\n  let oldRangeStart = 0, newRangeStart = 0, curRange = [],\n      oldLine = 1, newLine = 1;\n  for (let i = 0; i < diff.length; i++) {\n    const current = diff[i],\n          lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n    current.lines = lines;\n\n    if (current.added || current.removed) {\n      // If we have previous context, start with that\n      if (!oldRangeStart) {\n        const prev = diff[i - 1];\n        oldRangeStart = oldLine;\n        newRangeStart = newLine;\n\n        if (prev) {\n          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n          oldRangeStart -= curRange.length;\n          newRangeStart -= curRange.length;\n        }\n      }\n\n      // Output our changes\n      curRange.push(... lines.map(function(entry) {\n        return (current.added ? '+' : '-') + entry;\n      }));\n\n      // Track the updated file position\n      if (current.added) {\n        newLine += lines.length;\n      } else {\n        oldLine += lines.length;\n      }\n    } else {\n      // Identical context lines. Track line changes\n      if (oldRangeStart) {\n        // Close out any changes that have been output (or join overlapping)\n        if (lines.length <= options.context * 2 && i < diff.length - 2) {\n          // Overlapping\n          curRange.push(... contextLines(lines));\n        } else {\n          // end the range and output\n          let contextSize = Math.min(lines.length, options.context);\n          curRange.push(... contextLines(lines.slice(0, contextSize)));\n\n          let hunk = {\n            oldStart: oldRangeStart,\n            oldLines: (oldLine - oldRangeStart + contextSize),\n            newStart: newRangeStart,\n            newLines: (newLine - newRangeStart + contextSize),\n            lines: curRange\n          };\n          if (i >= diff.length - 2 && lines.length <= options.context) {\n            // EOF is inside this hunk\n            let oldEOFNewline = ((/\\n$/).test(oldStr));\n            let newEOFNewline = ((/\\n$/).test(newStr));\n            let noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n            if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {\n              // special case: old has no eol and no trailing context; no-nl can end up before adds\n              // however, if the old file is empty, do not output the no-nl line\n              curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n            }\n            if ((!oldEOFNewline && !noNlBeforeAdds) || !newEOFNewline) {\n              curRange.push('\\\\ No newline at end of file');\n            }\n          }\n          hunks.push(hunk);\n\n          oldRangeStart = 0;\n          newRangeStart = 0;\n          curRange = [];\n        }\n      }\n      oldLine += lines.length;\n      newLine += lines.length;\n    }\n  }\n\n  return {\n    oldFileName: oldFileName, newFileName: newFileName,\n    oldHeader: oldHeader, newHeader: newHeader,\n    hunks: hunks\n  };\n}\n\nexport function formatPatch(diff) {\n  const ret = [];\n  if (diff.oldFileName == diff.newFileName) {\n    ret.push('Index: ' + diff.oldFileName);\n  }\n  ret.push('===================================================================');\n  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n  for (let i = 0; i < diff.hunks.length; i++) {\n    const hunk = diff.hunks[i];\n    // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n    if (hunk.oldLines === 0) {\n      hunk.oldStart -= 1;\n    }\n    if (hunk.newLines === 0) {\n      hunk.newStart -= 1;\n    }\n    ret.push(\n      '@@ -' + hunk.oldStart + ',' + hunk.oldLines\n      + ' +' + hunk.newStart + ',' + hunk.newLines\n      + ' @@'\n    );\n    ret.push.apply(ret, hunk.lines);\n  }\n\n  return ret.join('\\n') + '\\n';\n}\n\nexport function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\n}\n\nexport function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}\n"]},"metadata":{},"sourceType":"script"}