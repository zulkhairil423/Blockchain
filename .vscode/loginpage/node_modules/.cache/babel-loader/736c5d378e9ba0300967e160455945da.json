{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArgumentsParser = void 0;\n\nconst errors_1 = require(\"../core/errors\");\n\nconst errors_list_1 = require(\"../core/errors-list\");\n\nclass ArgumentsParser {\n  static paramNameToCLA(paramName) {\n    return ArgumentsParser.PARAM_PREFIX + paramName.split(/(?=[A-Z])/g).map(s => s.toLowerCase()).join(\"-\");\n  }\n\n  static cLAToParamName(cLA) {\n    if (cLA.toLowerCase() !== cLA) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.PARAM_NAME_INVALID_CASING, {\n        param: cLA\n      });\n    }\n\n    const parts = cLA.slice(ArgumentsParser.PARAM_PREFIX.length).split(\"-\").filter(x => x.length > 0);\n    return parts[0] + parts.slice(1).map(s => s[0].toUpperCase() + s.slice(1)).join(\"\");\n  }\n\n  parseHardhatArguments(hardhatParamDefinitions, envVariableArguments, rawCLAs) {\n    const hardhatArguments = {};\n    let taskName;\n    const unparsedCLAs = [];\n\n    for (let i = 0; i < rawCLAs.length; i++) {\n      const arg = rawCLAs[i];\n\n      if (taskName === undefined) {\n        if (!this._hasCLAParamNameFormat(arg)) {\n          taskName = arg;\n          continue;\n        }\n\n        if (!this._isCLAParamName(arg, hardhatParamDefinitions)) {\n          throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_COMMAND_LINE_ARG, {\n            argument: arg\n          });\n        }\n\n        i = this._parseArgumentAt(rawCLAs, i, hardhatParamDefinitions, hardhatArguments, taskName);\n      } else {\n        if (!this._isCLAParamName(arg, hardhatParamDefinitions)) {\n          unparsedCLAs.push(arg);\n          continue;\n        }\n\n        i = this._parseArgumentAt(rawCLAs, i, hardhatParamDefinitions, hardhatArguments, taskName);\n      }\n    }\n\n    return {\n      hardhatArguments: this._addHardhatDefaultArguments(hardhatParamDefinitions, envVariableArguments, hardhatArguments),\n      taskName,\n      unparsedCLAs\n    };\n  }\n\n  parseTaskArguments(taskDefinition, rawCLAs) {\n    const {\n      paramArguments,\n      rawPositionalArguments\n    } = this._parseTaskParamArguments(taskDefinition, rawCLAs);\n\n    const positionalArguments = this._parsePositionalParamArgs(rawPositionalArguments, taskDefinition.positionalParamDefinitions);\n\n    return { ...paramArguments,\n      ...positionalArguments\n    };\n  }\n\n  _parseTaskParamArguments(taskDefinition, rawCLAs) {\n    const paramArguments = {};\n    const rawPositionalArguments = [];\n\n    for (let i = 0; i < rawCLAs.length; i++) {\n      const arg = rawCLAs[i];\n\n      if (!this._hasCLAParamNameFormat(arg)) {\n        rawPositionalArguments.push(arg);\n        continue;\n      }\n\n      if (!this._isCLAParamName(arg, taskDefinition.paramDefinitions)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_PARAM_NAME, {\n          param: arg\n        });\n      }\n\n      i = this._parseArgumentAt(rawCLAs, i, taskDefinition.paramDefinitions, paramArguments, taskDefinition.name);\n    }\n\n    this._addTaskDefaultArguments(taskDefinition, paramArguments);\n\n    return {\n      paramArguments,\n      rawPositionalArguments\n    };\n  }\n\n  _addHardhatDefaultArguments(hardhatParamDefinitions, envVariableArguments, hardhatArguments) {\n    return { ...envVariableArguments,\n      ...hardhatArguments\n    };\n  }\n\n  _addTaskDefaultArguments(taskDefinition, taskArguments) {\n    for (const paramName of Object.keys(taskDefinition.paramDefinitions)) {\n      const definition = taskDefinition.paramDefinitions[paramName];\n\n      if (taskArguments[paramName] !== undefined) {\n        continue;\n      }\n\n      if (!definition.isOptional) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n          param: ArgumentsParser.paramNameToCLA(paramName),\n          task: taskDefinition.name\n        });\n      }\n\n      taskArguments[paramName] = definition.defaultValue;\n    }\n  }\n\n  _isCLAParamName(str, paramDefinitions) {\n    if (!this._hasCLAParamNameFormat(str)) {\n      return false;\n    }\n\n    const name = ArgumentsParser.cLAToParamName(str);\n    return paramDefinitions[name] !== undefined;\n  }\n\n  _hasCLAParamNameFormat(str) {\n    return str.startsWith(ArgumentsParser.PARAM_PREFIX);\n  }\n\n  _parseArgumentAt(rawCLAs, index, paramDefinitions, parsedArguments, taskName) {\n    const claArg = rawCLAs[index];\n    const paramName = ArgumentsParser.cLAToParamName(claArg);\n    const definition = paramDefinitions[paramName];\n\n    if (parsedArguments[paramName] !== undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.REPEATED_PARAM, {\n        param: claArg\n      });\n    }\n\n    if (definition.isFlag) {\n      parsedArguments[paramName] = true;\n    } else {\n      index++;\n      const value = rawCLAs[index];\n\n      if (value === undefined) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n          param: ArgumentsParser.paramNameToCLA(paramName),\n          task: taskName ?? \"help\"\n        });\n      } // We only parse the arguments of non-subtasks, and those only\n      // accept CLIArgumentTypes.\n\n\n      const type = definition.type;\n      parsedArguments[paramName] = type.parse(paramName, value);\n    }\n\n    return index;\n  }\n\n  _parsePositionalParamArgs(rawPositionalParamArgs, positionalParamDefinitions) {\n    const args = {};\n\n    for (let i = 0; i < positionalParamDefinitions.length; i++) {\n      const definition = positionalParamDefinitions[i]; // We only parse the arguments of non-subtasks, and those only\n      // accept CLIArgumentTypes.\n\n      const type = definition.type;\n      const rawArg = rawPositionalParamArgs[i];\n\n      if (rawArg === undefined) {\n        if (!definition.isOptional) {\n          throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.MISSING_POSITIONAL_ARG, {\n            param: definition.name\n          });\n        }\n\n        args[definition.name] = definition.defaultValue;\n      } else if (!definition.isVariadic) {\n        args[definition.name] = type.parse(definition.name, rawArg);\n      } else {\n        args[definition.name] = rawPositionalParamArgs.slice(i).map(raw => type.parse(definition.name, raw));\n      }\n    }\n\n    const lastDefinition = positionalParamDefinitions[positionalParamDefinitions.length - 1];\n    const hasVariadicParam = lastDefinition !== undefined && lastDefinition.isVariadic;\n\n    if (!hasVariadicParam && rawPositionalParamArgs.length > positionalParamDefinitions.length) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_POSITIONAL_ARG, {\n        argument: rawPositionalParamArgs[positionalParamDefinitions.length]\n      });\n    }\n\n    return args;\n  }\n\n}\n\nexports.ArgumentsParser = ArgumentsParser;\nArgumentsParser.PARAM_PREFIX = \"--\";","map":{"version":3,"mappings":"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","names":["ArgumentsParser","paramNameToCLA","paramName","PARAM_PREFIX","split","map","s","toLowerCase","join","cLAToParamName","cLA","errors_1","errors_list_1","ARGUMENTS","PARAM_NAME_INVALID_CASING","param","parts","slice","length","filter","x","toUpperCase","parseHardhatArguments","hardhatParamDefinitions","envVariableArguments","rawCLAs","hardhatArguments","taskName","unparsedCLAs","i","arg","undefined","_hasCLAParamNameFormat","_isCLAParamName","UNRECOGNIZED_COMMAND_LINE_ARG","argument","_parseArgumentAt","push","_addHardhatDefaultArguments","parseTaskArguments","taskDefinition","paramArguments","rawPositionalArguments","_parseTaskParamArguments","positionalArguments","_parsePositionalParamArgs","positionalParamDefinitions","paramDefinitions","UNRECOGNIZED_PARAM_NAME","name","_addTaskDefaultArguments","taskArguments","Object","keys","definition","isOptional","MISSING_TASK_ARGUMENT","task","defaultValue","str","startsWith","index","parsedArguments","claArg","REPEATED_PARAM","isFlag","value","type","parse","rawPositionalParamArgs","args","rawArg","MISSING_POSITIONAL_ARG","isVariadic","raw","lastDefinition","hasVariadicParam","UNRECOGNIZED_POSITIONAL_ARG","exports"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\hardhat\\src\\internal\\cli\\ArgumentsParser.ts"],"sourcesContent":["import {\n  CLIArgumentType,\n  HardhatArguments,\n  HardhatParamDefinitions,\n  ParamDefinition,\n  ParamDefinitionsMap,\n  TaskArguments,\n  TaskDefinition,\n} from \"../../types\";\nimport { HardhatError } from \"../core/errors\";\nimport { ERRORS } from \"../core/errors-list\";\n\nexport class ArgumentsParser {\n  public static readonly PARAM_PREFIX = \"--\";\n\n  public static paramNameToCLA(paramName: string): string {\n    return (\n      ArgumentsParser.PARAM_PREFIX +\n      paramName\n        .split(/(?=[A-Z])/g)\n        .map((s) => s.toLowerCase())\n        .join(\"-\")\n    );\n  }\n\n  public static cLAToParamName(cLA: string): string {\n    if (cLA.toLowerCase() !== cLA) {\n      throw new HardhatError(ERRORS.ARGUMENTS.PARAM_NAME_INVALID_CASING, {\n        param: cLA,\n      });\n    }\n\n    const parts = cLA\n      .slice(ArgumentsParser.PARAM_PREFIX.length)\n      .split(\"-\")\n      .filter((x) => x.length > 0);\n\n    return (\n      parts[0] +\n      parts\n        .slice(1)\n        .map((s) => s[0].toUpperCase() + s.slice(1))\n        .join(\"\")\n    );\n  }\n\n  public parseHardhatArguments(\n    hardhatParamDefinitions: HardhatParamDefinitions,\n    envVariableArguments: HardhatArguments,\n    rawCLAs: string[]\n  ): {\n    hardhatArguments: HardhatArguments;\n    taskName?: string;\n    unparsedCLAs: string[];\n  } {\n    const hardhatArguments: Partial<HardhatArguments> = {};\n    let taskName: string | undefined;\n    const unparsedCLAs: string[] = [];\n\n    for (let i = 0; i < rawCLAs.length; i++) {\n      const arg = rawCLAs[i];\n\n      if (taskName === undefined) {\n        if (!this._hasCLAParamNameFormat(arg)) {\n          taskName = arg;\n          continue;\n        }\n\n        if (!this._isCLAParamName(arg, hardhatParamDefinitions)) {\n          throw new HardhatError(\n            ERRORS.ARGUMENTS.UNRECOGNIZED_COMMAND_LINE_ARG,\n            { argument: arg }\n          );\n        }\n\n        i = this._parseArgumentAt(\n          rawCLAs,\n          i,\n          hardhatParamDefinitions,\n          hardhatArguments,\n          taskName\n        );\n      } else {\n        if (!this._isCLAParamName(arg, hardhatParamDefinitions)) {\n          unparsedCLAs.push(arg);\n          continue;\n        }\n\n        i = this._parseArgumentAt(\n          rawCLAs,\n          i,\n          hardhatParamDefinitions,\n          hardhatArguments,\n          taskName\n        );\n      }\n    }\n\n    return {\n      hardhatArguments: this._addHardhatDefaultArguments(\n        hardhatParamDefinitions,\n        envVariableArguments,\n        hardhatArguments\n      ),\n      taskName,\n      unparsedCLAs,\n    };\n  }\n\n  public parseTaskArguments(\n    taskDefinition: TaskDefinition,\n    rawCLAs: string[]\n  ): TaskArguments {\n    const { paramArguments, rawPositionalArguments } =\n      this._parseTaskParamArguments(taskDefinition, rawCLAs);\n\n    const positionalArguments = this._parsePositionalParamArgs(\n      rawPositionalArguments,\n      taskDefinition.positionalParamDefinitions\n    );\n\n    return { ...paramArguments, ...positionalArguments };\n  }\n\n  private _parseTaskParamArguments(\n    taskDefinition: TaskDefinition,\n    rawCLAs: string[]\n  ) {\n    const paramArguments = {};\n    const rawPositionalArguments: string[] = [];\n\n    for (let i = 0; i < rawCLAs.length; i++) {\n      const arg = rawCLAs[i];\n\n      if (!this._hasCLAParamNameFormat(arg)) {\n        rawPositionalArguments.push(arg);\n        continue;\n      }\n\n      if (!this._isCLAParamName(arg, taskDefinition.paramDefinitions)) {\n        throw new HardhatError(ERRORS.ARGUMENTS.UNRECOGNIZED_PARAM_NAME, {\n          param: arg,\n        });\n      }\n\n      i = this._parseArgumentAt(\n        rawCLAs,\n        i,\n        taskDefinition.paramDefinitions,\n        paramArguments,\n        taskDefinition.name\n      );\n    }\n\n    this._addTaskDefaultArguments(taskDefinition, paramArguments);\n\n    return { paramArguments, rawPositionalArguments };\n  }\n\n  private _addHardhatDefaultArguments(\n    hardhatParamDefinitions: HardhatParamDefinitions,\n    envVariableArguments: HardhatArguments,\n    hardhatArguments: Partial<HardhatArguments>\n  ): HardhatArguments {\n    return {\n      ...envVariableArguments,\n      ...hardhatArguments,\n    };\n  }\n\n  private _addTaskDefaultArguments(\n    taskDefinition: TaskDefinition,\n    taskArguments: TaskArguments\n  ) {\n    for (const paramName of Object.keys(taskDefinition.paramDefinitions)) {\n      const definition = taskDefinition.paramDefinitions[paramName];\n\n      if (taskArguments[paramName] !== undefined) {\n        continue;\n      }\n      if (!definition.isOptional) {\n        throw new HardhatError(ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n          param: ArgumentsParser.paramNameToCLA(paramName),\n          task: taskDefinition.name,\n        });\n      }\n\n      taskArguments[paramName] = definition.defaultValue;\n    }\n  }\n\n  private _isCLAParamName(str: string, paramDefinitions: ParamDefinitionsMap) {\n    if (!this._hasCLAParamNameFormat(str)) {\n      return false;\n    }\n\n    const name = ArgumentsParser.cLAToParamName(str);\n    return paramDefinitions[name] !== undefined;\n  }\n\n  private _hasCLAParamNameFormat(str: string) {\n    return str.startsWith(ArgumentsParser.PARAM_PREFIX);\n  }\n\n  private _parseArgumentAt(\n    rawCLAs: string[],\n    index: number,\n    paramDefinitions: ParamDefinitionsMap,\n    parsedArguments: TaskArguments,\n    taskName?: string\n  ) {\n    const claArg = rawCLAs[index];\n    const paramName = ArgumentsParser.cLAToParamName(claArg);\n    const definition = paramDefinitions[paramName];\n\n    if (parsedArguments[paramName] !== undefined) {\n      throw new HardhatError(ERRORS.ARGUMENTS.REPEATED_PARAM, {\n        param: claArg,\n      });\n    }\n\n    if (definition.isFlag) {\n      parsedArguments[paramName] = true;\n    } else {\n      index++;\n      const value = rawCLAs[index];\n\n      if (value === undefined) {\n        throw new HardhatError(ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n          param: ArgumentsParser.paramNameToCLA(paramName),\n          task: taskName ?? \"help\",\n        });\n      }\n\n      // We only parse the arguments of non-subtasks, and those only\n      // accept CLIArgumentTypes.\n      const type = definition.type as CLIArgumentType<any>;\n      parsedArguments[paramName] = type.parse(paramName, value);\n    }\n\n    return index;\n  }\n\n  private _parsePositionalParamArgs(\n    rawPositionalParamArgs: string[],\n    positionalParamDefinitions: Array<ParamDefinition<any>>\n  ): TaskArguments {\n    const args: TaskArguments = {};\n\n    for (let i = 0; i < positionalParamDefinitions.length; i++) {\n      const definition = positionalParamDefinitions[i];\n      // We only parse the arguments of non-subtasks, and those only\n      // accept CLIArgumentTypes.\n      const type = definition.type as CLIArgumentType<any>;\n\n      const rawArg = rawPositionalParamArgs[i];\n\n      if (rawArg === undefined) {\n        if (!definition.isOptional) {\n          throw new HardhatError(ERRORS.ARGUMENTS.MISSING_POSITIONAL_ARG, {\n            param: definition.name,\n          });\n        }\n\n        args[definition.name] = definition.defaultValue;\n      } else if (!definition.isVariadic) {\n        args[definition.name] = type.parse(definition.name, rawArg);\n      } else {\n        args[definition.name] = rawPositionalParamArgs\n          .slice(i)\n          .map((raw) => type.parse(definition.name, raw));\n      }\n    }\n\n    const lastDefinition =\n      positionalParamDefinitions[positionalParamDefinitions.length - 1];\n\n    const hasVariadicParam =\n      lastDefinition !== undefined && lastDefinition.isVariadic;\n\n    if (\n      !hasVariadicParam &&\n      rawPositionalParamArgs.length > positionalParamDefinitions.length\n    ) {\n      throw new HardhatError(ERRORS.ARGUMENTS.UNRECOGNIZED_POSITIONAL_ARG, {\n        argument: rawPositionalParamArgs[positionalParamDefinitions.length],\n      });\n    }\n\n    return args;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}