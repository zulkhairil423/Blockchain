{"ast":null,"code":"var ZipEntry = require(\"./zipEntry\"),\n    Headers = require(\"./headers\"),\n    Utils = require(\"./util\");\n\nmodule.exports = function (\n/*String|Buffer*/\ninput,\n/*Number*/\ninputType) {\n  var entryList = [],\n      entryTable = {},\n      _comment = Buffer.alloc(0),\n      filename = \"\",\n      fs = Utils.FileSystem.require(),\n      inBuffer = null,\n      mainHeader = new Headers.MainHeader(),\n      loadedEntries = false;\n\n  if (inputType === Utils.Constants.FILE) {\n    // is a filename\n    filename = input;\n    inBuffer = fs.readFileSync(filename);\n    readMainHeader();\n  } else if (inputType === Utils.Constants.BUFFER) {\n    // is a memory buffer\n    inBuffer = input;\n    readMainHeader();\n  } else {\n    // none. is a new file\n    loadedEntries = true;\n  }\n\n  function iterateEntries(callback) {\n    const totalEntries = mainHeader.diskEntries; // total number of entries\n\n    let index = mainHeader.offset; // offset of first CEN header\n\n    for (let i = 0; i < totalEntries; i++) {\n      let tmp = index;\n      const entry = new ZipEntry(inBuffer);\n      entry.header = inBuffer.slice(tmp, tmp += Utils.Constants.CENHDR);\n      entry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);\n      index += entry.header.entryHeaderSize;\n      callback(entry);\n    }\n  }\n\n  function readEntries() {\n    loadedEntries = true;\n    entryTable = {};\n    entryList = new Array(mainHeader.diskEntries); // total number of entries\n\n    var index = mainHeader.offset; // offset of first CEN header\n\n    for (var i = 0; i < entryList.length; i++) {\n      var tmp = index,\n          entry = new ZipEntry(inBuffer);\n      entry.header = inBuffer.slice(tmp, tmp += Utils.Constants.CENHDR);\n      entry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);\n\n      if (entry.header.extraLength) {\n        entry.extra = inBuffer.slice(tmp, tmp += entry.header.extraLength);\n      }\n\n      if (entry.header.commentLength) entry.comment = inBuffer.slice(tmp, tmp + entry.header.commentLength);\n      index += entry.header.entryHeaderSize;\n      entryList[i] = entry;\n      entryTable[entry.entryName] = entry;\n    }\n  }\n\n  function readMainHeader() {\n    var i = inBuffer.length - Utils.Constants.ENDHDR,\n        // END header size\n    max = Math.max(0, i - 0xFFFF),\n        // 0xFFFF is the max zip file comment length\n    n = max,\n        endStart = inBuffer.length,\n        endOffset = -1,\n        // Start offset of the END header\n    commentEnd = 0;\n\n    for (i; i >= n; i--) {\n      if (inBuffer[i] !== 0x50) continue; // quick check that the byte is 'P'\n\n      if (inBuffer.readUInt32LE(i) === Utils.Constants.ENDSIG) {\n        // \"PK\\005\\006\"\n        endOffset = i;\n        commentEnd = i;\n        endStart = i + Utils.Constants.ENDHDR; // We already found a regular signature, let's look just a bit further to check if there's any zip64 signature\n\n        n = i - Utils.Constants.END64HDR;\n        continue;\n      }\n\n      if (inBuffer.readUInt32LE(i) === Utils.Constants.END64SIG) {\n        // Found a zip64 signature, let's continue reading the whole zip64 record\n        n = max;\n        continue;\n      }\n\n      if (inBuffer.readUInt32LE(i) == Utils.Constants.ZIP64SIG) {\n        // Found the zip64 record, let's determine it's size\n        endOffset = i;\n        endStart = i + Utils.readBigUInt64LE(inBuffer, i + Utils.Constants.ZIP64SIZE) + Utils.Constants.ZIP64LEAD;\n        break;\n      }\n    }\n\n    if (!~endOffset) throw new Error(Utils.Errors.INVALID_FORMAT);\n    mainHeader.loadFromBinary(inBuffer.slice(endOffset, endStart));\n\n    if (mainHeader.commentLength) {\n      _comment = inBuffer.slice(commentEnd + Utils.Constants.ENDHDR);\n    } // readEntries();\n\n  }\n\n  return {\n    /**\r\n     * Returns an array of ZipEntry objects existent in the current opened archive\r\n     * @return Array\r\n     */\n    get entries() {\n      if (!loadedEntries) {\n        readEntries();\n      }\n\n      return entryList;\n    },\n\n    /**\r\n     * Archive comment\r\n     * @return {String}\r\n     */\n    get comment() {\n      return _comment.toString();\n    },\n\n    set comment(val) {\n      mainHeader.commentLength = val.length;\n      _comment = val;\n    },\n\n    getEntryCount: function () {\n      if (!loadedEntries) {\n        return mainHeader.diskEntries;\n      }\n\n      return entryList.length;\n    },\n    forEach: function (callback) {\n      if (!loadedEntries) {\n        iterateEntries(callback);\n        return;\n      }\n\n      entryList.forEach(callback);\n    },\n\n    /**\r\n     * Returns a reference to the entry with the given name or null if entry is inexistent\r\n     *\r\n     * @param entryName\r\n     * @return ZipEntry\r\n     */\n    getEntry: function (\n    /*String*/\n    entryName) {\n      if (!loadedEntries) {\n        readEntries();\n      }\n\n      return entryTable[entryName] || null;\n    },\n\n    /**\r\n     * Adds the given entry to the entry list\r\n     *\r\n     * @param entry\r\n     */\n    setEntry: function (\n    /*ZipEntry*/\n    entry) {\n      if (!loadedEntries) {\n        readEntries();\n      }\n\n      entryList.push(entry);\n      entryTable[entry.entryName] = entry;\n      mainHeader.totalEntries = entryList.length;\n    },\n\n    /**\r\n     * Removes the entry with the given name from the entry list.\r\n     *\r\n     * If the entry is a directory, then all nested files and directories will be removed\r\n     * @param entryName\r\n     */\n    deleteEntry: function (\n    /*String*/\n    entryName) {\n      if (!loadedEntries) {\n        readEntries();\n      }\n\n      var entry = entryTable[entryName];\n\n      if (entry && entry.isDirectory) {\n        var _self = this;\n\n        this.getEntryChildren(entry).forEach(function (child) {\n          if (child.entryName !== entryName) {\n            _self.deleteEntry(child.entryName);\n          }\n        });\n      }\n\n      entryList.splice(entryList.indexOf(entry), 1);\n      delete entryTable[entryName];\n      mainHeader.totalEntries = entryList.length;\n    },\n\n    /**\r\n     *  Iterates and returns all nested files and directories of the given entry\r\n     *\r\n     * @param entry\r\n     * @return Array\r\n     */\n    getEntryChildren: function (\n    /*ZipEntry*/\n    entry) {\n      if (!loadedEntries) {\n        readEntries();\n      }\n\n      if (entry.isDirectory) {\n        var list = [],\n            name = entry.entryName,\n            len = name.length;\n        entryList.forEach(function (zipEntry) {\n          if (zipEntry.entryName.substr(0, len) === name) {\n            list.push(zipEntry);\n          }\n        });\n        return list;\n      }\n\n      return [];\n    },\n\n    /**\r\n     * Returns the zip file\r\n     *\r\n     * @return Buffer\r\n     */\n    compressToBuffer: function () {\n      if (!loadedEntries) {\n        readEntries();\n      }\n\n      if (entryList.length > 1) {\n        entryList.sort(function (a, b) {\n          var nameA = a.entryName.toLowerCase();\n          var nameB = b.entryName.toLowerCase();\n\n          if (nameA < nameB) {\n            return -1;\n          }\n\n          if (nameA > nameB) {\n            return 1;\n          }\n\n          return 0;\n        });\n      }\n\n      var totalSize = 0,\n          dataBlock = [],\n          entryHeaders = [],\n          dindex = 0;\n      mainHeader.size = 0;\n      mainHeader.offset = 0;\n      entryList.forEach(function (entry) {\n        // compress data and set local and entry header accordingly. Reason why is called first\n        var compressedData = entry.getCompressedData(); // data header\n\n        entry.header.offset = dindex;\n        var dataHeader = entry.header.dataHeaderToBinary();\n        var entryNameLen = entry.rawEntryName.length;\n        var extra = entry.extra.toString();\n        var postHeader = Buffer.alloc(entryNameLen + extra.length);\n        entry.rawEntryName.copy(postHeader, 0);\n        postHeader.fill(extra, entryNameLen);\n        var dataLength = dataHeader.length + postHeader.length + compressedData.length;\n        dindex += dataLength;\n        dataBlock.push(dataHeader);\n        dataBlock.push(postHeader);\n        dataBlock.push(compressedData);\n        var entryHeader = entry.packHeader();\n        entryHeaders.push(entryHeader);\n        mainHeader.size += entryHeader.length;\n        totalSize += dataLength + entryHeader.length;\n      });\n      totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\n      // point to end of data and beginning of central directory first record\n\n      mainHeader.offset = dindex;\n      dindex = 0;\n      var outBuffer = Buffer.alloc(totalSize);\n      dataBlock.forEach(function (content) {\n        content.copy(outBuffer, dindex); // write data blocks\n\n        dindex += content.length;\n      });\n      entryHeaders.forEach(function (content) {\n        content.copy(outBuffer, dindex); // write central directory entries\n\n        dindex += content.length;\n      });\n      var mh = mainHeader.toBinary();\n\n      if (_comment) {\n        Buffer.from(_comment).copy(mh, Utils.Constants.ENDHDR); // add zip file comment\n      }\n\n      mh.copy(outBuffer, dindex); // write main header\n\n      return outBuffer;\n    },\n    toAsyncBuffer: function (\n    /*Function*/\n    onSuccess,\n    /*Function*/\n    onFail,\n    /*Function*/\n    onItemStart,\n    /*Function*/\n    onItemEnd) {\n      if (!loadedEntries) {\n        readEntries();\n      }\n\n      if (entryList.length > 1) {\n        entryList.sort(function (a, b) {\n          var nameA = a.entryName.toLowerCase();\n          var nameB = b.entryName.toLowerCase();\n\n          if (nameA > nameB) {\n            return -1;\n          }\n\n          if (nameA < nameB) {\n            return 1;\n          }\n\n          return 0;\n        });\n      }\n\n      var totalSize = 0,\n          dataBlock = [],\n          entryHeaders = [],\n          dindex = 0;\n      mainHeader.size = 0;\n      mainHeader.offset = 0;\n\n      var compress = function (entryList) {\n        var self = arguments.callee;\n\n        if (entryList.length) {\n          var entry = entryList.pop();\n          var name = entry.entryName + entry.extra.toString();\n          if (onItemStart) onItemStart(name);\n          entry.getCompressedDataAsync(function (compressedData) {\n            if (onItemEnd) onItemEnd(name);\n            entry.header.offset = dindex; // data header\n\n            var dataHeader = entry.header.dataHeaderToBinary();\n            var postHeader;\n\n            try {\n              postHeader = Buffer.alloc(name.length, name); // using alloc will work on node  5.x+\n            } catch (e) {\n              postHeader = new Buffer(name); // use deprecated method if alloc fails...\n            }\n\n            var dataLength = dataHeader.length + postHeader.length + compressedData.length;\n            dindex += dataLength;\n            dataBlock.push(dataHeader);\n            dataBlock.push(postHeader);\n            dataBlock.push(compressedData);\n            var entryHeader = entry.packHeader();\n            entryHeaders.push(entryHeader);\n            mainHeader.size += entryHeader.length;\n            totalSize += dataLength + entryHeader.length;\n\n            if (entryList.length) {\n              self(entryList);\n            } else {\n              totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\n              // point to end of data and beginning of central directory first record\n\n              mainHeader.offset = dindex;\n              dindex = 0;\n              var outBuffer = Buffer.alloc(totalSize);\n              dataBlock.forEach(function (content) {\n                content.copy(outBuffer, dindex); // write data blocks\n\n                dindex += content.length;\n              });\n              entryHeaders.forEach(function (content) {\n                content.copy(outBuffer, dindex); // write central directory entries\n\n                dindex += content.length;\n              });\n              var mh = mainHeader.toBinary();\n\n              if (_comment) {\n                _comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment\n\n              }\n\n              mh.copy(outBuffer, dindex); // write main header\n\n              onSuccess(outBuffer);\n            }\n          });\n        }\n      };\n\n      compress(entryList);\n    }\n  };\n};","map":{"version":3,"names":["ZipEntry","require","Headers","Utils","module","exports","input","inputType","entryList","entryTable","_comment","Buffer","alloc","filename","fs","FileSystem","inBuffer","mainHeader","MainHeader","loadedEntries","Constants","FILE","readFileSync","readMainHeader","BUFFER","iterateEntries","callback","totalEntries","diskEntries","index","offset","i","tmp","entry","header","slice","CENHDR","entryName","fileNameLength","entryHeaderSize","readEntries","Array","length","extraLength","extra","commentLength","comment","ENDHDR","max","Math","n","endStart","endOffset","commentEnd","readUInt32LE","ENDSIG","END64HDR","END64SIG","ZIP64SIG","readBigUInt64LE","ZIP64SIZE","ZIP64LEAD","Error","Errors","INVALID_FORMAT","loadFromBinary","entries","toString","val","getEntryCount","forEach","getEntry","setEntry","push","deleteEntry","isDirectory","_self","getEntryChildren","child","splice","indexOf","list","name","len","zipEntry","substr","compressToBuffer","sort","a","b","nameA","toLowerCase","nameB","totalSize","dataBlock","entryHeaders","dindex","size","compressedData","getCompressedData","dataHeader","dataHeaderToBinary","entryNameLen","rawEntryName","postHeader","copy","fill","dataLength","entryHeader","packHeader","mainHeaderSize","outBuffer","content","mh","toBinary","from","toAsyncBuffer","onSuccess","onFail","onItemStart","onItemEnd","compress","self","arguments","callee","pop","getCompressedDataAsync","e"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/adm-zip/zipFile.js"],"sourcesContent":["var ZipEntry = require(\"./zipEntry\"),\r\n\tHeaders = require(\"./headers\"),\r\n\tUtils = require(\"./util\");\r\n\r\nmodule.exports = function (/*String|Buffer*/input, /*Number*/inputType) {\r\n\tvar entryList = [],\r\n\t\tentryTable = {},\r\n\t\t_comment = Buffer.alloc(0),\r\n\t\tfilename = \"\",\r\n\t\tfs = Utils.FileSystem.require(),\r\n\t\tinBuffer = null,\r\n\t\tmainHeader = new Headers.MainHeader(),\r\n\t\tloadedEntries = false;\r\n\r\n\tif (inputType === Utils.Constants.FILE) {\r\n\t\t// is a filename\r\n\t\tfilename = input;\r\n\t\tinBuffer = fs.readFileSync(filename);\r\n\t\treadMainHeader();\r\n\t} else if (inputType === Utils.Constants.BUFFER) {\r\n\t\t// is a memory buffer\r\n\t\tinBuffer = input;\r\n\t\treadMainHeader();\r\n\t} else {\r\n\t\t// none. is a new file\r\n\t\tloadedEntries = true;\r\n\t}\r\n\r\n\tfunction iterateEntries(callback) {\r\n\t\tconst totalEntries = mainHeader.diskEntries; // total number of entries\r\n\t\tlet index = mainHeader.offset; // offset of first CEN header\r\n\r\n\t\tfor (let i = 0; i < totalEntries; i++) {\r\n\t\t\tlet tmp = index;\r\n\t\t\tconst entry = new ZipEntry(inBuffer);\r\n\r\n\t\t\tentry.header = inBuffer.slice(tmp, tmp += Utils.Constants.CENHDR);\r\n\t\t\tentry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);\r\n\r\n\t\t\tindex += entry.header.entryHeaderSize;\r\n\r\n\t\t\tcallback(entry);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction readEntries() {\r\n\t\tloadedEntries = true;\r\n\t\tentryTable = {};\r\n\t\tentryList = new Array(mainHeader.diskEntries);  // total number of entries\r\n\t\tvar index = mainHeader.offset;  // offset of first CEN header\r\n\t\tfor (var i = 0; i < entryList.length; i++) {\r\n\r\n\t\t\tvar tmp = index,\r\n\t\t\t\tentry = new ZipEntry(inBuffer);\r\n\t\t\tentry.header = inBuffer.slice(tmp, tmp += Utils.Constants.CENHDR);\r\n\r\n\t\t\tentry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);\r\n\r\n\t\t\tif (entry.header.extraLength) {\r\n\t\t\t\tentry.extra = inBuffer.slice(tmp, tmp += entry.header.extraLength);\r\n\t\t\t}\r\n\r\n\t\t\tif (entry.header.commentLength)\r\n\t\t\t\tentry.comment = inBuffer.slice(tmp, tmp + entry.header.commentLength);\r\n\r\n\t\t\tindex += entry.header.entryHeaderSize;\r\n\r\n\t\t\tentryList[i] = entry;\r\n\t\t\tentryTable[entry.entryName] = entry;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction readMainHeader() {\r\n\t\tvar i = inBuffer.length - Utils.Constants.ENDHDR, // END header size\r\n\t\t\tmax = Math.max(0, i - 0xFFFF), // 0xFFFF is the max zip file comment length\r\n\t\t\tn = max,\r\n\t\t\tendStart = inBuffer.length,\r\n\t\t\tendOffset = -1, // Start offset of the END header\r\n\t\t\tcommentEnd = 0;\r\n\r\n\t\tfor (i; i >= n; i--) {\r\n\t\t\tif (inBuffer[i] !== 0x50) continue; // quick check that the byte is 'P'\r\n\t\t\tif (inBuffer.readUInt32LE(i) === Utils.Constants.ENDSIG) { // \"PK\\005\\006\"\r\n\t\t\t\tendOffset = i;\r\n\t\t\t\tcommentEnd = i;\r\n\t\t\t\tendStart = i + Utils.Constants.ENDHDR;\r\n\t\t\t\t// We already found a regular signature, let's look just a bit further to check if there's any zip64 signature\r\n\t\t\t\tn = i - Utils.Constants.END64HDR;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif (inBuffer.readUInt32LE(i) === Utils.Constants.END64SIG) {\r\n\t\t\t\t// Found a zip64 signature, let's continue reading the whole zip64 record\r\n\t\t\t\tn = max;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif (inBuffer.readUInt32LE(i) == Utils.Constants.ZIP64SIG) {\r\n\t\t\t\t// Found the zip64 record, let's determine it's size\r\n\t\t\t\tendOffset = i;\r\n\t\t\t\tendStart = i + Utils.readBigUInt64LE(inBuffer, i + Utils.Constants.ZIP64SIZE) + Utils.Constants.ZIP64LEAD;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!~endOffset)\r\n\t\t\tthrow new Error(Utils.Errors.INVALID_FORMAT);\r\n\r\n\t\tmainHeader.loadFromBinary(inBuffer.slice(endOffset, endStart));\r\n\t\tif (mainHeader.commentLength) {\r\n\t\t\t_comment = inBuffer.slice(commentEnd + Utils.Constants.ENDHDR);\r\n\t\t}\r\n\t\t// readEntries();\r\n\t}\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * Returns an array of ZipEntry objects existent in the current opened archive\r\n\t\t * @return Array\r\n\t\t */\r\n\t\tget entries() {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treadEntries();\r\n\t\t\t}\r\n\t\t\treturn entryList;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Archive comment\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tget comment() {\r\n\t\t\treturn _comment.toString();\r\n\t\t},\r\n\t\tset comment(val) {\r\n\t\t\tmainHeader.commentLength = val.length;\r\n\t\t\t_comment = val;\r\n\t\t},\r\n\r\n\t\tgetEntryCount: function() {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treturn mainHeader.diskEntries;\r\n\t\t\t}\r\n\r\n\t\t\treturn entryList.length;\r\n\t\t},\r\n\r\n\t\tforEach: function(callback) {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\titerateEntries(callback);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tentryList.forEach(callback);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns a reference to the entry with the given name or null if entry is inexistent\r\n\t\t *\r\n\t\t * @param entryName\r\n\t\t * @return ZipEntry\r\n\t\t */\r\n\t\tgetEntry: function (/*String*/entryName) {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treadEntries();\r\n\t\t\t}\r\n\t\t\treturn entryTable[entryName] || null;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds the given entry to the entry list\r\n\t\t *\r\n\t\t * @param entry\r\n\t\t */\r\n\t\tsetEntry: function (/*ZipEntry*/entry) {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treadEntries();\r\n\t\t\t}\r\n\t\t\tentryList.push(entry);\r\n\t\t\tentryTable[entry.entryName] = entry;\r\n\t\t\tmainHeader.totalEntries = entryList.length;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Removes the entry with the given name from the entry list.\r\n\t\t *\r\n\t\t * If the entry is a directory, then all nested files and directories will be removed\r\n\t\t * @param entryName\r\n\t\t */\r\n\t\tdeleteEntry: function (/*String*/entryName) {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treadEntries();\r\n\t\t\t}\r\n\t\t\tvar entry = entryTable[entryName];\r\n\t\t\tif (entry && entry.isDirectory) {\r\n\t\t\t\tvar _self = this;\r\n\t\t\t\tthis.getEntryChildren(entry).forEach(function (child) {\r\n\t\t\t\t\tif (child.entryName !== entryName) {\r\n\t\t\t\t\t\t_self.deleteEntry(child.entryName)\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tentryList.splice(entryList.indexOf(entry), 1);\r\n\t\t\tdelete(entryTable[entryName]);\r\n\t\t\tmainHeader.totalEntries = entryList.length;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t *  Iterates and returns all nested files and directories of the given entry\r\n\t\t *\r\n\t\t * @param entry\r\n\t\t * @return Array\r\n\t\t */\r\n\t\tgetEntryChildren: function (/*ZipEntry*/entry) {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treadEntries();\r\n\t\t\t}\r\n\t\t\tif (entry.isDirectory) {\r\n\t\t\t\tvar list = [],\r\n\t\t\t\t\tname = entry.entryName,\r\n\t\t\t\t\tlen = name.length;\r\n\r\n\t\t\t\tentryList.forEach(function (zipEntry) {\r\n\t\t\t\t\tif (zipEntry.entryName.substr(0, len) === name) {\r\n\t\t\t\t\t\tlist.push(zipEntry);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\treturn list;\r\n\t\t\t}\r\n\t\t\treturn []\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the zip file\r\n\t\t *\r\n\t\t * @return Buffer\r\n\t\t */\r\n\t\tcompressToBuffer: function () {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treadEntries();\r\n\t\t\t}\r\n\t\t\tif (entryList.length > 1) {\r\n\t\t\t\tentryList.sort(function (a, b) {\r\n\t\t\t\t\tvar nameA = a.entryName.toLowerCase();\r\n\t\t\t\t\tvar nameB = b.entryName.toLowerCase();\r\n\t\t\t\t\tif (nameA < nameB) {\r\n\t\t\t\t\t\treturn -1\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (nameA > nameB) {\r\n\t\t\t\t\t\treturn 1\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tvar totalSize = 0,\r\n\t\t\t\tdataBlock = [],\r\n\t\t\t\tentryHeaders = [],\r\n\t\t\t\tdindex = 0;\r\n\r\n\t\t\tmainHeader.size = 0;\r\n\t\t\tmainHeader.offset = 0;\r\n\r\n\t\t\tentryList.forEach(function (entry) {\r\n\t\t\t\t// compress data and set local and entry header accordingly. Reason why is called first\r\n\t\t\t\tvar compressedData = entry.getCompressedData();\r\n\t\t\t\t// data header\r\n\t\t\t\tentry.header.offset = dindex;\r\n\t\t\t\tvar dataHeader = entry.header.dataHeaderToBinary();\r\n\t\t\t\tvar entryNameLen = entry.rawEntryName.length;\r\n\t\t\t\tvar extra = entry.extra.toString();\r\n\t\t\t\tvar postHeader = Buffer.alloc(entryNameLen + extra.length);\r\n\t\t\t\tentry.rawEntryName.copy(postHeader, 0);\r\n\t\t\t\tpostHeader.fill(extra, entryNameLen);\r\n\r\n\t\t\t\tvar dataLength = dataHeader.length + postHeader.length + compressedData.length;\r\n\r\n\t\t\t\tdindex += dataLength;\r\n\r\n\t\t\t\tdataBlock.push(dataHeader);\r\n\t\t\t\tdataBlock.push(postHeader);\r\n\t\t\t\tdataBlock.push(compressedData);\r\n\r\n\t\t\t\tvar entryHeader = entry.packHeader();\r\n\t\t\t\tentryHeaders.push(entryHeader);\r\n\t\t\t\tmainHeader.size += entryHeader.length;\r\n\t\t\t\ttotalSize += (dataLength + entryHeader.length);\r\n\t\t\t});\r\n\r\n\t\t\ttotalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\r\n\t\t\t// point to end of data and beginning of central directory first record\r\n\t\t\tmainHeader.offset = dindex;\r\n\r\n\t\t\tdindex = 0;\r\n\t\t\tvar outBuffer = Buffer.alloc(totalSize);\r\n\t\t\tdataBlock.forEach(function (content) {\r\n\t\t\t\tcontent.copy(outBuffer, dindex); // write data blocks\r\n\t\t\t\tdindex += content.length;\r\n\t\t\t});\r\n\t\t\tentryHeaders.forEach(function (content) {\r\n\t\t\t\tcontent.copy(outBuffer, dindex); // write central directory entries\r\n\t\t\t\tdindex += content.length;\r\n\t\t\t});\r\n\r\n\t\t\tvar mh = mainHeader.toBinary();\r\n\t\t\tif (_comment) {\r\n\t\t\t\tBuffer.from(_comment).copy(mh, Utils.Constants.ENDHDR); // add zip file comment\r\n\t\t\t}\r\n\r\n\t\t\tmh.copy(outBuffer, dindex); // write main header\r\n\r\n\t\t\treturn outBuffer\r\n\t\t},\r\n\r\n\t\ttoAsyncBuffer: function (/*Function*/onSuccess, /*Function*/onFail, /*Function*/onItemStart, /*Function*/onItemEnd) {\r\n\t\t\tif (!loadedEntries) {\r\n\t\t\t\treadEntries();\r\n\t\t\t}\r\n\t\t\tif (entryList.length > 1) {\r\n\t\t\t\tentryList.sort(function (a, b) {\r\n\t\t\t\t\tvar nameA = a.entryName.toLowerCase();\r\n\t\t\t\t\tvar nameB = b.entryName.toLowerCase();\r\n\t\t\t\t\tif (nameA > nameB) {\r\n\t\t\t\t\t\treturn -1\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (nameA < nameB) {\r\n\t\t\t\t\t\treturn 1\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tvar totalSize = 0,\r\n\t\t\t\tdataBlock = [],\r\n\t\t\t\tentryHeaders = [],\r\n\t\t\t\tdindex = 0;\r\n\r\n\t\t\tmainHeader.size = 0;\r\n\t\t\tmainHeader.offset = 0;\r\n\r\n\t\t\tvar compress = function (entryList) {\r\n\t\t\t\tvar self = arguments.callee;\r\n\t\t\t\tif (entryList.length) {\r\n\t\t\t\t\tvar entry = entryList.pop();\r\n\t\t\t\t\tvar name = entry.entryName + entry.extra.toString();\r\n\t\t\t\t\tif (onItemStart) onItemStart(name);\r\n\t\t\t\t\tentry.getCompressedDataAsync(function (compressedData) {\r\n\t\t\t\t\t\tif (onItemEnd) onItemEnd(name);\r\n\r\n\t\t\t\t\t\tentry.header.offset = dindex;\r\n\t\t\t\t\t\t// data header\r\n\t\t\t\t\t\tvar dataHeader = entry.header.dataHeaderToBinary();\r\n\t\t\t\t\t\tvar postHeader;\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tpostHeader = Buffer.alloc(name.length, name);  // using alloc will work on node  5.x+\r\n\t\t\t\t\t\t} catch(e){\r\n\t\t\t\t\t\t\tpostHeader = new Buffer(name); // use deprecated method if alloc fails...\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar dataLength = dataHeader.length + postHeader.length + compressedData.length;\r\n\r\n\t\t\t\t\t\tdindex += dataLength;\r\n\r\n\t\t\t\t\t\tdataBlock.push(dataHeader);\r\n\t\t\t\t\t\tdataBlock.push(postHeader);\r\n\t\t\t\t\t\tdataBlock.push(compressedData);\r\n\r\n\t\t\t\t\t\tvar entryHeader = entry.packHeader();\r\n\t\t\t\t\t\tentryHeaders.push(entryHeader);\r\n\t\t\t\t\t\tmainHeader.size += entryHeader.length;\r\n\t\t\t\t\t\ttotalSize += (dataLength + entryHeader.length);\r\n\r\n\t\t\t\t\t\tif (entryList.length) {\r\n\t\t\t\t\t\t\tself(entryList);\r\n\t\t\t\t\t\t} else {\r\n\r\n\r\n\t\t\t\t\t\t\ttotalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\r\n\t\t\t\t\t\t\t// point to end of data and beginning of central directory first record\r\n\t\t\t\t\t\t\tmainHeader.offset = dindex;\r\n\r\n\t\t\t\t\t\t\tdindex = 0;\r\n\t\t\t\t\t\t\tvar outBuffer = Buffer.alloc(totalSize);\r\n\t\t\t\t\t\t\tdataBlock.forEach(function (content) {\r\n\t\t\t\t\t\t\t\tcontent.copy(outBuffer, dindex); // write data blocks\r\n\t\t\t\t\t\t\t\tdindex += content.length;\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\tentryHeaders.forEach(function (content) {\r\n\t\t\t\t\t\t\t\tcontent.copy(outBuffer, dindex); // write central directory entries\r\n\t\t\t\t\t\t\t\tdindex += content.length;\r\n\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\tvar mh = mainHeader.toBinary();\r\n\t\t\t\t\t\t\tif (_comment) {\r\n\t\t\t\t\t\t\t\t_comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tmh.copy(outBuffer, dindex); // write main header\r\n\r\n\t\t\t\t\t\t\tonSuccess(outBuffer);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tcompress(entryList);\r\n\t\t}\r\n\t}\r\n};\r\n"],"mappings":"AAAA,IAAIA,QAAQ,GAAGC,OAAO,CAAC,YAAD,CAAtB;AAAA,IACCC,OAAO,GAAGD,OAAO,CAAC,WAAD,CADlB;AAAA,IAECE,KAAK,GAAGF,OAAO,CAAC,QAAD,CAFhB;;AAIAG,MAAM,CAACC,OAAP,GAAiB;AAAU;AAAiBC,KAA3B;AAAkC;AAAUC,SAA5C,EAAuD;EACvE,IAAIC,SAAS,GAAG,EAAhB;EAAA,IACCC,UAAU,GAAG,EADd;EAAA,IAECC,QAAQ,GAAGC,MAAM,CAACC,KAAP,CAAa,CAAb,CAFZ;EAAA,IAGCC,QAAQ,GAAG,EAHZ;EAAA,IAICC,EAAE,GAAGX,KAAK,CAACY,UAAN,CAAiBd,OAAjB,EAJN;EAAA,IAKCe,QAAQ,GAAG,IALZ;EAAA,IAMCC,UAAU,GAAG,IAAIf,OAAO,CAACgB,UAAZ,EANd;EAAA,IAOCC,aAAa,GAAG,KAPjB;;EASA,IAAIZ,SAAS,KAAKJ,KAAK,CAACiB,SAAN,CAAgBC,IAAlC,EAAwC;IACvC;IACAR,QAAQ,GAAGP,KAAX;IACAU,QAAQ,GAAGF,EAAE,CAACQ,YAAH,CAAgBT,QAAhB,CAAX;IACAU,cAAc;EACd,CALD,MAKO,IAAIhB,SAAS,KAAKJ,KAAK,CAACiB,SAAN,CAAgBI,MAAlC,EAA0C;IAChD;IACAR,QAAQ,GAAGV,KAAX;IACAiB,cAAc;EACd,CAJM,MAIA;IACN;IACAJ,aAAa,GAAG,IAAhB;EACA;;EAED,SAASM,cAAT,CAAwBC,QAAxB,EAAkC;IACjC,MAAMC,YAAY,GAAGV,UAAU,CAACW,WAAhC,CADiC,CACY;;IAC7C,IAAIC,KAAK,GAAGZ,UAAU,CAACa,MAAvB,CAFiC,CAEF;;IAE/B,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,YAApB,EAAkCI,CAAC,EAAnC,EAAuC;MACtC,IAAIC,GAAG,GAAGH,KAAV;MACA,MAAMI,KAAK,GAAG,IAAIjC,QAAJ,CAAagB,QAAb,CAAd;MAEAiB,KAAK,CAACC,MAAN,GAAelB,QAAQ,CAACmB,KAAT,CAAeH,GAAf,EAAoBA,GAAG,IAAI7B,KAAK,CAACiB,SAAN,CAAgBgB,MAA3C,CAAf;MACAH,KAAK,CAACI,SAAN,GAAkBrB,QAAQ,CAACmB,KAAT,CAAeH,GAAf,EAAoBA,GAAG,IAAIC,KAAK,CAACC,MAAN,CAAaI,cAAxC,CAAlB;MAEAT,KAAK,IAAII,KAAK,CAACC,MAAN,CAAaK,eAAtB;MAEAb,QAAQ,CAACO,KAAD,CAAR;IACA;EACD;;EAED,SAASO,WAAT,GAAuB;IACtBrB,aAAa,GAAG,IAAhB;IACAV,UAAU,GAAG,EAAb;IACAD,SAAS,GAAG,IAAIiC,KAAJ,CAAUxB,UAAU,CAACW,WAArB,CAAZ,CAHsB,CAG0B;;IAChD,IAAIC,KAAK,GAAGZ,UAAU,CAACa,MAAvB,CAJsB,CAIU;;IAChC,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGvB,SAAS,CAACkC,MAA9B,EAAsCX,CAAC,EAAvC,EAA2C;MAE1C,IAAIC,GAAG,GAAGH,KAAV;MAAA,IACCI,KAAK,GAAG,IAAIjC,QAAJ,CAAagB,QAAb,CADT;MAEAiB,KAAK,CAACC,MAAN,GAAelB,QAAQ,CAACmB,KAAT,CAAeH,GAAf,EAAoBA,GAAG,IAAI7B,KAAK,CAACiB,SAAN,CAAgBgB,MAA3C,CAAf;MAEAH,KAAK,CAACI,SAAN,GAAkBrB,QAAQ,CAACmB,KAAT,CAAeH,GAAf,EAAoBA,GAAG,IAAIC,KAAK,CAACC,MAAN,CAAaI,cAAxC,CAAlB;;MAEA,IAAIL,KAAK,CAACC,MAAN,CAAaS,WAAjB,EAA8B;QAC7BV,KAAK,CAACW,KAAN,GAAc5B,QAAQ,CAACmB,KAAT,CAAeH,GAAf,EAAoBA,GAAG,IAAIC,KAAK,CAACC,MAAN,CAAaS,WAAxC,CAAd;MACA;;MAED,IAAIV,KAAK,CAACC,MAAN,CAAaW,aAAjB,EACCZ,KAAK,CAACa,OAAN,GAAgB9B,QAAQ,CAACmB,KAAT,CAAeH,GAAf,EAAoBA,GAAG,GAAGC,KAAK,CAACC,MAAN,CAAaW,aAAvC,CAAhB;MAEDhB,KAAK,IAAII,KAAK,CAACC,MAAN,CAAaK,eAAtB;MAEA/B,SAAS,CAACuB,CAAD,CAAT,GAAeE,KAAf;MACAxB,UAAU,CAACwB,KAAK,CAACI,SAAP,CAAV,GAA8BJ,KAA9B;IACA;EACD;;EAED,SAASV,cAAT,GAA0B;IACzB,IAAIQ,CAAC,GAAGf,QAAQ,CAAC0B,MAAT,GAAkBvC,KAAK,CAACiB,SAAN,CAAgB2B,MAA1C;IAAA,IAAkD;IACjDC,GAAG,GAAGC,IAAI,CAACD,GAAL,CAAS,CAAT,EAAYjB,CAAC,GAAG,MAAhB,CADP;IAAA,IACgC;IAC/BmB,CAAC,GAAGF,GAFL;IAAA,IAGCG,QAAQ,GAAGnC,QAAQ,CAAC0B,MAHrB;IAAA,IAICU,SAAS,GAAG,CAAC,CAJd;IAAA,IAIiB;IAChBC,UAAU,GAAG,CALd;;IAOA,KAAKtB,CAAL,EAAQA,CAAC,IAAImB,CAAb,EAAgBnB,CAAC,EAAjB,EAAqB;MACpB,IAAIf,QAAQ,CAACe,CAAD,CAAR,KAAgB,IAApB,EAA0B,SADN,CACgB;;MACpC,IAAIf,QAAQ,CAACsC,YAAT,CAAsBvB,CAAtB,MAA6B5B,KAAK,CAACiB,SAAN,CAAgBmC,MAAjD,EAAyD;QAAE;QAC1DH,SAAS,GAAGrB,CAAZ;QACAsB,UAAU,GAAGtB,CAAb;QACAoB,QAAQ,GAAGpB,CAAC,GAAG5B,KAAK,CAACiB,SAAN,CAAgB2B,MAA/B,CAHwD,CAIxD;;QACAG,CAAC,GAAGnB,CAAC,GAAG5B,KAAK,CAACiB,SAAN,CAAgBoC,QAAxB;QACA;MACA;;MAED,IAAIxC,QAAQ,CAACsC,YAAT,CAAsBvB,CAAtB,MAA6B5B,KAAK,CAACiB,SAAN,CAAgBqC,QAAjD,EAA2D;QAC1D;QACAP,CAAC,GAAGF,GAAJ;QACA;MACA;;MAED,IAAIhC,QAAQ,CAACsC,YAAT,CAAsBvB,CAAtB,KAA4B5B,KAAK,CAACiB,SAAN,CAAgBsC,QAAhD,EAA0D;QACzD;QACAN,SAAS,GAAGrB,CAAZ;QACAoB,QAAQ,GAAGpB,CAAC,GAAG5B,KAAK,CAACwD,eAAN,CAAsB3C,QAAtB,EAAgCe,CAAC,GAAG5B,KAAK,CAACiB,SAAN,CAAgBwC,SAApD,CAAJ,GAAqEzD,KAAK,CAACiB,SAAN,CAAgByC,SAAhG;QACA;MACA;IACD;;IAED,IAAI,CAAC,CAACT,SAAN,EACC,MAAM,IAAIU,KAAJ,CAAU3D,KAAK,CAAC4D,MAAN,CAAaC,cAAvB,CAAN;IAED/C,UAAU,CAACgD,cAAX,CAA0BjD,QAAQ,CAACmB,KAAT,CAAeiB,SAAf,EAA0BD,QAA1B,CAA1B;;IACA,IAAIlC,UAAU,CAAC4B,aAAf,EAA8B;MAC7BnC,QAAQ,GAAGM,QAAQ,CAACmB,KAAT,CAAekB,UAAU,GAAGlD,KAAK,CAACiB,SAAN,CAAgB2B,MAA5C,CAAX;IACA,CAvCwB,CAwCzB;;EACA;;EAED,OAAO;IACN;AACF;AACA;AACA;IACE,IAAImB,OAAJ,GAAc;MACb,IAAI,CAAC/C,aAAL,EAAoB;QACnBqB,WAAW;MACX;;MACD,OAAOhC,SAAP;IACA,CAVK;;IAYN;AACF;AACA;AACA;IACE,IAAIsC,OAAJ,GAAc;MACb,OAAOpC,QAAQ,CAACyD,QAAT,EAAP;IACA,CAlBK;;IAmBN,IAAIrB,OAAJ,CAAYsB,GAAZ,EAAiB;MAChBnD,UAAU,CAAC4B,aAAX,GAA2BuB,GAAG,CAAC1B,MAA/B;MACAhC,QAAQ,GAAG0D,GAAX;IACA,CAtBK;;IAwBNC,aAAa,EAAE,YAAW;MACzB,IAAI,CAAClD,aAAL,EAAoB;QACnB,OAAOF,UAAU,CAACW,WAAlB;MACA;;MAED,OAAOpB,SAAS,CAACkC,MAAjB;IACA,CA9BK;IAgCN4B,OAAO,EAAE,UAAS5C,QAAT,EAAmB;MAC3B,IAAI,CAACP,aAAL,EAAoB;QACnBM,cAAc,CAACC,QAAD,CAAd;QACA;MACA;;MAEDlB,SAAS,CAAC8D,OAAV,CAAkB5C,QAAlB;IACA,CAvCK;;IAyCN;AACF;AACA;AACA;AACA;AACA;IACE6C,QAAQ,EAAE;IAAU;IAAUlC,SAApB,EAA+B;MACxC,IAAI,CAAClB,aAAL,EAAoB;QACnBqB,WAAW;MACX;;MACD,OAAO/B,UAAU,CAAC4B,SAAD,CAAV,IAAyB,IAAhC;IACA,CApDK;;IAsDN;AACF;AACA;AACA;AACA;IACEmC,QAAQ,EAAE;IAAU;IAAYvC,KAAtB,EAA6B;MACtC,IAAI,CAACd,aAAL,EAAoB;QACnBqB,WAAW;MACX;;MACDhC,SAAS,CAACiE,IAAV,CAAexC,KAAf;MACAxB,UAAU,CAACwB,KAAK,CAACI,SAAP,CAAV,GAA8BJ,KAA9B;MACAhB,UAAU,CAACU,YAAX,GAA0BnB,SAAS,CAACkC,MAApC;IACA,CAlEK;;IAoEN;AACF;AACA;AACA;AACA;AACA;IACEgC,WAAW,EAAE;IAAU;IAAUrC,SAApB,EAA+B;MAC3C,IAAI,CAAClB,aAAL,EAAoB;QACnBqB,WAAW;MACX;;MACD,IAAIP,KAAK,GAAGxB,UAAU,CAAC4B,SAAD,CAAtB;;MACA,IAAIJ,KAAK,IAAIA,KAAK,CAAC0C,WAAnB,EAAgC;QAC/B,IAAIC,KAAK,GAAG,IAAZ;;QACA,KAAKC,gBAAL,CAAsB5C,KAAtB,EAA6BqC,OAA7B,CAAqC,UAAUQ,KAAV,EAAiB;UACrD,IAAIA,KAAK,CAACzC,SAAN,KAAoBA,SAAxB,EAAmC;YAClCuC,KAAK,CAACF,WAAN,CAAkBI,KAAK,CAACzC,SAAxB;UACA;QACD,CAJD;MAKA;;MACD7B,SAAS,CAACuE,MAAV,CAAiBvE,SAAS,CAACwE,OAAV,CAAkB/C,KAAlB,CAAjB,EAA2C,CAA3C;MACA,OAAOxB,UAAU,CAAC4B,SAAD,CAAjB;MACApB,UAAU,CAACU,YAAX,GAA0BnB,SAAS,CAACkC,MAApC;IACA,CA1FK;;IA4FN;AACF;AACA;AACA;AACA;AACA;IACEmC,gBAAgB,EAAE;IAAU;IAAY5C,KAAtB,EAA6B;MAC9C,IAAI,CAACd,aAAL,EAAoB;QACnBqB,WAAW;MACX;;MACD,IAAIP,KAAK,CAAC0C,WAAV,EAAuB;QACtB,IAAIM,IAAI,GAAG,EAAX;QAAA,IACCC,IAAI,GAAGjD,KAAK,CAACI,SADd;QAAA,IAEC8C,GAAG,GAAGD,IAAI,CAACxC,MAFZ;QAIAlC,SAAS,CAAC8D,OAAV,CAAkB,UAAUc,QAAV,EAAoB;UACrC,IAAIA,QAAQ,CAAC/C,SAAT,CAAmBgD,MAAnB,CAA0B,CAA1B,EAA6BF,GAA7B,MAAsCD,IAA1C,EAAgD;YAC/CD,IAAI,CAACR,IAAL,CAAUW,QAAV;UACA;QACD,CAJD;QAKA,OAAOH,IAAP;MACA;;MACD,OAAO,EAAP;IACA,CAnHK;;IAqHN;AACF;AACA;AACA;AACA;IACEK,gBAAgB,EAAE,YAAY;MAC7B,IAAI,CAACnE,aAAL,EAAoB;QACnBqB,WAAW;MACX;;MACD,IAAIhC,SAAS,CAACkC,MAAV,GAAmB,CAAvB,EAA0B;QACzBlC,SAAS,CAAC+E,IAAV,CAAe,UAAUC,CAAV,EAAaC,CAAb,EAAgB;UAC9B,IAAIC,KAAK,GAAGF,CAAC,CAACnD,SAAF,CAAYsD,WAAZ,EAAZ;UACA,IAAIC,KAAK,GAAGH,CAAC,CAACpD,SAAF,CAAYsD,WAAZ,EAAZ;;UACA,IAAID,KAAK,GAAGE,KAAZ,EAAmB;YAClB,OAAO,CAAC,CAAR;UACA;;UACD,IAAIF,KAAK,GAAGE,KAAZ,EAAmB;YAClB,OAAO,CAAP;UACA;;UACD,OAAO,CAAP;QACA,CAVD;MAWA;;MAED,IAAIC,SAAS,GAAG,CAAhB;MAAA,IACCC,SAAS,GAAG,EADb;MAAA,IAECC,YAAY,GAAG,EAFhB;MAAA,IAGCC,MAAM,GAAG,CAHV;MAKA/E,UAAU,CAACgF,IAAX,GAAkB,CAAlB;MACAhF,UAAU,CAACa,MAAX,GAAoB,CAApB;MAEAtB,SAAS,CAAC8D,OAAV,CAAkB,UAAUrC,KAAV,EAAiB;QAClC;QACA,IAAIiE,cAAc,GAAGjE,KAAK,CAACkE,iBAAN,EAArB,CAFkC,CAGlC;;QACAlE,KAAK,CAACC,MAAN,CAAaJ,MAAb,GAAsBkE,MAAtB;QACA,IAAII,UAAU,GAAGnE,KAAK,CAACC,MAAN,CAAamE,kBAAb,EAAjB;QACA,IAAIC,YAAY,GAAGrE,KAAK,CAACsE,YAAN,CAAmB7D,MAAtC;QACA,IAAIE,KAAK,GAAGX,KAAK,CAACW,KAAN,CAAYuB,QAAZ,EAAZ;QACA,IAAIqC,UAAU,GAAG7F,MAAM,CAACC,KAAP,CAAa0F,YAAY,GAAG1D,KAAK,CAACF,MAAlC,CAAjB;QACAT,KAAK,CAACsE,YAAN,CAAmBE,IAAnB,CAAwBD,UAAxB,EAAoC,CAApC;QACAA,UAAU,CAACE,IAAX,CAAgB9D,KAAhB,EAAuB0D,YAAvB;QAEA,IAAIK,UAAU,GAAGP,UAAU,CAAC1D,MAAX,GAAoB8D,UAAU,CAAC9D,MAA/B,GAAwCwD,cAAc,CAACxD,MAAxE;QAEAsD,MAAM,IAAIW,UAAV;QAEAb,SAAS,CAACrB,IAAV,CAAe2B,UAAf;QACAN,SAAS,CAACrB,IAAV,CAAe+B,UAAf;QACAV,SAAS,CAACrB,IAAV,CAAeyB,cAAf;QAEA,IAAIU,WAAW,GAAG3E,KAAK,CAAC4E,UAAN,EAAlB;QACAd,YAAY,CAACtB,IAAb,CAAkBmC,WAAlB;QACA3F,UAAU,CAACgF,IAAX,IAAmBW,WAAW,CAAClE,MAA/B;QACAmD,SAAS,IAAKc,UAAU,GAAGC,WAAW,CAAClE,MAAvC;MACA,CAxBD;MA0BAmD,SAAS,IAAI5E,UAAU,CAAC6F,cAAxB,CApD6B,CAoDW;MACxC;;MACA7F,UAAU,CAACa,MAAX,GAAoBkE,MAApB;MAEAA,MAAM,GAAG,CAAT;MACA,IAAIe,SAAS,GAAGpG,MAAM,CAACC,KAAP,CAAaiF,SAAb,CAAhB;MACAC,SAAS,CAACxB,OAAV,CAAkB,UAAU0C,OAAV,EAAmB;QACpCA,OAAO,CAACP,IAAR,CAAaM,SAAb,EAAwBf,MAAxB,EADoC,CACH;;QACjCA,MAAM,IAAIgB,OAAO,CAACtE,MAAlB;MACA,CAHD;MAIAqD,YAAY,CAACzB,OAAb,CAAqB,UAAU0C,OAAV,EAAmB;QACvCA,OAAO,CAACP,IAAR,CAAaM,SAAb,EAAwBf,MAAxB,EADuC,CACN;;QACjCA,MAAM,IAAIgB,OAAO,CAACtE,MAAlB;MACA,CAHD;MAKA,IAAIuE,EAAE,GAAGhG,UAAU,CAACiG,QAAX,EAAT;;MACA,IAAIxG,QAAJ,EAAc;QACbC,MAAM,CAACwG,IAAP,CAAYzG,QAAZ,EAAsB+F,IAAtB,CAA2BQ,EAA3B,EAA+B9G,KAAK,CAACiB,SAAN,CAAgB2B,MAA/C,EADa,CAC2C;MACxD;;MAEDkE,EAAE,CAACR,IAAH,CAAQM,SAAR,EAAmBf,MAAnB,EAxE6B,CAwED;;MAE5B,OAAOe,SAAP;IACA,CArMK;IAuMNK,aAAa,EAAE;IAAU;IAAYC,SAAtB;IAAiC;IAAYC,MAA7C;IAAqD;IAAYC,WAAjE;IAA8E;IAAYC,SAA1F,EAAqG;MACnH,IAAI,CAACrG,aAAL,EAAoB;QACnBqB,WAAW;MACX;;MACD,IAAIhC,SAAS,CAACkC,MAAV,GAAmB,CAAvB,EAA0B;QACzBlC,SAAS,CAAC+E,IAAV,CAAe,UAAUC,CAAV,EAAaC,CAAb,EAAgB;UAC9B,IAAIC,KAAK,GAAGF,CAAC,CAACnD,SAAF,CAAYsD,WAAZ,EAAZ;UACA,IAAIC,KAAK,GAAGH,CAAC,CAACpD,SAAF,CAAYsD,WAAZ,EAAZ;;UACA,IAAID,KAAK,GAAGE,KAAZ,EAAmB;YAClB,OAAO,CAAC,CAAR;UACA;;UACD,IAAIF,KAAK,GAAGE,KAAZ,EAAmB;YAClB,OAAO,CAAP;UACA;;UACD,OAAO,CAAP;QACA,CAVD;MAWA;;MAED,IAAIC,SAAS,GAAG,CAAhB;MAAA,IACCC,SAAS,GAAG,EADb;MAAA,IAECC,YAAY,GAAG,EAFhB;MAAA,IAGCC,MAAM,GAAG,CAHV;MAKA/E,UAAU,CAACgF,IAAX,GAAkB,CAAlB;MACAhF,UAAU,CAACa,MAAX,GAAoB,CAApB;;MAEA,IAAI2F,QAAQ,GAAG,UAAUjH,SAAV,EAAqB;QACnC,IAAIkH,IAAI,GAAGC,SAAS,CAACC,MAArB;;QACA,IAAIpH,SAAS,CAACkC,MAAd,EAAsB;UACrB,IAAIT,KAAK,GAAGzB,SAAS,CAACqH,GAAV,EAAZ;UACA,IAAI3C,IAAI,GAAGjD,KAAK,CAACI,SAAN,GAAkBJ,KAAK,CAACW,KAAN,CAAYuB,QAAZ,EAA7B;UACA,IAAIoD,WAAJ,EAAiBA,WAAW,CAACrC,IAAD,CAAX;UACjBjD,KAAK,CAAC6F,sBAAN,CAA6B,UAAU5B,cAAV,EAA0B;YACtD,IAAIsB,SAAJ,EAAeA,SAAS,CAACtC,IAAD,CAAT;YAEfjD,KAAK,CAACC,MAAN,CAAaJ,MAAb,GAAsBkE,MAAtB,CAHsD,CAItD;;YACA,IAAII,UAAU,GAAGnE,KAAK,CAACC,MAAN,CAAamE,kBAAb,EAAjB;YACA,IAAIG,UAAJ;;YACA,IAAI;cACHA,UAAU,GAAG7F,MAAM,CAACC,KAAP,CAAasE,IAAI,CAACxC,MAAlB,EAA0BwC,IAA1B,CAAb,CADG,CAC4C;YAC/C,CAFD,CAEE,OAAM6C,CAAN,EAAQ;cACTvB,UAAU,GAAG,IAAI7F,MAAJ,CAAWuE,IAAX,CAAb,CADS,CACsB;YAC/B;;YACD,IAAIyB,UAAU,GAAGP,UAAU,CAAC1D,MAAX,GAAoB8D,UAAU,CAAC9D,MAA/B,GAAwCwD,cAAc,CAACxD,MAAxE;YAEAsD,MAAM,IAAIW,UAAV;YAEAb,SAAS,CAACrB,IAAV,CAAe2B,UAAf;YACAN,SAAS,CAACrB,IAAV,CAAe+B,UAAf;YACAV,SAAS,CAACrB,IAAV,CAAeyB,cAAf;YAEA,IAAIU,WAAW,GAAG3E,KAAK,CAAC4E,UAAN,EAAlB;YACAd,YAAY,CAACtB,IAAb,CAAkBmC,WAAlB;YACA3F,UAAU,CAACgF,IAAX,IAAmBW,WAAW,CAAClE,MAA/B;YACAmD,SAAS,IAAKc,UAAU,GAAGC,WAAW,CAAClE,MAAvC;;YAEA,IAAIlC,SAAS,CAACkC,MAAd,EAAsB;cACrBgF,IAAI,CAAClH,SAAD,CAAJ;YACA,CAFD,MAEO;cAGNqF,SAAS,IAAI5E,UAAU,CAAC6F,cAAxB,CAHM,CAGkC;cACxC;;cACA7F,UAAU,CAACa,MAAX,GAAoBkE,MAApB;cAEAA,MAAM,GAAG,CAAT;cACA,IAAIe,SAAS,GAAGpG,MAAM,CAACC,KAAP,CAAaiF,SAAb,CAAhB;cACAC,SAAS,CAACxB,OAAV,CAAkB,UAAU0C,OAAV,EAAmB;gBACpCA,OAAO,CAACP,IAAR,CAAaM,SAAb,EAAwBf,MAAxB,EADoC,CACH;;gBACjCA,MAAM,IAAIgB,OAAO,CAACtE,MAAlB;cACA,CAHD;cAIAqD,YAAY,CAACzB,OAAb,CAAqB,UAAU0C,OAAV,EAAmB;gBACvCA,OAAO,CAACP,IAAR,CAAaM,SAAb,EAAwBf,MAAxB,EADuC,CACN;;gBACjCA,MAAM,IAAIgB,OAAO,CAACtE,MAAlB;cACA,CAHD;cAKA,IAAIuE,EAAE,GAAGhG,UAAU,CAACiG,QAAX,EAAT;;cACA,IAAIxG,QAAJ,EAAc;gBACbA,QAAQ,CAAC+F,IAAT,CAAcQ,EAAd,EAAkB9G,KAAK,CAACiB,SAAN,CAAgB2B,MAAlC,EADa,CAC8B;;cAC3C;;cAEDkE,EAAE,CAACR,IAAH,CAAQM,SAAR,EAAmBf,MAAnB,EAvBM,CAuBsB;;cAE5BqB,SAAS,CAACN,SAAD,CAAT;YACA;UACD,CAtDD;QAuDA;MACD,CA9DD;;MAgEAU,QAAQ,CAACjH,SAAD,CAAR;IACA;EAlSK,CAAP;AAoSA,CAnZD"},"metadata":{},"sourceType":"script"}