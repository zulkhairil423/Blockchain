{"ast":null,"code":"const flagSymbol = Symbol('arg flag');\n\nfunction arg(opts) {\n  let {\n    argv = process.argv.slice(2),\n    permissive = false,\n    stopAtPositional = false\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!opts) {\n    throw new Error('Argument specification object is required');\n  }\n\n  const result = {\n    _: []\n  };\n  const aliases = {};\n  const handlers = {};\n\n  for (const key of Object.keys(opts)) {\n    if (!key) {\n      throw new TypeError('Argument key cannot be an empty string');\n    }\n\n    if (key[0] !== '-') {\n      throw new TypeError(`Argument key must start with '-' but found: '${key}'`);\n    }\n\n    if (key.length === 1) {\n      throw new TypeError(`Argument key must have a name; singular '-' keys are not allowed: ${key}`);\n    }\n\n    if (typeof opts[key] === 'string') {\n      aliases[key] = opts[key];\n      continue;\n    }\n\n    let type = opts[key];\n    let isFlag = false;\n\n    if (Array.isArray(type) && type.length === 1 && typeof type[0] === 'function') {\n      const [fn] = type;\n\n      type = function (value, name) {\n        let prev = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n        prev.push(fn(value, name, prev[prev.length - 1]));\n        return prev;\n      };\n\n      isFlag = fn === Boolean || fn[flagSymbol] === true;\n    } else if (typeof type === 'function') {\n      isFlag = type === Boolean || type[flagSymbol] === true;\n    } else {\n      throw new TypeError(`Type missing or not a function or valid array type: ${key}`);\n    }\n\n    if (key[1] !== '-' && key.length > 2) {\n      throw new TypeError(`Short argument keys (with a single hyphen) must have only one character: ${key}`);\n    }\n\n    handlers[key] = [type, isFlag];\n  }\n\n  for (let i = 0, len = argv.length; i < len; i++) {\n    const wholeArg = argv[i];\n\n    if (stopAtPositional && result._.length > 0) {\n      result._ = result._.concat(argv.slice(i));\n      break;\n    }\n\n    if (wholeArg === '--') {\n      result._ = result._.concat(argv.slice(i + 1));\n      break;\n    }\n\n    if (wholeArg.length > 1 && wholeArg[0] === '-') {\n      /* eslint-disable operator-linebreak */\n      const separatedArguments = wholeArg[1] === '-' || wholeArg.length === 2 ? [wholeArg] : wholeArg.slice(1).split('').map(a => `-${a}`);\n      /* eslint-enable operator-linebreak */\n\n      for (let j = 0; j < separatedArguments.length; j++) {\n        const arg = separatedArguments[j];\n        const [originalArgName, argStr] = arg[1] === '-' ? arg.split(/=(.*)/, 2) : [arg, undefined];\n        let argName = originalArgName;\n\n        while (argName in aliases) {\n          argName = aliases[argName];\n        }\n\n        if (!(argName in handlers)) {\n          if (permissive) {\n            result._.push(arg);\n\n            continue;\n          } else {\n            const err = new Error(`Unknown or unexpected option: ${originalArgName}`);\n            err.code = 'ARG_UNKNOWN_OPTION';\n            throw err;\n          }\n        }\n\n        const [type, isFlag] = handlers[argName];\n\n        if (!isFlag && j + 1 < separatedArguments.length) {\n          throw new TypeError(`Option requires argument (but was followed by another short argument): ${originalArgName}`);\n        }\n\n        if (isFlag) {\n          result[argName] = type(true, argName, result[argName]);\n        } else if (argStr === undefined) {\n          if (argv.length < i + 2 || argv[i + 1].length > 1 && argv[i + 1][0] === '-' && !(argv[i + 1].match(/^-?\\d*(\\.(?=\\d))?\\d*$/) && (type === Number || // eslint-disable-next-line no-undef\n          typeof BigInt !== 'undefined' && type === BigInt))) {\n            const extended = originalArgName === argName ? '' : ` (alias for ${argName})`;\n            throw new Error(`Option requires argument: ${originalArgName}${extended}`);\n          }\n\n          result[argName] = type(argv[i + 1], argName, result[argName]);\n          ++i;\n        } else {\n          result[argName] = type(argStr, argName, result[argName]);\n        }\n      }\n    } else {\n      result._.push(wholeArg);\n    }\n  }\n\n  return result;\n}\n\narg.flag = fn => {\n  fn[flagSymbol] = true;\n  return fn;\n}; // Utility types\n\n\narg.COUNT = arg.flag((v, name, existingCount) => (existingCount || 0) + 1);\nmodule.exports = arg;","map":{"version":3,"names":["flagSymbol","Symbol","arg","opts","argv","process","slice","permissive","stopAtPositional","Error","result","_","aliases","handlers","key","Object","keys","TypeError","length","type","isFlag","Array","isArray","fn","value","name","prev","push","Boolean","i","len","wholeArg","concat","separatedArguments","split","map","a","j","originalArgName","argStr","undefined","argName","err","code","match","Number","BigInt","extended","flag","COUNT","v","existingCount","module","exports"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/ts-node/node_modules/arg/index.js"],"sourcesContent":["const flagSymbol = Symbol('arg flag');\n\nfunction arg(opts, {argv = process.argv.slice(2), permissive = false, stopAtPositional = false} = {}) {\n\tif (!opts) {\n\t\tthrow new Error('Argument specification object is required');\n\t}\n\n\tconst result = {_: []};\n\n\tconst aliases = {};\n\tconst handlers = {};\n\n\tfor (const key of Object.keys(opts)) {\n\t\tif (!key) {\n\t\t\tthrow new TypeError('Argument key cannot be an empty string');\n\t\t}\n\n\t\tif (key[0] !== '-') {\n\t\t\tthrow new TypeError(`Argument key must start with '-' but found: '${key}'`);\n\t\t}\n\n\t\tif (key.length === 1) {\n\t\t\tthrow new TypeError(`Argument key must have a name; singular '-' keys are not allowed: ${key}`);\n\t\t}\n\n\t\tif (typeof opts[key] === 'string') {\n\t\t\taliases[key] = opts[key];\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet type = opts[key];\n\t\tlet isFlag = false;\n\n\t\tif (Array.isArray(type) && type.length === 1 && typeof type[0] === 'function') {\n\t\t\tconst [fn] = type;\n\t\t\ttype = (value, name, prev = []) => {\n\t\t\t\tprev.push(fn(value, name, prev[prev.length - 1]));\n\t\t\t\treturn prev;\n\t\t\t};\n\t\t\tisFlag = fn === Boolean || fn[flagSymbol] === true;\n\t\t} else if (typeof type === 'function') {\n\t\t\tisFlag = type === Boolean || type[flagSymbol] === true;\n\t\t} else {\n\t\t\tthrow new TypeError(`Type missing or not a function or valid array type: ${key}`);\n\t\t}\n\n\t\tif (key[1] !== '-' && key.length > 2) {\n\t\t\tthrow new TypeError(`Short argument keys (with a single hyphen) must have only one character: ${key}`);\n\t\t}\n\n\t\thandlers[key] = [type, isFlag];\n\t}\n\n\tfor (let i = 0, len = argv.length; i < len; i++) {\n\t\tconst wholeArg = argv[i];\n\n\t\tif (stopAtPositional && result._.length > 0) {\n\t\t\tresult._ = result._.concat(argv.slice(i));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wholeArg === '--') {\n\t\t\tresult._ = result._.concat(argv.slice(i + 1));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wholeArg.length > 1 && wholeArg[0] === '-') {\n\t\t\t/* eslint-disable operator-linebreak */\n\t\t\tconst separatedArguments = (wholeArg[1] === '-' || wholeArg.length === 2)\n\t\t\t\t? [wholeArg]\n\t\t\t\t: wholeArg.slice(1).split('').map(a => `-${a}`);\n\t\t\t/* eslint-enable operator-linebreak */\n\n\t\t\tfor (let j = 0; j < separatedArguments.length; j++) {\n\t\t\t\tconst arg = separatedArguments[j];\n\t\t\t\tconst [originalArgName, argStr] = arg[1] === '-' ? arg.split(/=(.*)/, 2) : [arg, undefined];\n\n\t\t\t\tlet argName = originalArgName;\n\t\t\t\twhile (argName in aliases) {\n\t\t\t\t\targName = aliases[argName];\n\t\t\t\t}\n\n\t\t\t\tif (!(argName in handlers)) {\n\t\t\t\t\tif (permissive) {\n\t\t\t\t\t\tresult._.push(arg);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst err = new Error(`Unknown or unexpected option: ${originalArgName}`);\n\t\t\t\t\t\terr.code = 'ARG_UNKNOWN_OPTION';\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst [type, isFlag] = handlers[argName];\n\n\t\t\t\tif (!isFlag && ((j + 1) < separatedArguments.length)) {\n\t\t\t\t\tthrow new TypeError(`Option requires argument (but was followed by another short argument): ${originalArgName}`);\n\t\t\t\t}\n\n\t\t\t\tif (isFlag) {\n\t\t\t\t\tresult[argName] = type(true, argName, result[argName]);\n\t\t\t\t} else if (argStr === undefined) {\n\t\t\t\t\tif (\n\t\t\t\t\t\targv.length < i + 2 ||\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\targv[i + 1].length > 1 &&\n\t\t\t\t\t\t\t(argv[i + 1][0] === '-') &&\n\t\t\t\t\t\t\t!(\n\t\t\t\t\t\t\t\targv[i + 1].match(/^-?\\d*(\\.(?=\\d))?\\d*$/) &&\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\ttype === Number ||\n\t\t\t\t\t\t\t\t\t// eslint-disable-next-line no-undef\n\t\t\t\t\t\t\t\t\t(typeof BigInt !== 'undefined' && type === BigInt)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst extended = originalArgName === argName ? '' : ` (alias for ${argName})`;\n\t\t\t\t\t\tthrow new Error(`Option requires argument: ${originalArgName}${extended}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tresult[argName] = type(argv[i + 1], argName, result[argName]);\n\t\t\t\t\t++i;\n\t\t\t\t} else {\n\t\t\t\t\tresult[argName] = type(argStr, argName, result[argName]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tresult._.push(wholeArg);\n\t\t}\n\t}\n\n\treturn result;\n}\n\narg.flag = fn => {\n\tfn[flagSymbol] = true;\n\treturn fn;\n};\n\n// Utility types\narg.COUNT = arg.flag((v, name, existingCount) => (existingCount || 0) + 1);\n\nmodule.exports = arg;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}