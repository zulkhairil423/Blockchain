{"ast":null,"code":"/* eslint-disable */\n'use strict'; // Extracted from node/lib/internal/fixed_queue.js\n// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.\n\nconst kSize = 2048;\nconst kMask = kSize - 1; // The FixedQueue is implemented as a singly-linked list of fixed-size\n// circular buffers. It looks something like this:\n//\n//  head                                                       tail\n//    |                                                          |\n//    v                                                          v\n// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n// +-----------+               +-----------+                  +-----------+\n// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |       bottom --> |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |    ...    |               |    ...    |                  |    ...    |\n// |   item    |               |   item    |                  |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |  [empty]  | <-- top       |   item    |                  |   item    |\n// |  [empty]  |               |   item    |                  |   item    |\n// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |\n// +-----------+               +-----------+                  +-----------+\n//\n// Or, if there is only one circular buffer, it looks something\n// like either of these:\n//\n//  head   tail                                 head   tail\n//    |     |                                     |     |\n//    v     v                                     v     v\n// +-----------+                               +-----------+\n// |  [null]   |                               |  [null]   |\n// +-----------+                               +-----------+\n// |  [empty]  |                               |   item    |\n// |  [empty]  |                               |   item    |\n// |   item    | <-- bottom            top --> |  [empty]  |\n// |   item    |                               |  [empty]  |\n// |  [empty]  | <-- top            bottom --> |   item    |\n// |  [empty]  |                               |   item    |\n// +-----------+                               +-----------+\n//\n// Adding a value means moving `top` forward by one, removing means\n// moving `bottom` forward by one. After reaching the end, the queue\n// wraps around.\n//\n// When `top === bottom` the current queue is empty and when\n// `top + 1 === bottom` it's full. This wastes a single space of storage\n// but allows much quicker checks.\n\nclass FixedCircularBuffer {\n  constructor() {\n    this.bottom = 0;\n    this.top = 0;\n    this.list = new Array(kSize);\n    this.next = null;\n  }\n\n  isEmpty() {\n    return this.top === this.bottom;\n  }\n\n  isFull() {\n    return (this.top + 1 & kMask) === this.bottom;\n  }\n\n  push(data) {\n    this.list[this.top] = data;\n    this.top = this.top + 1 & kMask;\n  }\n\n  shift() {\n    const nextItem = this.list[this.bottom];\n    if (nextItem === undefined) return null;\n    this.list[this.bottom] = undefined;\n    this.bottom = this.bottom + 1 & kMask;\n    return nextItem;\n  }\n\n}\n\nmodule.exports = class FixedQueue {\n  constructor() {\n    this.head = this.tail = new FixedCircularBuffer();\n  }\n\n  isEmpty() {\n    return this.head.isEmpty();\n  }\n\n  push(data) {\n    if (this.head.isFull()) {\n      // Head is full: Creates a new queue, sets the old queue's `.next` to it,\n      // and sets it as the new main queue.\n      this.head = this.head.next = new FixedCircularBuffer();\n    }\n\n    this.head.push(data);\n  }\n\n  shift() {\n    const tail = this.tail;\n    const next = tail.shift();\n\n    if (tail.isEmpty() && tail.next !== null) {\n      // If there is another queue, it forms the new tail.\n      this.tail = tail.next;\n    }\n\n    return next;\n  }\n\n};","map":{"version":3,"names":["kSize","kMask","FixedCircularBuffer","constructor","bottom","top","list","Array","next","isEmpty","isFull","push","data","shift","nextItem","undefined","module","exports","FixedQueue","head","tail"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/undici/lib/node/fixed-queue.js"],"sourcesContent":["/* eslint-disable */\n\n'use strict'\n\n// Extracted from node/lib/internal/fixed_queue.js\n\n// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.\nconst kSize = 2048;\nconst kMask = kSize - 1;\n\n// The FixedQueue is implemented as a singly-linked list of fixed-size\n// circular buffers. It looks something like this:\n//\n//  head                                                       tail\n//    |                                                          |\n//    v                                                          v\n// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n// +-----------+               +-----------+                  +-----------+\n// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |       bottom --> |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |    ...    |               |    ...    |                  |    ...    |\n// |   item    |               |   item    |                  |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |  [empty]  | <-- top       |   item    |                  |   item    |\n// |  [empty]  |               |   item    |                  |   item    |\n// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |\n// +-----------+               +-----------+                  +-----------+\n//\n// Or, if there is only one circular buffer, it looks something\n// like either of these:\n//\n//  head   tail                                 head   tail\n//    |     |                                     |     |\n//    v     v                                     v     v\n// +-----------+                               +-----------+\n// |  [null]   |                               |  [null]   |\n// +-----------+                               +-----------+\n// |  [empty]  |                               |   item    |\n// |  [empty]  |                               |   item    |\n// |   item    | <-- bottom            top --> |  [empty]  |\n// |   item    |                               |  [empty]  |\n// |  [empty]  | <-- top            bottom --> |   item    |\n// |  [empty]  |                               |   item    |\n// +-----------+                               +-----------+\n//\n// Adding a value means moving `top` forward by one, removing means\n// moving `bottom` forward by one. After reaching the end, the queue\n// wraps around.\n//\n// When `top === bottom` the current queue is empty and when\n// `top + 1 === bottom` it's full. This wastes a single space of storage\n// but allows much quicker checks.\n\nclass FixedCircularBuffer {\n  constructor() {\n    this.bottom = 0;\n    this.top = 0;\n    this.list = new Array(kSize);\n    this.next = null;\n  }\n\n  isEmpty() {\n    return this.top === this.bottom;\n  }\n\n  isFull() {\n    return ((this.top + 1) & kMask) === this.bottom;\n  }\n\n  push(data) {\n    this.list[this.top] = data;\n    this.top = (this.top + 1) & kMask;\n  }\n\n  shift() {\n    const nextItem = this.list[this.bottom];\n    if (nextItem === undefined)\n      return null;\n    this.list[this.bottom] = undefined;\n    this.bottom = (this.bottom + 1) & kMask;\n    return nextItem;\n  }\n}\n\nmodule.exports = class FixedQueue {\n  constructor() {\n    this.head = this.tail = new FixedCircularBuffer();\n  }\n\n  isEmpty() {\n    return this.head.isEmpty();\n  }\n\n  push(data) {\n    if (this.head.isFull()) {\n      // Head is full: Creates a new queue, sets the old queue's `.next` to it,\n      // and sets it as the new main queue.\n      this.head = this.head.next = new FixedCircularBuffer();\n    }\n    this.head.push(data);\n  }\n\n  shift() {\n    const tail = this.tail;\n    const next = tail.shift();\n    if (tail.isEmpty() && tail.next !== null) {\n      // If there is another queue, it forms the new tail.\n      this.tail = tail.next;\n    }\n    return next;\n  }\n};\n"],"mappings":"AAAA;AAEA,a,CAEA;AAEA;;AACA,MAAMA,KAAK,GAAG,IAAd;AACA,MAAMC,KAAK,GAAGD,KAAK,GAAG,CAAtB,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAME,mBAAN,CAA0B;EACxBC,WAAW,GAAG;IACZ,KAAKC,MAAL,GAAc,CAAd;IACA,KAAKC,GAAL,GAAW,CAAX;IACA,KAAKC,IAAL,GAAY,IAAIC,KAAJ,CAAUP,KAAV,CAAZ;IACA,KAAKQ,IAAL,GAAY,IAAZ;EACD;;EAEDC,OAAO,GAAG;IACR,OAAO,KAAKJ,GAAL,KAAa,KAAKD,MAAzB;EACD;;EAEDM,MAAM,GAAG;IACP,OAAO,CAAE,KAAKL,GAAL,GAAW,CAAZ,GAAiBJ,KAAlB,MAA6B,KAAKG,MAAzC;EACD;;EAEDO,IAAI,CAACC,IAAD,EAAO;IACT,KAAKN,IAAL,CAAU,KAAKD,GAAf,IAAsBO,IAAtB;IACA,KAAKP,GAAL,GAAY,KAAKA,GAAL,GAAW,CAAZ,GAAiBJ,KAA5B;EACD;;EAEDY,KAAK,GAAG;IACN,MAAMC,QAAQ,GAAG,KAAKR,IAAL,CAAU,KAAKF,MAAf,CAAjB;IACA,IAAIU,QAAQ,KAAKC,SAAjB,EACE,OAAO,IAAP;IACF,KAAKT,IAAL,CAAU,KAAKF,MAAf,IAAyBW,SAAzB;IACA,KAAKX,MAAL,GAAe,KAAKA,MAAL,GAAc,CAAf,GAAoBH,KAAlC;IACA,OAAOa,QAAP;EACD;;AA5BuB;;AA+B1BE,MAAM,CAACC,OAAP,GAAiB,MAAMC,UAAN,CAAiB;EAChCf,WAAW,GAAG;IACZ,KAAKgB,IAAL,GAAY,KAAKC,IAAL,GAAY,IAAIlB,mBAAJ,EAAxB;EACD;;EAEDO,OAAO,GAAG;IACR,OAAO,KAAKU,IAAL,CAAUV,OAAV,EAAP;EACD;;EAEDE,IAAI,CAACC,IAAD,EAAO;IACT,IAAI,KAAKO,IAAL,CAAUT,MAAV,EAAJ,EAAwB;MACtB;MACA;MACA,KAAKS,IAAL,GAAY,KAAKA,IAAL,CAAUX,IAAV,GAAiB,IAAIN,mBAAJ,EAA7B;IACD;;IACD,KAAKiB,IAAL,CAAUR,IAAV,CAAeC,IAAf;EACD;;EAEDC,KAAK,GAAG;IACN,MAAMO,IAAI,GAAG,KAAKA,IAAlB;IACA,MAAMZ,IAAI,GAAGY,IAAI,CAACP,KAAL,EAAb;;IACA,IAAIO,IAAI,CAACX,OAAL,MAAkBW,IAAI,CAACZ,IAAL,KAAc,IAApC,EAA0C;MACxC;MACA,KAAKY,IAAL,GAAYA,IAAI,CAACZ,IAAjB;IACD;;IACD,OAAOA,IAAP;EACD;;AA1B+B,CAAlC"},"metadata":{},"sourceType":"script"}