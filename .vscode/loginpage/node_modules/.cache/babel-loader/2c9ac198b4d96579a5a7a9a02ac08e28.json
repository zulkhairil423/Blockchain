{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toType = exports.TypeOutput = void 0;\n\nconst bytes_1 = require(\"./bytes\");\n\nconst internal_1 = require(\"./internal\");\n/**\n * Type output options\n */\n\n\nvar TypeOutput;\n\n(function (TypeOutput) {\n  TypeOutput[TypeOutput[\"Number\"] = 0] = \"Number\";\n  TypeOutput[TypeOutput[\"BigInt\"] = 1] = \"BigInt\";\n  TypeOutput[TypeOutput[\"Buffer\"] = 2] = \"Buffer\";\n  TypeOutput[TypeOutput[\"PrefixedHexString\"] = 3] = \"PrefixedHexString\";\n})(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));\n\nfunction toType(input, outputType) {\n  if (input === null) {\n    return null;\n  }\n\n  if (input === undefined) {\n    return undefined;\n  }\n\n  if (typeof input === 'string' && !(0, internal_1.isHexString)(input)) {\n    throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);\n  } else if (typeof input === 'number' && !Number.isSafeInteger(input)) {\n    throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');\n  }\n\n  const output = (0, bytes_1.toBuffer)(input);\n\n  switch (outputType) {\n    case TypeOutput.Buffer:\n      return output;\n\n    case TypeOutput.BigInt:\n      return (0, bytes_1.bufferToBigInt)(output);\n\n    case TypeOutput.Number:\n      {\n        const bigInt = (0, bytes_1.bufferToBigInt)(output);\n\n        if (bigInt > BigInt(Number.MAX_SAFE_INTEGER)) {\n          throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)');\n        }\n\n        return Number(bigInt);\n      }\n\n    case TypeOutput.PrefixedHexString:\n      return (0, bytes_1.bufferToHex)(output);\n\n    default:\n      throw new Error('unknown outputType');\n  }\n}\n\nexports.toType = toType;","map":{"version":3,"mappings":";;;;;;;AAAA;;AACA;AAmDA;;;;;AAGA,IAAYA,UAAZ;;AAAA,WAAYA,UAAZ,EAAsB;EACpBA;EACAA;EACAA;EACAA;AACD,CALD,EAAYA,UAAU,GAAVC,4CAAU,EAAV,CAAZ;;AA0BA,SAAgBC,MAAhB,CACEC,KADF,EAEEC,UAFF,EAEe;EAEb,IAAID,KAAK,KAAK,IAAd,EAAoB;IAClB,OAAO,IAAP;EACD;;EACD,IAAIA,KAAK,KAAKE,SAAd,EAAyB;IACvB,OAAOA,SAAP;EACD;;EAED,IAAI,OAAOF,KAAP,KAAiB,QAAjB,IAA6B,CAAC,4BAAYA,KAAZ,CAAlC,EAAsD;IACpD,MAAM,IAAIG,KAAJ,CAAU,sDAAsDH,KAAK,EAArE,CAAN;EACD,CAFD,MAEO,IAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6B,CAACI,MAAM,CAACC,aAAP,CAAqBL,KAArB,CAAlC,EAA+D;IACpE,MAAM,IAAIG,KAAJ,CACJ,6FADI,CAAN;EAGD;;EAED,MAAMG,MAAM,GAAG,sBAASN,KAAT,CAAf;;EAEA,QAAQC,UAAR;IACE,KAAKJ,UAAU,CAACU,MAAhB;MACE,OAAOD,MAAP;;IACF,KAAKT,UAAU,CAACW,MAAhB;MACE,OAAO,4BAAeF,MAAf,CAAP;;IACF,KAAKT,UAAU,CAACO,MAAhB;MAAwB;QACtB,MAAMK,MAAM,GAAG,4BAAeH,MAAf,CAAf;;QACA,IAAIG,MAAM,GAAGD,MAAM,CAACJ,MAAM,CAACM,gBAAR,CAAnB,EAA8C;UAC5C,MAAM,IAAIP,KAAJ,CACJ,8FADI,CAAN;QAGD;;QACD,OAAOC,MAAM,CAACK,MAAD,CAAb;MACD;;IACD,KAAKZ,UAAU,CAACc,iBAAhB;MACE,OAAO,yBAAYL,MAAZ,CAAP;;IACF;MACE,MAAM,IAAIH,KAAJ,CAAU,oBAAV,CAAN;EAjBJ;AAmBD;;AAxCDL","names":["TypeOutput","exports","toType","input","outputType","undefined","Error","Number","isSafeInteger","output","Buffer","BigInt","bigInt","MAX_SAFE_INTEGER","PrefixedHexString"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\@nomicfoundation\\ethereumjs-util\\src\\types.ts"],"sourcesContent":["import { bufferToBigInt, bufferToHex, toBuffer } from './bytes'\nimport { isHexString } from './internal'\n\nimport type { Address } from './address'\nimport type { ToBufferInputTypes } from './bytes'\n\n/*\n * A type that represents an input that can be converted to a BigInt.\n */\nexport type BigIntLike = bigint | PrefixedHexString | number | Buffer\n\n/*\n * A type that represents an input that can be converted to a Buffer.\n */\nexport type BufferLike =\n  | Buffer\n  | Uint8Array\n  | number[]\n  | number\n  | bigint\n  | TransformableToBuffer\n  | PrefixedHexString\n\n/*\n * A type that represents a `0x`-prefixed hex string.\n */\nexport type PrefixedHexString = string\n\n/**\n * A type that represents an input that can be converted to an Address.\n */\nexport type AddressLike = Address | Buffer | PrefixedHexString\n\n/*\n * A type that represents an object that has a `toArray()` method.\n */\nexport interface TransformableToArray {\n  toArray(): Uint8Array\n  toBuffer?(): Buffer\n}\n\n/*\n * A type that represents an object that has a `toBuffer()` method.\n */\nexport interface TransformableToBuffer {\n  toBuffer(): Buffer\n  toArray?(): Uint8Array\n}\n\nexport type NestedUint8Array = Array<Uint8Array | NestedUint8Array>\nexport type NestedBufferArray = Array<Buffer | NestedBufferArray>\n\n/**\n * Type output options\n */\nexport enum TypeOutput {\n  Number,\n  BigInt,\n  Buffer,\n  PrefixedHexString,\n}\n\nexport type TypeOutputReturnType = {\n  [TypeOutput.Number]: number\n  [TypeOutput.BigInt]: bigint\n  [TypeOutput.Buffer]: Buffer\n  [TypeOutput.PrefixedHexString]: PrefixedHexString\n}\n\n/**\n * Convert an input to a specified type.\n * Input of null/undefined returns null/undefined regardless of the output type.\n * @param input value to convert\n * @param outputType type to output\n */\nexport function toType<T extends TypeOutput>(input: null, outputType: T): null\nexport function toType<T extends TypeOutput>(input: undefined, outputType: T): undefined\nexport function toType<T extends TypeOutput>(\n  input: ToBufferInputTypes,\n  outputType: T\n): TypeOutputReturnType[T]\nexport function toType<T extends TypeOutput>(\n  input: ToBufferInputTypes,\n  outputType: T\n): TypeOutputReturnType[T] | undefined | null {\n  if (input === null) {\n    return null\n  }\n  if (input === undefined) {\n    return undefined\n  }\n\n  if (typeof input === 'string' && !isHexString(input)) {\n    throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`)\n  } else if (typeof input === 'number' && !Number.isSafeInteger(input)) {\n    throw new Error(\n      'The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)'\n    )\n  }\n\n  const output = toBuffer(input)\n\n  switch (outputType) {\n    case TypeOutput.Buffer:\n      return output as TypeOutputReturnType[T]\n    case TypeOutput.BigInt:\n      return bufferToBigInt(output) as TypeOutputReturnType[T]\n    case TypeOutput.Number: {\n      const bigInt = bufferToBigInt(output)\n      if (bigInt > BigInt(Number.MAX_SAFE_INTEGER)) {\n        throw new Error(\n          'The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)'\n        )\n      }\n      return Number(bigInt) as TypeOutputReturnType[T]\n    }\n    case TypeOutput.PrefixedHexString:\n      return bufferToHex(output) as TypeOutputReturnType[T]\n    default:\n      throw new Error('unknown outputType')\n  }\n}\n"]},"metadata":{},"sourceType":"script"}