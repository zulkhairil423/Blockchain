{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DependencyGraph = void 0;\n\nclass DependencyGraph {\n  constructor() {\n    this._resolvedFiles = new Map();\n    this._dependenciesPerFile = new Map();\n    this._visitedFiles = new Set();\n  }\n\n  static async createFromResolvedFiles(resolver, resolvedFiles) {\n    const graph = new DependencyGraph();\n    await Promise.all(resolvedFiles.map(resolvedFile => graph._addDependenciesFrom(resolver, resolvedFile)));\n    return graph;\n  }\n\n  getResolvedFiles() {\n    return Array.from(this._resolvedFiles.values());\n  }\n\n  has(file) {\n    return this._resolvedFiles.has(file.sourceName);\n  }\n\n  isEmpty() {\n    return this._resolvedFiles.size === 0;\n  }\n\n  entries() {\n    return Array.from(this._dependenciesPerFile.entries()).map(_ref => {\n      let [key, value] = _ref;\n      return [this._resolvedFiles.get(key), value];\n    });\n  }\n\n  getDependencies(file) {\n    const dependencies = this._dependenciesPerFile.get(file.sourceName) ?? new Set();\n    return [...dependencies];\n  }\n\n  getTransitiveDependencies(file) {\n    const visited = new Set();\n\n    const transitiveDependencies = this._getTransitiveDependencies(file, visited, []);\n\n    return [...transitiveDependencies];\n  }\n\n  getConnectedComponents() {\n    const undirectedGraph = {};\n\n    for (const [sourceName, dependencies] of this._dependenciesPerFile.entries()) {\n      undirectedGraph[sourceName] = undirectedGraph[sourceName] ?? new Set();\n\n      for (const dependency of dependencies) {\n        undirectedGraph[dependency.sourceName] = undirectedGraph[dependency.sourceName] ?? new Set();\n        undirectedGraph[sourceName].add(dependency.sourceName);\n        undirectedGraph[dependency.sourceName].add(sourceName);\n      }\n    }\n\n    const components = [];\n    const visited = new Set();\n\n    for (const node of Object.keys(undirectedGraph)) {\n      if (visited.has(node)) {\n        continue;\n      }\n\n      visited.add(node);\n      const component = new Set([node]);\n      const stack = [...undirectedGraph[node]];\n\n      while (stack.length > 0) {\n        const newNode = stack.pop();\n\n        if (visited.has(newNode)) {\n          continue;\n        }\n\n        visited.add(newNode);\n        component.add(newNode);\n        [...undirectedGraph[newNode]].forEach(adjacent => {\n          if (!visited.has(adjacent)) {\n            stack.push(adjacent);\n          }\n        });\n      }\n\n      components.push(component);\n    }\n\n    const connectedComponents = [];\n\n    for (const component of components) {\n      const dependencyGraph = new DependencyGraph();\n\n      for (const sourceName of component) {\n        const file = this._resolvedFiles.get(sourceName);\n\n        const dependencies = this._dependenciesPerFile.get(sourceName);\n\n        dependencyGraph._resolvedFiles.set(sourceName, file);\n\n        dependencyGraph._dependenciesPerFile.set(sourceName, dependencies);\n      }\n\n      connectedComponents.push(dependencyGraph);\n    }\n\n    return connectedComponents;\n  }\n\n  _getTransitiveDependencies(file, visited, path) {\n    if (visited.has(file)) {\n      return new Set();\n    }\n\n    visited.add(file);\n    const directDependencies = this.getDependencies(file).map(dependency => ({\n      dependency,\n      path\n    }));\n    const transitiveDependencies = new Set(directDependencies);\n\n    for (const {\n      dependency\n    } of transitiveDependencies) {\n      this._getTransitiveDependencies(dependency, visited, path.concat(dependency)).forEach(x => transitiveDependencies.add(x));\n    }\n\n    return transitiveDependencies;\n  }\n\n  async _addDependenciesFrom(resolver, file) {\n    if (this._visitedFiles.has(file.absolutePath)) {\n      return;\n    }\n\n    this._visitedFiles.add(file.absolutePath);\n\n    const dependencies = new Set();\n\n    this._resolvedFiles.set(file.sourceName, file);\n\n    this._dependenciesPerFile.set(file.sourceName, dependencies);\n\n    await Promise.all(file.content.imports.map(async imp => {\n      const dependency = await resolver.resolveImport(file, imp);\n      dependencies.add(dependency);\n      await this._addDependenciesFrom(resolver, dependency);\n    }));\n  }\n\n}\n\nexports.DependencyGraph = DependencyGraph;","map":{"version":3,"mappings":"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","names":["DependencyGraph","constructor","Map","Set","createFromResolvedFiles","resolver","resolvedFiles","graph","Promise","all","map","resolvedFile","_addDependenciesFrom","getResolvedFiles","Array","from","_resolvedFiles","values","has","file","sourceName","isEmpty","size","entries","_dependenciesPerFile","key","value","get","getDependencies","dependencies","getTransitiveDependencies","visited","transitiveDependencies","_getTransitiveDependencies","getConnectedComponents","undirectedGraph","dependency","add","components","node","Object","keys","component","stack","length","newNode","pop","forEach","adjacent","push","connectedComponents","dependencyGraph","set","path","directDependencies","concat","x","_visitedFiles","absolutePath","content","imports","imp","resolveImport","exports"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\hardhat\\src\\internal\\solidity\\dependencyGraph.ts"],"sourcesContent":["import * as taskTypes from \"../../types/builtin-tasks\";\n\nimport { ResolvedFile, Resolver } from \"./resolver\";\n\nexport class DependencyGraph implements taskTypes.DependencyGraph {\n  public static async createFromResolvedFiles(\n    resolver: Resolver,\n    resolvedFiles: ResolvedFile[]\n  ): Promise<DependencyGraph> {\n    const graph = new DependencyGraph();\n\n    await Promise.all(\n      resolvedFiles.map((resolvedFile) =>\n        graph._addDependenciesFrom(resolver, resolvedFile)\n      )\n    );\n\n    return graph;\n  }\n\n  private _resolvedFiles = new Map<string, ResolvedFile>();\n  private _dependenciesPerFile = new Map<string, Set<ResolvedFile>>();\n\n  private readonly _visitedFiles = new Set<string>();\n\n  private constructor() {}\n\n  public getResolvedFiles(): ResolvedFile[] {\n    return Array.from(this._resolvedFiles.values());\n  }\n\n  public has(file: ResolvedFile): boolean {\n    return this._resolvedFiles.has(file.sourceName);\n  }\n\n  public isEmpty(): boolean {\n    return this._resolvedFiles.size === 0;\n  }\n\n  public entries(): Array<[ResolvedFile, Set<ResolvedFile>]> {\n    return Array.from(this._dependenciesPerFile.entries()).map(\n      ([key, value]) => [this._resolvedFiles.get(key)!, value]\n    );\n  }\n\n  public getDependencies(file: ResolvedFile): ResolvedFile[] {\n    const dependencies =\n      this._dependenciesPerFile.get(file.sourceName) ?? new Set();\n\n    return [...dependencies];\n  }\n\n  public getTransitiveDependencies(\n    file: ResolvedFile\n  ): taskTypes.TransitiveDependency[] {\n    const visited = new Set<ResolvedFile>();\n\n    const transitiveDependencies = this._getTransitiveDependencies(\n      file,\n      visited,\n      []\n    );\n\n    return [...transitiveDependencies];\n  }\n\n  public getConnectedComponents(): DependencyGraph[] {\n    const undirectedGraph: Record<string, Set<string>> = {};\n\n    for (const [\n      sourceName,\n      dependencies,\n    ] of this._dependenciesPerFile.entries()) {\n      undirectedGraph[sourceName] = undirectedGraph[sourceName] ?? new Set();\n      for (const dependency of dependencies) {\n        undirectedGraph[dependency.sourceName] =\n          undirectedGraph[dependency.sourceName] ?? new Set();\n        undirectedGraph[sourceName].add(dependency.sourceName);\n        undirectedGraph[dependency.sourceName].add(sourceName);\n      }\n    }\n\n    const components: Array<Set<string>> = [];\n    const visited = new Set<string>();\n\n    for (const node of Object.keys(undirectedGraph)) {\n      if (visited.has(node)) {\n        continue;\n      }\n      visited.add(node);\n      const component = new Set([node]);\n      const stack = [...undirectedGraph[node]];\n      while (stack.length > 0) {\n        const newNode = stack.pop()!;\n        if (visited.has(newNode)) {\n          continue;\n        }\n        visited.add(newNode);\n        component.add(newNode);\n        [...undirectedGraph[newNode]].forEach((adjacent) => {\n          if (!visited.has(adjacent)) {\n            stack.push(adjacent);\n          }\n        });\n      }\n\n      components.push(component);\n    }\n\n    const connectedComponents: DependencyGraph[] = [];\n    for (const component of components) {\n      const dependencyGraph = new DependencyGraph();\n\n      for (const sourceName of component) {\n        const file = this._resolvedFiles.get(sourceName)!;\n        const dependencies = this._dependenciesPerFile.get(sourceName)!;\n\n        dependencyGraph._resolvedFiles.set(sourceName, file);\n        dependencyGraph._dependenciesPerFile.set(sourceName, dependencies);\n      }\n      connectedComponents.push(dependencyGraph);\n    }\n\n    return connectedComponents;\n  }\n\n  private _getTransitiveDependencies(\n    file: ResolvedFile,\n    visited: Set<ResolvedFile>,\n    path: ResolvedFile[]\n  ): Set<taskTypes.TransitiveDependency> {\n    if (visited.has(file)) {\n      return new Set();\n    }\n    visited.add(file);\n\n    const directDependencies: taskTypes.TransitiveDependency[] =\n      this.getDependencies(file).map((dependency) => ({\n        dependency,\n        path,\n      }));\n\n    const transitiveDependencies = new Set<taskTypes.TransitiveDependency>(\n      directDependencies\n    );\n\n    for (const { dependency } of transitiveDependencies) {\n      this._getTransitiveDependencies(\n        dependency,\n        visited,\n        path.concat(dependency)\n      ).forEach((x) => transitiveDependencies.add(x));\n    }\n\n    return transitiveDependencies;\n  }\n\n  private async _addDependenciesFrom(\n    resolver: Resolver,\n    file: ResolvedFile\n  ): Promise<void> {\n    if (this._visitedFiles.has(file.absolutePath)) {\n      return;\n    }\n\n    this._visitedFiles.add(file.absolutePath);\n\n    const dependencies = new Set<ResolvedFile>();\n    this._resolvedFiles.set(file.sourceName, file);\n    this._dependenciesPerFile.set(file.sourceName, dependencies);\n\n    await Promise.all(\n      file.content.imports.map(async (imp) => {\n        const dependency = await resolver.resolveImport(file, imp);\n        dependencies.add(dependency);\n\n        await this._addDependenciesFrom(resolver, dependency);\n      })\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"script"}