{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mnemonicToSeedSync = exports.mnemonicToSeed = exports.validateMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.generateMnemonic = void 0;\n/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\n\nconst _assert_1 = require(\"@noble/hashes/_assert\");\n\nconst pbkdf2_1 = require(\"@noble/hashes/pbkdf2\");\n\nconst sha256_1 = require(\"@noble/hashes/sha256\");\n\nconst sha512_1 = require(\"@noble/hashes/sha512\");\n\nconst utils_1 = require(\"@noble/hashes/utils\");\n\nconst base_1 = require(\"@scure/base\"); // Japanese wordlist\n\n\nconst isJapanese = wordlist => wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093'; // Normalization replaces equivalent sequences of characters\n// so that any two texts that are equivalent will be reduced\n// to the same sequence of code points, called the normal form of the original text.\n\n\nfunction nfkd(str) {\n  if (typeof str !== 'string') throw new TypeError(`Invalid mnemonic type: ${typeof str}`);\n  return str.normalize('NFKD');\n}\n\nfunction normalize(str) {\n  const norm = nfkd(str);\n  const words = norm.split(' ');\n  if (![12, 15, 18, 21, 24].includes(words.length)) throw new Error('Invalid mnemonic');\n  return {\n    nfkd: norm,\n    words\n  };\n}\n\nfunction assertEntropy(entropy) {\n  _assert_1.default.bytes(entropy, 16, 20, 24, 28, 32);\n}\n/**\n * Generate x random words. Uses Cryptographically-Secure Random Number Generator.\n * @param wordlist imported wordlist for specific language\n * @param strength mnemonic strength 128-256 bits\n * @example\n * generateMnemonic(wordlist, 128)\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */\n\n\nfunction generateMnemonic(wordlist) {\n  let strength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 128;\n\n  _assert_1.default.number(strength);\n\n  if (strength % 32 !== 0 || strength > 256) throw new TypeError('Invalid entropy');\n  return entropyToMnemonic((0, utils_1.randomBytes)(strength / 8), wordlist);\n}\n\nexports.generateMnemonic = generateMnemonic;\n\nconst calcChecksum = entropy => {\n  // Checksum is ent.length/4 bits long\n  const bitsLeft = 8 - entropy.length / 4; // Zero rightmost \"bitsLeft\" bits in byte\n  // For example: bitsLeft=4 val=10111101 -> 10110000\n\n  return new Uint8Array([(0, sha256_1.sha256)(entropy)[0] >> bitsLeft << bitsLeft]);\n};\n\nfunction getCoder(wordlist) {\n  if (!Array.isArray(wordlist) || wordlist.length !== 2 ** 11 || typeof wordlist[0] !== 'string') throw new Error('Worlist: expected array of 2048 strings');\n  wordlist.forEach(i => {\n    if (typeof i !== 'string') throw new Error(`Wordlist: non-string element: ${i}`);\n  });\n  return base_1.utils.chain(base_1.utils.checksum(1, calcChecksum), base_1.utils.radix2(11, true), base_1.utils.alphabet(wordlist));\n}\n/**\n * Reversible: Converts mnemonic string to raw entropy in form of byte array.\n * @param mnemonic 12-24 words\n * @param wordlist imported wordlist for specific language\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToEntropy(mnem, wordlist)\n * // Produces\n * new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ])\n */\n\n\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n  const {\n    words\n  } = normalize(mnemonic);\n  const entropy = getCoder(wordlist).decode(words);\n  assertEntropy(entropy);\n  return entropy;\n}\n\nexports.mnemonicToEntropy = mnemonicToEntropy;\n/**\n * Reversible: Converts raw entropy in form of byte array to mnemonic string.\n * @param entropy byte array\n * @param wordlist imported wordlist for specific language\n * @returns 12-24 words\n * @example\n * const ent = new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ]);\n * entropyToMnemonic(ent, wordlist);\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */\n\nfunction entropyToMnemonic(entropy, wordlist) {\n  assertEntropy(entropy);\n  const words = getCoder(wordlist).encode(entropy);\n  return words.join(isJapanese(wordlist) ? '\\u3000' : ' ');\n}\n\nexports.entropyToMnemonic = entropyToMnemonic;\n/**\n * Validates mnemonic for being 12-24 words contained in `wordlist`.\n */\n\nfunction validateMnemonic(mnemonic, wordlist) {\n  try {\n    mnemonicToEntropy(mnemonic, wordlist);\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.validateMnemonic = validateMnemonic;\n\nconst salt = passphrase => nfkd(`mnemonic${passphrase}`);\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * await mnemonicToSeed(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\n\n\nfunction mnemonicToSeed(mnemonic) {\n  let passphrase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  return (0, pbkdf2_1.pbkdf2Async)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), {\n    c: 2048,\n    dkLen: 64\n  });\n}\n\nexports.mnemonicToSeed = mnemonicToSeed;\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToSeedSync(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\n\nfunction mnemonicToSeedSync(mnemonic) {\n  let passphrase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  return (0, pbkdf2_1.pbkdf2)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), {\n    c: 2048,\n    dkLen: 64\n  });\n}\n\nexports.mnemonicToSeedSync = mnemonicToSeedSync;","map":{"version":3,"names":["Object","defineProperty","exports","value","mnemonicToSeedSync","mnemonicToSeed","validateMnemonic","entropyToMnemonic","mnemonicToEntropy","generateMnemonic","_assert_1","require","pbkdf2_1","sha256_1","sha512_1","utils_1","base_1","isJapanese","wordlist","nfkd","str","TypeError","normalize","norm","words","split","includes","length","Error","assertEntropy","entropy","default","bytes","strength","number","randomBytes","calcChecksum","bitsLeft","Uint8Array","sha256","getCoder","Array","isArray","forEach","i","utils","chain","checksum","radix2","alphabet","mnemonic","decode","encode","join","e","salt","passphrase","pbkdf2Async","sha512","c","dkLen","pbkdf2"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/@scure/bip39/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mnemonicToSeedSync = exports.mnemonicToSeed = exports.validateMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.generateMnemonic = void 0;\n/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nconst _assert_1 = require(\"@noble/hashes/_assert\");\nconst pbkdf2_1 = require(\"@noble/hashes/pbkdf2\");\nconst sha256_1 = require(\"@noble/hashes/sha256\");\nconst sha512_1 = require(\"@noble/hashes/sha512\");\nconst utils_1 = require(\"@noble/hashes/utils\");\nconst base_1 = require(\"@scure/base\");\n// Japanese wordlist\nconst isJapanese = (wordlist) => wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093';\n// Normalization replaces equivalent sequences of characters\n// so that any two texts that are equivalent will be reduced\n// to the same sequence of code points, called the normal form of the original text.\nfunction nfkd(str) {\n    if (typeof str !== 'string')\n        throw new TypeError(`Invalid mnemonic type: ${typeof str}`);\n    return str.normalize('NFKD');\n}\nfunction normalize(str) {\n    const norm = nfkd(str);\n    const words = norm.split(' ');\n    if (![12, 15, 18, 21, 24].includes(words.length))\n        throw new Error('Invalid mnemonic');\n    return { nfkd: norm, words };\n}\nfunction assertEntropy(entropy) {\n    _assert_1.default.bytes(entropy, 16, 20, 24, 28, 32);\n}\n/**\n * Generate x random words. Uses Cryptographically-Secure Random Number Generator.\n * @param wordlist imported wordlist for specific language\n * @param strength mnemonic strength 128-256 bits\n * @example\n * generateMnemonic(wordlist, 128)\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */\nfunction generateMnemonic(wordlist, strength = 128) {\n    _assert_1.default.number(strength);\n    if (strength % 32 !== 0 || strength > 256)\n        throw new TypeError('Invalid entropy');\n    return entropyToMnemonic((0, utils_1.randomBytes)(strength / 8), wordlist);\n}\nexports.generateMnemonic = generateMnemonic;\nconst calcChecksum = (entropy) => {\n    // Checksum is ent.length/4 bits long\n    const bitsLeft = 8 - entropy.length / 4;\n    // Zero rightmost \"bitsLeft\" bits in byte\n    // For example: bitsLeft=4 val=10111101 -> 10110000\n    return new Uint8Array([((0, sha256_1.sha256)(entropy)[0] >> bitsLeft) << bitsLeft]);\n};\nfunction getCoder(wordlist) {\n    if (!Array.isArray(wordlist) || wordlist.length !== 2 ** 11 || typeof wordlist[0] !== 'string')\n        throw new Error('Worlist: expected array of 2048 strings');\n    wordlist.forEach((i) => {\n        if (typeof i !== 'string')\n            throw new Error(`Wordlist: non-string element: ${i}`);\n    });\n    return base_1.utils.chain(base_1.utils.checksum(1, calcChecksum), base_1.utils.radix2(11, true), base_1.utils.alphabet(wordlist));\n}\n/**\n * Reversible: Converts mnemonic string to raw entropy in form of byte array.\n * @param mnemonic 12-24 words\n * @param wordlist imported wordlist for specific language\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToEntropy(mnem, wordlist)\n * // Produces\n * new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ])\n */\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n    const { words } = normalize(mnemonic);\n    const entropy = getCoder(wordlist).decode(words);\n    assertEntropy(entropy);\n    return entropy;\n}\nexports.mnemonicToEntropy = mnemonicToEntropy;\n/**\n * Reversible: Converts raw entropy in form of byte array to mnemonic string.\n * @param entropy byte array\n * @param wordlist imported wordlist for specific language\n * @returns 12-24 words\n * @example\n * const ent = new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ]);\n * entropyToMnemonic(ent, wordlist);\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */\nfunction entropyToMnemonic(entropy, wordlist) {\n    assertEntropy(entropy);\n    const words = getCoder(wordlist).encode(entropy);\n    return words.join(isJapanese(wordlist) ? '\\u3000' : ' ');\n}\nexports.entropyToMnemonic = entropyToMnemonic;\n/**\n * Validates mnemonic for being 12-24 words contained in `wordlist`.\n */\nfunction validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\nexports.validateMnemonic = validateMnemonic;\nconst salt = (passphrase) => nfkd(`mnemonic${passphrase}`);\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * await mnemonicToSeed(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\nfunction mnemonicToSeed(mnemonic, passphrase = '') {\n    return (0, pbkdf2_1.pbkdf2Async)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });\n}\nexports.mnemonicToSeed = mnemonicToSeed;\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToSeedSync(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\nfunction mnemonicToSeedSync(mnemonic, passphrase = '') {\n    return (0, pbkdf2_1.pbkdf2)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });\n}\nexports.mnemonicToSeedSync = mnemonicToSeedSync;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}