{"ast":null,"code":"'use strict';\n\nconst {\n  MockNotMatchedError\n} = require('./mock-errors');\n\nconst {\n  kDispatches,\n  kMockAgent,\n  kOriginalDispatch,\n  kOrigin,\n  kGetNetConnect\n} = require('./mock-symbols');\n\nconst {\n  buildURL,\n  nop\n} = require('../core/util');\n\nconst {\n  STATUS_CODES\n} = require('http');\n\nfunction matchValue(match, value) {\n  if (typeof match === 'string') {\n    return match === value;\n  }\n\n  if (match instanceof RegExp) {\n    return match.test(value);\n  }\n\n  if (typeof match === 'function') {\n    return match(value) === true;\n  }\n\n  return false;\n}\n\nfunction lowerCaseEntries(headers) {\n  return Object.fromEntries(Object.entries(headers).map(_ref => {\n    let [headerName, headerValue] = _ref;\n    return [headerName.toLocaleLowerCase(), headerValue];\n  }));\n}\n/**\n * @param {import('../../index').Headers|string[]|Record<string, string>} headers\n * @param {string} key\n */\n\n\nfunction getHeaderByName(headers, key) {\n  if (Array.isArray(headers)) {\n    for (let i = 0; i < headers.length; i += 2) {\n      if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {\n        return headers[i + 1];\n      }\n    }\n\n    return undefined;\n  } else if (typeof headers.get === 'function') {\n    return headers.get(key);\n  } else {\n    return lowerCaseEntries(headers)[key.toLocaleLowerCase()];\n  }\n}\n/** @param {string[]} headers */\n\n\nfunction buildHeadersFromArray(headers) {\n  // fetch HeadersList\n  const clone = headers.slice();\n  const entries = [];\n\n  for (let index = 0; index < clone.length; index += 2) {\n    entries.push([clone[index], clone[index + 1]]);\n  }\n\n  return Object.fromEntries(entries);\n}\n\nfunction matchHeaders(mockDispatch, headers) {\n  if (typeof mockDispatch.headers === 'function') {\n    if (Array.isArray(headers)) {\n      // fetch HeadersList\n      headers = buildHeadersFromArray(headers);\n    }\n\n    return mockDispatch.headers(headers ? lowerCaseEntries(headers) : {});\n  }\n\n  if (typeof mockDispatch.headers === 'undefined') {\n    return true;\n  }\n\n  if (typeof headers !== 'object' || typeof mockDispatch.headers !== 'object') {\n    return false;\n  }\n\n  for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)) {\n    const headerValue = getHeaderByName(headers, matchHeaderName);\n\n    if (!matchValue(matchHeaderValue, headerValue)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction safeUrl(path) {\n  if (typeof path !== 'string') {\n    return path;\n  }\n\n  const pathSegments = path.split('?');\n\n  if (pathSegments.length !== 2) {\n    return path;\n  }\n\n  const qp = new URLSearchParams(pathSegments.pop());\n  qp.sort();\n  return [...pathSegments, qp.toString()].join('?');\n}\n\nfunction matchKey(mockDispatch, _ref2) {\n  let {\n    path,\n    method,\n    body,\n    headers\n  } = _ref2;\n  const pathMatch = matchValue(mockDispatch.path, path);\n  const methodMatch = matchValue(mockDispatch.method, method);\n  const bodyMatch = typeof mockDispatch.body !== 'undefined' ? matchValue(mockDispatch.body, body) : true;\n  const headersMatch = matchHeaders(mockDispatch, headers);\n  return pathMatch && methodMatch && bodyMatch && headersMatch;\n}\n\nfunction getResponseData(data) {\n  if (Buffer.isBuffer(data)) {\n    return data;\n  } else if (typeof data === 'object') {\n    return JSON.stringify(data);\n  } else {\n    return data.toString();\n  }\n}\n\nfunction getMockDispatch(mockDispatches, key) {\n  const basePath = key.query ? buildURL(key.path, key.query) : key.path;\n  const resolvedPath = typeof basePath === 'string' ? safeUrl(basePath) : basePath; // Match path\n\n  let matchedMockDispatches = mockDispatches.filter(_ref3 => {\n    let {\n      consumed\n    } = _ref3;\n    return !consumed;\n  }).filter(_ref4 => {\n    let {\n      path\n    } = _ref4;\n    return matchValue(safeUrl(path), resolvedPath);\n  });\n\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);\n  } // Match method\n\n\n  matchedMockDispatches = matchedMockDispatches.filter(_ref5 => {\n    let {\n      method\n    } = _ref5;\n    return matchValue(method, key.method);\n  });\n\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);\n  } // Match body\n\n\n  matchedMockDispatches = matchedMockDispatches.filter(_ref6 => {\n    let {\n      body\n    } = _ref6;\n    return typeof body !== 'undefined' ? matchValue(body, key.body) : true;\n  });\n\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);\n  } // Match headers\n\n\n  matchedMockDispatches = matchedMockDispatches.filter(mockDispatch => matchHeaders(mockDispatch, key.headers));\n\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === 'object' ? JSON.stringify(key.headers) : key.headers}'`);\n  }\n\n  return matchedMockDispatches[0];\n}\n\nfunction addMockDispatch(mockDispatches, key, data) {\n  const baseData = {\n    timesInvoked: 0,\n    times: 1,\n    persist: false,\n    consumed: false\n  };\n  const replyData = typeof data === 'function' ? {\n    callback: data\n  } : { ...data\n  };\n  const newMockDispatch = { ...baseData,\n    ...key,\n    pending: true,\n    data: {\n      error: null,\n      ...replyData\n    }\n  };\n  mockDispatches.push(newMockDispatch);\n  return newMockDispatch;\n}\n\nfunction deleteMockDispatch(mockDispatches, key) {\n  const index = mockDispatches.findIndex(dispatch => {\n    if (!dispatch.consumed) {\n      return false;\n    }\n\n    return matchKey(dispatch, key);\n  });\n\n  if (index !== -1) {\n    mockDispatches.splice(index, 1);\n  }\n}\n\nfunction buildKey(opts) {\n  const {\n    path,\n    method,\n    body,\n    headers,\n    query\n  } = opts;\n  return {\n    path,\n    method,\n    body,\n    headers,\n    query\n  };\n}\n\nfunction generateKeyValues(data) {\n  return Object.entries(data).reduce((keyValuePairs, _ref7) => {\n    let [key, value] = _ref7;\n    return [...keyValuePairs, key, value];\n  }, []);\n}\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n * @param {number} statusCode\n */\n\n\nfunction getStatusText(statusCode) {\n  return STATUS_CODES[statusCode] || 'unknown';\n}\n\nasync function getResponse(body) {\n  const buffers = [];\n\n  for await (const data of body) {\n    buffers.push(data);\n  }\n\n  return Buffer.concat(buffers).toString('utf8');\n}\n/**\n * Mock dispatch function used to simulate undici dispatches\n */\n\n\nfunction mockDispatch(opts, handler) {\n  // Get mock dispatch from built key\n  const key = buildKey(opts);\n  const mockDispatch = getMockDispatch(this[kDispatches], key);\n  mockDispatch.timesInvoked++; // Here's where we resolve a callback if a callback is present for the dispatch data.\n\n  if (mockDispatch.data.callback) {\n    mockDispatch.data = { ...mockDispatch.data,\n      ...mockDispatch.data.callback(opts)\n    };\n  } // Parse mockDispatch data\n\n\n  const {\n    data: {\n      statusCode,\n      data,\n      headers,\n      trailers,\n      error\n    },\n    delay,\n    persist\n  } = mockDispatch;\n  const {\n    timesInvoked,\n    times\n  } = mockDispatch; // If it's used up and not persistent, mark as consumed\n\n  mockDispatch.consumed = !persist && timesInvoked >= times;\n  mockDispatch.pending = timesInvoked < times; // If specified, trigger dispatch error\n\n  if (error !== null) {\n    deleteMockDispatch(this[kDispatches], key);\n    handler.onError(error);\n    return true;\n  } // Handle the request with a delay if necessary\n\n\n  if (typeof delay === 'number' && delay > 0) {\n    setTimeout(() => {\n      handleReply(this[kDispatches]);\n    }, delay);\n  } else {\n    handleReply(this[kDispatches]);\n  }\n\n  function handleReply(mockDispatches) {\n    // fetch's HeadersList is a 1D string array\n    const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;\n    const responseData = getResponseData(typeof data === 'function' ? data({ ...opts,\n      headers: optsHeaders\n    }) : data);\n    const responseHeaders = generateKeyValues(headers);\n    const responseTrailers = generateKeyValues(trailers);\n    handler.abort = nop;\n    handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));\n    handler.onData(Buffer.from(responseData));\n    handler.onComplete(responseTrailers);\n    deleteMockDispatch(mockDispatches, key);\n  }\n\n  function resume() {}\n\n  return true;\n}\n\nfunction buildMockDispatch() {\n  const agent = this[kMockAgent];\n  const origin = this[kOrigin];\n  const originalDispatch = this[kOriginalDispatch];\n  return function dispatch(opts, handler) {\n    if (agent.isMockActive) {\n      try {\n        mockDispatch.call(this, opts, handler);\n      } catch (error) {\n        if (error instanceof MockNotMatchedError) {\n          const netConnect = agent[kGetNetConnect]();\n\n          if (netConnect === false) {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);\n          }\n\n          if (checkNetConnect(netConnect, origin)) {\n            originalDispatch.call(this, opts, handler);\n          } else {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);\n          }\n        } else {\n          throw error;\n        }\n      }\n    } else {\n      originalDispatch.call(this, opts, handler);\n    }\n  };\n}\n\nfunction checkNetConnect(netConnect, origin) {\n  const url = new URL(origin);\n\n  if (netConnect === true) {\n    return true;\n  } else if (Array.isArray(netConnect) && netConnect.some(matcher => matchValue(matcher, url.host))) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction buildMockOptions(opts) {\n  if (opts) {\n    const {\n      agent,\n      ...mockOptions\n    } = opts;\n    return mockOptions;\n  }\n}\n\nmodule.exports = {\n  getResponseData,\n  getMockDispatch,\n  addMockDispatch,\n  deleteMockDispatch,\n  buildKey,\n  generateKeyValues,\n  matchValue,\n  getResponse,\n  getStatusText,\n  mockDispatch,\n  buildMockDispatch,\n  checkNetConnect,\n  buildMockOptions,\n  getHeaderByName\n};","map":{"version":3,"names":["MockNotMatchedError","require","kDispatches","kMockAgent","kOriginalDispatch","kOrigin","kGetNetConnect","buildURL","nop","STATUS_CODES","matchValue","match","value","RegExp","test","lowerCaseEntries","headers","Object","fromEntries","entries","map","headerName","headerValue","toLocaleLowerCase","getHeaderByName","key","Array","isArray","i","length","undefined","get","buildHeadersFromArray","clone","slice","index","push","matchHeaders","mockDispatch","matchHeaderName","matchHeaderValue","safeUrl","path","pathSegments","split","qp","URLSearchParams","pop","sort","toString","join","matchKey","method","body","pathMatch","methodMatch","bodyMatch","headersMatch","getResponseData","data","Buffer","isBuffer","JSON","stringify","getMockDispatch","mockDispatches","basePath","query","resolvedPath","matchedMockDispatches","filter","consumed","addMockDispatch","baseData","timesInvoked","times","persist","replyData","callback","newMockDispatch","pending","error","deleteMockDispatch","findIndex","dispatch","splice","buildKey","opts","generateKeyValues","reduce","keyValuePairs","getStatusText","statusCode","getResponse","buffers","concat","handler","trailers","delay","onError","setTimeout","handleReply","optsHeaders","responseData","responseHeaders","responseTrailers","abort","onHeaders","resume","onData","from","onComplete","buildMockDispatch","agent","origin","originalDispatch","isMockActive","call","netConnect","message","checkNetConnect","url","URL","some","matcher","host","buildMockOptions","mockOptions","module","exports"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/undici/lib/mock/mock-utils.js"],"sourcesContent":["'use strict'\n\nconst { MockNotMatchedError } = require('./mock-errors')\nconst {\n  kDispatches,\n  kMockAgent,\n  kOriginalDispatch,\n  kOrigin,\n  kGetNetConnect\n} = require('./mock-symbols')\nconst { buildURL, nop } = require('../core/util')\nconst { STATUS_CODES } = require('http')\n\nfunction matchValue (match, value) {\n  if (typeof match === 'string') {\n    return match === value\n  }\n  if (match instanceof RegExp) {\n    return match.test(value)\n  }\n  if (typeof match === 'function') {\n    return match(value) === true\n  }\n  return false\n}\n\nfunction lowerCaseEntries (headers) {\n  return Object.fromEntries(\n    Object.entries(headers).map(([headerName, headerValue]) => {\n      return [headerName.toLocaleLowerCase(), headerValue]\n    })\n  )\n}\n\n/**\n * @param {import('../../index').Headers|string[]|Record<string, string>} headers\n * @param {string} key\n */\nfunction getHeaderByName (headers, key) {\n  if (Array.isArray(headers)) {\n    for (let i = 0; i < headers.length; i += 2) {\n      if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {\n        return headers[i + 1]\n      }\n    }\n\n    return undefined\n  } else if (typeof headers.get === 'function') {\n    return headers.get(key)\n  } else {\n    return lowerCaseEntries(headers)[key.toLocaleLowerCase()]\n  }\n}\n\n/** @param {string[]} headers */\nfunction buildHeadersFromArray (headers) { // fetch HeadersList\n  const clone = headers.slice()\n  const entries = []\n  for (let index = 0; index < clone.length; index += 2) {\n    entries.push([clone[index], clone[index + 1]])\n  }\n  return Object.fromEntries(entries)\n}\n\nfunction matchHeaders (mockDispatch, headers) {\n  if (typeof mockDispatch.headers === 'function') {\n    if (Array.isArray(headers)) { // fetch HeadersList\n      headers = buildHeadersFromArray(headers)\n    }\n    return mockDispatch.headers(headers ? lowerCaseEntries(headers) : {})\n  }\n  if (typeof mockDispatch.headers === 'undefined') {\n    return true\n  }\n  if (typeof headers !== 'object' || typeof mockDispatch.headers !== 'object') {\n    return false\n  }\n\n  for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)) {\n    const headerValue = getHeaderByName(headers, matchHeaderName)\n\n    if (!matchValue(matchHeaderValue, headerValue)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction safeUrl (path) {\n  if (typeof path !== 'string') {\n    return path\n  }\n\n  const pathSegments = path.split('?')\n\n  if (pathSegments.length !== 2) {\n    return path\n  }\n\n  const qp = new URLSearchParams(pathSegments.pop())\n  qp.sort()\n  return [...pathSegments, qp.toString()].join('?')\n}\n\nfunction matchKey (mockDispatch, { path, method, body, headers }) {\n  const pathMatch = matchValue(mockDispatch.path, path)\n  const methodMatch = matchValue(mockDispatch.method, method)\n  const bodyMatch = typeof mockDispatch.body !== 'undefined' ? matchValue(mockDispatch.body, body) : true\n  const headersMatch = matchHeaders(mockDispatch, headers)\n  return pathMatch && methodMatch && bodyMatch && headersMatch\n}\n\nfunction getResponseData (data) {\n  if (Buffer.isBuffer(data)) {\n    return data\n  } else if (typeof data === 'object') {\n    return JSON.stringify(data)\n  } else {\n    return data.toString()\n  }\n}\n\nfunction getMockDispatch (mockDispatches, key) {\n  const basePath = key.query ? buildURL(key.path, key.query) : key.path\n  const resolvedPath = typeof basePath === 'string' ? safeUrl(basePath) : basePath\n\n  // Match path\n  let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(safeUrl(path), resolvedPath))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`)\n  }\n\n  // Match method\n  matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`)\n  }\n\n  // Match body\n  matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== 'undefined' ? matchValue(body, key.body) : true)\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`)\n  }\n\n  // Match headers\n  matchedMockDispatches = matchedMockDispatches.filter((mockDispatch) => matchHeaders(mockDispatch, key.headers))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === 'object' ? JSON.stringify(key.headers) : key.headers}'`)\n  }\n\n  return matchedMockDispatches[0]\n}\n\nfunction addMockDispatch (mockDispatches, key, data) {\n  const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false }\n  const replyData = typeof data === 'function' ? { callback: data } : { ...data }\n  const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } }\n  mockDispatches.push(newMockDispatch)\n  return newMockDispatch\n}\n\nfunction deleteMockDispatch (mockDispatches, key) {\n  const index = mockDispatches.findIndex(dispatch => {\n    if (!dispatch.consumed) {\n      return false\n    }\n    return matchKey(dispatch, key)\n  })\n  if (index !== -1) {\n    mockDispatches.splice(index, 1)\n  }\n}\n\nfunction buildKey (opts) {\n  const { path, method, body, headers, query } = opts\n  return {\n    path,\n    method,\n    body,\n    headers,\n    query\n  }\n}\n\nfunction generateKeyValues (data) {\n  return Object.entries(data).reduce((keyValuePairs, [key, value]) => [...keyValuePairs, key, value], [])\n}\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n * @param {number} statusCode\n */\nfunction getStatusText (statusCode) {\n  return STATUS_CODES[statusCode] || 'unknown'\n}\n\nasync function getResponse (body) {\n  const buffers = []\n  for await (const data of body) {\n    buffers.push(data)\n  }\n  return Buffer.concat(buffers).toString('utf8')\n}\n\n/**\n * Mock dispatch function used to simulate undici dispatches\n */\nfunction mockDispatch (opts, handler) {\n  // Get mock dispatch from built key\n  const key = buildKey(opts)\n  const mockDispatch = getMockDispatch(this[kDispatches], key)\n\n  mockDispatch.timesInvoked++\n\n  // Here's where we resolve a callback if a callback is present for the dispatch data.\n  if (mockDispatch.data.callback) {\n    mockDispatch.data = { ...mockDispatch.data, ...mockDispatch.data.callback(opts) }\n  }\n\n  // Parse mockDispatch data\n  const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch\n  const { timesInvoked, times } = mockDispatch\n\n  // If it's used up and not persistent, mark as consumed\n  mockDispatch.consumed = !persist && timesInvoked >= times\n  mockDispatch.pending = timesInvoked < times\n\n  // If specified, trigger dispatch error\n  if (error !== null) {\n    deleteMockDispatch(this[kDispatches], key)\n    handler.onError(error)\n    return true\n  }\n\n  // Handle the request with a delay if necessary\n  if (typeof delay === 'number' && delay > 0) {\n    setTimeout(() => {\n      handleReply(this[kDispatches])\n    }, delay)\n  } else {\n    handleReply(this[kDispatches])\n  }\n\n  function handleReply (mockDispatches) {\n    // fetch's HeadersList is a 1D string array\n    const optsHeaders = Array.isArray(opts.headers)\n      ? buildHeadersFromArray(opts.headers)\n      : opts.headers\n    const responseData = getResponseData(\n      typeof data === 'function' ? data({ ...opts, headers: optsHeaders }) : data\n    )\n    const responseHeaders = generateKeyValues(headers)\n    const responseTrailers = generateKeyValues(trailers)\n\n    handler.abort = nop\n    handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode))\n    handler.onData(Buffer.from(responseData))\n    handler.onComplete(responseTrailers)\n    deleteMockDispatch(mockDispatches, key)\n  }\n\n  function resume () {}\n\n  return true\n}\n\nfunction buildMockDispatch () {\n  const agent = this[kMockAgent]\n  const origin = this[kOrigin]\n  const originalDispatch = this[kOriginalDispatch]\n\n  return function dispatch (opts, handler) {\n    if (agent.isMockActive) {\n      try {\n        mockDispatch.call(this, opts, handler)\n      } catch (error) {\n        if (error instanceof MockNotMatchedError) {\n          const netConnect = agent[kGetNetConnect]()\n          if (netConnect === false) {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`)\n          }\n          if (checkNetConnect(netConnect, origin)) {\n            originalDispatch.call(this, opts, handler)\n          } else {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`)\n          }\n        } else {\n          throw error\n        }\n      }\n    } else {\n      originalDispatch.call(this, opts, handler)\n    }\n  }\n}\n\nfunction checkNetConnect (netConnect, origin) {\n  const url = new URL(origin)\n  if (netConnect === true) {\n    return true\n  } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {\n    return true\n  }\n  return false\n}\n\nfunction buildMockOptions (opts) {\n  if (opts) {\n    const { agent, ...mockOptions } = opts\n    return mockOptions\n  }\n}\n\nmodule.exports = {\n  getResponseData,\n  getMockDispatch,\n  addMockDispatch,\n  deleteMockDispatch,\n  buildKey,\n  generateKeyValues,\n  matchValue,\n  getResponse,\n  getStatusText,\n  mockDispatch,\n  buildMockDispatch,\n  checkNetConnect,\n  buildMockOptions,\n  getHeaderByName\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}