{"ast":null,"code":"'use strict';\n\nconst {\n  Headers,\n  HeadersList,\n  fill\n} = require('./headers');\n\nconst {\n  extractBody,\n  cloneBody,\n  mixinBody\n} = require('./body');\n\nconst util = require('../core/util');\n\nconst {\n  kEnumerableProperty\n} = util;\n\nconst {\n  responseURL,\n  isValidReasonPhrase,\n  isCancelled,\n  isAborted,\n  isBlobLike,\n  serializeJavascriptValueToJSONString,\n  isErrorLike\n} = require('./util');\n\nconst {\n  redirectStatus,\n  nullBodyStatus,\n  DOMException\n} = require('./constants');\n\nconst {\n  kState,\n  kHeaders,\n  kGuard,\n  kRealm\n} = require('./symbols');\n\nconst {\n  webidl\n} = require('./webidl');\n\nconst {\n  FormData\n} = require('./formdata');\n\nconst {\n  getGlobalOrigin\n} = require('./global');\n\nconst {\n  kHeadersList\n} = require('../core/symbols');\n\nconst assert = require('assert');\n\nconst {\n  types\n} = require('util');\n\nconst ReadableStream = globalThis.ReadableStream || require('stream/web').ReadableStream; // https://fetch.spec.whatwg.org/#response-class\n\n\nclass Response {\n  // Creates network error Response.\n  static error() {\n    // TODO\n    const relevantRealm = {\n      settingsObject: {}\n    }; // The static error() method steps are to return the result of creating a\n    // Response object, given a new network error, \"immutable\", and this’s\n    // relevant Realm.\n\n    const responseObject = new Response();\n    responseObject[kState] = makeNetworkError();\n    responseObject[kRealm] = relevantRealm;\n    responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;\n    responseObject[kHeaders][kGuard] = 'immutable';\n    responseObject[kHeaders][kRealm] = relevantRealm;\n    return responseObject;\n  } // https://fetch.spec.whatwg.org/#dom-response-json\n\n\n  static json(data) {\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (arguments.length === 0) {\n      throw new TypeError('Failed to execute \\'json\\' on \\'Response\\': 1 argument required, but 0 present.');\n    }\n\n    if (init !== null) {\n      init = webidl.converters.ResponseInit(init);\n    } // 1. Let bytes the result of running serialize a JavaScript value to JSON bytes on data.\n\n\n    const bytes = new TextEncoder('utf-8').encode(serializeJavascriptValueToJSONString(data)); // 2. Let body be the result of extracting bytes.\n\n    const body = extractBody(bytes); // 3. Let responseObject be the result of creating a Response object, given a new response,\n    //    \"response\", and this’s relevant Realm.\n\n    const relevantRealm = {\n      settingsObject: {}\n    };\n    const responseObject = new Response();\n    responseObject[kRealm] = relevantRealm;\n    responseObject[kHeaders][kGuard] = 'response';\n    responseObject[kHeaders][kRealm] = relevantRealm; // 4. Perform initialize a response given responseObject, init, and (body, \"application/json\").\n\n    initializeResponse(responseObject, init, {\n      body: body[0],\n      type: 'application/json'\n    }); // 5. Return responseObject.\n\n    return responseObject;\n  } // Creates a redirect Response that redirects to url with status status.\n\n\n  static redirect(url) {\n    let status = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 302;\n    const relevantRealm = {\n      settingsObject: {}\n    };\n\n    if (arguments.length < 1) {\n      throw new TypeError(`Failed to execute 'redirect' on 'Response': 1 argument required, but only ${arguments.length} present.`);\n    }\n\n    url = webidl.converters.USVString(url);\n    status = webidl.converters['unsigned short'](status); // 1. Let parsedURL be the result of parsing url with current settings\n    // object’s API base URL.\n    // 2. If parsedURL is failure, then throw a TypeError.\n    // TODO: base-URL?\n\n    let parsedURL;\n\n    try {\n      parsedURL = new URL(url, getGlobalOrigin());\n    } catch (err) {\n      throw Object.assign(new TypeError('Failed to parse URL from ' + url), {\n        cause: err\n      });\n    } // 3. If status is not a redirect status, then throw a RangeError.\n\n\n    if (!redirectStatus.includes(status)) {\n      throw new RangeError('Invalid status code');\n    } // 4. Let responseObject be the result of creating a Response object,\n    // given a new response, \"immutable\", and this’s relevant Realm.\n\n\n    const responseObject = new Response();\n    responseObject[kRealm] = relevantRealm;\n    responseObject[kHeaders][kGuard] = 'immutable';\n    responseObject[kHeaders][kRealm] = relevantRealm; // 5. Set responseObject’s response’s status to status.\n\n    responseObject[kState].status = status; // 6. Let value be parsedURL, serialized and isomorphic encoded.\n    // TODO: isomorphic encoded?\n\n    const value = parsedURL.toString(); // 7. Append `Location`/value to responseObject’s response’s header list.\n\n    responseObject[kState].headersList.append('location', value); // 8. Return responseObject.\n\n    return responseObject;\n  } // https://fetch.spec.whatwg.org/#dom-response\n\n\n  constructor() {\n    let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (body !== null) {\n      body = webidl.converters.BodyInit(body);\n    }\n\n    init = webidl.converters.ResponseInit(init); // TODO\n\n    this[kRealm] = {\n      settingsObject: {}\n    }; // 1. Set this’s response to a new response.\n\n    this[kState] = makeResponse({}); // 2. Set this’s headers to a new Headers object with this’s relevant\n    // Realm, whose header list is this’s response’s header list and guard\n    // is \"response\".\n\n    this[kHeaders] = new Headers();\n    this[kHeaders][kGuard] = 'response';\n    this[kHeaders][kHeadersList] = this[kState].headersList;\n    this[kHeaders][kRealm] = this[kRealm]; // 3. Let bodyWithType be null.\n\n    let bodyWithType = null; // 4. If body is non-null, then set bodyWithType to the result of extracting body.\n\n    if (body != null) {\n      const [extractedBody, type] = extractBody(body);\n      bodyWithType = {\n        body: extractedBody,\n        type\n      };\n    } // 5. Perform initialize a response given this, init, and bodyWithType.\n\n\n    initializeResponse(this, init, bodyWithType);\n  }\n\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  } // Returns response’s type, e.g., \"cors\".\n\n\n  get type() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    } // The type getter steps are to return this’s response’s type.\n\n\n    return this[kState].type;\n  } // Returns response’s URL, if it has one; otherwise the empty string.\n\n\n  get url() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    } // The url getter steps are to return the empty string if this’s\n    // response’s URL is null; otherwise this’s response’s URL,\n    // serialized with exclude fragment set to true.\n\n\n    let url = responseURL(this[kState]);\n\n    if (url == null) {\n      return '';\n    }\n\n    if (url.hash) {\n      url = new URL(url);\n      url.hash = '';\n    }\n\n    return url.toString();\n  } // Returns whether response was obtained through a redirect.\n\n\n  get redirected() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    } // The redirected getter steps are to return true if this’s response’s URL\n    // list has more than one item; otherwise false.\n\n\n    return this[kState].urlList.length > 1;\n  } // Returns response’s status.\n\n\n  get status() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    } // The status getter steps are to return this’s response’s status.\n\n\n    return this[kState].status;\n  } // Returns whether response’s status is an ok status.\n\n\n  get ok() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    } // The ok getter steps are to return true if this’s response’s status is an\n    // ok status; otherwise false.\n\n\n    return this[kState].status >= 200 && this[kState].status <= 299;\n  } // Returns response’s status message.\n\n\n  get statusText() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    } // The statusText getter steps are to return this’s response’s status\n    // message.\n\n\n    return this[kState].statusText;\n  } // Returns response’s headers as Headers.\n\n\n  get headers() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    } // The headers getter steps are to return this’s headers.\n\n\n    return this[kHeaders];\n  } // Returns a clone of response.\n\n\n  clone() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    } // 1. If this is unusable, then throw a TypeError.\n\n\n    if (this.bodyUsed || this.body && this.body.locked) {\n      webidl.errors.exception({\n        header: 'Response.clone',\n        message: 'Body has already been consumed.'\n      });\n    } // 2. Let clonedResponse be the result of cloning this’s response.\n\n\n    const clonedResponse = cloneResponse(this[kState]); // 3. Return the result of creating a Response object, given\n    // clonedResponse, this’s headers’s guard, and this’s relevant Realm.\n\n    const clonedResponseObject = new Response();\n    clonedResponseObject[kState] = clonedResponse;\n    clonedResponseObject[kRealm] = this[kRealm];\n    clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;\n    clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];\n    clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];\n    return clonedResponseObject;\n  }\n\n}\n\nmixinBody(Response);\nObject.defineProperties(Response.prototype, {\n  type: kEnumerableProperty,\n  url: kEnumerableProperty,\n  status: kEnumerableProperty,\n  ok: kEnumerableProperty,\n  redirected: kEnumerableProperty,\n  statusText: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  clone: kEnumerableProperty\n}); // https://fetch.spec.whatwg.org/#concept-response-clone\n\nfunction cloneResponse(response) {\n  // To clone a response response, run these steps:\n  // 1. If response is a filtered response, then return a new identical\n  // filtered response whose internal response is a clone of response’s\n  // internal response.\n  if (response.internalResponse) {\n    return filterResponse(cloneResponse(response.internalResponse), response.type);\n  } // 2. Let newResponse be a copy of response, except for its body.\n\n\n  const newResponse = makeResponse({ ...response,\n    body: null\n  }); // 3. If response’s body is non-null, then set newResponse’s body to the\n  // result of cloning response’s body.\n\n  if (response.body != null) {\n    newResponse.body = cloneBody(response.body);\n  } // 4. Return newResponse.\n\n\n  return newResponse;\n}\n\nfunction makeResponse(init) {\n  return {\n    aborted: false,\n    rangeRequested: false,\n    timingAllowPassed: false,\n    requestIncludesCredentials: false,\n    type: 'default',\n    status: 200,\n    timingInfo: null,\n    cacheState: '',\n    statusText: '',\n    ...init,\n    headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList(),\n    urlList: init.urlList ? [...init.urlList] : []\n  };\n}\n\nfunction makeNetworkError(reason) {\n  const isError = isErrorLike(reason);\n  return makeResponse({\n    type: 'error',\n    status: 0,\n    error: isError ? reason : new Error(reason ? String(reason) : reason, {\n      cause: isError ? reason : undefined\n    }),\n    aborted: reason && reason.name === 'AbortError'\n  });\n}\n\nfunction makeFilteredResponse(response, state) {\n  state = {\n    internalResponse: response,\n    ...state\n  };\n  return new Proxy(response, {\n    get(target, p) {\n      return p in state ? state[p] : target[p];\n    },\n\n    set(target, p, value) {\n      assert(!(p in state));\n      target[p] = value;\n      return true;\n    }\n\n  });\n} // https://fetch.spec.whatwg.org/#concept-filtered-response\n\n\nfunction filterResponse(response, type) {\n  // Set response to the following filtered response with response as its\n  // internal response, depending on request’s response tainting:\n  if (type === 'basic') {\n    // A basic filtered response is a filtered response whose type is \"basic\"\n    // and header list excludes any headers in internal response’s header list\n    // whose name is a forbidden response-header name.\n    // Note: undici does not implement forbidden response-header names\n    return makeFilteredResponse(response, {\n      type: 'basic',\n      headersList: response.headersList\n    });\n  } else if (type === 'cors') {\n    // A CORS filtered response is a filtered response whose type is \"cors\"\n    // and header list excludes any headers in internal response’s header\n    // list whose name is not a CORS-safelisted response-header name, given\n    // internal response’s CORS-exposed header-name list.\n    // Note: undici does not implement CORS-safelisted response-header names\n    return makeFilteredResponse(response, {\n      type: 'cors',\n      headersList: response.headersList\n    });\n  } else if (type === 'opaque') {\n    // An opaque filtered response is a filtered response whose type is\n    // \"opaque\", URL list is the empty list, status is 0, status message\n    // is the empty byte sequence, header list is empty, and body is null.\n    return makeFilteredResponse(response, {\n      type: 'opaque',\n      urlList: Object.freeze([]),\n      status: 0,\n      statusText: '',\n      body: null\n    });\n  } else if (type === 'opaqueredirect') {\n    // An opaque-redirect filtered response is a filtered response whose type\n    // is \"opaqueredirect\", status is 0, status message is the empty byte\n    // sequence, header list is empty, and body is null.\n    return makeFilteredResponse(response, {\n      type: 'opaqueredirect',\n      status: 0,\n      statusText: '',\n      headersList: [],\n      body: null\n    });\n  } else {\n    assert(false);\n  }\n} // https://fetch.spec.whatwg.org/#appropriate-network-error\n\n\nfunction makeAppropriateNetworkError(fetchParams) {\n  // 1. Assert: fetchParams is canceled.\n  assert(isCancelled(fetchParams)); // 2. Return an aborted network error if fetchParams is aborted;\n  // otherwise return a network error.\n\n  return isAborted(fetchParams) ? makeNetworkError(new DOMException('The operation was aborted.', 'AbortError')) : makeNetworkError(fetchParams.controller.terminated.reason);\n} // https://whatpr.org/fetch/1392.html#initialize-a-response\n\n\nfunction initializeResponse(response, init, body) {\n  // 1. If init[\"status\"] is not in the range 200 to 599, inclusive, then\n  //    throw a RangeError.\n  if (init.status !== null && (init.status < 200 || init.status > 599)) {\n    throw new RangeError('init[\"status\"] must be in the range of 200 to 599, inclusive.');\n  } // 2. If init[\"statusText\"] does not match the reason-phrase token production,\n  //    then throw a TypeError.\n\n\n  if ('statusText' in init && init.statusText != null) {\n    // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:\n    //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )\n    if (!isValidReasonPhrase(String(init.statusText))) {\n      throw new TypeError('Invalid statusText');\n    }\n  } // 3. Set response’s response’s status to init[\"status\"].\n\n\n  if ('status' in init && init.status != null) {\n    response[kState].status = init.status;\n  } // 4. Set response’s response’s status message to init[\"statusText\"].\n\n\n  if ('statusText' in init && init.statusText != null) {\n    response[kState].statusText = init.statusText;\n  } // 5. If init[\"headers\"] exists, then fill response’s headers with init[\"headers\"].\n\n\n  if ('headers' in init && init.headers != null) {\n    fill(response[kState].headersList, init.headers);\n  } // 6. If body was given, then:\n\n\n  if (body) {\n    // 1. If response's status is a null body status, then throw a TypeError.\n    if (nullBodyStatus.includes(response.status)) {\n      webidl.errors.exception({\n        header: 'Response constructor',\n        message: 'Invalid response status code.'\n      });\n    } // 2. Set response's body to body's body.\n\n\n    response[kState].body = body.body; // 3. If body's type is non-null and response's header list does not contain\n    //    `Content-Type`, then append (`Content-Type`, body's type) to response's header list.\n\n    if (body.type != null && !response[kState].headersList.has('Content-Type')) {\n      response[kState].headersList.append('content-type', body.type);\n    }\n  }\n}\n\nwebidl.converters.ReadableStream = webidl.interfaceConverter(ReadableStream);\nwebidl.converters.FormData = webidl.interfaceConverter(FormData);\nwebidl.converters.URLSearchParams = webidl.interfaceConverter(URLSearchParams); // https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit\n\nwebidl.converters.XMLHttpRequestBodyInit = function (V) {\n  if (typeof V === 'string') {\n    return webidl.converters.USVString(V);\n  }\n\n  if (isBlobLike(V)) {\n    return webidl.converters.Blob(V, {\n      strict: false\n    });\n  }\n\n  if (types.isAnyArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) {\n    return webidl.converters.BufferSource(V);\n  }\n\n  if (util.isFormDataLike(V)) {\n    return webidl.converters.FormData(V, {\n      strict: false\n    });\n  }\n\n  if (V instanceof URLSearchParams) {\n    return webidl.converters.URLSearchParams(V);\n  }\n\n  return webidl.converters.DOMString(V);\n}; // https://fetch.spec.whatwg.org/#bodyinit\n\n\nwebidl.converters.BodyInit = function (V) {\n  if (V instanceof ReadableStream) {\n    return webidl.converters.ReadableStream(V);\n  } // Note: the spec doesn't include async iterables,\n  // this is an undici extension.\n\n\n  if (V?.[Symbol.asyncIterator]) {\n    return V;\n  }\n\n  return webidl.converters.XMLHttpRequestBodyInit(V);\n};\n\nwebidl.converters.ResponseInit = webidl.dictionaryConverter([{\n  key: 'status',\n  converter: webidl.converters['unsigned short'],\n  defaultValue: 200\n}, {\n  key: 'statusText',\n  converter: webidl.converters.ByteString,\n  defaultValue: ''\n}, {\n  key: 'headers',\n  converter: webidl.converters.HeadersInit\n}]);\nmodule.exports = {\n  makeNetworkError,\n  makeResponse,\n  makeAppropriateNetworkError,\n  filterResponse,\n  Response\n};","map":{"version":3,"names":["Headers","HeadersList","fill","require","extractBody","cloneBody","mixinBody","util","kEnumerableProperty","responseURL","isValidReasonPhrase","isCancelled","isAborted","isBlobLike","serializeJavascriptValueToJSONString","isErrorLike","redirectStatus","nullBodyStatus","DOMException","kState","kHeaders","kGuard","kRealm","webidl","FormData","getGlobalOrigin","kHeadersList","assert","types","ReadableStream","globalThis","Response","error","relevantRealm","settingsObject","responseObject","makeNetworkError","headersList","json","data","init","arguments","length","TypeError","converters","ResponseInit","bytes","TextEncoder","encode","body","initializeResponse","type","redirect","url","status","USVString","parsedURL","URL","err","Object","assign","cause","includes","RangeError","value","toString","append","constructor","BodyInit","makeResponse","bodyWithType","extractedBody","Symbol","toStringTag","name","hash","redirected","urlList","ok","statusText","headers","clone","bodyUsed","locked","errors","exception","header","message","clonedResponse","cloneResponse","clonedResponseObject","defineProperties","prototype","response","internalResponse","filterResponse","newResponse","aborted","rangeRequested","timingAllowPassed","requestIncludesCredentials","timingInfo","cacheState","reason","isError","Error","String","undefined","makeFilteredResponse","state","Proxy","get","target","p","set","freeze","makeAppropriateNetworkError","fetchParams","controller","terminated","has","interfaceConverter","URLSearchParams","XMLHttpRequestBodyInit","V","Blob","strict","isAnyArrayBuffer","isTypedArray","isDataView","BufferSource","isFormDataLike","DOMString","asyncIterator","dictionaryConverter","key","converter","defaultValue","ByteString","HeadersInit","module","exports"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/undici/lib/fetch/response.js"],"sourcesContent":["'use strict'\n\nconst { Headers, HeadersList, fill } = require('./headers')\nconst { extractBody, cloneBody, mixinBody } = require('./body')\nconst util = require('../core/util')\nconst { kEnumerableProperty } = util\nconst {\n  responseURL,\n  isValidReasonPhrase,\n  isCancelled,\n  isAborted,\n  isBlobLike,\n  serializeJavascriptValueToJSONString,\n  isErrorLike\n} = require('./util')\nconst {\n  redirectStatus,\n  nullBodyStatus,\n  DOMException\n} = require('./constants')\nconst { kState, kHeaders, kGuard, kRealm } = require('./symbols')\nconst { webidl } = require('./webidl')\nconst { FormData } = require('./formdata')\nconst { getGlobalOrigin } = require('./global')\nconst { kHeadersList } = require('../core/symbols')\nconst assert = require('assert')\nconst { types } = require('util')\n\nconst ReadableStream = globalThis.ReadableStream || require('stream/web').ReadableStream\n\n// https://fetch.spec.whatwg.org/#response-class\nclass Response {\n  // Creates network error Response.\n  static error () {\n    // TODO\n    const relevantRealm = { settingsObject: {} }\n\n    // The static error() method steps are to return the result of creating a\n    // Response object, given a new network error, \"immutable\", and this’s\n    // relevant Realm.\n    const responseObject = new Response()\n    responseObject[kState] = makeNetworkError()\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList\n    responseObject[kHeaders][kGuard] = 'immutable'\n    responseObject[kHeaders][kRealm] = relevantRealm\n    return responseObject\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response-json\n  static json (data, init = {}) {\n    if (arguments.length === 0) {\n      throw new TypeError(\n        'Failed to execute \\'json\\' on \\'Response\\': 1 argument required, but 0 present.'\n      )\n    }\n\n    if (init !== null) {\n      init = webidl.converters.ResponseInit(init)\n    }\n\n    // 1. Let bytes the result of running serialize a JavaScript value to JSON bytes on data.\n    const bytes = new TextEncoder('utf-8').encode(\n      serializeJavascriptValueToJSONString(data)\n    )\n\n    // 2. Let body be the result of extracting bytes.\n    const body = extractBody(bytes)\n\n    // 3. Let responseObject be the result of creating a Response object, given a new response,\n    //    \"response\", and this’s relevant Realm.\n    const relevantRealm = { settingsObject: {} }\n    const responseObject = new Response()\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kGuard] = 'response'\n    responseObject[kHeaders][kRealm] = relevantRealm\n\n    // 4. Perform initialize a response given responseObject, init, and (body, \"application/json\").\n    initializeResponse(responseObject, init, { body: body[0], type: 'application/json' })\n\n    // 5. Return responseObject.\n    return responseObject\n  }\n\n  // Creates a redirect Response that redirects to url with status status.\n  static redirect (url, status = 302) {\n    const relevantRealm = { settingsObject: {} }\n\n    if (arguments.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'redirect' on 'Response': 1 argument required, but only ${arguments.length} present.`\n      )\n    }\n\n    url = webidl.converters.USVString(url)\n    status = webidl.converters['unsigned short'](status)\n\n    // 1. Let parsedURL be the result of parsing url with current settings\n    // object’s API base URL.\n    // 2. If parsedURL is failure, then throw a TypeError.\n    // TODO: base-URL?\n    let parsedURL\n    try {\n      parsedURL = new URL(url, getGlobalOrigin())\n    } catch (err) {\n      throw Object.assign(new TypeError('Failed to parse URL from ' + url), {\n        cause: err\n      })\n    }\n\n    // 3. If status is not a redirect status, then throw a RangeError.\n    if (!redirectStatus.includes(status)) {\n      throw new RangeError('Invalid status code')\n    }\n\n    // 4. Let responseObject be the result of creating a Response object,\n    // given a new response, \"immutable\", and this’s relevant Realm.\n    const responseObject = new Response()\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kGuard] = 'immutable'\n    responseObject[kHeaders][kRealm] = relevantRealm\n\n    // 5. Set responseObject’s response’s status to status.\n    responseObject[kState].status = status\n\n    // 6. Let value be parsedURL, serialized and isomorphic encoded.\n    // TODO: isomorphic encoded?\n    const value = parsedURL.toString()\n\n    // 7. Append `Location`/value to responseObject’s response’s header list.\n    responseObject[kState].headersList.append('location', value)\n\n    // 8. Return responseObject.\n    return responseObject\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response\n  constructor (body = null, init = {}) {\n    if (body !== null) {\n      body = webidl.converters.BodyInit(body)\n    }\n\n    init = webidl.converters.ResponseInit(init)\n\n    // TODO\n    this[kRealm] = { settingsObject: {} }\n\n    // 1. Set this’s response to a new response.\n    this[kState] = makeResponse({})\n\n    // 2. Set this’s headers to a new Headers object with this’s relevant\n    // Realm, whose header list is this’s response’s header list and guard\n    // is \"response\".\n    this[kHeaders] = new Headers()\n    this[kHeaders][kGuard] = 'response'\n    this[kHeaders][kHeadersList] = this[kState].headersList\n    this[kHeaders][kRealm] = this[kRealm]\n\n    // 3. Let bodyWithType be null.\n    let bodyWithType = null\n\n    // 4. If body is non-null, then set bodyWithType to the result of extracting body.\n    if (body != null) {\n      const [extractedBody, type] = extractBody(body)\n      bodyWithType = { body: extractedBody, type }\n    }\n\n    // 5. Perform initialize a response given this, init, and bodyWithType.\n    initializeResponse(this, init, bodyWithType)\n  }\n\n  get [Symbol.toStringTag] () {\n    return this.constructor.name\n  }\n\n  // Returns response’s type, e.g., \"cors\".\n  get type () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The type getter steps are to return this’s response’s type.\n    return this[kState].type\n  }\n\n  // Returns response’s URL, if it has one; otherwise the empty string.\n  get url () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The url getter steps are to return the empty string if this’s\n    // response’s URL is null; otherwise this’s response’s URL,\n    // serialized with exclude fragment set to true.\n    let url = responseURL(this[kState])\n\n    if (url == null) {\n      return ''\n    }\n\n    if (url.hash) {\n      url = new URL(url)\n      url.hash = ''\n    }\n\n    return url.toString()\n  }\n\n  // Returns whether response was obtained through a redirect.\n  get redirected () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The redirected getter steps are to return true if this’s response’s URL\n    // list has more than one item; otherwise false.\n    return this[kState].urlList.length > 1\n  }\n\n  // Returns response’s status.\n  get status () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The status getter steps are to return this’s response’s status.\n    return this[kState].status\n  }\n\n  // Returns whether response’s status is an ok status.\n  get ok () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The ok getter steps are to return true if this’s response’s status is an\n    // ok status; otherwise false.\n    return this[kState].status >= 200 && this[kState].status <= 299\n  }\n\n  // Returns response’s status message.\n  get statusText () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The statusText getter steps are to return this’s response’s status\n    // message.\n    return this[kState].statusText\n  }\n\n  // Returns response’s headers as Headers.\n  get headers () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The headers getter steps are to return this’s headers.\n    return this[kHeaders]\n  }\n\n  // Returns a clone of response.\n  clone () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (this.bodyUsed || (this.body && this.body.locked)) {\n      webidl.errors.exception({\n        header: 'Response.clone',\n        message: 'Body has already been consumed.'\n      })\n    }\n\n    // 2. Let clonedResponse be the result of cloning this’s response.\n    const clonedResponse = cloneResponse(this[kState])\n\n    // 3. Return the result of creating a Response object, given\n    // clonedResponse, this’s headers’s guard, and this’s relevant Realm.\n    const clonedResponseObject = new Response()\n    clonedResponseObject[kState] = clonedResponse\n    clonedResponseObject[kRealm] = this[kRealm]\n    clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList\n    clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard]\n    clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm]\n\n    return clonedResponseObject\n  }\n}\n\nmixinBody(Response)\n\nObject.defineProperties(Response.prototype, {\n  type: kEnumerableProperty,\n  url: kEnumerableProperty,\n  status: kEnumerableProperty,\n  ok: kEnumerableProperty,\n  redirected: kEnumerableProperty,\n  statusText: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  clone: kEnumerableProperty\n})\n\n// https://fetch.spec.whatwg.org/#concept-response-clone\nfunction cloneResponse (response) {\n  // To clone a response response, run these steps:\n\n  // 1. If response is a filtered response, then return a new identical\n  // filtered response whose internal response is a clone of response’s\n  // internal response.\n  if (response.internalResponse) {\n    return filterResponse(\n      cloneResponse(response.internalResponse),\n      response.type\n    )\n  }\n\n  // 2. Let newResponse be a copy of response, except for its body.\n  const newResponse = makeResponse({ ...response, body: null })\n\n  // 3. If response’s body is non-null, then set newResponse’s body to the\n  // result of cloning response’s body.\n  if (response.body != null) {\n    newResponse.body = cloneBody(response.body)\n  }\n\n  // 4. Return newResponse.\n  return newResponse\n}\n\nfunction makeResponse (init) {\n  return {\n    aborted: false,\n    rangeRequested: false,\n    timingAllowPassed: false,\n    requestIncludesCredentials: false,\n    type: 'default',\n    status: 200,\n    timingInfo: null,\n    cacheState: '',\n    statusText: '',\n    ...init,\n    headersList: init.headersList\n      ? new HeadersList(init.headersList)\n      : new HeadersList(),\n    urlList: init.urlList ? [...init.urlList] : []\n  }\n}\n\nfunction makeNetworkError (reason) {\n  const isError = isErrorLike(reason)\n  return makeResponse({\n    type: 'error',\n    status: 0,\n    error: isError\n      ? reason\n      : new Error(reason ? String(reason) : reason, {\n        cause: isError ? reason : undefined\n      }),\n    aborted: reason && reason.name === 'AbortError'\n  })\n}\n\nfunction makeFilteredResponse (response, state) {\n  state = {\n    internalResponse: response,\n    ...state\n  }\n\n  return new Proxy(response, {\n    get (target, p) {\n      return p in state ? state[p] : target[p]\n    },\n    set (target, p, value) {\n      assert(!(p in state))\n      target[p] = value\n      return true\n    }\n  })\n}\n\n// https://fetch.spec.whatwg.org/#concept-filtered-response\nfunction filterResponse (response, type) {\n  // Set response to the following filtered response with response as its\n  // internal response, depending on request’s response tainting:\n  if (type === 'basic') {\n    // A basic filtered response is a filtered response whose type is \"basic\"\n    // and header list excludes any headers in internal response’s header list\n    // whose name is a forbidden response-header name.\n\n    // Note: undici does not implement forbidden response-header names\n    return makeFilteredResponse(response, {\n      type: 'basic',\n      headersList: response.headersList\n    })\n  } else if (type === 'cors') {\n    // A CORS filtered response is a filtered response whose type is \"cors\"\n    // and header list excludes any headers in internal response’s header\n    // list whose name is not a CORS-safelisted response-header name, given\n    // internal response’s CORS-exposed header-name list.\n\n    // Note: undici does not implement CORS-safelisted response-header names\n    return makeFilteredResponse(response, {\n      type: 'cors',\n      headersList: response.headersList\n    })\n  } else if (type === 'opaque') {\n    // An opaque filtered response is a filtered response whose type is\n    // \"opaque\", URL list is the empty list, status is 0, status message\n    // is the empty byte sequence, header list is empty, and body is null.\n\n    return makeFilteredResponse(response, {\n      type: 'opaque',\n      urlList: Object.freeze([]),\n      status: 0,\n      statusText: '',\n      body: null\n    })\n  } else if (type === 'opaqueredirect') {\n    // An opaque-redirect filtered response is a filtered response whose type\n    // is \"opaqueredirect\", status is 0, status message is the empty byte\n    // sequence, header list is empty, and body is null.\n\n    return makeFilteredResponse(response, {\n      type: 'opaqueredirect',\n      status: 0,\n      statusText: '',\n      headersList: [],\n      body: null\n    })\n  } else {\n    assert(false)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#appropriate-network-error\nfunction makeAppropriateNetworkError (fetchParams) {\n  // 1. Assert: fetchParams is canceled.\n  assert(isCancelled(fetchParams))\n\n  // 2. Return an aborted network error if fetchParams is aborted;\n  // otherwise return a network error.\n  return isAborted(fetchParams)\n    ? makeNetworkError(new DOMException('The operation was aborted.', 'AbortError'))\n    : makeNetworkError(fetchParams.controller.terminated.reason)\n}\n\n// https://whatpr.org/fetch/1392.html#initialize-a-response\nfunction initializeResponse (response, init, body) {\n  // 1. If init[\"status\"] is not in the range 200 to 599, inclusive, then\n  //    throw a RangeError.\n  if (init.status !== null && (init.status < 200 || init.status > 599)) {\n    throw new RangeError('init[\"status\"] must be in the range of 200 to 599, inclusive.')\n  }\n\n  // 2. If init[\"statusText\"] does not match the reason-phrase token production,\n  //    then throw a TypeError.\n  if ('statusText' in init && init.statusText != null) {\n    // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:\n    //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )\n    if (!isValidReasonPhrase(String(init.statusText))) {\n      throw new TypeError('Invalid statusText')\n    }\n  }\n\n  // 3. Set response’s response’s status to init[\"status\"].\n  if ('status' in init && init.status != null) {\n    response[kState].status = init.status\n  }\n\n  // 4. Set response’s response’s status message to init[\"statusText\"].\n  if ('statusText' in init && init.statusText != null) {\n    response[kState].statusText = init.statusText\n  }\n\n  // 5. If init[\"headers\"] exists, then fill response’s headers with init[\"headers\"].\n  if ('headers' in init && init.headers != null) {\n    fill(response[kState].headersList, init.headers)\n  }\n\n  // 6. If body was given, then:\n  if (body) {\n    // 1. If response's status is a null body status, then throw a TypeError.\n    if (nullBodyStatus.includes(response.status)) {\n      webidl.errors.exception({\n        header: 'Response constructor',\n        message: 'Invalid response status code.'\n      })\n    }\n\n    // 2. Set response's body to body's body.\n    response[kState].body = body.body\n\n    // 3. If body's type is non-null and response's header list does not contain\n    //    `Content-Type`, then append (`Content-Type`, body's type) to response's header list.\n    if (body.type != null && !response[kState].headersList.has('Content-Type')) {\n      response[kState].headersList.append('content-type', body.type)\n    }\n  }\n}\n\nwebidl.converters.ReadableStream = webidl.interfaceConverter(\n  ReadableStream\n)\n\nwebidl.converters.FormData = webidl.interfaceConverter(\n  FormData\n)\n\nwebidl.converters.URLSearchParams = webidl.interfaceConverter(\n  URLSearchParams\n)\n\n// https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit\nwebidl.converters.XMLHttpRequestBodyInit = function (V) {\n  if (typeof V === 'string') {\n    return webidl.converters.USVString(V)\n  }\n\n  if (isBlobLike(V)) {\n    return webidl.converters.Blob(V, { strict: false })\n  }\n\n  if (\n    types.isAnyArrayBuffer(V) ||\n    types.isTypedArray(V) ||\n    types.isDataView(V)\n  ) {\n    return webidl.converters.BufferSource(V)\n  }\n\n  if (util.isFormDataLike(V)) {\n    return webidl.converters.FormData(V, { strict: false })\n  }\n\n  if (V instanceof URLSearchParams) {\n    return webidl.converters.URLSearchParams(V)\n  }\n\n  return webidl.converters.DOMString(V)\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit\nwebidl.converters.BodyInit = function (V) {\n  if (V instanceof ReadableStream) {\n    return webidl.converters.ReadableStream(V)\n  }\n\n  // Note: the spec doesn't include async iterables,\n  // this is an undici extension.\n  if (V?.[Symbol.asyncIterator]) {\n    return V\n  }\n\n  return webidl.converters.XMLHttpRequestBodyInit(V)\n}\n\nwebidl.converters.ResponseInit = webidl.dictionaryConverter([\n  {\n    key: 'status',\n    converter: webidl.converters['unsigned short'],\n    defaultValue: 200\n  },\n  {\n    key: 'statusText',\n    converter: webidl.converters.ByteString,\n    defaultValue: ''\n  },\n  {\n    key: 'headers',\n    converter: webidl.converters.HeadersInit\n  }\n])\n\nmodule.exports = {\n  makeNetworkError,\n  makeResponse,\n  makeAppropriateNetworkError,\n  filterResponse,\n  Response\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}