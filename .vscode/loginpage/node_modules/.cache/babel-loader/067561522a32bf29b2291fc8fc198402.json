{"ast":null,"code":"'use strict';\n\nconst {\n  InvalidArgumentError,\n  RequestAbortedError,\n  SocketError\n} = require('../core/errors');\n\nconst {\n  AsyncResource\n} = require('async_hooks');\n\nconst util = require('../core/util');\n\nconst {\n  addSignal,\n  removeSignal\n} = require('./abort-signal');\n\nconst assert = require('assert');\n\nclass UpgradeHandler extends AsyncResource {\n  constructor(opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts');\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback');\n    }\n\n    const {\n      signal,\n      opaque,\n      responseHeaders\n    } = opts;\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');\n    }\n\n    super('UNDICI_UPGRADE');\n    this.responseHeaders = responseHeaders || null;\n    this.opaque = opaque || null;\n    this.callback = callback;\n    this.abort = null;\n    this.context = null;\n    addSignal(this, signal);\n  }\n\n  onConnect(abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError();\n    }\n\n    this.abort = abort;\n    this.context = null;\n  }\n\n  onHeaders() {\n    throw new SocketError('bad upgrade', null);\n  }\n\n  onUpgrade(statusCode, rawHeaders, socket) {\n    const {\n      callback,\n      opaque,\n      context\n    } = this;\n    assert.strictEqual(statusCode, 101);\n    removeSignal(this);\n    this.callback = null;\n    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n    this.runInAsyncScope(callback, null, null, {\n      headers,\n      socket,\n      opaque,\n      context\n    });\n  }\n\n  onError(err) {\n    const {\n      callback,\n      opaque\n    } = this;\n    removeSignal(this);\n\n    if (callback) {\n      this.callback = null;\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, {\n          opaque\n        });\n      });\n    }\n  }\n\n}\n\nfunction upgrade(opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      upgrade.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data);\n      });\n    });\n  }\n\n  try {\n    const upgradeHandler = new UpgradeHandler(opts, callback);\n    this.dispatch({ ...opts,\n      method: opts.method || 'GET',\n      upgrade: opts.protocol || 'Websocket'\n    }, upgradeHandler);\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err;\n    }\n\n    const opaque = opts && opts.opaque;\n    queueMicrotask(() => callback(err, {\n      opaque\n    }));\n  }\n}\n\nmodule.exports = upgrade;","map":{"version":3,"names":["InvalidArgumentError","RequestAbortedError","SocketError","require","AsyncResource","util","addSignal","removeSignal","assert","UpgradeHandler","constructor","opts","callback","signal","opaque","responseHeaders","on","addEventListener","abort","context","onConnect","onHeaders","onUpgrade","statusCode","rawHeaders","socket","strictEqual","headers","parseRawHeaders","parseHeaders","runInAsyncScope","onError","err","queueMicrotask","upgrade","undefined","Promise","resolve","reject","call","data","upgradeHandler","dispatch","method","protocol","module","exports"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/undici/lib/api/api-upgrade.js"],"sourcesContent":["'use strict'\n\nconst { InvalidArgumentError, RequestAbortedError, SocketError } = require('../core/errors')\nconst { AsyncResource } = require('async_hooks')\nconst util = require('../core/util')\nconst { addSignal, removeSignal } = require('./abort-signal')\nconst assert = require('assert')\n\nclass UpgradeHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    const { signal, opaque, responseHeaders } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    super('UNDICI_UPGRADE')\n\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.callback = callback\n    this.abort = null\n    this.context = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError()\n    }\n\n    this.abort = abort\n    this.context = null\n  }\n\n  onHeaders () {\n    throw new SocketError('bad upgrade', null)\n  }\n\n  onUpgrade (statusCode, rawHeaders, socket) {\n    const { callback, opaque, context } = this\n\n    assert.strictEqual(statusCode, 101)\n\n    removeSignal(this)\n\n    this.callback = null\n    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n    this.runInAsyncScope(callback, null, null, {\n      headers,\n      socket,\n      opaque,\n      context\n    })\n  }\n\n  onError (err) {\n    const { callback, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n  }\n}\n\nfunction upgrade (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      upgrade.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    const upgradeHandler = new UpgradeHandler(opts, callback)\n    this.dispatch({\n      ...opts,\n      method: opts.method || 'GET',\n      upgrade: opts.protocol || 'Websocket'\n    }, upgradeHandler)\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts && opts.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = upgrade\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}