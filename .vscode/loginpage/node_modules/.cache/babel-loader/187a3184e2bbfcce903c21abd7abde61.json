{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HttpProvider = void 0;\n\nconst events_1 = require(\"events\");\n\nconst constants_1 = require(\"../../constants\");\n\nconst jsonrpc_1 = require(\"../../util/jsonrpc\");\n\nconst packageInfo_1 = require(\"../../util/packageInfo\");\n\nconst errors_1 = require(\"../errors\");\n\nconst errors_list_1 = require(\"../errors-list\");\n\nconst errors_2 = require(\"./errors\");\n\nfunction isErrorResponse(response) {\n  return typeof response.error !== \"undefined\";\n}\n\nconst MAX_RETRIES = 6;\nconst MAX_RETRY_AWAIT_SECONDS = 5;\nconst TOO_MANY_REQUEST_STATUS = 429;\nconst hardhatVersion = (0, packageInfo_1.getHardhatVersion)();\n\nclass HttpProvider extends events_1.EventEmitter {\n  constructor(_url, _networkName) {\n    let _extraHeaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    let _timeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 20000;\n\n    let client = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n    super();\n    this._url = _url;\n    this._networkName = _networkName;\n    this._extraHeaders = _extraHeaders;\n    this._timeout = _timeout;\n    this._nextRequestId = 1;\n\n    const {\n      Pool\n    } = require(\"undici\");\n\n    const url = new URL(this._url);\n    this._path = url.pathname;\n    this._authHeader = url.username === \"\" ? undefined : `Basic ${Buffer.from(`${url.username}:${url.password}`, \"utf-8\").toString(\"base64\")}`;\n\n    try {\n      this._dispatcher = client ?? new Pool(url.origin);\n    } catch (e) {\n      if (e instanceof TypeError && e.message === \"Invalid URL\") {\n        e.message += ` ${url.origin}`;\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw e;\n    }\n  }\n\n  get url() {\n    return this._url;\n  }\n\n  async request(args) {\n    // We create the error here to capture the stack traces at this point,\n    // the async call that follows would probably loose of the stack trace\n    const error = new errors_2.ProviderError(\"HttpProviderError\", -1);\n\n    const jsonRpcRequest = this._getJsonRpcRequest(args.method, args.params);\n\n    const jsonRpcResponse = await this._fetchJsonRpcResponse(jsonRpcRequest);\n\n    if (isErrorResponse(jsonRpcResponse)) {\n      error.message = jsonRpcResponse.error.message;\n      error.code = jsonRpcResponse.error.code;\n      error.data = jsonRpcResponse.error.data; // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n      throw error;\n    }\n\n    if (args.method === \"hardhat_reset\") {\n      this.emit(constants_1.HARDHAT_NETWORK_RESET_EVENT);\n    }\n\n    if (args.method === \"evm_revert\") {\n      this.emit(constants_1.HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT);\n    }\n\n    return jsonRpcResponse.result;\n  }\n  /**\n   * Sends a batch of requests. Fails if any of them fails.\n   */\n\n\n  async sendBatch(batch) {\n    // We create the errors here to capture the stack traces at this point,\n    // the async call that follows would probably loose of the stack trace\n    const error = new errors_2.ProviderError(\"HttpProviderError\", -1); // we need this to sort the responses\n\n    const idToIndexMap = {};\n    const requests = batch.map((r, i) => {\n      const jsonRpcRequest = this._getJsonRpcRequest(r.method, r.params);\n\n      idToIndexMap[jsonRpcRequest.id] = i;\n      return jsonRpcRequest;\n    });\n    const jsonRpcResponses = await this._fetchJsonRpcResponse(requests);\n\n    for (const response of jsonRpcResponses) {\n      if (isErrorResponse(response)) {\n        error.message = response.error.message;\n        error.code = response.error.code;\n        error.data = response.error.data; // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n        throw error;\n      }\n    } // We already know that it has this type, but TS can't infer it.\n\n\n    const responses = jsonRpcResponses; // we use the id to sort the responses so that they match the order of the requests\n\n    const sortedResponses = responses.map(response => [idToIndexMap[response.id], response.result]).sort((_ref, _ref2) => {\n      let [indexA] = _ref;\n      let [indexB] = _ref2;\n      return indexA - indexB;\n    }).map(_ref3 => {\n      let [, result] = _ref3;\n      return result;\n    });\n    return sortedResponses;\n  }\n\n  async _fetchJsonRpcResponse(request) {\n    let retryNumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    try {\n      const response = await this._dispatcher.request({\n        method: \"POST\",\n        path: this._path,\n        body: JSON.stringify(request),\n        maxRedirections: 10,\n        headersTimeout: process.env.DO_NOT_SET_THIS_ENV_VAR____IS_HARDHAT_CI !== undefined ? 0 : this._timeout,\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"User-Agent\": `hardhat ${hardhatVersion ?? \"(unknown version)\"}`,\n          Authorization: this._authHeader,\n          ...this._extraHeaders\n        }\n      });\n\n      if (this._isRateLimitResponse(response)) {\n        // \"The Fetch Standard allows users to skip consuming the response body\n        // by relying on garbage collection to release connection resources.\n        // Undici does not do the same. Therefore, it is important to always\n        // either consume or cancel the response body.\"\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        // It's not clear how to \"cancel\", so we'll just consume:\n        await response.body.text();\n\n        const seconds = this._getRetryAfterSeconds(response);\n\n        if (seconds !== undefined && this._shouldRetry(retryNumber, seconds)) {\n          return await this._retry(request, seconds, retryNumber);\n        }\n\n        const url = new URL(this._url); // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n        throw new errors_2.ProviderError(`Too Many Requests error received from ${url.hostname}`, -32005 // Limit exceeded according to EIP1474\n        );\n      }\n\n      return (0, jsonrpc_1.parseJsonResponse)(await response.body.text());\n    } catch (error) {\n      if (error.code === \"ECONNREFUSED\") {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.NODE_IS_NOT_RUNNING, {\n          network: this._networkName\n        }, error);\n      }\n\n      if (error.type === \"request-timeout\") {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.NETWORK_TIMEOUT, {}, error);\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw error;\n    }\n  }\n\n  async _retry(request, seconds, retryNumber) {\n    await new Promise(resolve => setTimeout(resolve, 1000 * seconds));\n    return this._fetchJsonRpcResponse(request, retryNumber + 1);\n  }\n\n  _getJsonRpcRequest(method) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return {\n      jsonrpc: \"2.0\",\n      method,\n      params,\n      id: this._nextRequestId++\n    };\n  }\n\n  _shouldRetry(retryNumber, retryAfterSeconds) {\n    if (retryNumber > MAX_RETRIES) {\n      return false;\n    }\n\n    if (retryAfterSeconds > MAX_RETRY_AWAIT_SECONDS) {\n      return false;\n    }\n\n    return true;\n  }\n\n  _isRateLimitResponse(response) {\n    return response.statusCode === TOO_MANY_REQUEST_STATUS;\n  }\n\n  _getRetryAfterSeconds(response) {\n    const header = response.headers[\"retry-after\"];\n\n    if (header === undefined || header === null) {\n      return undefined;\n    }\n\n    const parsed = parseInt(header, 10);\n\n    if (isNaN(parsed)) {\n      return undefined;\n    }\n\n    return parsed;\n  }\n\n}\n\nexports.HttpProvider = HttpProvider;","map":{"version":3,"mappings":";;;;;;;AAEA;;AAGA;;AAIA;;AAOA;;AACA;;AACA;;AAEA;;AAEA,SAASA,eAAT,CAAyBC,QAAzB,EAAsC;EACpC,OAAO,OAAOA,QAAQ,CAACC,KAAhB,KAA0B,WAAjC;AACD;;AAED,MAAMC,WAAW,GAAG,CAApB;AACA,MAAMC,uBAAuB,GAAG,CAAhC;AAEA,MAAMC,uBAAuB,GAAG,GAAhC;AAEA,MAAMC,cAAc,GAAG,sCAAvB;;AAEA,MAAaC,YAAb,SAAkCC,qBAAlC,CAA8C;EAM5CC,YACmBC,IADnB,EAEmBC,YAFnB,EAK4C;IAAA,IAFzBC,aAEyB,uEAFmB,EAEnB;;IAAA,IADzBC,QACyB,uEADd,KACc;;IAAA,IAA1CC,MAA0C,uEAATC,SAAS;IAE1C;IANiB;IACA;IACA;IACA;IATX,sBAAiB,CAAjB;;IAcN,MAAM;MAAEC;IAAF,IAAWC,OAAO,CAAC,QAAD,CAAxB;;IAEA,MAAMC,GAAG,GAAG,IAAIC,GAAJ,CAAQ,KAAKT,IAAb,CAAZ;IACA,KAAKU,KAAL,GAAaF,GAAG,CAACG,QAAjB;IACA,KAAKC,WAAL,GACEJ,GAAG,CAACK,QAAJ,KAAiB,EAAjB,GACIR,SADJ,GAEI,SAASS,MAAM,CAACC,IAAP,CACP,GAAGP,GAAG,CAACK,QAAQ,IAAIL,GAAG,CAACQ,QAAQ,EADxB,EAEP,OAFO,EAGPC,QAHO,CAGE,QAHF,CAGW,EAN1B;;IAOA,IAAI;MACF,KAAKC,WAAL,GAAmBd,MAAM,IAAI,IAAIE,IAAJ,CAASE,GAAG,CAACW,MAAb,CAA7B;IACD,CAFD,CAEE,OAAOC,CAAP,EAAU;MACV,IAAIA,CAAC,YAAYC,SAAb,IAA0BD,CAAC,CAACE,OAAF,KAAc,aAA5C,EAA2D;QACzDF,CAAC,CAACE,OAAF,IAAa,IAAId,GAAG,CAACW,MAAM,EAA3B;MACD,CAHS,CAIV;;;MACA,MAAMC,CAAN;IACD;EACF;;EAEa,IAAHZ,GAAG;IACZ,OAAO,KAAKR,IAAZ;EACD;;EAEmB,MAAPuB,OAAO,CAACC,IAAD,EAAuB;IACzC;IACA;IACA,MAAMhC,KAAK,GAAG,IAAIiC,sBAAJ,CAAkB,mBAAlB,EAAuC,CAAC,CAAxC,CAAd;;IAEA,MAAMC,cAAc,GAAG,KAAKC,kBAAL,CACrBH,IAAI,CAACI,MADgB,EAErBJ,IAAI,CAACK,MAFgB,CAAvB;;IAIA,MAAMC,eAAe,GAAG,MAAM,KAAKC,qBAAL,CAA2BL,cAA3B,CAA9B;;IAEA,IAAIpC,eAAe,CAACwC,eAAD,CAAnB,EAAsC;MACpCtC,KAAK,CAAC8B,OAAN,GAAgBQ,eAAe,CAACtC,KAAhB,CAAsB8B,OAAtC;MACA9B,KAAK,CAACwC,IAAN,GAAaF,eAAe,CAACtC,KAAhB,CAAsBwC,IAAnC;MACAxC,KAAK,CAACyC,IAAN,GAAaH,eAAe,CAACtC,KAAhB,CAAsByC,IAAnC,CAHoC,CAIpC;;MACA,MAAMzC,KAAN;IACD;;IAED,IAAIgC,IAAI,CAACI,MAAL,KAAgB,eAApB,EAAqC;MACnC,KAAKM,IAAL,CAAUC,uCAAV;IACD;;IACD,IAAIX,IAAI,CAACI,MAAL,KAAgB,YAApB,EAAkC;MAChC,KAAKM,IAAL,CAAUC,iDAAV;IACD;;IAED,OAAOL,eAAe,CAACM,MAAvB;EACD;EAED;;;;;EAGsB,MAATC,SAAS,CACpBC,KADoB,EAC2B;IAE/C;IACA;IACA,MAAM9C,KAAK,GAAG,IAAIiC,sBAAJ,CAAkB,mBAAlB,EAAuC,CAAC,CAAxC,CAAd,CAJ+C,CAM/C;;IACA,MAAMc,YAAY,GAA2B,EAA7C;IAEA,MAAMC,QAAQ,GAAGF,KAAK,CAACG,GAAN,CAAU,CAACC,CAAD,EAAIC,CAAJ,KAAS;MAClC,MAAMjB,cAAc,GAAG,KAAKC,kBAAL,CAAwBe,CAAC,CAACd,MAA1B,EAAkCc,CAAC,CAACb,MAApC,CAAvB;;MACAU,YAAY,CAACb,cAAc,CAACkB,EAAhB,CAAZ,GAAkCD,CAAlC;MACA,OAAOjB,cAAP;IACD,CAJgB,CAAjB;IAMA,MAAMmB,gBAAgB,GAAG,MAAM,KAAKd,qBAAL,CAA2BS,QAA3B,CAA/B;;IAEA,KAAK,MAAMjD,QAAX,IAAuBsD,gBAAvB,EAAyC;MACvC,IAAIvD,eAAe,CAACC,QAAD,CAAnB,EAA+B;QAC7BC,KAAK,CAAC8B,OAAN,GAAgB/B,QAAQ,CAACC,KAAT,CAAe8B,OAA/B;QACA9B,KAAK,CAACwC,IAAN,GAAazC,QAAQ,CAACC,KAAT,CAAewC,IAA5B;QACAxC,KAAK,CAACyC,IAAN,GAAa1C,QAAQ,CAACC,KAAT,CAAeyC,IAA5B,CAH6B,CAI7B;;QACA,MAAMzC,KAAN;MACD;IACF,CAzB8C,CA2B/C;;;IACA,MAAMsD,SAAS,GAAGD,gBAAlB,CA5B+C,CA8B/C;;IACA,MAAME,eAAe,GAAGD,SAAS,CAC9BL,GADqB,CAEnBlD,QAAD,IACE,CAACgD,YAAY,CAAChD,QAAQ,CAACqD,EAAV,CAAb,EAA4BrD,QAAQ,CAAC6C,MAArC,CAHkB,EAKrBY,IALqB,CAKhB;MAAA,IAAC,CAACC,MAAD,CAAD;MAAA,IAAW,CAACC,MAAD,CAAX;MAAA,OAAwBD,MAAM,GAAGC,MAAjC;IAAA,CALgB,EAMrBT,GANqB,CAMjB;MAAA,IAAC,GAAGL,MAAH,CAAD;MAAA,OAAgBA,MAAhB;IAAA,CANiB,CAAxB;IAQA,OAAOW,eAAP;EACD;;EAckC,MAArBhB,qBAAqB,CACjCR,OADiC,EAElB;IAAA,IAAf4B,WAAe,uEAAD,CAAC;;IAEf,IAAI;MACF,MAAM5D,QAAQ,GAAG,MAAM,KAAK2B,WAAL,CAAiBK,OAAjB,CAAyB;QAC9CK,MAAM,EAAE,MADsC;QAE9CwB,IAAI,EAAE,KAAK1C,KAFmC;QAG9C2C,IAAI,EAAEC,IAAI,CAACC,SAAL,CAAehC,OAAf,CAHwC;QAI9CiC,eAAe,EAAE,EAJ6B;QAK9CC,cAAc,EACZC,OAAO,CAACC,GAAR,CAAYC,wCAAZ,KAAyDvD,SAAzD,GACI,CADJ,GAEI,KAAKF,QARmC;QAS9C0D,OAAO,EAAE;UACP,gBAAgB,kBADT;UAEP,cAAc,WAAWjE,cAAc,IAAI,mBAAmB,EAFvD;UAGPkE,aAAa,EAAE,KAAKlD,WAHb;UAIP,GAAG,KAAKV;QAJD;MATqC,CAAzB,CAAvB;;MAiBA,IAAI,KAAK6D,oBAAL,CAA0BxE,QAA1B,CAAJ,EAAyC;QACvC;QACA;QACA;QACA;QACA;QACA;QACA,MAAMA,QAAQ,CAAC8D,IAAT,CAAcW,IAAd,EAAN;;QACA,MAAMC,OAAO,GAAG,KAAKC,qBAAL,CAA2B3E,QAA3B,CAAhB;;QACA,IAAI0E,OAAO,KAAK5D,SAAZ,IAAyB,KAAK8D,YAAL,CAAkBhB,WAAlB,EAA+Bc,OAA/B,CAA7B,EAAsE;UACpE,OAAO,MAAM,KAAKG,MAAL,CAAY7C,OAAZ,EAAqB0C,OAArB,EAA8Bd,WAA9B,CAAb;QACD;;QAED,MAAM3C,GAAG,GAAG,IAAIC,GAAJ,CAAQ,KAAKT,IAAb,CAAZ,CAbuC,CAevC;;QACA,MAAM,IAAIyB,sBAAJ,CACJ,yCAAyCjB,GAAG,CAAC6D,QAAQ,EADjD,EAEJ,CAAC,KAFG,CAEG;QAFH,CAAN;MAID;;MAED,OAAO,iCAAkB,MAAM9E,QAAQ,CAAC8D,IAAT,CAAcW,IAAd,EAAxB,CAAP;IACD,CAzCD,CAyCE,OAAOxE,KAAP,EAAmB;MACnB,IAAIA,KAAK,CAACwC,IAAN,KAAe,cAAnB,EAAmC;QACjC,MAAM,IAAIsC,qBAAJ,CACJC,qBAAOC,OAAP,CAAeC,mBADX,EAEJ;UAAEC,OAAO,EAAE,KAAKzE;QAAhB,CAFI,EAGJT,KAHI,CAAN;MAKD;;MAED,IAAIA,KAAK,CAACmF,IAAN,KAAe,iBAAnB,EAAsC;QACpC,MAAM,IAAIL,qBAAJ,CAAiBC,qBAAOC,OAAP,CAAeI,eAAhC,EAAiD,EAAjD,EAAqDpF,KAArD,CAAN;MACD,CAXkB,CAanB;;;MACA,MAAMA,KAAN;IACD;EACF;;EAEmB,MAAN4E,MAAM,CAClB7C,OADkB,EAElB0C,OAFkB,EAGlBd,WAHkB,EAGC;IAEnB,MAAM,IAAI0B,OAAJ,CAAaC,OAAD,IAAaC,UAAU,CAACD,OAAD,EAAU,OAAOb,OAAjB,CAAnC,CAAN;IACA,OAAO,KAAKlC,qBAAL,CAA2BR,OAA3B,EAAoC4B,WAAW,GAAG,CAAlD,CAAP;EACD;;EAEOxB,kBAAkB,CACxBC,MADwB,EAEN;IAAA,IAAlBC,MAAkB,uEAAF,EAAE;IAElB,OAAO;MACLmD,OAAO,EAAE,KADJ;MAELpD,MAFK;MAGLC,MAHK;MAILe,EAAE,EAAE,KAAKqC,cAAL;IAJC,CAAP;EAMD;;EAEOd,YAAY,CAAChB,WAAD,EAAsB+B,iBAAtB,EAA+C;IACjE,IAAI/B,WAAW,GAAG1D,WAAlB,EAA+B;MAC7B,OAAO,KAAP;IACD;;IAED,IAAIyF,iBAAiB,GAAGxF,uBAAxB,EAAiD;MAC/C,OAAO,KAAP;IACD;;IAED,OAAO,IAAP;EACD;;EAEOqE,oBAAoB,CAACxE,QAAD,EAAkC;IAC5D,OAAOA,QAAQ,CAAC4F,UAAT,KAAwBxF,uBAA/B;EACD;;EAEOuE,qBAAqB,CAC3B3E,QAD2B,EACM;IAEjC,MAAM6F,MAAM,GAAG7F,QAAQ,CAACsE,OAAT,CAAiB,aAAjB,CAAf;;IAEA,IAAIuB,MAAM,KAAK/E,SAAX,IAAwB+E,MAAM,KAAK,IAAvC,EAA6C;MAC3C,OAAO/E,SAAP;IACD;;IAED,MAAMgF,MAAM,GAAGC,QAAQ,CAACF,MAAD,EAAS,EAAT,CAAvB;;IACA,IAAIG,KAAK,CAACF,MAAD,CAAT,EAAmB;MACjB,OAAOhF,SAAP;IACD;;IAED,OAAOgF,MAAP;EACD;;AAnP2C;;AAA9CG","names":["isErrorResponse","response","error","MAX_RETRIES","MAX_RETRY_AWAIT_SECONDS","TOO_MANY_REQUEST_STATUS","hardhatVersion","HttpProvider","events_1","constructor","_url","_networkName","_extraHeaders","_timeout","client","undefined","Pool","require","url","URL","_path","pathname","_authHeader","username","Buffer","from","password","toString","_dispatcher","origin","e","TypeError","message","request","args","errors_2","jsonRpcRequest","_getJsonRpcRequest","method","params","jsonRpcResponse","_fetchJsonRpcResponse","code","data","emit","constants_1","result","sendBatch","batch","idToIndexMap","requests","map","r","i","id","jsonRpcResponses","responses","sortedResponses","sort","indexA","indexB","retryNumber","path","body","JSON","stringify","maxRedirections","headersTimeout","process","env","DO_NOT_SET_THIS_ENV_VAR____IS_HARDHAT_CI","headers","Authorization","_isRateLimitResponse","text","seconds","_getRetryAfterSeconds","_shouldRetry","_retry","hostname","errors_1","errors_list_1","NETWORK","NODE_IS_NOT_RUNNING","network","type","NETWORK_TIMEOUT","Promise","resolve","setTimeout","jsonrpc","_nextRequestId","retryAfterSeconds","statusCode","header","parsed","parseInt","isNaN","exports"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\hardhat\\src\\internal\\core\\providers\\http.ts"],"sourcesContent":["import type { Dispatcher, Pool as PoolT } from \"undici\";\n\nimport { EventEmitter } from \"events\";\n\nimport { EIP1193Provider, RequestArguments } from \"../../../types\";\nimport {\n  HARDHAT_NETWORK_RESET_EVENT,\n  HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT,\n} from \"../../constants\";\nimport {\n  FailedJsonRpcResponse,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  parseJsonResponse,\n  SuccessfulJsonRpcResponse,\n} from \"../../util/jsonrpc\";\nimport { getHardhatVersion } from \"../../util/packageInfo\";\nimport { HardhatError } from \"../errors\";\nimport { ERRORS } from \"../errors-list\";\n\nimport { ProviderError } from \"./errors\";\n\nfunction isErrorResponse(response: any): response is FailedJsonRpcResponse {\n  return typeof response.error !== \"undefined\";\n}\n\nconst MAX_RETRIES = 6;\nconst MAX_RETRY_AWAIT_SECONDS = 5;\n\nconst TOO_MANY_REQUEST_STATUS = 429;\n\nconst hardhatVersion = getHardhatVersion();\n\nexport class HttpProvider extends EventEmitter implements EIP1193Provider {\n  private _nextRequestId = 1;\n  private _dispatcher: Dispatcher;\n  private _path: string;\n  private _authHeader: string | undefined;\n\n  constructor(\n    private readonly _url: string,\n    private readonly _networkName: string,\n    private readonly _extraHeaders: { [name: string]: string } = {},\n    private readonly _timeout = 20000,\n    client: Dispatcher | undefined = undefined\n  ) {\n    super();\n\n    const { Pool } = require(\"undici\") as { Pool: typeof PoolT };\n\n    const url = new URL(this._url);\n    this._path = url.pathname;\n    this._authHeader =\n      url.username === \"\"\n        ? undefined\n        : `Basic ${Buffer.from(\n            `${url.username}:${url.password}`,\n            \"utf-8\"\n          ).toString(\"base64\")}`;\n    try {\n      this._dispatcher = client ?? new Pool(url.origin);\n    } catch (e) {\n      if (e instanceof TypeError && e.message === \"Invalid URL\") {\n        e.message += ` ${url.origin}`;\n      }\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    }\n  }\n\n  public get url(): string {\n    return this._url;\n  }\n\n  public async request(args: RequestArguments): Promise<unknown> {\n    // We create the error here to capture the stack traces at this point,\n    // the async call that follows would probably loose of the stack trace\n    const error = new ProviderError(\"HttpProviderError\", -1);\n\n    const jsonRpcRequest = this._getJsonRpcRequest(\n      args.method,\n      args.params as any[]\n    );\n    const jsonRpcResponse = await this._fetchJsonRpcResponse(jsonRpcRequest);\n\n    if (isErrorResponse(jsonRpcResponse)) {\n      error.message = jsonRpcResponse.error.message;\n      error.code = jsonRpcResponse.error.code;\n      error.data = jsonRpcResponse.error.data;\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n\n    if (args.method === \"hardhat_reset\") {\n      this.emit(HARDHAT_NETWORK_RESET_EVENT);\n    }\n    if (args.method === \"evm_revert\") {\n      this.emit(HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT);\n    }\n\n    return jsonRpcResponse.result;\n  }\n\n  /**\n   * Sends a batch of requests. Fails if any of them fails.\n   */\n  public async sendBatch(\n    batch: Array<{ method: string; params: any[] }>\n  ): Promise<any[]> {\n    // We create the errors here to capture the stack traces at this point,\n    // the async call that follows would probably loose of the stack trace\n    const error = new ProviderError(\"HttpProviderError\", -1);\n\n    // we need this to sort the responses\n    const idToIndexMap: Record<string, number> = {};\n\n    const requests = batch.map((r, i) => {\n      const jsonRpcRequest = this._getJsonRpcRequest(r.method, r.params);\n      idToIndexMap[jsonRpcRequest.id] = i;\n      return jsonRpcRequest;\n    });\n\n    const jsonRpcResponses = await this._fetchJsonRpcResponse(requests);\n\n    for (const response of jsonRpcResponses) {\n      if (isErrorResponse(response)) {\n        error.message = response.error.message;\n        error.code = response.error.code;\n        error.data = response.error.data;\n        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n        throw error;\n      }\n    }\n\n    // We already know that it has this type, but TS can't infer it.\n    const responses = jsonRpcResponses as SuccessfulJsonRpcResponse[];\n\n    // we use the id to sort the responses so that they match the order of the requests\n    const sortedResponses = responses\n      .map(\n        (response) =>\n          [idToIndexMap[response.id], response.result] as [number, any]\n      )\n      .sort(([indexA], [indexB]) => indexA - indexB)\n      .map(([, result]) => result);\n\n    return sortedResponses;\n  }\n\n  private async _fetchJsonRpcResponse(\n    request: JsonRpcRequest,\n    retryNumber?: number\n  ): Promise<JsonRpcResponse>;\n  private async _fetchJsonRpcResponse(\n    request: JsonRpcRequest[],\n    retryNumber?: number\n  ): Promise<JsonRpcResponse[]>;\n  private async _fetchJsonRpcResponse(\n    request: JsonRpcRequest | JsonRpcRequest[],\n    retryNumber?: number\n  ): Promise<JsonRpcResponse | JsonRpcResponse[]>;\n  private async _fetchJsonRpcResponse(\n    request: JsonRpcRequest | JsonRpcRequest[],\n    retryNumber = 0\n  ): Promise<JsonRpcResponse | JsonRpcResponse[]> {\n    try {\n      const response = await this._dispatcher.request({\n        method: \"POST\",\n        path: this._path,\n        body: JSON.stringify(request),\n        maxRedirections: 10,\n        headersTimeout:\n          process.env.DO_NOT_SET_THIS_ENV_VAR____IS_HARDHAT_CI !== undefined\n            ? 0\n            : this._timeout,\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"User-Agent\": `hardhat ${hardhatVersion ?? \"(unknown version)\"}`,\n          Authorization: this._authHeader,\n          ...this._extraHeaders,\n        },\n      });\n\n      if (this._isRateLimitResponse(response)) {\n        // \"The Fetch Standard allows users to skip consuming the response body\n        // by relying on garbage collection to release connection resources.\n        // Undici does not do the same. Therefore, it is important to always\n        // either consume or cancel the response body.\"\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        // It's not clear how to \"cancel\", so we'll just consume:\n        await response.body.text();\n        const seconds = this._getRetryAfterSeconds(response);\n        if (seconds !== undefined && this._shouldRetry(retryNumber, seconds)) {\n          return await this._retry(request, seconds, retryNumber);\n        }\n\n        const url = new URL(this._url);\n\n        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n        throw new ProviderError(\n          `Too Many Requests error received from ${url.hostname}`,\n          -32005 // Limit exceeded according to EIP1474\n        );\n      }\n\n      return parseJsonResponse(await response.body.text());\n    } catch (error: any) {\n      if (error.code === \"ECONNREFUSED\") {\n        throw new HardhatError(\n          ERRORS.NETWORK.NODE_IS_NOT_RUNNING,\n          { network: this._networkName },\n          error\n        );\n      }\n\n      if (error.type === \"request-timeout\") {\n        throw new HardhatError(ERRORS.NETWORK.NETWORK_TIMEOUT, {}, error);\n      }\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  }\n\n  private async _retry(\n    request: JsonRpcRequest | JsonRpcRequest[],\n    seconds: number,\n    retryNumber: number\n  ) {\n    await new Promise((resolve) => setTimeout(resolve, 1000 * seconds));\n    return this._fetchJsonRpcResponse(request, retryNumber + 1);\n  }\n\n  private _getJsonRpcRequest(\n    method: string,\n    params: any[] = []\n  ): JsonRpcRequest {\n    return {\n      jsonrpc: \"2.0\",\n      method,\n      params,\n      id: this._nextRequestId++,\n    };\n  }\n\n  private _shouldRetry(retryNumber: number, retryAfterSeconds: number) {\n    if (retryNumber > MAX_RETRIES) {\n      return false;\n    }\n\n    if (retryAfterSeconds > MAX_RETRY_AWAIT_SECONDS) {\n      return false;\n    }\n\n    return true;\n  }\n\n  private _isRateLimitResponse(response: Dispatcher.ResponseData) {\n    return response.statusCode === TOO_MANY_REQUEST_STATUS;\n  }\n\n  private _getRetryAfterSeconds(\n    response: Dispatcher.ResponseData\n  ): number | undefined {\n    const header = response.headers[\"retry-after\"];\n\n    if (header === undefined || header === null) {\n      return undefined;\n    }\n\n    const parsed = parseInt(header, 10);\n    if (isNaN(parsed)) {\n      return undefined;\n    }\n\n    return parsed;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}