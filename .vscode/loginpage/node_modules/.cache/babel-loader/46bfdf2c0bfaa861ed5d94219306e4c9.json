{"ast":null,"code":"var debug = require('debug')('eventstore:eventstream'),\n    _ = require('lodash'),\n    Event = require('./event');\n/**\n * EventStream constructor\n * The eventstream is one of the main objects to interagate with the eventstore.\n * @param {Object} eventstore the eventstore that should be injected\n * @param {Object} query the query object\n * @param {Array} events the events (from store)\n * @constructor\n */\n\n\nfunction EventStream(eventstore, query, events) {\n  if (!eventstore) {\n    var errESMsg = 'eventstore not injected!';\n    debug(errESMsg);\n    throw new Error(errESMsg);\n  }\n\n  if (typeof eventstore.commit !== 'function') {\n    var errESfnMsg = 'eventstore.commit not injected!';\n    debug(errESfnMsg);\n    throw new Error(errESfnMsg);\n  }\n\n  if (!query) {\n    var errQryMsg = 'query not injected!';\n    debug(errQryMsg);\n    throw new Error(errQryMsg);\n  }\n\n  if (!query.aggregateId) {\n    var errAggIdMsg = 'query.aggregateId not injected!';\n    debug(errAggIdMsg);\n    throw new Error(errAggIdMsg);\n  }\n\n  if (events) {\n    if (!_.isArray(events)) {\n      var errEvtsArrMsg = 'events should be an array!';\n      debug(errEvtsArrMsg);\n      throw new Error(errEvtsArrMsg);\n    }\n\n    for (var i = 0, len = events.length; i < len; i++) {\n      var evt = events[i];\n\n      if (evt.streamRevision === undefined || evt.streamRevision === null) {\n        var errEvtMsg = 'The events passed should all have a streamRevision!';\n        debug(errEvtMsg);\n        throw new Error(errEvtMsg);\n      }\n    }\n  }\n\n  this.eventstore = eventstore;\n  this.streamId = query.aggregateId;\n  this.aggregateId = query.aggregateId;\n  this.aggregate = query.aggregate;\n  this.context = query.context;\n  this.events = events || [];\n  this.uncommittedEvents = [];\n  this.lastRevision = -1;\n  this.events = _.sortBy(this.events, 'streamRevision'); // to update lastRevision...\n\n  this.currentRevision();\n}\n\nEventStream.prototype = {\n  /**\n   * This helper function calculates and returns the current stream revision.\n   * @returns {Number} lastRevision\n   */\n  currentRevision: function () {\n    for (var i = 0, len = this.events.length; i < len; i++) {\n      if (this.events[i].streamRevision > this.lastRevision) {\n        this.lastRevision = this.events[i].streamRevision;\n      }\n    }\n\n    return this.lastRevision;\n  },\n\n  /**\n   * adds an event to the uncommittedEvents array\n   * @param {Object} event\n   */\n  addEvent: function (event) {\n    new Event(this, event, this.eventstore.eventMappings);\n  },\n\n  /**\n   * adds an array of events to the uncommittedEvents array\n   * @param {Array} events\n   */\n  addEvents: function (events) {\n    if (!_.isArray(events)) {\n      var errEvtsArrMsg = 'events should be an array!';\n      debug(errEvtsArrMsg);\n      throw new Error(errEvtsArrMsg);\n    }\n\n    var self = this;\n\n    _.each(events, function (evt) {\n      self.addEvent(evt);\n    });\n  },\n\n  /**\n   * commits all uncommittedEvents\n   * @param {Function} callback the function that will be called when this action has finished [optional]\n   */\n  commit: function (callback) {\n    this.eventstore.commit(this, callback);\n  }\n};\nmodule.exports = EventStream;","map":{"version":3,"names":["debug","require","_","Event","EventStream","eventstore","query","events","errESMsg","Error","commit","errESfnMsg","errQryMsg","aggregateId","errAggIdMsg","isArray","errEvtsArrMsg","i","len","length","evt","streamRevision","undefined","errEvtMsg","streamId","aggregate","context","uncommittedEvents","lastRevision","sortBy","currentRevision","prototype","addEvent","event","eventMappings","addEvents","self","each","callback","module","exports"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/eventstore/lib/eventStream.js"],"sourcesContent":["var debug = require('debug')('eventstore:eventstream'),\n  _ = require('lodash'),\n  Event = require('./event');\n\n/**\n * EventStream constructor\n * The eventstream is one of the main objects to interagate with the eventstore.\n * @param {Object} eventstore the eventstore that should be injected\n * @param {Object} query the query object\n * @param {Array} events the events (from store)\n * @constructor\n */\nfunction EventStream (eventstore, query, events) {\n  if (!eventstore) {\n    var errESMsg = 'eventstore not injected!';\n    debug(errESMsg);\n    throw new Error(errESMsg);\n  }\n\n  if (typeof eventstore.commit !== 'function') {\n    var errESfnMsg = 'eventstore.commit not injected!';\n    debug(errESfnMsg);\n    throw new Error(errESfnMsg);\n  }\n\n  if (!query) {\n    var errQryMsg = 'query not injected!';\n    debug(errQryMsg);\n    throw new Error(errQryMsg);\n  }\n\n  if (!query.aggregateId) {\n    var errAggIdMsg = 'query.aggregateId not injected!';\n    debug(errAggIdMsg);\n    throw new Error(errAggIdMsg);\n  }\n\n  if (events) {\n    if (!_.isArray(events)) {\n      var errEvtsArrMsg = 'events should be an array!';\n      debug(errEvtsArrMsg);\n      throw new Error(errEvtsArrMsg);\n    }\n\n    for (var i = 0, len = events.length; i < len; i++) {\n      var evt = events[i];\n      if (evt.streamRevision === undefined || evt.streamRevision === null) {\n        var errEvtMsg = 'The events passed should all have a streamRevision!';\n        debug(errEvtMsg);\n        throw new Error(errEvtMsg);\n      }\n    }\n  }\n\n  this.eventstore = eventstore;\n  this.streamId = query.aggregateId;\n  this.aggregateId = query.aggregateId;\n  this.aggregate = query.aggregate;\n  this.context = query.context;\n  this.events = events || [];\n  this.uncommittedEvents = [];\n  this.lastRevision = -1;\n\n  this.events = _.sortBy(this.events, 'streamRevision');\n\n  // to update lastRevision...\n  this.currentRevision();\n}\n\nEventStream.prototype = {\n\n  /**\n   * This helper function calculates and returns the current stream revision.\n   * @returns {Number} lastRevision\n   */\n  currentRevision: function() {\n    for (var i = 0, len = this.events.length; i < len; i++) {\n      if (this.events[i].streamRevision > this.lastRevision) {\n        this.lastRevision = this.events[i].streamRevision;\n      }\n    }\n\n    return this.lastRevision;\n  },\n\n  /**\n   * adds an event to the uncommittedEvents array\n   * @param {Object} event\n   */\n  addEvent: function(event) {\n    new Event(this, event, this.eventstore.eventMappings);\n  },\n\n  /**\n   * adds an array of events to the uncommittedEvents array\n   * @param {Array} events\n   */\n  addEvents: function(events) {\n    if (!_.isArray(events)) {\n      var errEvtsArrMsg = 'events should be an array!';\n      debug(errEvtsArrMsg);\n      throw new Error(errEvtsArrMsg);\n    }\n    var self = this;\n    _.each(events, function(evt) {\n      self.addEvent(evt);\n    });\n  },\n\n  /**\n   * commits all uncommittedEvents\n   * @param {Function} callback the function that will be called when this action has finished [optional]\n   */\n  commit: function(callback) {\n    this.eventstore.commit(this, callback);\n  }\n};\n\nmodule.exports = EventStream;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}