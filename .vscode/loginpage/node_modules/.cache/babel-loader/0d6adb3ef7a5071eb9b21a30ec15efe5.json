{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Environment = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst artifacts_1 = require(\"../artifacts\");\n\nconst lazy_1 = require(\"../util/lazy\");\n\nconst config_loading_1 = require(\"./config/config-loading\");\n\nconst errors_1 = require(\"./errors\");\n\nconst errors_list_1 = require(\"./errors-list\");\n\nconst construction_1 = require(\"./providers/construction\");\n\nconst task_definitions_1 = require(\"./tasks/task-definitions\");\n\nconst task_profiling_1 = require(\"./task-profiling\");\n\nconst log = (0, debug_1.default)(\"hardhat:core:hre\");\n\nclass Environment {\n  /**\n   * Initializes the Hardhat Runtime Environment and the given\n   * extender functions.\n   *\n   * @remarks The extenders' execution order is given by the order\n   * of the requires in the hardhat's config file and its plugins.\n   *\n   * @param config The hardhat's config object.\n   * @param hardhatArguments The parsed hardhat's arguments.\n   * @param tasks A map of tasks.\n   * @param extenders A list of extenders.\n   */\n  constructor(config, hardhatArguments, tasks) {\n    var _this = this;\n\n    let extenders = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    let experimentalHardhatNetworkMessageTraceHooks = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n    let userConfig = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    this.config = config;\n    this.hardhatArguments = hardhatArguments;\n    this.tasks = tasks;\n    this.userConfig = userConfig;\n    /**\n     * Executes the task with the given name.\n     *\n     * @param name The task's name.\n     * @param taskArguments A map of task's arguments.\n     *\n     * @throws a HH303 if there aren't any defined tasks with the given name.\n     * @returns a promise with the task's execution result.\n     */\n\n    this.run = async function (name) {\n      let taskArguments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      let callerTaskProfile = arguments.length > 2 ? arguments[2] : undefined;\n      const taskDefinition = _this.tasks[name];\n      log(\"Running task %s\", name);\n\n      if (taskDefinition === undefined) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_TASK, {\n          task: name\n        });\n      }\n\n      const resolvedTaskArguments = _this._resolveValidTaskArguments(taskDefinition, taskArguments);\n\n      let taskProfile;\n\n      if (_this.hardhatArguments.flamegraph === true) {\n        taskProfile = (0, task_profiling_1.createTaskProfile)(name);\n\n        if (callerTaskProfile !== undefined) {\n          callerTaskProfile.children.push(taskProfile);\n        } else {\n          _this.entryTaskProfile = taskProfile;\n        }\n      }\n\n      try {\n        return await _this._runTaskDefinition(taskDefinition, resolvedTaskArguments, taskProfile);\n      } catch (e) {\n        (0, config_loading_1.analyzeModuleNotFoundError)(e, _this.config.paths.configFile); // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n        throw e;\n      } finally {\n        if (taskProfile !== undefined) {\n          (0, task_profiling_1.completeTaskProfile)(taskProfile);\n        }\n      }\n    };\n\n    log(\"Creating HardhatRuntimeEnvironment\");\n    const networkName = hardhatArguments.network !== undefined ? hardhatArguments.network : config.defaultNetwork;\n    const networkConfig = config.networks[networkName];\n\n    if (networkConfig === undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.CONFIG_NOT_FOUND, {\n        network: networkName\n      });\n    }\n\n    this.artifacts = new artifacts_1.Artifacts(config.paths.artifacts);\n    const provider = (0, lazy_1.lazyObject)(() => {\n      log(`Creating provider for network ${networkName}`);\n      return (0, construction_1.createProvider)(networkName, networkConfig, this.config.paths, this.artifacts, experimentalHardhatNetworkMessageTraceHooks.map(hook => (trace, isCallMessageTrace) => hook(this, trace, isCallMessageTrace)));\n    });\n    this.network = {\n      name: networkName,\n      config: config.networks[networkName],\n      provider\n    };\n    this._extenders = extenders;\n    extenders.forEach(extender => extender(this));\n  }\n  /**\n   * Injects the properties of `this` (the Hardhat Runtime Environment) into the global scope.\n   *\n   * @param blacklist a list of property names that won't be injected.\n   *\n   * @returns a function that restores the previous environment.\n   */\n\n\n  injectToGlobal() {\n    let blacklist = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Environment._BLACKLISTED_PROPERTIES;\n    const globalAsAny = global;\n    const previousValues = {};\n    const previousHre = globalAsAny.hre;\n    globalAsAny.hre = this;\n\n    for (const [key, value] of Object.entries(this)) {\n      if (blacklist.includes(key)) {\n        continue;\n      }\n\n      previousValues[key] = globalAsAny[key];\n      globalAsAny[key] = value;\n    }\n\n    return () => {\n      for (const [key, _] of Object.entries(this)) {\n        if (blacklist.includes(key)) {\n          continue;\n        }\n\n        globalAsAny.hre = previousHre;\n        globalAsAny[key] = previousValues[key];\n      }\n    };\n  }\n  /**\n   * @param taskProfile Undefined if we aren't computing task profiles\n   * @private\n   */\n\n\n  async _runTaskDefinition(taskDefinition, taskArguments, taskProfile) {\n    var _this2 = this;\n\n    let runSuperFunction;\n\n    if (taskDefinition instanceof task_definitions_1.OverriddenTaskDefinition) {\n      runSuperFunction = async function () {\n        let _taskArguments = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : taskArguments;\n\n        log(\"Running %s's super\", taskDefinition.name);\n\n        if (taskProfile === undefined) {\n          return _this2._runTaskDefinition(taskDefinition.parentTaskDefinition, _taskArguments);\n        }\n\n        const parentTaskProfile = (0, task_profiling_1.createParentTaskProfile)(taskProfile);\n        taskProfile.children.push(parentTaskProfile);\n\n        try {\n          return await _this2._runTaskDefinition(taskDefinition.parentTaskDefinition, _taskArguments, parentTaskProfile);\n        } finally {\n          (0, task_profiling_1.completeTaskProfile)(parentTaskProfile);\n        }\n      };\n\n      runSuperFunction.isDefined = true;\n    } else {\n      runSuperFunction = async () => {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.TASK_DEFINITIONS.RUNSUPER_NOT_AVAILABLE, {\n          taskName: taskDefinition.name\n        });\n      };\n\n      runSuperFunction.isDefined = false;\n    }\n\n    const runSuper = runSuperFunction;\n    const globalAsAny = global;\n    const previousRunSuper = globalAsAny.runSuper;\n    globalAsAny.runSuper = runSuper;\n    let modifiedHreWithParentTaskProfile;\n\n    if (this.hardhatArguments.flamegraph === true) {\n      // We create a modified version of `this`, as we want to keep track of the\n      // `taskProfile` and use it as `callerTaskProfile` if the action calls\n      // `run`, and add a few utility methods.\n      //\n      // Note that for this to work we need to set the prototype later\n      modifiedHreWithParentTaskProfile = { ...this,\n        run: (_name, _taskArguments) => this.run(_name, _taskArguments, taskProfile),\n        adhocProfile: async (_name, f) => {\n          const adhocProfile = (0, task_profiling_1.createTaskProfile)(_name);\n          taskProfile.children.push(adhocProfile);\n\n          try {\n            return await f();\n          } finally {\n            (0, task_profiling_1.completeTaskProfile)(adhocProfile);\n          }\n        },\n        adhocProfileSync: (_name, f) => {\n          const adhocProfile = (0, task_profiling_1.createTaskProfile)(_name);\n          taskProfile.children.push(adhocProfile);\n\n          try {\n            return f();\n          } finally {\n            (0, task_profiling_1.completeTaskProfile)(adhocProfile);\n          }\n        }\n      };\n      Object.setPrototypeOf(modifiedHreWithParentTaskProfile, Object.getPrototypeOf(this));\n    }\n\n    const uninjectFromGlobal = modifiedHreWithParentTaskProfile?.injectToGlobal() ?? this.injectToGlobal();\n\n    try {\n      return await taskDefinition.action(taskArguments, modifiedHreWithParentTaskProfile ?? this, runSuper);\n    } finally {\n      uninjectFromGlobal();\n      globalAsAny.runSuper = previousRunSuper;\n    }\n  }\n  /**\n   * Check that task arguments are within TaskDefinition defined params constraints.\n   * Also, populate missing, non-mandatory arguments with default param values (if any).\n   *\n   * @private\n   * @throws HardhatError if any of the following are true:\n   *  > a required argument is missing\n   *  > an argument's value's type doesn't match the defined param type\n   *\n   * @param taskDefinition\n   * @param taskArguments\n   * @returns resolvedTaskArguments\n   */\n\n\n  _resolveValidTaskArguments(taskDefinition, taskArguments) {\n    const {\n      paramDefinitions,\n      positionalParamDefinitions\n    } = taskDefinition;\n    const nonPositionalParamDefinitions = Object.values(paramDefinitions); // gather all task param definitions\n\n    const allTaskParamDefinitions = [...nonPositionalParamDefinitions, ...positionalParamDefinitions];\n    const initResolvedArguments = {\n      errors: [],\n      values: {}\n    };\n    const resolvedArguments = allTaskParamDefinitions.reduce((_ref, paramDefinition) => {\n      let {\n        errors,\n        values\n      } = _ref;\n\n      try {\n        const paramName = paramDefinition.name;\n        const argumentValue = taskArguments[paramName];\n\n        const resolvedArgumentValue = this._resolveArgument(paramDefinition, argumentValue, taskDefinition.name);\n\n        if (resolvedArgumentValue !== undefined) {\n          values[paramName] = resolvedArgumentValue;\n        }\n      } catch (error) {\n        if (errors_1.HardhatError.isHardhatError(error)) {\n          errors.push(error);\n        }\n      }\n\n      return {\n        errors,\n        values\n      };\n    }, initResolvedArguments);\n    const {\n      errors: resolveErrors,\n      values: resolvedValues\n    } = resolvedArguments; // if has argument errors, throw the first one\n\n    if (resolveErrors.length > 0) {\n      throw resolveErrors[0];\n    } // append the rest of arguments that where not in the task param definitions\n\n\n    const resolvedTaskArguments = { ...taskArguments,\n      ...resolvedValues\n    };\n    return resolvedTaskArguments;\n  }\n  /**\n   * Resolves an argument according to a ParamDefinition rules.\n   *\n   * @param paramDefinition\n   * @param argumentValue\n   * @private\n   */\n\n\n  _resolveArgument(paramDefinition, argumentValue, taskName) {\n    const {\n      name,\n      isOptional,\n      defaultValue\n    } = paramDefinition;\n\n    if (argumentValue === undefined) {\n      if (isOptional) {\n        // undefined & optional argument -> return defaultValue\n        return defaultValue;\n      } // undefined & mandatory argument -> error\n\n\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n        param: name,\n        task: taskName\n      });\n    } // arg was present -> validate type, if applicable\n\n\n    this._checkTypeValidation(paramDefinition, argumentValue);\n\n    return argumentValue;\n  }\n  /**\n   * Checks if value is valid for the specified param definition.\n   *\n   * @param paramDefinition {ParamDefinition} - the param definition for validation\n   * @param argumentValue - the value to be validated\n   * @private\n   * @throws HH301 if value is not valid for the param type\n   */\n\n\n  _checkTypeValidation(paramDefinition, argumentValue) {\n    const {\n      name: paramName,\n      type,\n      isVariadic\n    } = paramDefinition; // in case of variadic param, argValue is an array and the type validation must pass for all values.\n    // otherwise, it's a single value that is to be validated\n\n    const argumentValueContainer = isVariadic ? argumentValue : [argumentValue];\n\n    for (const value of argumentValueContainer) {\n      type.validate(paramName, value);\n    }\n  }\n\n}\n\nexports.Environment = Environment;\nEnvironment._BLACKLISTED_PROPERTIES = [\"injectToGlobal\", \"entryTaskProfile\", \"_runTaskDefinition\", \"_extenders\"];","map":{"version":3,"mappings":"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","names":["log","Environment","constructor","config","hardhatArguments","tasks","extenders","experimentalHardhatNetworkMessageTraceHooks","userConfig","name","taskArguments","callerTaskProfile","taskDefinition","undefined","errors_1","errors_list_1","ARGUMENTS","UNRECOGNIZED_TASK","task","resolvedTaskArguments","_resolveValidTaskArguments","taskProfile","flamegraph","children","push","entryTaskProfile","_runTaskDefinition","e","paths","configFile","networkName","network","defaultNetwork","networkConfig","networks","NETWORK","CONFIG_NOT_FOUND","artifacts","artifacts_1","provider","map","hook","trace","isCallMessageTrace","_extenders","forEach","extender","injectToGlobal","blacklist","_BLACKLISTED_PROPERTIES","globalAsAny","global","previousValues","previousHre","hre","key","value","Object","entries","includes","_","runSuperFunction","task_definitions_1","_taskArguments","parentTaskDefinition","parentTaskProfile","isDefined","TASK_DEFINITIONS","RUNSUPER_NOT_AVAILABLE","taskName","runSuper","previousRunSuper","modifiedHreWithParentTaskProfile","run","_name","adhocProfile","f","adhocProfileSync","setPrototypeOf","getPrototypeOf","uninjectFromGlobal","action","paramDefinitions","positionalParamDefinitions","nonPositionalParamDefinitions","values","allTaskParamDefinitions","initResolvedArguments","errors","resolvedArguments","reduce","paramDefinition","paramName","argumentValue","resolvedArgumentValue","_resolveArgument","error","isHardhatError","resolveErrors","resolvedValues","length","isOptional","defaultValue","MISSING_TASK_ARGUMENT","param","_checkTypeValidation","type","isVariadic","argumentValueContainer","validate","exports"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\hardhat\\src\\internal\\core\\runtime-environment.ts"],"sourcesContent":["import debug from \"debug\";\n\nimport {\n  Artifacts as IArtifacts,\n  EnvironmentExtender,\n  ExperimentalHardhatNetworkMessageTraceHook,\n  HardhatArguments,\n  HardhatConfig,\n  HardhatRuntimeEnvironment,\n  HardhatUserConfig,\n  Network,\n  ParamDefinition,\n  RunSuperFunction,\n  RunTaskFunction,\n  TaskArguments,\n  TaskDefinition,\n  TasksMap,\n} from \"../../types\";\nimport { Artifacts } from \"../artifacts\";\nimport { MessageTrace } from \"../hardhat-network/stack-traces/message-trace\";\nimport { lazyObject } from \"../util/lazy\";\n\nimport { analyzeModuleNotFoundError } from \"./config/config-loading\";\nimport { HardhatError } from \"./errors\";\nimport { ERRORS } from \"./errors-list\";\nimport { createProvider } from \"./providers/construction\";\nimport { OverriddenTaskDefinition } from \"./tasks/task-definitions\";\nimport {\n  completeTaskProfile,\n  createParentTaskProfile,\n  createTaskProfile,\n  TaskProfile,\n} from \"./task-profiling\";\n\nconst log = debug(\"hardhat:core:hre\");\n\nexport class Environment implements HardhatRuntimeEnvironment {\n  private static readonly _BLACKLISTED_PROPERTIES: string[] = [\n    \"injectToGlobal\",\n    \"entryTaskProfile\",\n    \"_runTaskDefinition\",\n    \"_extenders\",\n  ];\n\n  public network: Network;\n\n  public artifacts: IArtifacts;\n\n  private readonly _extenders: EnvironmentExtender[];\n\n  public entryTaskProfile?: TaskProfile;\n\n  /**\n   * Initializes the Hardhat Runtime Environment and the given\n   * extender functions.\n   *\n   * @remarks The extenders' execution order is given by the order\n   * of the requires in the hardhat's config file and its plugins.\n   *\n   * @param config The hardhat's config object.\n   * @param hardhatArguments The parsed hardhat's arguments.\n   * @param tasks A map of tasks.\n   * @param extenders A list of extenders.\n   */\n  constructor(\n    public readonly config: HardhatConfig,\n    public readonly hardhatArguments: HardhatArguments,\n    public readonly tasks: TasksMap,\n    extenders: EnvironmentExtender[] = [],\n    experimentalHardhatNetworkMessageTraceHooks: ExperimentalHardhatNetworkMessageTraceHook[] = [],\n    public readonly userConfig: HardhatUserConfig = {}\n  ) {\n    log(\"Creating HardhatRuntimeEnvironment\");\n\n    const networkName =\n      hardhatArguments.network !== undefined\n        ? hardhatArguments.network\n        : config.defaultNetwork;\n\n    const networkConfig = config.networks[networkName];\n\n    if (networkConfig === undefined) {\n      throw new HardhatError(ERRORS.NETWORK.CONFIG_NOT_FOUND, {\n        network: networkName,\n      });\n    }\n\n    this.artifacts = new Artifacts(config.paths.artifacts);\n\n    const provider = lazyObject(() => {\n      log(`Creating provider for network ${networkName}`);\n      return createProvider(\n        networkName,\n        networkConfig,\n        this.config.paths,\n        this.artifacts,\n        experimentalHardhatNetworkMessageTraceHooks.map(\n          (hook) => (trace: MessageTrace, isCallMessageTrace: boolean) =>\n            hook(this, trace, isCallMessageTrace)\n        )\n      );\n    });\n\n    this.network = {\n      name: networkName,\n      config: config.networks[networkName],\n      provider,\n    };\n\n    this._extenders = extenders;\n\n    extenders.forEach((extender) => extender(this));\n  }\n\n  /**\n   * Executes the task with the given name.\n   *\n   * @param name The task's name.\n   * @param taskArguments A map of task's arguments.\n   *\n   * @throws a HH303 if there aren't any defined tasks with the given name.\n   * @returns a promise with the task's execution result.\n   */\n  public readonly run: RunTaskFunction = async (\n    name,\n    taskArguments = {},\n    callerTaskProfile?: TaskProfile\n  ) => {\n    const taskDefinition = this.tasks[name];\n\n    log(\"Running task %s\", name);\n\n    if (taskDefinition === undefined) {\n      throw new HardhatError(ERRORS.ARGUMENTS.UNRECOGNIZED_TASK, {\n        task: name,\n      });\n    }\n\n    const resolvedTaskArguments = this._resolveValidTaskArguments(\n      taskDefinition,\n      taskArguments\n    );\n\n    let taskProfile: TaskProfile | undefined;\n    if (this.hardhatArguments.flamegraph === true) {\n      taskProfile = createTaskProfile(name);\n\n      if (callerTaskProfile !== undefined) {\n        callerTaskProfile.children.push(taskProfile);\n      } else {\n        this.entryTaskProfile = taskProfile;\n      }\n    }\n\n    try {\n      return await this._runTaskDefinition(\n        taskDefinition,\n        resolvedTaskArguments,\n        taskProfile\n      );\n    } catch (e) {\n      analyzeModuleNotFoundError(e, this.config.paths.configFile);\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    } finally {\n      if (taskProfile !== undefined) {\n        completeTaskProfile(taskProfile);\n      }\n    }\n  };\n\n  /**\n   * Injects the properties of `this` (the Hardhat Runtime Environment) into the global scope.\n   *\n   * @param blacklist a list of property names that won't be injected.\n   *\n   * @returns a function that restores the previous environment.\n   */\n  public injectToGlobal(\n    blacklist: string[] = Environment._BLACKLISTED_PROPERTIES\n  ): () => void {\n    const globalAsAny = global as any;\n\n    const previousValues: { [name: string]: any } = {};\n    const previousHre = globalAsAny.hre;\n\n    globalAsAny.hre = this;\n\n    for (const [key, value] of Object.entries(this)) {\n      if (blacklist.includes(key)) {\n        continue;\n      }\n\n      previousValues[key] = globalAsAny[key];\n      globalAsAny[key] = value;\n    }\n\n    return () => {\n      for (const [key, _] of Object.entries(this)) {\n        if (blacklist.includes(key)) {\n          continue;\n        }\n\n        globalAsAny.hre = previousHre;\n        globalAsAny[key] = previousValues[key];\n      }\n    };\n  }\n\n  /**\n   * @param taskProfile Undefined if we aren't computing task profiles\n   * @private\n   */\n  private async _runTaskDefinition(\n    taskDefinition: TaskDefinition,\n    taskArguments: TaskArguments,\n    taskProfile?: TaskProfile\n  ): Promise<any> {\n    let runSuperFunction: any;\n\n    if (taskDefinition instanceof OverriddenTaskDefinition) {\n      runSuperFunction = async (\n        _taskArguments: TaskArguments = taskArguments\n      ) => {\n        log(\"Running %s's super\", taskDefinition.name);\n\n        if (taskProfile === undefined) {\n          return this._runTaskDefinition(\n            taskDefinition.parentTaskDefinition,\n            _taskArguments\n          );\n        }\n\n        const parentTaskProfile = createParentTaskProfile(taskProfile);\n        taskProfile.children.push(parentTaskProfile);\n\n        try {\n          return await this._runTaskDefinition(\n            taskDefinition.parentTaskDefinition,\n            _taskArguments,\n            parentTaskProfile\n          );\n        } finally {\n          completeTaskProfile(parentTaskProfile);\n        }\n      };\n\n      runSuperFunction.isDefined = true;\n    } else {\n      runSuperFunction = async () => {\n        throw new HardhatError(ERRORS.TASK_DEFINITIONS.RUNSUPER_NOT_AVAILABLE, {\n          taskName: taskDefinition.name,\n        });\n      };\n\n      runSuperFunction.isDefined = false;\n    }\n\n    const runSuper: RunSuperFunction<TaskArguments> = runSuperFunction;\n\n    const globalAsAny = global as any;\n    const previousRunSuper: any = globalAsAny.runSuper;\n    globalAsAny.runSuper = runSuper;\n\n    let modifiedHreWithParentTaskProfile: any | undefined;\n    if (this.hardhatArguments.flamegraph === true) {\n      // We create a modified version of `this`, as we want to keep track of the\n      // `taskProfile` and use it as `callerTaskProfile` if the action calls\n      // `run`, and add a few utility methods.\n      //\n      // Note that for this to work we need to set the prototype later\n      modifiedHreWithParentTaskProfile = {\n        ...this,\n        run: (_name: string, _taskArguments: TaskArguments) =>\n          (this as any).run(_name, _taskArguments, taskProfile),\n        adhocProfile: async (_name: string, f: () => Promise<any>) => {\n          const adhocProfile = createTaskProfile(_name);\n          taskProfile!.children.push(adhocProfile);\n          try {\n            return await f();\n          } finally {\n            completeTaskProfile(adhocProfile);\n          }\n        },\n        adhocProfileSync: (_name: string, f: () => any) => {\n          const adhocProfile = createTaskProfile(_name);\n          taskProfile!.children.push(adhocProfile);\n          try {\n            return f();\n          } finally {\n            completeTaskProfile(adhocProfile);\n          }\n        },\n      };\n\n      Object.setPrototypeOf(\n        modifiedHreWithParentTaskProfile,\n        Object.getPrototypeOf(this)\n      );\n    }\n\n    const uninjectFromGlobal =\n      modifiedHreWithParentTaskProfile?.injectToGlobal() ??\n      this.injectToGlobal();\n\n    try {\n      return await taskDefinition.action(\n        taskArguments,\n        modifiedHreWithParentTaskProfile ?? this,\n        runSuper\n      );\n    } finally {\n      uninjectFromGlobal();\n      globalAsAny.runSuper = previousRunSuper;\n    }\n  }\n\n  /**\n   * Check that task arguments are within TaskDefinition defined params constraints.\n   * Also, populate missing, non-mandatory arguments with default param values (if any).\n   *\n   * @private\n   * @throws HardhatError if any of the following are true:\n   *  > a required argument is missing\n   *  > an argument's value's type doesn't match the defined param type\n   *\n   * @param taskDefinition\n   * @param taskArguments\n   * @returns resolvedTaskArguments\n   */\n  private _resolveValidTaskArguments(\n    taskDefinition: TaskDefinition,\n    taskArguments: TaskArguments\n  ): TaskArguments {\n    const { paramDefinitions, positionalParamDefinitions } = taskDefinition;\n\n    const nonPositionalParamDefinitions = Object.values(paramDefinitions);\n\n    // gather all task param definitions\n    const allTaskParamDefinitions = [\n      ...nonPositionalParamDefinitions,\n      ...positionalParamDefinitions,\n    ];\n\n    const initResolvedArguments: {\n      errors: HardhatError[];\n      values: TaskArguments;\n    } = { errors: [], values: {} };\n\n    const resolvedArguments = allTaskParamDefinitions.reduce(\n      ({ errors, values }, paramDefinition) => {\n        try {\n          const paramName = paramDefinition.name;\n          const argumentValue = taskArguments[paramName];\n          const resolvedArgumentValue = this._resolveArgument(\n            paramDefinition,\n            argumentValue,\n            taskDefinition.name\n          );\n          if (resolvedArgumentValue !== undefined) {\n            values[paramName] = resolvedArgumentValue;\n          }\n        } catch (error) {\n          if (HardhatError.isHardhatError(error)) {\n            errors.push(error);\n          }\n        }\n        return { errors, values };\n      },\n      initResolvedArguments\n    );\n\n    const { errors: resolveErrors, values: resolvedValues } = resolvedArguments;\n\n    // if has argument errors, throw the first one\n    if (resolveErrors.length > 0) {\n      throw resolveErrors[0];\n    }\n\n    // append the rest of arguments that where not in the task param definitions\n    const resolvedTaskArguments = { ...taskArguments, ...resolvedValues };\n\n    return resolvedTaskArguments;\n  }\n\n  /**\n   * Resolves an argument according to a ParamDefinition rules.\n   *\n   * @param paramDefinition\n   * @param argumentValue\n   * @private\n   */\n  private _resolveArgument(\n    paramDefinition: ParamDefinition<any>,\n    argumentValue: any,\n    taskName: string\n  ) {\n    const { name, isOptional, defaultValue } = paramDefinition;\n\n    if (argumentValue === undefined) {\n      if (isOptional) {\n        // undefined & optional argument -> return defaultValue\n        return defaultValue;\n      }\n\n      // undefined & mandatory argument -> error\n      throw new HardhatError(ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n        param: name,\n        task: taskName,\n      });\n    }\n\n    // arg was present -> validate type, if applicable\n    this._checkTypeValidation(paramDefinition, argumentValue);\n\n    return argumentValue;\n  }\n\n  /**\n   * Checks if value is valid for the specified param definition.\n   *\n   * @param paramDefinition {ParamDefinition} - the param definition for validation\n   * @param argumentValue - the value to be validated\n   * @private\n   * @throws HH301 if value is not valid for the param type\n   */\n  private _checkTypeValidation(\n    paramDefinition: ParamDefinition<any>,\n    argumentValue: any\n  ) {\n    const { name: paramName, type, isVariadic } = paramDefinition;\n\n    // in case of variadic param, argValue is an array and the type validation must pass for all values.\n    // otherwise, it's a single value that is to be validated\n    const argumentValueContainer = isVariadic ? argumentValue : [argumentValue];\n\n    for (const value of argumentValueContainer) {\n      type.validate(paramName, value);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}