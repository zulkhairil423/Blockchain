{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Address = void 0;\n\nconst account_1 = require(\"./account\");\n\nconst bytes_1 = require(\"./bytes\");\n\nclass Address {\n  constructor(buf) {\n    if (buf.length !== 20) {\n      throw new Error('Invalid address length');\n    }\n\n    this.buf = buf;\n  }\n  /**\n   * Returns the zero address.\n   */\n\n\n  static zero() {\n    return new Address((0, bytes_1.zeros)(20));\n  }\n  /**\n   * Returns an Address object from a hex-encoded string.\n   * @param str - Hex-encoded address\n   */\n\n\n  static fromString(str) {\n    if (!(0, account_1.isValidAddress)(str)) {\n      throw new Error('Invalid address');\n    }\n\n    return new Address((0, bytes_1.toBuffer)(str));\n  }\n  /**\n   * Returns an address for a given public key.\n   * @param pubKey The two points of an uncompressed key\n   */\n\n\n  static fromPublicKey(pubKey) {\n    if (!Buffer.isBuffer(pubKey)) {\n      throw new Error('Public key should be Buffer');\n    }\n\n    const buf = (0, account_1.pubToAddress)(pubKey);\n    return new Address(buf);\n  }\n  /**\n   * Returns an address for a given private key.\n   * @param privateKey A private key must be 256 bits wide\n   */\n\n\n  static fromPrivateKey(privateKey) {\n    if (!Buffer.isBuffer(privateKey)) {\n      throw new Error('Private key should be Buffer');\n    }\n\n    const buf = (0, account_1.privateToAddress)(privateKey);\n    return new Address(buf);\n  }\n  /**\n   * Generates an address for a newly created contract.\n   * @param from The address which is creating this new address\n   * @param nonce The nonce of the from account\n   */\n\n\n  static generate(from, nonce) {\n    if (typeof nonce !== 'bigint') {\n      throw new Error('Expected nonce to be a bigint');\n    }\n\n    return new Address((0, account_1.generateAddress)(from.buf, (0, bytes_1.bigIntToBuffer)(nonce)));\n  }\n  /**\n   * Generates an address for a contract created using CREATE2.\n   * @param from The address which is creating this new address\n   * @param salt A salt\n   * @param initCode The init code of the contract being created\n   */\n\n\n  static generate2(from, salt, initCode) {\n    if (!Buffer.isBuffer(salt)) {\n      throw new Error('Expected salt to be a Buffer');\n    }\n\n    if (!Buffer.isBuffer(initCode)) {\n      throw new Error('Expected initCode to be a Buffer');\n    }\n\n    return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));\n  }\n  /**\n   * Is address equal to another.\n   */\n\n\n  equals(address) {\n    return this.buf.equals(address.buf);\n  }\n  /**\n   * Is address zero.\n   */\n\n\n  isZero() {\n    return this.equals(Address.zero());\n  }\n  /**\n   * True if address is in the address range defined\n   * by EIP-1352\n   */\n\n\n  isPrecompileOrSystemAddress() {\n    const address = (0, bytes_1.bufferToBigInt)(this.buf);\n    const rangeMin = BigInt(0);\n    const rangeMax = BigInt('0xffff');\n    return address >= rangeMin && address <= rangeMax;\n  }\n  /**\n   * Returns hex encoding of address.\n   */\n\n\n  toString() {\n    return '0x' + this.buf.toString('hex');\n  }\n  /**\n   * Returns Buffer representation of address.\n   */\n\n\n  toBuffer() {\n    return Buffer.from(this.buf);\n  }\n\n}\n\nexports.Address = Address;","map":{"version":3,"mappings":";;;;;;;AAAA;;AAOA;;AAEA,MAAaA,OAAb,CAAoB;EAGlBC,YAAYC,GAAZ,EAAuB;IACrB,IAAIA,GAAG,CAACC,MAAJ,KAAe,EAAnB,EAAuB;MACrB,MAAM,IAAIC,KAAJ,CAAU,wBAAV,CAAN;IACD;;IACD,KAAKF,GAAL,GAAWA,GAAX;EACD;EAED;;;;;EAGW,OAAJG,IAAI;IACT,OAAO,IAAIL,OAAJ,CAAY,mBAAM,EAAN,CAAZ,CAAP;EACD;EAED;;;;;;EAIiB,OAAVM,UAAU,CAACC,GAAD,EAAY;IAC3B,IAAI,CAAC,8BAAeA,GAAf,CAAL,EAA0B;MACxB,MAAM,IAAIH,KAAJ,CAAU,iBAAV,CAAN;IACD;;IACD,OAAO,IAAIJ,OAAJ,CAAY,sBAASO,GAAT,CAAZ,CAAP;EACD;EAED;;;;;;EAIoB,OAAbC,aAAa,CAACC,MAAD,EAAe;IACjC,IAAI,CAACC,MAAM,CAACC,QAAP,CAAgBF,MAAhB,CAAL,EAA8B;MAC5B,MAAM,IAAIL,KAAJ,CAAU,6BAAV,CAAN;IACD;;IACD,MAAMF,GAAG,GAAG,4BAAaO,MAAb,CAAZ;IACA,OAAO,IAAIT,OAAJ,CAAYE,GAAZ,CAAP;EACD;EAED;;;;;;EAIqB,OAAdU,cAAc,CAACC,UAAD,EAAmB;IACtC,IAAI,CAACH,MAAM,CAACC,QAAP,CAAgBE,UAAhB,CAAL,EAAkC;MAChC,MAAM,IAAIT,KAAJ,CAAU,8BAAV,CAAN;IACD;;IACD,MAAMF,GAAG,GAAG,gCAAiBW,UAAjB,CAAZ;IACA,OAAO,IAAIb,OAAJ,CAAYE,GAAZ,CAAP;EACD;EAED;;;;;;;EAKe,OAARY,QAAQ,CAACC,IAAD,EAAgBC,KAAhB,EAA6B;IAC1C,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;MAC7B,MAAM,IAAIZ,KAAJ,CAAU,+BAAV,CAAN;IACD;;IACD,OAAO,IAAIJ,OAAJ,CAAY,+BAAgBe,IAAI,CAACb,GAArB,EAA0B,4BAAec,KAAf,CAA1B,CAAZ,CAAP;EACD;EAED;;;;;;;;EAMgB,OAATC,SAAS,CAACF,IAAD,EAAgBG,IAAhB,EAA8BC,QAA9B,EAA8C;IAC5D,IAAI,CAACT,MAAM,CAACC,QAAP,CAAgBO,IAAhB,CAAL,EAA4B;MAC1B,MAAM,IAAId,KAAJ,CAAU,8BAAV,CAAN;IACD;;IACD,IAAI,CAACM,MAAM,CAACC,QAAP,CAAgBQ,QAAhB,CAAL,EAAgC;MAC9B,MAAM,IAAIf,KAAJ,CAAU,kCAAV,CAAN;IACD;;IACD,OAAO,IAAIJ,OAAJ,CAAY,gCAAiBe,IAAI,CAACb,GAAtB,EAA2BgB,IAA3B,EAAiCC,QAAjC,CAAZ,CAAP;EACD;EAED;;;;;EAGAC,MAAM,CAACC,OAAD,EAAiB;IACrB,OAAO,KAAKnB,GAAL,CAASkB,MAAT,CAAgBC,OAAO,CAACnB,GAAxB,CAAP;EACD;EAED;;;;;EAGAoB,MAAM;IACJ,OAAO,KAAKF,MAAL,CAAYpB,OAAO,CAACK,IAAR,EAAZ,CAAP;EACD;EAED;;;;;;EAIAkB,2BAA2B;IACzB,MAAMF,OAAO,GAAG,4BAAe,KAAKnB,GAApB,CAAhB;IACA,MAAMsB,QAAQ,GAAGC,MAAM,CAAC,CAAD,CAAvB;IACA,MAAMC,QAAQ,GAAGD,MAAM,CAAC,QAAD,CAAvB;IACA,OAAOJ,OAAO,IAAIG,QAAX,IAAuBH,OAAO,IAAIK,QAAzC;EACD;EAED;;;;;EAGAC,QAAQ;IACN,OAAO,OAAO,KAAKzB,GAAL,CAASyB,QAAT,CAAkB,KAAlB,CAAd;EACD;EAED;;;;;EAGAC,QAAQ;IACN,OAAOlB,MAAM,CAACK,IAAP,CAAY,KAAKb,GAAjB,CAAP;EACD;;AArHiB;;AAApB2B","names":["Address","constructor","buf","length","Error","zero","fromString","str","fromPublicKey","pubKey","Buffer","isBuffer","fromPrivateKey","privateKey","generate","from","nonce","generate2","salt","initCode","equals","address","isZero","isPrecompileOrSystemAddress","rangeMin","BigInt","rangeMax","toString","toBuffer","exports"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\@nomicfoundation\\ethereumjs-util\\src\\address.ts"],"sourcesContent":["import {\n  generateAddress,\n  generateAddress2,\n  isValidAddress,\n  privateToAddress,\n  pubToAddress,\n} from './account'\nimport { bigIntToBuffer, bufferToBigInt, toBuffer, zeros } from './bytes'\n\nexport class Address {\n  public readonly buf: Buffer\n\n  constructor(buf: Buffer) {\n    if (buf.length !== 20) {\n      throw new Error('Invalid address length')\n    }\n    this.buf = buf\n  }\n\n  /**\n   * Returns the zero address.\n   */\n  static zero(): Address {\n    return new Address(zeros(20))\n  }\n\n  /**\n   * Returns an Address object from a hex-encoded string.\n   * @param str - Hex-encoded address\n   */\n  static fromString(str: string): Address {\n    if (!isValidAddress(str)) {\n      throw new Error('Invalid address')\n    }\n    return new Address(toBuffer(str))\n  }\n\n  /**\n   * Returns an address for a given public key.\n   * @param pubKey The two points of an uncompressed key\n   */\n  static fromPublicKey(pubKey: Buffer): Address {\n    if (!Buffer.isBuffer(pubKey)) {\n      throw new Error('Public key should be Buffer')\n    }\n    const buf = pubToAddress(pubKey)\n    return new Address(buf)\n  }\n\n  /**\n   * Returns an address for a given private key.\n   * @param privateKey A private key must be 256 bits wide\n   */\n  static fromPrivateKey(privateKey: Buffer): Address {\n    if (!Buffer.isBuffer(privateKey)) {\n      throw new Error('Private key should be Buffer')\n    }\n    const buf = privateToAddress(privateKey)\n    return new Address(buf)\n  }\n\n  /**\n   * Generates an address for a newly created contract.\n   * @param from The address which is creating this new address\n   * @param nonce The nonce of the from account\n   */\n  static generate(from: Address, nonce: bigint): Address {\n    if (typeof nonce !== 'bigint') {\n      throw new Error('Expected nonce to be a bigint')\n    }\n    return new Address(generateAddress(from.buf, bigIntToBuffer(nonce)))\n  }\n\n  /**\n   * Generates an address for a contract created using CREATE2.\n   * @param from The address which is creating this new address\n   * @param salt A salt\n   * @param initCode The init code of the contract being created\n   */\n  static generate2(from: Address, salt: Buffer, initCode: Buffer): Address {\n    if (!Buffer.isBuffer(salt)) {\n      throw new Error('Expected salt to be a Buffer')\n    }\n    if (!Buffer.isBuffer(initCode)) {\n      throw new Error('Expected initCode to be a Buffer')\n    }\n    return new Address(generateAddress2(from.buf, salt, initCode))\n  }\n\n  /**\n   * Is address equal to another.\n   */\n  equals(address: Address): boolean {\n    return this.buf.equals(address.buf)\n  }\n\n  /**\n   * Is address zero.\n   */\n  isZero(): boolean {\n    return this.equals(Address.zero())\n  }\n\n  /**\n   * True if address is in the address range defined\n   * by EIP-1352\n   */\n  isPrecompileOrSystemAddress(): boolean {\n    const address = bufferToBigInt(this.buf)\n    const rangeMin = BigInt(0)\n    const rangeMax = BigInt('0xffff')\n    return address >= rangeMin && address <= rangeMax\n  }\n\n  /**\n   * Returns hex encoding of address.\n   */\n  toString(): string {\n    return '0x' + this.buf.toString('hex')\n  }\n\n  /**\n   * Returns Buffer representation of address.\n   */\n  toBuffer(): Buffer {\n    return Buffer.from(this.buf)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}