{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.any = exports.json = exports.inputFile = exports.float = exports.int = exports.boolean = exports.string = void 0;\n\nconst fs = __importStar(require(\"fs\"));\n\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nconst errors_1 = require(\"../errors\");\n\nconst errors_list_1 = require(\"../errors-list\");\n/**\n * String type.\n *\n * Accepts any kind of string.\n */\n\n\nexports.string = {\n  name: \"string\",\n  parse: (argName, strValue) => strValue,\n\n  /**\n   * Check if argument value is of type \"string\"\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"string\"\n   */\n  validate: (argName, value) => {\n    const isString = typeof value === \"string\";\n\n    if (!isString) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: exports.string.name\n      });\n    }\n  }\n};\n/**\n * Boolean type.\n *\n * Accepts only 'true' or 'false' (case-insensitive).\n * @throws HH301\n */\n\nexports.boolean = {\n  name: \"boolean\",\n  parse: (argName, strValue) => {\n    if (strValue.toLowerCase() === \"true\") {\n      return true;\n    }\n\n    if (strValue.toLowerCase() === \"false\") {\n      return false;\n    }\n\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n      value: strValue,\n      name: argName,\n      type: \"boolean\"\n    });\n  },\n\n  /**\n   * Check if argument value is of type \"boolean\"\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"boolean\"\n   */\n  validate: (argName, value) => {\n    const isBoolean = typeof value === \"boolean\";\n\n    if (!isBoolean) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: exports.boolean.name\n      });\n    }\n  }\n};\n/**\n * Int type.\n * Accepts either a decimal string integer or hexadecimal string integer.\n * @throws HH301\n */\n\nexports.int = {\n  name: \"int\",\n  parse: (argName, strValue) => {\n    const decimalPattern = /^\\d+(?:[eE]\\d+)?$/;\n    const hexPattern = /^0[xX][\\dABCDEabcde]+$/;\n\n    if (strValue.match(decimalPattern) === null && strValue.match(hexPattern) === null) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value: strValue,\n        name: argName,\n        type: exports.int.name\n      });\n    }\n\n    return Number(strValue);\n  },\n\n  /**\n   * Check if argument value is of type \"int\"\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"int\"\n   */\n  validate: (argName, value) => {\n    const isInt = Number.isInteger(value);\n\n    if (!isInt) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: exports.int.name\n      });\n    }\n  }\n};\n/**\n * Float type.\n * Accepts either a decimal string number or hexadecimal string number.\n * @throws HH301\n */\n\nexports.float = {\n  name: \"float\",\n  parse: (argName, strValue) => {\n    const decimalPattern = /^(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE]\\d+)?$/;\n    const hexPattern = /^0[xX][\\dABCDEabcde]+$/;\n\n    if (strValue.match(decimalPattern) === null && strValue.match(hexPattern) === null) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value: strValue,\n        name: argName,\n        type: exports.float.name\n      });\n    }\n\n    return Number(strValue);\n  },\n\n  /**\n   * Check if argument value is of type \"float\".\n   * Both decimal and integer number values are valid.\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"number\"\n   */\n  validate: (argName, value) => {\n    const isFloatOrInteger = typeof value === \"number\" && !isNaN(value);\n\n    if (!isFloatOrInteger) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: exports.float.name\n      });\n    }\n  }\n};\n/**\n * Input file type.\n * Accepts a path to a readable file..\n * @throws HH302\n */\n\nexports.inputFile = {\n  name: \"inputFile\",\n\n  parse(argName, strValue) {\n    try {\n      fs.accessSync(strValue, fs_extra_1.default.constants.R_OK);\n      const stats = fs.lstatSync(strValue);\n\n      if (stats.isDirectory()) {\n        // This is caught and encapsulated in a hardhat error.\n        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n        throw new Error(`${strValue} is a directory, not a file`);\n      }\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_INPUT_FILE, {\n          name: argName,\n          value: strValue\n        }, error);\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw error;\n    }\n\n    return strValue;\n  },\n\n  /**\n   * Check if argument value is of type \"inputFile\"\n   * File string validation succeeds if it can be parsed, ie. is a valid accessible file dir\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"inputFile\"\n   */\n  validate: (argName, value) => {\n    try {\n      exports.inputFile.parse(argName, value);\n    } catch (error) {\n      // the input value is considered invalid, throw error.\n      if (error instanceof Error) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n          value,\n          name: argName,\n          type: exports.inputFile.name\n        }, error);\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw error;\n    }\n  }\n};\nexports.json = {\n  name: \"json\",\n\n  parse(argName, strValue) {\n    try {\n      return JSON.parse(strValue);\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_JSON_ARGUMENT, {\n          param: argName,\n          error: error.message\n        }, error);\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw error;\n    }\n  },\n\n  /**\n   * Check if argument value is of type \"json\". We consider everything except\n   * undefined to be json.\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"json\"\n   */\n  validate: (argName, value) => {\n    if (value === undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: exports.json.name\n      });\n    }\n  }\n};\nexports.any = {\n  name: \"any\",\n\n  validate(_argName, _argumentValue) {}\n\n};","map":{"version":3,"mappings":"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","names":["exports","name","parse","argName","strValue","validate","value","isString","errors_1","errors_list_1","ARGUMENTS","INVALID_VALUE_FOR_TYPE","type","toLowerCase","isBoolean","decimalPattern","hexPattern","match","Number","isInt","isInteger","isFloatOrInteger","isNaN","fs","accessSync","fs_extra_1","constants","R_OK","stats","lstatSync","isDirectory","Error","error","INVALID_INPUT_FILE","JSON","INVALID_JSON_ARGUMENT","param","message","undefined","_argName","_argumentValue"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\hardhat\\src\\internal\\core\\params\\argumentTypes.ts"],"sourcesContent":["import * as fs from \"fs\";\nimport fsExtra from \"fs-extra\";\n\nimport { ArgumentType, CLIArgumentType } from \"../../../types\";\nimport { HardhatError } from \"../errors\";\nimport { ERRORS } from \"../errors-list\";\n\n/**\n * String type.\n *\n * Accepts any kind of string.\n */\nexport const string: CLIArgumentType<string> = {\n  name: \"string\",\n  parse: (argName, strValue) => strValue,\n  /**\n   * Check if argument value is of type \"string\"\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"string\"\n   */\n  validate: (argName: string, value: any): void => {\n    const isString = typeof value === \"string\";\n\n    if (!isString) {\n      throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: string.name,\n      });\n    }\n  },\n};\n\n/**\n * Boolean type.\n *\n * Accepts only 'true' or 'false' (case-insensitive).\n * @throws HH301\n */\nexport const boolean: CLIArgumentType<boolean> = {\n  name: \"boolean\",\n  parse: (argName, strValue) => {\n    if (strValue.toLowerCase() === \"true\") {\n      return true;\n    }\n    if (strValue.toLowerCase() === \"false\") {\n      return false;\n    }\n\n    throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n      value: strValue,\n      name: argName,\n      type: \"boolean\",\n    });\n  },\n  /**\n   * Check if argument value is of type \"boolean\"\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"boolean\"\n   */\n  validate: (argName: string, value: any): void => {\n    const isBoolean = typeof value === \"boolean\";\n\n    if (!isBoolean) {\n      throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: boolean.name,\n      });\n    }\n  },\n};\n\n/**\n * Int type.\n * Accepts either a decimal string integer or hexadecimal string integer.\n * @throws HH301\n */\nexport const int: CLIArgumentType<number> = {\n  name: \"int\",\n  parse: (argName, strValue) => {\n    const decimalPattern = /^\\d+(?:[eE]\\d+)?$/;\n    const hexPattern = /^0[xX][\\dABCDEabcde]+$/;\n\n    if (\n      strValue.match(decimalPattern) === null &&\n      strValue.match(hexPattern) === null\n    ) {\n      throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value: strValue,\n        name: argName,\n        type: int.name,\n      });\n    }\n\n    return Number(strValue);\n  },\n  /**\n   * Check if argument value is of type \"int\"\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"int\"\n   */\n  validate: (argName: string, value: any): void => {\n    const isInt = Number.isInteger(value);\n    if (!isInt) {\n      throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: int.name,\n      });\n    }\n  },\n};\n\n/**\n * Float type.\n * Accepts either a decimal string number or hexadecimal string number.\n * @throws HH301\n */\nexport const float: CLIArgumentType<number> = {\n  name: \"float\",\n  parse: (argName, strValue) => {\n    const decimalPattern = /^(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE]\\d+)?$/;\n    const hexPattern = /^0[xX][\\dABCDEabcde]+$/;\n\n    if (\n      strValue.match(decimalPattern) === null &&\n      strValue.match(hexPattern) === null\n    ) {\n      throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value: strValue,\n        name: argName,\n        type: float.name,\n      });\n    }\n\n    return Number(strValue);\n  },\n  /**\n   * Check if argument value is of type \"float\".\n   * Both decimal and integer number values are valid.\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"number\"\n   */\n  validate: (argName: string, value: any): void => {\n    const isFloatOrInteger = typeof value === \"number\" && !isNaN(value);\n\n    if (!isFloatOrInteger) {\n      throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: float.name,\n      });\n    }\n  },\n};\n\n/**\n * Input file type.\n * Accepts a path to a readable file..\n * @throws HH302\n */\nexport const inputFile: CLIArgumentType<string> = {\n  name: \"inputFile\",\n  parse(argName: string, strValue: string): string {\n    try {\n      fs.accessSync(strValue, fsExtra.constants.R_OK);\n      const stats = fs.lstatSync(strValue);\n\n      if (stats.isDirectory()) {\n        // This is caught and encapsulated in a hardhat error.\n        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n        throw new Error(`${strValue} is a directory, not a file`);\n      }\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new HardhatError(\n          ERRORS.ARGUMENTS.INVALID_INPUT_FILE,\n          {\n            name: argName,\n            value: strValue,\n          },\n          error\n        );\n      }\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n\n    return strValue;\n  },\n\n  /**\n   * Check if argument value is of type \"inputFile\"\n   * File string validation succeeds if it can be parsed, ie. is a valid accessible file dir\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"inputFile\"\n   */\n  validate: (argName: string, value: any): void => {\n    try {\n      inputFile.parse(argName, value);\n    } catch (error) {\n      // the input value is considered invalid, throw error.\n      if (error instanceof Error) {\n        throw new HardhatError(\n          ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE,\n          {\n            value,\n            name: argName,\n            type: inputFile.name,\n          },\n          error\n        );\n      }\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  },\n};\n\nexport const json: CLIArgumentType<any> = {\n  name: \"json\",\n  parse(argName: string, strValue: string): any {\n    try {\n      return JSON.parse(strValue);\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new HardhatError(\n          ERRORS.ARGUMENTS.INVALID_JSON_ARGUMENT,\n          {\n            param: argName,\n            error: error.message,\n          },\n          error\n        );\n      }\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  },\n\n  /**\n   * Check if argument value is of type \"json\". We consider everything except\n   * undefined to be json.\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"json\"\n   */\n  validate: (argName: string, value: any): void => {\n    if (value === undefined) {\n      throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: json.name,\n      });\n    }\n  },\n};\n\nexport const any: ArgumentType<any> = {\n  name: \"any\",\n  validate(_argName: string, _argumentValue: any) {},\n};\n"]},"metadata":{},"sourceType":"script"}