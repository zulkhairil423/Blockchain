{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@jridgewell/sourcemap-codec'), require('@jridgewell/resolve-uri')) : typeof define === 'function' && define.amd ? define(['exports', '@jridgewell/sourcemap-codec', '@jridgewell/resolve-uri'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.traceMapping = {}, global.sourcemapCodec, global.resolveURI));\n})(this, function (exports, sourcemapCodec, resolveUri) {\n  'use strict';\n\n  function _interopDefaultLegacy(e) {\n    return e && typeof e === 'object' && 'default' in e ? e : {\n      'default': e\n    };\n  }\n\n  var resolveUri__default = /*#__PURE__*/_interopDefaultLegacy(resolveUri);\n\n  function resolve(input, base) {\n    // The base is always treated as a directory, if it's not empty.\n    // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n    // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n    if (base && !base.endsWith('/')) base += '/';\n    return resolveUri__default[\"default\"](input, base);\n  }\n  /**\n   * Removes everything after the last \"/\", but leaves the slash.\n   */\n\n\n  function stripFilename(path) {\n    if (!path) return '';\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n  }\n\n  const COLUMN = 0;\n  const SOURCES_INDEX = 1;\n  const SOURCE_LINE = 2;\n  const SOURCE_COLUMN = 3;\n  const NAMES_INDEX = 4;\n  const REV_GENERATED_LINE = 1;\n  const REV_GENERATED_COLUMN = 2;\n\n  function maybeSort(mappings, owned) {\n    const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n    if (unsortedIndex === mappings.length) return mappings; // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n    // not, we do not want to modify the consumer's input array.\n\n    if (!owned) mappings = mappings.slice();\n\n    for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n      mappings[i] = sortSegments(mappings[i], owned);\n    }\n\n    return mappings;\n  }\n\n  function nextUnsortedSegmentLine(mappings, start) {\n    for (let i = start; i < mappings.length; i++) {\n      if (!isSorted(mappings[i])) return i;\n    }\n\n    return mappings.length;\n  }\n\n  function isSorted(line) {\n    for (let j = 1; j < line.length; j++) {\n      if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function sortSegments(line, owned) {\n    if (!owned) line = line.slice();\n    return line.sort(sortComparator);\n  }\n\n  function sortComparator(a, b) {\n    return a[COLUMN] - b[COLUMN];\n  }\n\n  let found = false;\n  /**\n   * A binary search implementation that returns the index if a match is found.\n   * If no match is found, then the left-index (the index associated with the item that comes just\n   * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n   * the next index:\n   *\n   * ```js\n   * const array = [1, 3];\n   * const needle = 2;\n   * const index = binarySearch(array, needle, (item, needle) => item - needle);\n   *\n   * assert.equal(index, 0);\n   * array.splice(index + 1, 0, needle);\n   * assert.deepEqual(array, [1, 2, 3]);\n   * ```\n   */\n\n  function binarySearch(haystack, needle, low, high) {\n    while (low <= high) {\n      const mid = low + (high - low >> 1);\n      const cmp = haystack[mid][COLUMN] - needle;\n\n      if (cmp === 0) {\n        found = true;\n        return mid;\n      }\n\n      if (cmp < 0) {\n        low = mid + 1;\n      } else {\n        high = mid - 1;\n      }\n    }\n\n    found = false;\n    return low - 1;\n  }\n\n  function upperBound(haystack, needle, index) {\n    for (let i = index + 1; i < haystack.length; i++, index++) {\n      if (haystack[i][COLUMN] !== needle) break;\n    }\n\n    return index;\n  }\n\n  function lowerBound(haystack, needle, index) {\n    for (let i = index - 1; i >= 0; i--, index--) {\n      if (haystack[i][COLUMN] !== needle) break;\n    }\n\n    return index;\n  }\n\n  function memoizedState() {\n    return {\n      lastKey: -1,\n      lastNeedle: -1,\n      lastIndex: -1\n    };\n  }\n  /**\n   * This overly complicated beast is just to record the last tested line/column and the resulting\n   * index, allowing us to skip a few tests if mappings are monotonically increasing.\n   */\n\n\n  function memoizedBinarySearch(haystack, needle, state, key) {\n    const {\n      lastKey,\n      lastNeedle,\n      lastIndex\n    } = state;\n    let low = 0;\n    let high = haystack.length - 1;\n\n    if (key === lastKey) {\n      if (needle === lastNeedle) {\n        found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n        return lastIndex;\n      }\n\n      if (needle >= lastNeedle) {\n        // lastIndex may be -1 if the previous needle was not found.\n        low = lastIndex === -1 ? 0 : lastIndex;\n      } else {\n        high = lastIndex;\n      }\n    }\n\n    state.lastKey = key;\n    state.lastNeedle = needle;\n    return state.lastIndex = binarySearch(haystack, needle, low, high);\n  } // Rebuilds the original source files, with mappings that are ordered by source line/column instead\n  // of generated line/column.\n\n\n  function buildBySources(decoded, memos) {\n    const sources = memos.map(buildNullArray);\n\n    for (let i = 0; i < decoded.length; i++) {\n      const line = decoded[i];\n\n      for (let j = 0; j < line.length; j++) {\n        const seg = line[j];\n        if (seg.length === 1) continue;\n        const sourceIndex = seg[SOURCES_INDEX];\n        const sourceLine = seg[SOURCE_LINE];\n        const sourceColumn = seg[SOURCE_COLUMN];\n        const originalSource = sources[sourceIndex];\n        const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);\n        const memo = memos[sourceIndex]; // The binary search either found a match, or it found the left-index just before where the\n        // segment should go. Either way, we want to insert after that. And there may be multiple\n        // generated segments associated with an original location, so there may need to move several\n        // indexes before we find where we need to insert.\n\n        const index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));\n        insert(originalLine, memo.lastIndex = index + 1, [sourceColumn, i, seg[COLUMN]]);\n      }\n    }\n\n    return sources;\n  }\n\n  function insert(array, index, value) {\n    for (let i = array.length; i > index; i--) {\n      array[i] = array[i - 1];\n    }\n\n    array[index] = value;\n  } // Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n  // a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n  // Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n  // the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n  // order when iterating with for-in.\n\n\n  function buildNullArray() {\n    return {\n      __proto__: null\n    };\n  }\n\n  const AnyMap = function (map, mapUrl) {\n    const parsed = typeof map === 'string' ? JSON.parse(map) : map;\n    if (!('sections' in parsed)) return new TraceMap(parsed, mapUrl);\n    const mappings = [];\n    const sources = [];\n    const sourcesContent = [];\n    const names = [];\n    const {\n      sections\n    } = parsed;\n    let i = 0;\n\n    for (; i < sections.length - 1; i++) {\n      const no = sections[i + 1].offset;\n      addSection(sections[i], mapUrl, mappings, sources, sourcesContent, names, no.line, no.column);\n    }\n\n    if (sections.length > 0) {\n      addSection(sections[i], mapUrl, mappings, sources, sourcesContent, names, Infinity, Infinity);\n    }\n\n    const joined = {\n      version: 3,\n      file: parsed.file,\n      names,\n      sources,\n      sourcesContent,\n      mappings\n    };\n    return exports.presortedDecodedMap(joined);\n  };\n\n  function addSection(section, mapUrl, mappings, sources, sourcesContent, names, stopLine, stopColumn) {\n    const map = AnyMap(section.map, mapUrl);\n    const {\n      line: lineOffset,\n      column: columnOffset\n    } = section.offset;\n    const sourcesOffset = sources.length;\n    const namesOffset = names.length;\n    const decoded = exports.decodedMappings(map);\n    const {\n      resolvedSources\n    } = map;\n    append(sources, resolvedSources);\n    append(sourcesContent, map.sourcesContent || fillSourcesContent(resolvedSources.length));\n    append(names, map.names); // If this section jumps forwards several lines, we need to add lines to the output mappings catch up.\n\n    for (let i = mappings.length; i <= lineOffset; i++) mappings.push([]); // We can only add so many lines before we step into the range that the next section's map\n    // controls. When we get to the last line, then we'll start checking the segments to see if\n    // they've crossed into the column range.\n\n\n    const stopI = stopLine - lineOffset;\n    const len = Math.min(decoded.length, stopI + 1);\n\n    for (let i = 0; i < len; i++) {\n      const line = decoded[i]; // On the 0th loop, the line will already exist due to a previous section, or the line catch up\n      // loop above.\n\n      const out = i === 0 ? mappings[lineOffset] : mappings[lineOffset + i] = []; // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n      // map can be multiple lines), it doesn't.\n\n      const cOffset = i === 0 ? columnOffset : 0;\n\n      for (let j = 0; j < line.length; j++) {\n        const seg = line[j];\n        const column = cOffset + seg[COLUMN]; // If this segment steps into the column range that the next section's map controls, we need\n        // to stop early.\n\n        if (i === stopI && column >= stopColumn) break;\n\n        if (seg.length === 1) {\n          out.push([column]);\n          continue;\n        }\n\n        const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n        const sourceLine = seg[SOURCE_LINE];\n        const sourceColumn = seg[SOURCE_COLUMN];\n\n        if (seg.length === 4) {\n          out.push([column, sourcesIndex, sourceLine, sourceColumn]);\n          continue;\n        }\n\n        out.push([column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);\n      }\n    }\n  }\n\n  function append(arr, other) {\n    for (let i = 0; i < other.length; i++) arr.push(other[i]);\n  } // Sourcemaps don't need to have sourcesContent, and if they don't, we need to create an array of\n  // equal length to the sources. This is because the sources and sourcesContent are paired arrays,\n  // where `sourcesContent[i]` is the content of the `sources[i]` file. If we didn't, then joined\n  // sourcemap would desynchronize the sources/contents.\n\n\n  function fillSourcesContent(len) {\n    const sourcesContent = [];\n\n    for (let i = 0; i < len; i++) sourcesContent[i] = null;\n\n    return sourcesContent;\n  }\n\n  const INVALID_ORIGINAL_MAPPING = Object.freeze({\n    source: null,\n    line: null,\n    column: null,\n    name: null\n  });\n  const INVALID_GENERATED_MAPPING = Object.freeze({\n    line: null,\n    column: null\n  });\n  const LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\n  const COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\n  const LEAST_UPPER_BOUND = -1;\n  const GREATEST_LOWER_BOUND = 1;\n  /**\n   * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n   */\n\n  exports.encodedMappings = void 0;\n  /**\n   * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n   */\n\n  exports.decodedMappings = void 0;\n  /**\n   * A low-level API to find the segment associated with a generated line/column (think, from a\n   * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n   */\n\n  exports.traceSegment = void 0;\n  /**\n   * A higher-level API to find the source/line/column associated with a generated line/column\n   * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n   * `source-map` library.\n   */\n\n  exports.originalPositionFor = void 0;\n  /**\n   * Finds the source/line/column directly after the mapping returned by originalPositionFor, provided\n   * the found mapping is from the same source and line as the originalPositionFor mapping.\n   *\n   * Eg, in the code `let id = 1`, `originalPositionAfter` could find the mapping associated with `1`\n   * using the same needle that would return `id` when calling `originalPositionFor`.\n   */\n\n  exports.generatedPositionFor = void 0;\n  /**\n   * Iterates each mapping in generated position order.\n   */\n\n  exports.eachMapping = void 0;\n  /**\n   * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n   * maps.\n   */\n\n  exports.presortedDecodedMap = void 0;\n  /**\n   * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n   * a sourcemap, or to JSON.stringify.\n   */\n\n  exports.decodedMap = void 0;\n  /**\n   * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n   * a sourcemap, or to JSON.stringify.\n   */\n\n  exports.encodedMap = void 0;\n\n  class TraceMap {\n    constructor(map, mapUrl) {\n      this._decodedMemo = memoizedState();\n      this._bySources = undefined;\n      this._bySourceMemos = undefined;\n      const isString = typeof map === 'string';\n      if (!isString && map.constructor === TraceMap) return map;\n      const parsed = isString ? JSON.parse(map) : map;\n      const {\n        version,\n        file,\n        names,\n        sourceRoot,\n        sources,\n        sourcesContent\n      } = parsed;\n      this.version = version;\n      this.file = file;\n      this.names = names;\n      this.sourceRoot = sourceRoot;\n      this.sources = sources;\n      this.sourcesContent = sourcesContent;\n\n      if (sourceRoot || mapUrl) {\n        const from = resolve(sourceRoot || '', stripFilename(mapUrl));\n        this.resolvedSources = sources.map(s => resolve(s || '', from));\n      } else {\n        this.resolvedSources = sources.map(s => s || '');\n      }\n\n      const {\n        mappings\n      } = parsed;\n\n      if (typeof mappings === 'string') {\n        this._encoded = mappings;\n        this._decoded = undefined;\n      } else {\n        this._encoded = undefined;\n        this._decoded = maybeSort(mappings, isString);\n      }\n    }\n\n  }\n\n  (() => {\n    exports.encodedMappings = map => {\n      var _a;\n\n      return (_a = map._encoded) !== null && _a !== void 0 ? _a : map._encoded = sourcemapCodec.encode(map._decoded);\n    };\n\n    exports.decodedMappings = map => {\n      return map._decoded || (map._decoded = sourcemapCodec.decode(map._encoded));\n    };\n\n    exports.traceSegment = (map, line, column) => {\n      const decoded = exports.decodedMappings(map); // It's common for parent source maps to have pointers to lines that have no\n      // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n\n      if (line >= decoded.length) return null;\n      return traceSegmentInternal(decoded[line], map._decodedMemo, line, column, GREATEST_LOWER_BOUND);\n    };\n\n    exports.originalPositionFor = (map, _ref) => {\n      let {\n        line,\n        column,\n        bias\n      } = _ref;\n      line--;\n      if (line < 0) throw new Error(LINE_GTR_ZERO);\n      if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n      const decoded = exports.decodedMappings(map); // It's common for parent source maps to have pointers to lines that have no\n      // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n\n      if (line >= decoded.length) return INVALID_ORIGINAL_MAPPING;\n      const segment = traceSegmentInternal(decoded[line], map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n      if (segment == null) return INVALID_ORIGINAL_MAPPING;\n      if (segment.length == 1) return INVALID_ORIGINAL_MAPPING;\n      const {\n        names,\n        resolvedSources\n      } = map;\n      return {\n        source: resolvedSources[segment[SOURCES_INDEX]],\n        line: segment[SOURCE_LINE] + 1,\n        column: segment[SOURCE_COLUMN],\n        name: segment.length === 5 ? names[segment[NAMES_INDEX]] : null\n      };\n    };\n\n    exports.generatedPositionFor = (map, _ref2) => {\n      let {\n        source,\n        line,\n        column,\n        bias\n      } = _ref2;\n      line--;\n      if (line < 0) throw new Error(LINE_GTR_ZERO);\n      if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n      const {\n        sources,\n        resolvedSources\n      } = map;\n      let sourceIndex = sources.indexOf(source);\n      if (sourceIndex === -1) sourceIndex = resolvedSources.indexOf(source);\n      if (sourceIndex === -1) return INVALID_GENERATED_MAPPING;\n      const generated = map._bySources || (map._bySources = buildBySources(exports.decodedMappings(map), map._bySourceMemos = sources.map(memoizedState)));\n      const memos = map._bySourceMemos;\n      const segments = generated[sourceIndex][line];\n      if (segments == null) return INVALID_GENERATED_MAPPING;\n      const segment = traceSegmentInternal(segments, memos[sourceIndex], line, column, bias || GREATEST_LOWER_BOUND);\n      if (segment == null) return INVALID_GENERATED_MAPPING;\n      return {\n        line: segment[REV_GENERATED_LINE] + 1,\n        column: segment[REV_GENERATED_COLUMN]\n      };\n    };\n\n    exports.eachMapping = (map, cb) => {\n      const decoded = exports.decodedMappings(map);\n      const {\n        names,\n        resolvedSources\n      } = map;\n\n      for (let i = 0; i < decoded.length; i++) {\n        const line = decoded[i];\n\n        for (let j = 0; j < line.length; j++) {\n          const seg = line[j];\n          const generatedLine = i + 1;\n          const generatedColumn = seg[0];\n          let source = null;\n          let originalLine = null;\n          let originalColumn = null;\n          let name = null;\n\n          if (seg.length !== 1) {\n            source = resolvedSources[seg[1]];\n            originalLine = seg[2] + 1;\n            originalColumn = seg[3];\n          }\n\n          if (seg.length === 5) name = names[seg[4]];\n          cb({\n            generatedLine,\n            generatedColumn,\n            source,\n            originalLine,\n            originalColumn,\n            name\n          });\n        }\n      }\n    };\n\n    exports.presortedDecodedMap = (map, mapUrl) => {\n      const clone = Object.assign({}, map);\n      clone.mappings = [];\n      const tracer = new TraceMap(clone, mapUrl);\n      tracer._decoded = map.mappings;\n      return tracer;\n    };\n\n    exports.decodedMap = map => {\n      return {\n        version: 3,\n        file: map.file,\n        names: map.names,\n        sourceRoot: map.sourceRoot,\n        sources: map.sources,\n        sourcesContent: map.sourcesContent,\n        mappings: exports.decodedMappings(map)\n      };\n    };\n\n    exports.encodedMap = map => {\n      return {\n        version: 3,\n        file: map.file,\n        names: map.names,\n        sourceRoot: map.sourceRoot,\n        sources: map.sources,\n        sourcesContent: map.sourcesContent,\n        mappings: exports.encodedMappings(map)\n      };\n    };\n  })();\n\n  function traceSegmentInternal(segments, memo, line, column, bias) {\n    let index = memoizedBinarySearch(segments, column, memo, line);\n\n    if (found) {\n      index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n    } else if (bias === LEAST_UPPER_BOUND) index++;\n\n    if (index === -1 || index === segments.length) return null;\n    return segments[index];\n  }\n\n  exports.AnyMap = AnyMap;\n  exports.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND;\n  exports.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND;\n  exports.TraceMap = TraceMap;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"mappings":"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","names":["resolve","input","base","endsWith","resolveUri","stripFilename","path","index","lastIndexOf","slice","COLUMN","SOURCES_INDEX","SOURCE_LINE","SOURCE_COLUMN","NAMES_INDEX","REV_GENERATED_LINE","REV_GENERATED_COLUMN","maybeSort","mappings","owned","unsortedIndex","nextUnsortedSegmentLine","length","i","sortSegments","start","isSorted","line","j","sort","sortComparator","a","b","found","binarySearch","haystack","needle","low","high","mid","cmp","upperBound","lowerBound","memoizedState","lastKey","lastNeedle","lastIndex","memoizedBinarySearch","state","key","buildBySources","decoded","memos","sources","map","buildNullArray","seg","sourceIndex","sourceLine","sourceColumn","originalSource","originalLine","memo","insert","array","value","__proto__","AnyMap","mapUrl","parsed","JSON","parse","TraceMap","sourcesContent","names","sections","no","offset","addSection","column","Infinity","joined","version","file","presortedDecodedMap","section","stopLine","stopColumn","lineOffset","columnOffset","sourcesOffset","namesOffset","decodedMappings","resolvedSources","append","fillSourcesContent","push","stopI","len","Math","min","out","cOffset","sourcesIndex","arr","other","INVALID_ORIGINAL_MAPPING","Object","freeze","source","name","INVALID_GENERATED_MAPPING","LINE_GTR_ZERO","COL_GTR_EQ_ZERO","LEAST_UPPER_BOUND","GREATEST_LOWER_BOUND","encodedMappings","traceSegment","originalPositionFor","generatedPositionFor","eachMapping","decodedMap","encodedMap","constructor","undefined","isString","sourceRoot","from","s","_encoded","_decoded","_a","encode","decode","traceSegmentInternal","_decodedMemo","bias","Error","segment","indexOf","generated","_bySources","_bySourceMemos","segments","cb","generatedLine","generatedColumn","originalColumn","clone","assign","tracer","bsFound"],"sources":["../../src/resolve.ts","../../src/strip-filename.ts","../../src/sourcemap-segment.ts","../../src/sort.ts","../../src/binary-search.ts","../../src/by-source.ts","../../src/any-map.ts","../../src/trace-mapping.ts"],"sourcesContent":[null,null,null,null,null,null,null,null]},"metadata":{},"sourceType":"script"}