{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSolidityFilesCachePath = exports.SolidityFilesCache = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nconst t = __importStar(require(\"io-ts\"));\n\nconst path = __importStar(require(\"path\"));\n\nconst constants_1 = require(\"../../internal/constants\");\n\nconst log = (0, debug_1.default)(\"hardhat:core:tasks:compile:cache\");\nconst FORMAT_VERSION = \"hh-sol-cache-2\";\nconst CacheEntryCodec = t.type({\n  lastModificationDate: t.number,\n  contentHash: t.string,\n  sourceName: t.string,\n  solcConfig: t.any,\n  imports: t.array(t.string),\n  versionPragmas: t.array(t.string),\n  artifacts: t.array(t.string)\n});\nconst CacheCodec = t.type({\n  _format: t.string,\n  files: t.record(t.string, CacheEntryCodec)\n});\n\nclass SolidityFilesCache {\n  constructor(_cache) {\n    this._cache = _cache;\n  }\n\n  static createEmpty() {\n    return new SolidityFilesCache({\n      _format: FORMAT_VERSION,\n      files: {}\n    });\n  }\n\n  static async readFromFile(solidityFilesCachePath) {\n    let cacheRaw = {\n      _format: FORMAT_VERSION,\n      files: {}\n    };\n\n    if (await fs_extra_1.default.pathExists(solidityFilesCachePath)) {\n      cacheRaw = await fs_extra_1.default.readJson(solidityFilesCachePath);\n    }\n\n    const result = CacheCodec.decode(cacheRaw);\n\n    if (result.isRight()) {\n      const solidityFilesCache = new SolidityFilesCache(result.value);\n      await solidityFilesCache.removeNonExistingFiles();\n      return solidityFilesCache;\n    }\n\n    log(\"There was a problem reading the cache\");\n    return new SolidityFilesCache({\n      _format: FORMAT_VERSION,\n      files: {}\n    });\n  }\n\n  async removeNonExistingFiles() {\n    await Promise.all(Object.keys(this._cache.files).map(async absolutePath => {\n      if (!(await fs_extra_1.default.pathExists(absolutePath))) {\n        this.removeEntry(absolutePath);\n      }\n    }));\n  }\n\n  async writeToFile(solidityFilesCachePath) {\n    await fs_extra_1.default.outputJson(solidityFilesCachePath, this._cache, {\n      spaces: 2\n    });\n  }\n\n  addFile(absolutePath, entry) {\n    this._cache.files[absolutePath] = entry;\n  }\n\n  getEntries() {\n    return Object.values(this._cache.files);\n  }\n\n  getEntry(file) {\n    return this._cache.files[file];\n  }\n\n  removeEntry(file) {\n    delete this._cache.files[file];\n  }\n\n  hasFileChanged(absolutePath, contentHash, solcConfig) {\n    const isEqual = require(\"lodash/isEqual\");\n\n    const cacheEntry = this.getEntry(absolutePath);\n\n    if (cacheEntry === undefined) {\n      // new file or no cache available, assume it's new\n      return true;\n    }\n\n    if (cacheEntry.contentHash !== contentHash) {\n      return true;\n    }\n\n    if (solcConfig !== undefined && !isEqual(solcConfig, cacheEntry.solcConfig)) {\n      return true;\n    }\n\n    return false;\n  }\n\n}\n\nexports.SolidityFilesCache = SolidityFilesCache;\n\nfunction getSolidityFilesCachePath(paths) {\n  return path.join(paths.cache, constants_1.SOLIDITY_FILES_CACHE_FILENAME);\n}\n\nexports.getSolidityFilesCachePath = getSolidityFilesCachePath;","map":{"version":3,"mappings":"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","names":["log","FORMAT_VERSION","CacheEntryCodec","t","type","lastModificationDate","number","contentHash","string","sourceName","solcConfig","any","imports","array","versionPragmas","artifacts","CacheCodec","_format","files","record","SolidityFilesCache","constructor","_cache","createEmpty","readFromFile","solidityFilesCachePath","cacheRaw","fs_extra_1","pathExists","readJson","result","decode","isRight","solidityFilesCache","value","removeNonExistingFiles","Promise","all","Object","keys","map","absolutePath","removeEntry","writeToFile","outputJson","spaces","addFile","entry","getEntries","values","getEntry","file","hasFileChanged","isEqual","require","cacheEntry","undefined","exports","getSolidityFilesCachePath","paths","path","join","cache","constants_1"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\hardhat\\src\\builtin-tasks\\utils\\solidity-files-cache.ts"],"sourcesContent":["import type { LoDashStatic } from \"lodash\";\nimport type { ProjectPathsConfig, SolcConfig } from \"../../types\";\n\nimport debug from \"debug\";\nimport fsExtra from \"fs-extra\";\nimport * as t from \"io-ts\";\nimport * as path from \"path\";\n\nimport { SOLIDITY_FILES_CACHE_FILENAME } from \"../../internal/constants\";\n\nconst log = debug(\"hardhat:core:tasks:compile:cache\");\n\nconst FORMAT_VERSION = \"hh-sol-cache-2\";\n\nconst CacheEntryCodec = t.type({\n  lastModificationDate: t.number,\n  contentHash: t.string,\n  sourceName: t.string,\n  solcConfig: t.any,\n  imports: t.array(t.string),\n  versionPragmas: t.array(t.string),\n  artifacts: t.array(t.string),\n});\n\nconst CacheCodec = t.type({\n  _format: t.string,\n  files: t.record(t.string, CacheEntryCodec),\n});\n\nexport interface CacheEntry {\n  lastModificationDate: number;\n  contentHash: string;\n  sourceName: string;\n  solcConfig: SolcConfig;\n  imports: string[];\n  versionPragmas: string[];\n  artifacts: string[];\n}\n\nexport interface Cache {\n  _format: string;\n  files: Record<string, CacheEntry>;\n}\n\nexport class SolidityFilesCache {\n  public static createEmpty(): SolidityFilesCache {\n    return new SolidityFilesCache({\n      _format: FORMAT_VERSION,\n      files: {},\n    });\n  }\n\n  public static async readFromFile(\n    solidityFilesCachePath: string\n  ): Promise<SolidityFilesCache> {\n    let cacheRaw: Cache = {\n      _format: FORMAT_VERSION,\n      files: {},\n    };\n    if (await fsExtra.pathExists(solidityFilesCachePath)) {\n      cacheRaw = await fsExtra.readJson(solidityFilesCachePath);\n    }\n\n    const result = CacheCodec.decode(cacheRaw);\n\n    if (result.isRight()) {\n      const solidityFilesCache = new SolidityFilesCache(result.value);\n      await solidityFilesCache.removeNonExistingFiles();\n      return solidityFilesCache;\n    }\n\n    log(\"There was a problem reading the cache\");\n\n    return new SolidityFilesCache({\n      _format: FORMAT_VERSION,\n      files: {},\n    });\n  }\n\n  constructor(private _cache: Cache) {}\n\n  public async removeNonExistingFiles() {\n    await Promise.all(\n      Object.keys(this._cache.files).map(async (absolutePath) => {\n        if (!(await fsExtra.pathExists(absolutePath))) {\n          this.removeEntry(absolutePath);\n        }\n      })\n    );\n  }\n\n  public async writeToFile(solidityFilesCachePath: string) {\n    await fsExtra.outputJson(solidityFilesCachePath, this._cache, {\n      spaces: 2,\n    });\n  }\n\n  public addFile(absolutePath: string, entry: CacheEntry) {\n    this._cache.files[absolutePath] = entry;\n  }\n\n  public getEntries(): CacheEntry[] {\n    return Object.values(this._cache.files);\n  }\n\n  public getEntry(file: string): CacheEntry | undefined {\n    return this._cache.files[file];\n  }\n\n  public removeEntry(file: string) {\n    delete this._cache.files[file];\n  }\n\n  public hasFileChanged(\n    absolutePath: string,\n    contentHash: string,\n    solcConfig?: SolcConfig\n  ): boolean {\n    const isEqual = require(\"lodash/isEqual\") as LoDashStatic[\"isEqual\"];\n\n    const cacheEntry = this.getEntry(absolutePath);\n\n    if (cacheEntry === undefined) {\n      // new file or no cache available, assume it's new\n      return true;\n    }\n\n    if (cacheEntry.contentHash !== contentHash) {\n      return true;\n    }\n\n    if (\n      solcConfig !== undefined &&\n      !isEqual(solcConfig, cacheEntry.solcConfig)\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n}\n\nexport function getSolidityFilesCachePath(paths: ProjectPathsConfig): string {\n  return path.join(paths.cache, SOLIDITY_FILES_CACHE_FILENAME);\n}\n"]},"metadata":{},"sourceType":"script"}