{"ast":null,"code":"'use strict';\n\nconst net = require('net');\n\nconst assert = require('assert');\n\nconst util = require('./util');\n\nconst {\n  InvalidArgumentError,\n  ConnectTimeoutError\n} = require('./errors');\n\nlet tls; // include tls conditionally since it is not always available\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\n\nfunction buildConnector(_ref) {\n  let {\n    maxCachedSessions,\n    socketPath,\n    timeout,\n    ...opts\n  } = _ref;\n\n  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero');\n  }\n\n  const options = {\n    path: socketPath,\n    ...opts\n  };\n  const sessionCache = new Map();\n  timeout = timeout == null ? 10e3 : timeout;\n  maxCachedSessions = maxCachedSessions == null ? 100 : maxCachedSessions;\n  return function connect(_ref2, callback) {\n    let {\n      hostname,\n      host,\n      protocol,\n      port,\n      servername,\n      httpSocket\n    } = _ref2;\n    let socket;\n\n    if (protocol === 'https:') {\n      if (!tls) {\n        tls = require('tls');\n      }\n\n      servername = servername || options.servername || util.getServerName(host) || null;\n      const sessionKey = servername || hostname;\n      const session = sessionCache.get(sessionKey) || null;\n      assert(sessionKey);\n      socket = tls.connect({\n        highWaterMark: 16384,\n        // TLS in node can't have bigger HWM anyway...\n        ...options,\n        servername,\n        session,\n        socket: httpSocket,\n        // upgrade socket connection\n        port: port || 443,\n        host: hostname\n      });\n      socket.on('session', function (session) {\n        // cache is disabled\n        if (maxCachedSessions === 0) {\n          return;\n        }\n\n        if (sessionCache.size >= maxCachedSessions) {\n          // remove the oldest session\n          const {\n            value: oldestKey\n          } = sessionCache.keys().next();\n          sessionCache.delete(oldestKey);\n        }\n\n        sessionCache.set(sessionKey, session);\n      }).on('error', function (err) {\n        if (sessionKey && err.code !== 'UND_ERR_INFO') {\n          // TODO (fix): Only delete for session related errors.\n          sessionCache.delete(sessionKey);\n        }\n      });\n    } else {\n      assert(!httpSocket, 'httpSocket can only be sent on TLS update');\n      socket = net.connect({\n        highWaterMark: 64 * 1024,\n        // Same as nodejs fs streams.\n        ...options,\n        port: port || 80,\n        host: hostname\n      });\n    }\n\n    const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);\n    socket.setNoDelay(true).once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {\n      cancelTimeout();\n\n      if (callback) {\n        const cb = callback;\n        callback = null;\n        cb(null, this);\n      }\n    }).on('error', function (err) {\n      cancelTimeout();\n\n      if (callback) {\n        const cb = callback;\n        callback = null;\n        cb(err);\n      }\n    });\n    return socket;\n  };\n}\n\nfunction setupTimeout(onConnectTimeout, timeout) {\n  if (!timeout) {\n    return () => {};\n  }\n\n  let s1 = null;\n  let s2 = null;\n  const timeoutId = setTimeout(() => {\n    // setImmediate is added to make sure that we priotorise socket error events over timeouts\n    s1 = setImmediate(() => {\n      if (process.platform === 'win32') {\n        // Windows needs an extra setImmediate probably due to implementation differences in the socket logic\n        s2 = setImmediate(() => onConnectTimeout());\n      } else {\n        onConnectTimeout();\n      }\n    });\n  }, timeout);\n  return () => {\n    clearTimeout(timeoutId);\n    clearImmediate(s1);\n    clearImmediate(s2);\n  };\n}\n\nfunction onConnectTimeout(socket) {\n  util.destroy(socket, new ConnectTimeoutError());\n}\n\nmodule.exports = buildConnector;","map":{"version":3,"names":["net","require","assert","util","InvalidArgumentError","ConnectTimeoutError","tls","buildConnector","maxCachedSessions","socketPath","timeout","opts","Number","isInteger","options","path","sessionCache","Map","connect","callback","hostname","host","protocol","port","servername","httpSocket","socket","getServerName","sessionKey","session","get","highWaterMark","on","size","value","oldestKey","keys","next","delete","set","err","code","cancelTimeout","setupTimeout","onConnectTimeout","setNoDelay","once","cb","s1","s2","timeoutId","setTimeout","setImmediate","process","platform","clearTimeout","clearImmediate","destroy","module","exports"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/undici/lib/core/connect.js"],"sourcesContent":["'use strict'\n\nconst net = require('net')\nconst assert = require('assert')\nconst util = require('./util')\nconst { InvalidArgumentError, ConnectTimeoutError } = require('./errors')\nlet tls // include tls conditionally since it is not always available\n\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\n\nfunction buildConnector ({ maxCachedSessions, socketPath, timeout, ...opts }) {\n  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero')\n  }\n\n  const options = { path: socketPath, ...opts }\n  const sessionCache = new Map()\n  timeout = timeout == null ? 10e3 : timeout\n  maxCachedSessions = maxCachedSessions == null ? 100 : maxCachedSessions\n\n  return function connect ({ hostname, host, protocol, port, servername, httpSocket }, callback) {\n    let socket\n    if (protocol === 'https:') {\n      if (!tls) {\n        tls = require('tls')\n      }\n      servername = servername || options.servername || util.getServerName(host) || null\n\n      const sessionKey = servername || hostname\n      const session = sessionCache.get(sessionKey) || null\n\n      assert(sessionKey)\n\n      socket = tls.connect({\n        highWaterMark: 16384, // TLS in node can't have bigger HWM anyway...\n        ...options,\n        servername,\n        session,\n        socket: httpSocket, // upgrade socket connection\n        port: port || 443,\n        host: hostname\n      })\n\n      socket\n        .on('session', function (session) {\n          // cache is disabled\n          if (maxCachedSessions === 0) {\n            return\n          }\n\n          if (sessionCache.size >= maxCachedSessions) {\n            // remove the oldest session\n            const { value: oldestKey } = sessionCache.keys().next()\n            sessionCache.delete(oldestKey)\n          }\n\n          sessionCache.set(sessionKey, session)\n        })\n        .on('error', function (err) {\n          if (sessionKey && err.code !== 'UND_ERR_INFO') {\n            // TODO (fix): Only delete for session related errors.\n            sessionCache.delete(sessionKey)\n          }\n        })\n    } else {\n      assert(!httpSocket, 'httpSocket can only be sent on TLS update')\n      socket = net.connect({\n        highWaterMark: 64 * 1024, // Same as nodejs fs streams.\n        ...options,\n        port: port || 80,\n        host: hostname\n      })\n    }\n\n    const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout)\n\n    socket\n      .setNoDelay(true)\n      .once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {\n        cancelTimeout()\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(null, this)\n        }\n      })\n      .on('error', function (err) {\n        cancelTimeout()\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(err)\n        }\n      })\n\n    return socket\n  }\n}\n\nfunction setupTimeout (onConnectTimeout, timeout) {\n  if (!timeout) {\n    return () => {}\n  }\n\n  let s1 = null\n  let s2 = null\n  const timeoutId = setTimeout(() => {\n    // setImmediate is added to make sure that we priotorise socket error events over timeouts\n    s1 = setImmediate(() => {\n      if (process.platform === 'win32') {\n        // Windows needs an extra setImmediate probably due to implementation differences in the socket logic\n        s2 = setImmediate(() => onConnectTimeout())\n      } else {\n        onConnectTimeout()\n      }\n    })\n  }, timeout)\n  return () => {\n    clearTimeout(timeoutId)\n    clearImmediate(s1)\n    clearImmediate(s2)\n  }\n}\n\nfunction onConnectTimeout (socket) {\n  util.destroy(socket, new ConnectTimeoutError())\n}\n\nmodule.exports = buildConnector\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}