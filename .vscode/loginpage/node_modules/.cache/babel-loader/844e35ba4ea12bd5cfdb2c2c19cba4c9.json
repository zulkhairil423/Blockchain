{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JsonRpcHandler = void 0;\n\nconst raw_body_1 = __importDefault(require(\"raw-body\"));\n\nconst errors_1 = require(\"../../core/providers/errors\");\n\nconst jsonrpc_1 = require(\"../../util/jsonrpc\");\n/* eslint-disable @nomiclabs/hardhat-internal-rules/only-hardhat-error */\n\n\nclass JsonRpcHandler {\n  constructor(_provider) {\n    this._provider = _provider;\n\n    this.handleHttp = async (req, res) => {\n      this._setCorsHeaders(res);\n\n      if (req.method === \"OPTIONS\") {\n        this._sendEmptyResponse(res);\n\n        return;\n      }\n\n      let jsonHttpRequest;\n\n      try {\n        jsonHttpRequest = await _readJsonHttpRequest(req);\n      } catch (error) {\n        this._sendResponse(res, _handleError(error));\n\n        return;\n      }\n\n      if (Array.isArray(jsonHttpRequest)) {\n        const responses = await Promise.all(jsonHttpRequest.map(singleReq => this._handleSingleRequest(singleReq)));\n\n        this._sendResponse(res, responses);\n\n        return;\n      }\n\n      const rpcResp = await this._handleSingleRequest(jsonHttpRequest);\n\n      this._sendResponse(res, rpcResp);\n    };\n\n    this.handleWs = async ws => {\n      const subscriptions = [];\n      let isClosed = false;\n\n      const listener = payload => {\n        // Don't attempt to send a message to the websocket if we already know it is closed,\n        // or the current websocket connection isn't interested in the particular subscription.\n        if (isClosed || !subscriptions.includes(payload.subscription)) {\n          return;\n        }\n\n        try {\n          ws.send(JSON.stringify({\n            jsonrpc: \"2.0\",\n            method: \"eth_subscription\",\n            params: payload\n          }));\n        } catch (error) {\n          _handleError(error);\n        }\n      }; // Handle eth_subscribe notifications.\n\n\n      this._provider.addListener(\"notification\", listener);\n\n      ws.on(\"message\", async msg => {\n        let rpcReq;\n        let rpcResp;\n\n        try {\n          rpcReq = _readWsRequest(msg);\n\n          if (!(0, jsonrpc_1.isValidJsonRequest)(rpcReq)) {\n            throw new errors_1.InvalidRequestError(\"Invalid request\");\n          }\n\n          rpcResp = await this._handleRequest(rpcReq); // If eth_subscribe was successful, keep track of the subscription id,\n          // so we can cleanup on websocket close.\n\n          if (rpcReq.method === \"eth_subscribe\" && (0, jsonrpc_1.isSuccessfulJsonResponse)(rpcResp)) {\n            subscriptions.push(rpcResp.result);\n          }\n        } catch (error) {\n          rpcResp = _handleError(error);\n        } // Validate the RPC response.\n\n\n        if (!(0, jsonrpc_1.isValidJsonResponse)(rpcResp)) {\n          // Malformed response coming from the provider, report to user as an internal error.\n          rpcResp = _handleError(new errors_1.InternalError(\"Internal error\"));\n        }\n\n        if (rpcReq !== undefined) {\n          rpcResp.id = rpcReq.id;\n        }\n\n        ws.send(JSON.stringify(rpcResp));\n      });\n      ws.on(\"close\", () => {\n        // Remove eth_subscribe listener.\n        this._provider.removeListener(\"notification\", listener); // Clear any active subscriptions for the closed websocket connection.\n\n\n        isClosed = true;\n        subscriptions.forEach(async subscriptionId => {\n          await this._provider.request({\n            method: \"eth_unsubscribe\",\n            params: [subscriptionId]\n          });\n        });\n      });\n    };\n\n    this._handleRequest = async req => {\n      const result = await this._provider.request({\n        method: req.method,\n        params: req.params\n      });\n      return {\n        jsonrpc: \"2.0\",\n        id: req.id,\n        result\n      };\n    };\n  }\n\n  _sendEmptyResponse(res) {\n    res.writeHead(200);\n    res.end();\n  }\n\n  _setCorsHeaders(res) {\n    res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n    res.setHeader(\"Access-Control-Request-Method\", \"*\");\n    res.setHeader(\"Access-Control-Allow-Methods\", \"OPTIONS, GET\");\n    res.setHeader(\"Access-Control-Allow-Headers\", \"*\");\n  }\n\n  _sendResponse(res, rpcResp) {\n    res.statusCode = 200;\n    res.setHeader(\"Content-Type\", \"application/json\");\n    res.end(JSON.stringify(rpcResp));\n  }\n\n  async _handleSingleRequest(req) {\n    if (!(0, jsonrpc_1.isValidJsonRequest)(req)) {\n      return _handleError(new errors_1.InvalidRequestError(\"Invalid request\"));\n    }\n\n    const rpcReq = req;\n    let rpcResp;\n\n    try {\n      rpcResp = await this._handleRequest(rpcReq);\n    } catch (error) {\n      rpcResp = _handleError(error);\n    } // Validate the RPC response.\n\n\n    if (!(0, jsonrpc_1.isValidJsonResponse)(rpcResp)) {\n      // Malformed response coming from the provider, report to user as an internal error.\n      rpcResp = _handleError(new errors_1.InternalError(\"Internal error\"));\n    }\n\n    if (rpcReq !== undefined) {\n      rpcResp.id = rpcReq.id !== undefined ? rpcReq.id : null;\n    }\n\n    return rpcResp;\n  }\n\n}\n\nexports.JsonRpcHandler = JsonRpcHandler;\n\nconst _readJsonHttpRequest = async req => {\n  let json;\n\n  try {\n    const buf = await (0, raw_body_1.default)(req);\n    const text = buf.toString();\n    json = JSON.parse(text);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new errors_1.InvalidJsonInputError(`Parse error: ${error.message}`);\n    } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n    throw error;\n  }\n\n  return json;\n};\n\nconst _readWsRequest = msg => {\n  let json;\n\n  try {\n    json = JSON.parse(msg);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new errors_1.InvalidJsonInputError(`Parse error: ${error.message}`);\n    } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n    throw error;\n  }\n\n  return json;\n};\n\nconst _handleError = error => {\n  // extract the relevant fields from the error before wrapping it\n  let txHash;\n  let returnData;\n\n  if (error.transactionHash !== undefined) {\n    txHash = error.transactionHash;\n  }\n\n  if (error.data !== undefined) {\n    returnData = error.data;\n  } // In case of non-hardhat error, treat it as internal and associate the appropriate error code.\n\n\n  if (!errors_1.ProviderError.isProviderError(error)) {\n    error = new errors_1.InternalError(error);\n  }\n\n  const response = {\n    jsonrpc: \"2.0\",\n    id: null,\n    error: {\n      code: error.code,\n      message: error.message\n    }\n  };\n  response.error.data = {\n    message: error.message\n  };\n\n  if (txHash !== undefined) {\n    response.error.data.txHash = txHash;\n  }\n\n  if (returnData !== undefined) {\n    response.error.data.data = returnData;\n  }\n\n  return response;\n};","map":{"version":3,"mappings":";;;;;;;;;;;;;AACA;;AAIA;;AAMA;AASA;;;AAEA,MAAaA,cAAb,CAA2B;EACzBC,YAA6BC,SAA7B,EAAuD;IAA1B;;IAEtB,kBAAa,OAAOC,GAAP,EAA6BC,GAA7B,KAAoD;MACtE,KAAKC,eAAL,CAAqBD,GAArB;;MACA,IAAID,GAAG,CAACG,MAAJ,KAAe,SAAnB,EAA8B;QAC5B,KAAKC,kBAAL,CAAwBH,GAAxB;;QACA;MACD;;MAED,IAAII,eAAJ;;MACA,IAAI;QACFA,eAAe,GAAG,MAAMC,oBAAoB,CAACN,GAAD,CAA5C;MACD,CAFD,CAEE,OAAOO,KAAP,EAAc;QACd,KAAKC,aAAL,CAAmBP,GAAnB,EAAwBQ,YAAY,CAACF,KAAD,CAApC;;QACA;MACD;;MAED,IAAIG,KAAK,CAACC,OAAN,CAAcN,eAAd,CAAJ,EAAoC;QAClC,MAAMO,SAAS,GAAG,MAAMC,OAAO,CAACC,GAAR,CACtBT,eAAe,CAACU,GAAhB,CAAqBC,SAAD,IAClB,KAAKC,oBAAL,CAA0BD,SAA1B,CADF,CADsB,CAAxB;;QAMA,KAAKR,aAAL,CAAmBP,GAAnB,EAAwBW,SAAxB;;QACA;MACD;;MAED,MAAMM,OAAO,GAAG,MAAM,KAAKD,oBAAL,CAA0BZ,eAA1B,CAAtB;;MAEA,KAAKG,aAAL,CAAmBP,GAAnB,EAAwBiB,OAAxB;IACD,CA7BM;;IA+BA,gBAAW,MAAOC,EAAP,IAAwB;MACxC,MAAMC,aAAa,GAAa,EAAhC;MACA,IAAIC,QAAQ,GAAG,KAAf;;MAEA,MAAMC,QAAQ,GAAIC,OAAD,IAAmD;QAClE;QACA;QACA,IAAIF,QAAQ,IAAI,CAACD,aAAa,CAACI,QAAd,CAAuBD,OAAO,CAACE,YAA/B,CAAjB,EAA+D;UAC7D;QACD;;QAED,IAAI;UACFN,EAAE,CAACO,IAAH,CACEC,IAAI,CAACC,SAAL,CAAe;YACbC,OAAO,EAAE,KADI;YAEb1B,MAAM,EAAE,kBAFK;YAGb2B,MAAM,EAAEP;UAHK,CAAf,CADF;QAOD,CARD,CAQE,OAAOhB,KAAP,EAAc;UACdE,YAAY,CAACF,KAAD,CAAZ;QACD;MACF,CAlBD,CAJwC,CAwBxC;;;MACA,KAAKR,SAAL,CAAegC,WAAf,CAA2B,cAA3B,EAA2CT,QAA3C;;MAEAH,EAAE,CAACa,EAAH,CAAM,SAAN,EAAiB,MAAOC,GAAP,IAAc;QAC7B,IAAIC,MAAJ;QACA,IAAIhB,OAAJ;;QAEA,IAAI;UACFgB,MAAM,GAAGC,cAAc,CAACF,GAAD,CAAvB;;UAEA,IAAI,CAAC,kCAAmBC,MAAnB,CAAL,EAAiC;YAC/B,MAAM,IAAIE,4BAAJ,CAAwB,iBAAxB,CAAN;UACD;;UAEDlB,OAAO,GAAG,MAAM,KAAKmB,cAAL,CAAoBH,MAApB,CAAhB,CAPE,CASF;UACA;;UACA,IACEA,MAAM,CAAC/B,MAAP,KAAkB,eAAlB,IACA,wCAAyBe,OAAzB,CAFF,EAGE;YACAE,aAAa,CAACkB,IAAd,CAAmBpB,OAAO,CAACqB,MAA3B;UACD;QACF,CAjBD,CAiBE,OAAOhC,KAAP,EAAc;UACdW,OAAO,GAAGT,YAAY,CAACF,KAAD,CAAtB;QACD,CAvB4B,CAyB7B;;;QACA,IAAI,CAAC,mCAAoBW,OAApB,CAAL,EAAmC;UACjC;UACAA,OAAO,GAAGT,YAAY,CAAC,IAAI2B,sBAAJ,CAAkB,gBAAlB,CAAD,CAAtB;QACD;;QAED,IAAIF,MAAM,KAAKM,SAAf,EAA0B;UACxBtB,OAAO,CAACuB,EAAR,GAAaP,MAAM,CAACO,EAApB;QACD;;QAEDtB,EAAE,CAACO,IAAH,CAAQC,IAAI,CAACC,SAAL,CAAeV,OAAf,CAAR;MACD,CApCD;MAsCAC,EAAE,CAACa,EAAH,CAAM,OAAN,EAAe,MAAK;QAClB;QACA,KAAKjC,SAAL,CAAe2C,cAAf,CAA8B,cAA9B,EAA8CpB,QAA9C,EAFkB,CAIlB;;;QACAD,QAAQ,GAAG,IAAX;QACAD,aAAa,CAACuB,OAAd,CAAsB,MAAOC,cAAP,IAAyB;UAC7C,MAAM,KAAK7C,SAAL,CAAe8C,OAAf,CAAuB;YAC3B1C,MAAM,EAAE,iBADmB;YAE3B2B,MAAM,EAAE,CAACc,cAAD;UAFmB,CAAvB,CAAN;QAID,CALD;MAMD,CAZD;IAaD,CA9EM;;IAgIC,sBAAiB,MACvB5C,GADuB,IAEK;MAC5B,MAAMuC,MAAM,GAAG,MAAM,KAAKxC,SAAL,CAAe8C,OAAf,CAAuB;QAC1C1C,MAAM,EAAEH,GAAG,CAACG,MAD8B;QAE1C2B,MAAM,EAAE9B,GAAG,CAAC8B;MAF8B,CAAvB,CAArB;MAKA,OAAO;QACLD,OAAO,EAAE,KADJ;QAELY,EAAE,EAAEzC,GAAG,CAACyC,EAFH;QAGLF;MAHK,CAAP;IAKD,CAbO;EAjKmD;;EAiHnDnC,kBAAkB,CAACH,GAAD,EAAoB;IAC5CA,GAAG,CAAC6C,SAAJ,CAAc,GAAd;IACA7C,GAAG,CAAC8C,GAAJ;EACD;;EAEO7C,eAAe,CAACD,GAAD,EAAoB;IACzCA,GAAG,CAAC+C,SAAJ,CAAc,6BAAd,EAA6C,GAA7C;IACA/C,GAAG,CAAC+C,SAAJ,CAAc,+BAAd,EAA+C,GAA/C;IACA/C,GAAG,CAAC+C,SAAJ,CAAc,8BAAd,EAA8C,cAA9C;IACA/C,GAAG,CAAC+C,SAAJ,CAAc,8BAAd,EAA8C,GAA9C;EACD;;EAEOxC,aAAa,CACnBP,GADmB,EAEnBiB,OAFmB,EAEyB;IAE5CjB,GAAG,CAACgD,UAAJ,GAAiB,GAAjB;IACAhD,GAAG,CAAC+C,SAAJ,CAAc,cAAd,EAA8B,kBAA9B;IACA/C,GAAG,CAAC8C,GAAJ,CAAQpB,IAAI,CAACC,SAAL,CAAeV,OAAf,CAAR;EACD;;EAEiC,MAApBD,oBAAoB,CAACjB,GAAD,EAAS;IACzC,IAAI,CAAC,kCAAmBA,GAAnB,CAAL,EAA8B;MAC5B,OAAOS,YAAY,CAAC,IAAI2B,4BAAJ,CAAwB,iBAAxB,CAAD,CAAnB;IACD;;IAED,MAAMF,MAAM,GAAmBlC,GAA/B;IACA,IAAIkB,OAAJ;;IAEA,IAAI;MACFA,OAAO,GAAG,MAAM,KAAKmB,cAAL,CAAoBH,MAApB,CAAhB;IACD,CAFD,CAEE,OAAO3B,KAAP,EAAc;MACdW,OAAO,GAAGT,YAAY,CAACF,KAAD,CAAtB;IACD,CAZwC,CAczC;;;IACA,IAAI,CAAC,mCAAoBW,OAApB,CAAL,EAAmC;MACjC;MACAA,OAAO,GAAGT,YAAY,CAAC,IAAI2B,sBAAJ,CAAkB,gBAAlB,CAAD,CAAtB;IACD;;IAED,IAAIF,MAAM,KAAKM,SAAf,EAA0B;MACxBtB,OAAO,CAACuB,EAAR,GAAaP,MAAM,CAACO,EAAP,KAAcD,SAAd,GAA0BN,MAAM,CAACO,EAAjC,GAAsC,IAAnD;IACD;;IAED,OAAOvB,OAAP;EACD;;AAhKwB;;AAA3BgC;;AAkLA,MAAM5C,oBAAoB,GAAG,MAAON,GAAP,IAA6C;EACxE,IAAImD,IAAJ;;EAEA,IAAI;IACF,MAAMC,GAAG,GAAG,MAAM,wBAAWpD,GAAX,CAAlB;IACA,MAAMqD,IAAI,GAAGD,GAAG,CAACE,QAAJ,EAAb;IAEAH,IAAI,GAAGxB,IAAI,CAAC4B,KAAL,CAAWF,IAAX,CAAP;EACD,CALD,CAKE,OAAO9C,KAAP,EAAc;IACd,IAAIA,KAAK,YAAYiD,KAArB,EAA4B;MAC1B,MAAM,IAAIpB,8BAAJ,CAA0B,gBAAgB7B,KAAK,CAACkD,OAAO,EAAvD,CAAN;IACD,CAHa,CAKd;;;IACA,MAAMlD,KAAN;EACD;;EAED,OAAO4C,IAAP;AACD,CAlBD;;AAoBA,MAAMhB,cAAc,GAAIF,GAAD,IAAgC;EACrD,IAAIkB,IAAJ;;EACA,IAAI;IACFA,IAAI,GAAGxB,IAAI,CAAC4B,KAAL,CAAWtB,GAAX,CAAP;EACD,CAFD,CAEE,OAAO1B,KAAP,EAAc;IACd,IAAIA,KAAK,YAAYiD,KAArB,EAA4B;MAC1B,MAAM,IAAIpB,8BAAJ,CAA0B,gBAAgB7B,KAAK,CAACkD,OAAO,EAAvD,CAAN;IACD,CAHa,CAKd;;;IACA,MAAMlD,KAAN;EACD;;EAED,OAAO4C,IAAP;AACD,CAdD;;AAgBA,MAAM1C,YAAY,GAAIF,KAAD,IAAgC;EACnD;EACA,IAAImD,MAAJ;EACA,IAAIC,UAAJ;;EAEA,IAAIpD,KAAK,CAACqD,eAAN,KAA0BpB,SAA9B,EAAyC;IACvCkB,MAAM,GAAGnD,KAAK,CAACqD,eAAf;EACD;;EACD,IAAIrD,KAAK,CAACsD,IAAN,KAAerB,SAAnB,EAA8B;IAC5BmB,UAAU,GAAGpD,KAAK,CAACsD,IAAnB;EACD,CAVkD,CAYnD;;;EACA,IAAI,CAACzB,uBAAc0B,eAAd,CAA8BvD,KAA9B,CAAL,EAA2C;IACzCA,KAAK,GAAG,IAAI6B,sBAAJ,CAAkB7B,KAAlB,CAAR;EACD;;EAED,MAAMwD,QAAQ,GAA0B;IACtClC,OAAO,EAAE,KAD6B;IAEtCY,EAAE,EAAE,IAFkC;IAGtClC,KAAK,EAAE;MACLyD,IAAI,EAAEzD,KAAK,CAACyD,IADP;MAELP,OAAO,EAAElD,KAAK,CAACkD;IAFV;EAH+B,CAAxC;EASAM,QAAQ,CAACxD,KAAT,CAAesD,IAAf,GAAsB;IACpBJ,OAAO,EAAElD,KAAK,CAACkD;EADK,CAAtB;;EAIA,IAAIC,MAAM,KAAKlB,SAAf,EAA0B;IACxBuB,QAAQ,CAACxD,KAAT,CAAesD,IAAf,CAAoBH,MAApB,GAA6BA,MAA7B;EACD;;EAED,IAAIC,UAAU,KAAKnB,SAAnB,EAA8B;IAC5BuB,QAAQ,CAACxD,KAAT,CAAesD,IAAf,CAAoBA,IAApB,GAA2BF,UAA3B;EACD;;EAED,OAAOI,QAAP;AACD,CAvCD","names":["JsonRpcHandler","constructor","_provider","req","res","_setCorsHeaders","method","_sendEmptyResponse","jsonHttpRequest","_readJsonHttpRequest","error","_sendResponse","_handleError","Array","isArray","responses","Promise","all","map","singleReq","_handleSingleRequest","rpcResp","ws","subscriptions","isClosed","listener","payload","includes","subscription","send","JSON","stringify","jsonrpc","params","addListener","on","msg","rpcReq","_readWsRequest","errors_1","_handleRequest","push","result","undefined","id","removeListener","forEach","subscriptionId","request","writeHead","end","setHeader","statusCode","exports","json","buf","text","toString","parse","Error","message","txHash","returnData","transactionHash","data","isProviderError","response","code"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\hardhat\\src\\internal\\hardhat-network\\jsonrpc\\handler.ts"],"sourcesContent":["import { IncomingMessage, ServerResponse } from \"http\";\nimport getRawBody from \"raw-body\";\nimport WebSocket from \"ws\";\n\nimport { EIP1193Provider } from \"../../../types\";\nimport {\n  InternalError,\n  InvalidJsonInputError,\n  InvalidRequestError,\n  ProviderError,\n} from \"../../core/providers/errors\";\nimport {\n  FailedJsonRpcResponse,\n  isSuccessfulJsonResponse,\n  isValidJsonRequest,\n  isValidJsonResponse,\n  JsonRpcRequest,\n  JsonRpcResponse,\n} from \"../../util/jsonrpc\";\n\n/* eslint-disable @nomiclabs/hardhat-internal-rules/only-hardhat-error */\n\nexport class JsonRpcHandler {\n  constructor(private readonly _provider: EIP1193Provider) {}\n\n  public handleHttp = async (req: IncomingMessage, res: ServerResponse) => {\n    this._setCorsHeaders(res);\n    if (req.method === \"OPTIONS\") {\n      this._sendEmptyResponse(res);\n      return;\n    }\n\n    let jsonHttpRequest: any;\n    try {\n      jsonHttpRequest = await _readJsonHttpRequest(req);\n    } catch (error) {\n      this._sendResponse(res, _handleError(error));\n      return;\n    }\n\n    if (Array.isArray(jsonHttpRequest)) {\n      const responses = await Promise.all(\n        jsonHttpRequest.map((singleReq: any) =>\n          this._handleSingleRequest(singleReq)\n        )\n      );\n\n      this._sendResponse(res, responses);\n      return;\n    }\n\n    const rpcResp = await this._handleSingleRequest(jsonHttpRequest);\n\n    this._sendResponse(res, rpcResp);\n  };\n\n  public handleWs = async (ws: WebSocket) => {\n    const subscriptions: string[] = [];\n    let isClosed = false;\n\n    const listener = (payload: { subscription: string; result: any }) => {\n      // Don't attempt to send a message to the websocket if we already know it is closed,\n      // or the current websocket connection isn't interested in the particular subscription.\n      if (isClosed || !subscriptions.includes(payload.subscription)) {\n        return;\n      }\n\n      try {\n        ws.send(\n          JSON.stringify({\n            jsonrpc: \"2.0\",\n            method: \"eth_subscription\",\n            params: payload,\n          })\n        );\n      } catch (error) {\n        _handleError(error);\n      }\n    };\n\n    // Handle eth_subscribe notifications.\n    this._provider.addListener(\"notification\", listener);\n\n    ws.on(\"message\", async (msg) => {\n      let rpcReq: JsonRpcRequest | undefined;\n      let rpcResp: JsonRpcResponse | undefined;\n\n      try {\n        rpcReq = _readWsRequest(msg as string);\n\n        if (!isValidJsonRequest(rpcReq)) {\n          throw new InvalidRequestError(\"Invalid request\");\n        }\n\n        rpcResp = await this._handleRequest(rpcReq);\n\n        // If eth_subscribe was successful, keep track of the subscription id,\n        // so we can cleanup on websocket close.\n        if (\n          rpcReq.method === \"eth_subscribe\" &&\n          isSuccessfulJsonResponse(rpcResp)\n        ) {\n          subscriptions.push(rpcResp.result);\n        }\n      } catch (error) {\n        rpcResp = _handleError(error);\n      }\n\n      // Validate the RPC response.\n      if (!isValidJsonResponse(rpcResp)) {\n        // Malformed response coming from the provider, report to user as an internal error.\n        rpcResp = _handleError(new InternalError(\"Internal error\"));\n      }\n\n      if (rpcReq !== undefined) {\n        rpcResp.id = rpcReq.id;\n      }\n\n      ws.send(JSON.stringify(rpcResp));\n    });\n\n    ws.on(\"close\", () => {\n      // Remove eth_subscribe listener.\n      this._provider.removeListener(\"notification\", listener);\n\n      // Clear any active subscriptions for the closed websocket connection.\n      isClosed = true;\n      subscriptions.forEach(async (subscriptionId) => {\n        await this._provider.request({\n          method: \"eth_unsubscribe\",\n          params: [subscriptionId],\n        });\n      });\n    });\n  };\n\n  private _sendEmptyResponse(res: ServerResponse) {\n    res.writeHead(200);\n    res.end();\n  }\n\n  private _setCorsHeaders(res: ServerResponse) {\n    res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n    res.setHeader(\"Access-Control-Request-Method\", \"*\");\n    res.setHeader(\"Access-Control-Allow-Methods\", \"OPTIONS, GET\");\n    res.setHeader(\"Access-Control-Allow-Headers\", \"*\");\n  }\n\n  private _sendResponse(\n    res: ServerResponse,\n    rpcResp: JsonRpcResponse | JsonRpcResponse[]\n  ) {\n    res.statusCode = 200;\n    res.setHeader(\"Content-Type\", \"application/json\");\n    res.end(JSON.stringify(rpcResp));\n  }\n\n  private async _handleSingleRequest(req: any): Promise<JsonRpcResponse> {\n    if (!isValidJsonRequest(req)) {\n      return _handleError(new InvalidRequestError(\"Invalid request\"));\n    }\n\n    const rpcReq: JsonRpcRequest = req;\n    let rpcResp: JsonRpcResponse | undefined;\n\n    try {\n      rpcResp = await this._handleRequest(rpcReq);\n    } catch (error) {\n      rpcResp = _handleError(error);\n    }\n\n    // Validate the RPC response.\n    if (!isValidJsonResponse(rpcResp)) {\n      // Malformed response coming from the provider, report to user as an internal error.\n      rpcResp = _handleError(new InternalError(\"Internal error\"));\n    }\n\n    if (rpcReq !== undefined) {\n      rpcResp.id = rpcReq.id !== undefined ? rpcReq.id : null;\n    }\n\n    return rpcResp;\n  }\n\n  private _handleRequest = async (\n    req: JsonRpcRequest\n  ): Promise<JsonRpcResponse> => {\n    const result = await this._provider.request({\n      method: req.method,\n      params: req.params,\n    });\n\n    return {\n      jsonrpc: \"2.0\",\n      id: req.id,\n      result,\n    };\n  };\n}\n\nconst _readJsonHttpRequest = async (req: IncomingMessage): Promise<any> => {\n  let json;\n\n  try {\n    const buf = await getRawBody(req);\n    const text = buf.toString();\n\n    json = JSON.parse(text);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new InvalidJsonInputError(`Parse error: ${error.message}`);\n    }\n\n    // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n\n  return json;\n};\n\nconst _readWsRequest = (msg: string): JsonRpcRequest => {\n  let json: any;\n  try {\n    json = JSON.parse(msg);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new InvalidJsonInputError(`Parse error: ${error.message}`);\n    }\n\n    // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n\n  return json;\n};\n\nconst _handleError = (error: any): JsonRpcResponse => {\n  // extract the relevant fields from the error before wrapping it\n  let txHash: string | undefined;\n  let returnData: string | undefined;\n\n  if (error.transactionHash !== undefined) {\n    txHash = error.transactionHash;\n  }\n  if (error.data !== undefined) {\n    returnData = error.data;\n  }\n\n  // In case of non-hardhat error, treat it as internal and associate the appropriate error code.\n  if (!ProviderError.isProviderError(error)) {\n    error = new InternalError(error);\n  }\n\n  const response: FailedJsonRpcResponse = {\n    jsonrpc: \"2.0\",\n    id: null,\n    error: {\n      code: error.code,\n      message: error.message,\n    },\n  };\n\n  response.error.data = {\n    message: error.message,\n  };\n\n  if (txHash !== undefined) {\n    response.error.data.txHash = txHash;\n  }\n\n  if (returnData !== undefined) {\n    response.error.data.data = returnData;\n  }\n\n  return response;\n};\n"]},"metadata":{},"sourceType":"script"}