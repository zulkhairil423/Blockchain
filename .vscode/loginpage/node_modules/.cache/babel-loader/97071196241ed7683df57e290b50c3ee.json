{"ast":null,"code":"import { __values } from \"tslib\";\nimport { htmlTreeAsString } from './browser';\nimport { isElement, isError, isEvent, isInstanceOf, isPlainObject, isPrimitive, isSyntheticEvent } from './is';\nimport { Memo } from './memo';\nimport { getFunctionName } from './stacktrace';\nimport { truncate } from './string';\n/**\n * Wrap a given object method with a higher-order function\n *\n * @param source An object that contains a method to be wrapped.\n * @param name A name of method to be wrapped.\n * @param replacementFactory A function that should be used to wrap a given method, returning the wrapped method which\n * will be substituted in for `source[name]`.\n * @returns void\n */\n\nexport function fill(source, name, replacementFactory) {\n  if (!(name in source)) {\n    return;\n  }\n\n  var original = source[name];\n  var wrapped = replacementFactory(original); // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work\n  // otherwise it'll throw \"TypeError: Object.defineProperties called on non-object\"\n\n  if (typeof wrapped === 'function') {\n    try {\n      wrapped.prototype = wrapped.prototype || {};\n      Object.defineProperties(wrapped, {\n        __sentry_original__: {\n          enumerable: false,\n          value: original\n        }\n      });\n    } catch (_Oo) {// This can throw if multiple fill happens on a global object like XMLHttpRequest\n      // Fixes https://github.com/getsentry/sentry-javascript/issues/2043\n    }\n  }\n\n  source[name] = wrapped;\n}\n/**\n * Encodes given object into url-friendly format\n *\n * @param object An object that contains serializable values\n * @returns string Encoded\n */\n\nexport function urlEncode(object) {\n  return Object.keys(object).map(function (key) {\n    return encodeURIComponent(key) + \"=\" + encodeURIComponent(object[key]);\n  }).join('&');\n}\n/**\n * Transforms any object into an object literal with all its attributes\n * attached to it.\n *\n * @param value Initial source that we have to transform in order for it to be usable by the serializer\n */\n\nfunction getWalkSource(value) {\n  if (isError(value)) {\n    var error = value;\n    var err = {\n      message: error.message,\n      name: error.name,\n      stack: error.stack\n    };\n\n    for (var i in error) {\n      if (Object.prototype.hasOwnProperty.call(error, i)) {\n        err[i] = error[i];\n      }\n    }\n\n    return err;\n  }\n\n  if (isEvent(value)) {\n    var event_1 = value;\n    var source = {};\n    source.type = event_1.type; // Accessing event.target can throw (see getsentry/raven-js#838, #768)\n\n    try {\n      source.target = isElement(event_1.target) ? htmlTreeAsString(event_1.target) : Object.prototype.toString.call(event_1.target);\n    } catch (_oO) {\n      source.target = '<unknown>';\n    }\n\n    try {\n      source.currentTarget = isElement(event_1.currentTarget) ? htmlTreeAsString(event_1.currentTarget) : Object.prototype.toString.call(event_1.currentTarget);\n    } catch (_oO) {\n      source.currentTarget = '<unknown>';\n    }\n\n    if (typeof CustomEvent !== 'undefined' && isInstanceOf(value, CustomEvent)) {\n      source.detail = event_1.detail;\n    }\n\n    for (var i in event_1) {\n      if (Object.prototype.hasOwnProperty.call(event_1, i)) {\n        source[i] = event_1;\n      }\n    }\n\n    return source;\n  }\n\n  return value;\n}\n/** Calculates bytes size of input string */\n\n\nfunction utf8Length(value) {\n  // eslint-disable-next-line no-bitwise\n  return ~-encodeURI(value).split(/%..|./).length;\n}\n/** Calculates bytes size of input object */\n\n\nfunction jsonSize(value) {\n  return utf8Length(JSON.stringify(value));\n}\n/** JSDoc */\n\n\nexport function normalizeToSize(object, // Default Node.js REPL depth\ndepth, // 100kB, as 200kB is max payload size, so half sounds reasonable\nmaxSize) {\n  if (depth === void 0) {\n    depth = 3;\n  }\n\n  if (maxSize === void 0) {\n    maxSize = 100 * 1024;\n  }\n\n  var serialized = normalize(object, depth);\n\n  if (jsonSize(serialized) > maxSize) {\n    return normalizeToSize(object, depth - 1, maxSize);\n  }\n\n  return serialized;\n}\n/**\n * Transform any non-primitive, BigInt, or Symbol-type value into a string. Acts as a no-op on strings, numbers,\n * booleans, null, and undefined.\n *\n * @param value The value to stringify\n * @returns For non-primitive, BigInt, and Symbol-type values, a string denoting the value's type, type and value, or\n *  type and `description` property, respectively. For non-BigInt, non-Symbol primitives, returns the original value,\n *  unchanged.\n */\n\nfunction serializeValue(value) {\n  var type = Object.prototype.toString.call(value); // Node.js REPL notation\n\n  if (typeof value === 'string') {\n    return value;\n  }\n\n  if (type === '[object Object]') {\n    return '[Object]';\n  }\n\n  if (type === '[object Array]') {\n    return '[Array]';\n  }\n\n  var normalized = normalizeValue(value);\n  return isPrimitive(normalized) ? normalized : type;\n}\n/**\n * normalizeValue()\n *\n * Takes unserializable input and make it serializable friendly\n *\n * - translates undefined/NaN values to \"[undefined]\"/\"[NaN]\" respectively,\n * - serializes Error objects\n * - filter global objects\n */\n\n\nfunction normalizeValue(value, key) {\n  if (key === 'domain' && value && typeof value === 'object' && value._events) {\n    return '[Domain]';\n  }\n\n  if (key === 'domainEmitter') {\n    return '[DomainEmitter]';\n  }\n\n  if (typeof global !== 'undefined' && value === global) {\n    return '[Global]';\n  }\n\n  if (typeof window !== 'undefined' && value === window) {\n    return '[Window]';\n  }\n\n  if (typeof document !== 'undefined' && value === document) {\n    return '[Document]';\n  } // React's SyntheticEvent thingy\n\n\n  if (isSyntheticEvent(value)) {\n    return '[SyntheticEvent]';\n  }\n\n  if (typeof value === 'number' && value !== value) {\n    return '[NaN]';\n  }\n\n  if (value === void 0) {\n    return '[undefined]';\n  }\n\n  if (typeof value === 'function') {\n    return \"[Function: \" + getFunctionName(value) + \"]\";\n  } // symbols and bigints are considered primitives by TS, but aren't natively JSON-serilaizable\n\n\n  if (typeof value === 'symbol') {\n    return \"[\" + String(value) + \"]\";\n  }\n\n  if (typeof value === 'bigint') {\n    return \"[BigInt: \" + String(value) + \"]\";\n  }\n\n  return value;\n}\n/**\n * Walks an object to perform a normalization on it\n *\n * @param key of object that's walked in current iteration\n * @param value object to be walked\n * @param depth Optional number indicating how deep should walking be performed\n * @param memo Optional Memo class handling decycling\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n\n\nexport function walk(key, value, depth, memo) {\n  if (depth === void 0) {\n    depth = +Infinity;\n  }\n\n  if (memo === void 0) {\n    memo = new Memo();\n  } // If we reach the maximum depth, serialize whatever has left\n\n\n  if (depth === 0) {\n    return serializeValue(value);\n  }\n  /* eslint-disable @typescript-eslint/no-unsafe-member-access */\n  // If value implements `toJSON` method, call it and return early\n\n\n  if (value !== null && value !== undefined && typeof value.toJSON === 'function') {\n    return value.toJSON();\n  }\n  /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n  // If normalized value is a primitive, there are no branches left to walk, so we can just bail out, as theres no point in going down that branch any further\n\n\n  var normalized = normalizeValue(value, key);\n\n  if (isPrimitive(normalized)) {\n    return normalized;\n  } // Create source that we will use for next itterations, either objectified error object (Error type with extracted keys:value pairs) or the input itself\n\n\n  var source = getWalkSource(value); // Create an accumulator that will act as a parent for all future itterations of that branch\n\n  var acc = Array.isArray(value) ? [] : {}; // If we already walked that branch, bail out, as it's circular reference\n\n  if (memo.memoize(value)) {\n    return '[Circular ~]';\n  } // Walk all keys of the source\n\n\n  for (var innerKey in source) {\n    // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.\n    if (!Object.prototype.hasOwnProperty.call(source, innerKey)) {\n      continue;\n    } // Recursively walk through all the child nodes\n\n\n    acc[innerKey] = walk(innerKey, source[innerKey], depth - 1, memo);\n  } // Once walked through all the branches, remove the parent from memo storage\n\n\n  memo.unmemoize(value); // Return accumulated values\n\n  return acc;\n}\n/**\n * normalize()\n *\n * - Creates a copy to prevent original input mutation\n * - Skip non-enumerablers\n * - Calls `toJSON` if implemented\n * - Removes circular references\n * - Translates non-serializeable values (undefined/NaN/Functions) to serializable format\n * - Translates known global objects/Classes to a string representations\n * - Takes care of Error objects serialization\n * - Optionally limit depth of final output\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n\nexport function normalize(input, depth) {\n  try {\n    return JSON.parse(JSON.stringify(input, function (key, value) {\n      return walk(key, value, depth);\n    }));\n  } catch (_oO) {\n    return '**non-serializable**';\n  }\n}\n/**\n * Given any captured exception, extract its keys and create a sorted\n * and truncated list that will be used inside the event message.\n * eg. `Non-error exception captured with keys: foo, bar, baz`\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n\nexport function extractExceptionKeysForMessage(exception, maxLength) {\n  if (maxLength === void 0) {\n    maxLength = 40;\n  }\n\n  var keys = Object.keys(getWalkSource(exception));\n  keys.sort();\n\n  if (!keys.length) {\n    return '[object has no keys]';\n  }\n\n  if (keys[0].length >= maxLength) {\n    return truncate(keys[0], maxLength);\n  }\n\n  for (var includedKeys = keys.length; includedKeys > 0; includedKeys--) {\n    var serialized = keys.slice(0, includedKeys).join(', ');\n\n    if (serialized.length > maxLength) {\n      continue;\n    }\n\n    if (includedKeys === keys.length) {\n      return serialized;\n    }\n\n    return truncate(serialized, maxLength);\n  }\n\n  return '';\n}\n/**\n * Given any object, return the new object with removed keys that value was `undefined`.\n * Works recursively on objects and arrays.\n */\n\nexport function dropUndefinedKeys(val) {\n  var e_1, _a;\n\n  if (isPlainObject(val)) {\n    var obj = val;\n    var rv = {};\n\n    try {\n      for (var _b = __values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var key = _c.value;\n\n        if (typeof obj[key] !== 'undefined') {\n          rv[key] = dropUndefinedKeys(obj[key]);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return rv;\n  }\n\n  if (Array.isArray(val)) {\n    return val.map(dropUndefinedKeys);\n  }\n\n  return val;\n}","map":{"version":3,"mappings":"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","names":["htmlTreeAsString","isElement","isError","isEvent","isInstanceOf","isPlainObject","isPrimitive","isSyntheticEvent","Memo","getFunctionName","truncate","fill","source","name","replacementFactory","original","wrapped","prototype","Object","defineProperties","__sentry_original__","enumerable","value","_Oo","urlEncode","object","keys","map","encodeURIComponent","key","join","getWalkSource","error","err","message","stack","i","hasOwnProperty","call","event_1","type","target","toString","_oO","currentTarget","CustomEvent","detail","utf8Length","encodeURI","split","length","jsonSize","JSON","stringify","normalizeToSize","depth","maxSize","serialized","normalize","serializeValue","normalized","normalizeValue","_events","global","window","document","String","walk","memo","Infinity","undefined","toJSON","acc","Array","isArray","memoize","innerKey","unmemoize","input","parse","extractExceptionKeysForMessage","exception","maxLength","sort","includedKeys","slice","dropUndefinedKeys","val","obj","rv","_c"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\@sentry\\utils\\src\\object.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { ExtendedError, WrappedFunction } from '@sentry/types';\n\nimport { htmlTreeAsString } from './browser';\nimport { isElement, isError, isEvent, isInstanceOf, isPlainObject, isPrimitive, isSyntheticEvent } from './is';\nimport { Memo } from './memo';\nimport { getFunctionName } from './stacktrace';\nimport { truncate } from './string';\n\n/**\n * Wrap a given object method with a higher-order function\n *\n * @param source An object that contains a method to be wrapped.\n * @param name A name of method to be wrapped.\n * @param replacementFactory A function that should be used to wrap a given method, returning the wrapped method which\n * will be substituted in for `source[name]`.\n * @returns void\n */\nexport function fill(source: { [key: string]: any }, name: string, replacementFactory: (...args: any[]) => any): void {\n  if (!(name in source)) {\n    return;\n  }\n\n  const original = source[name] as () => any;\n  const wrapped = replacementFactory(original) as WrappedFunction;\n\n  // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work\n  // otherwise it'll throw \"TypeError: Object.defineProperties called on non-object\"\n  if (typeof wrapped === 'function') {\n    try {\n      wrapped.prototype = wrapped.prototype || {};\n      Object.defineProperties(wrapped, {\n        __sentry_original__: {\n          enumerable: false,\n          value: original,\n        },\n      });\n    } catch (_Oo) {\n      // This can throw if multiple fill happens on a global object like XMLHttpRequest\n      // Fixes https://github.com/getsentry/sentry-javascript/issues/2043\n    }\n  }\n\n  source[name] = wrapped;\n}\n\n/**\n * Encodes given object into url-friendly format\n *\n * @param object An object that contains serializable values\n * @returns string Encoded\n */\nexport function urlEncode(object: { [key: string]: any }): string {\n  return Object.keys(object)\n    .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(object[key])}`)\n    .join('&');\n}\n\n/**\n * Transforms any object into an object literal with all its attributes\n * attached to it.\n *\n * @param value Initial source that we have to transform in order for it to be usable by the serializer\n */\nfunction getWalkSource(\n  value: any,\n): {\n  [key: string]: any;\n} {\n  if (isError(value)) {\n    const error = value as ExtendedError;\n    const err: {\n      [key: string]: any;\n      stack: string | undefined;\n      message: string;\n      name: string;\n    } = {\n      message: error.message,\n      name: error.name,\n      stack: error.stack,\n    };\n\n    for (const i in error) {\n      if (Object.prototype.hasOwnProperty.call(error, i)) {\n        err[i] = error[i];\n      }\n    }\n\n    return err;\n  }\n\n  if (isEvent(value)) {\n    /**\n     * Event-like interface that's usable in browser and node\n     */\n    interface SimpleEvent {\n      [key: string]: unknown;\n      type: string;\n      target?: unknown;\n      currentTarget?: unknown;\n    }\n\n    const event = value as SimpleEvent;\n\n    const source: {\n      [key: string]: any;\n    } = {};\n\n    source.type = event.type;\n\n    // Accessing event.target can throw (see getsentry/raven-js#838, #768)\n    try {\n      source.target = isElement(event.target)\n        ? htmlTreeAsString(event.target)\n        : Object.prototype.toString.call(event.target);\n    } catch (_oO) {\n      source.target = '<unknown>';\n    }\n\n    try {\n      source.currentTarget = isElement(event.currentTarget)\n        ? htmlTreeAsString(event.currentTarget)\n        : Object.prototype.toString.call(event.currentTarget);\n    } catch (_oO) {\n      source.currentTarget = '<unknown>';\n    }\n\n    if (typeof CustomEvent !== 'undefined' && isInstanceOf(value, CustomEvent)) {\n      source.detail = event.detail;\n    }\n\n    for (const i in event) {\n      if (Object.prototype.hasOwnProperty.call(event, i)) {\n        source[i] = event;\n      }\n    }\n\n    return source;\n  }\n\n  return value as {\n    [key: string]: any;\n  };\n}\n\n/** Calculates bytes size of input string */\nfunction utf8Length(value: string): number {\n  // eslint-disable-next-line no-bitwise\n  return ~-encodeURI(value).split(/%..|./).length;\n}\n\n/** Calculates bytes size of input object */\nfunction jsonSize(value: any): number {\n  return utf8Length(JSON.stringify(value));\n}\n\n/** JSDoc */\nexport function normalizeToSize<T>(\n  object: { [key: string]: any },\n  // Default Node.js REPL depth\n  depth: number = 3,\n  // 100kB, as 200kB is max payload size, so half sounds reasonable\n  maxSize: number = 100 * 1024,\n): T {\n  const serialized = normalize(object, depth);\n\n  if (jsonSize(serialized) > maxSize) {\n    return normalizeToSize(object, depth - 1, maxSize);\n  }\n\n  return serialized as T;\n}\n\n/**\n * Transform any non-primitive, BigInt, or Symbol-type value into a string. Acts as a no-op on strings, numbers,\n * booleans, null, and undefined.\n *\n * @param value The value to stringify\n * @returns For non-primitive, BigInt, and Symbol-type values, a string denoting the value's type, type and value, or\n *  type and `description` property, respectively. For non-BigInt, non-Symbol primitives, returns the original value,\n *  unchanged.\n */\nfunction serializeValue(value: any): any {\n  const type = Object.prototype.toString.call(value);\n\n  // Node.js REPL notation\n  if (typeof value === 'string') {\n    return value;\n  }\n  if (type === '[object Object]') {\n    return '[Object]';\n  }\n  if (type === '[object Array]') {\n    return '[Array]';\n  }\n\n  const normalized = normalizeValue(value);\n  return isPrimitive(normalized) ? normalized : type;\n}\n\n/**\n * normalizeValue()\n *\n * Takes unserializable input and make it serializable friendly\n *\n * - translates undefined/NaN values to \"[undefined]\"/\"[NaN]\" respectively,\n * - serializes Error objects\n * - filter global objects\n */\nfunction normalizeValue<T>(value: T, key?: any): T | string {\n  if (key === 'domain' && value && typeof value === 'object' && ((value as unknown) as { _events: any })._events) {\n    return '[Domain]';\n  }\n\n  if (key === 'domainEmitter') {\n    return '[DomainEmitter]';\n  }\n\n  if (typeof (global as any) !== 'undefined' && (value as unknown) === global) {\n    return '[Global]';\n  }\n\n  if (typeof (window as any) !== 'undefined' && (value as unknown) === window) {\n    return '[Window]';\n  }\n\n  if (typeof (document as any) !== 'undefined' && (value as unknown) === document) {\n    return '[Document]';\n  }\n\n  // React's SyntheticEvent thingy\n  if (isSyntheticEvent(value)) {\n    return '[SyntheticEvent]';\n  }\n\n  if (typeof value === 'number' && value !== value) {\n    return '[NaN]';\n  }\n\n  if (value === void 0) {\n    return '[undefined]';\n  }\n\n  if (typeof value === 'function') {\n    return `[Function: ${getFunctionName(value)}]`;\n  }\n\n  // symbols and bigints are considered primitives by TS, but aren't natively JSON-serilaizable\n\n  if (typeof value === 'symbol') {\n    return `[${String(value)}]`;\n  }\n\n  if (typeof value === 'bigint') {\n    return `[BigInt: ${String(value)}]`;\n  }\n\n  return value;\n}\n\n/**\n * Walks an object to perform a normalization on it\n *\n * @param key of object that's walked in current iteration\n * @param value object to be walked\n * @param depth Optional number indicating how deep should walking be performed\n * @param memo Optional Memo class handling decycling\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function walk(key: string, value: any, depth: number = +Infinity, memo: Memo = new Memo()): any {\n  // If we reach the maximum depth, serialize whatever has left\n  if (depth === 0) {\n    return serializeValue(value);\n  }\n\n  /* eslint-disable @typescript-eslint/no-unsafe-member-access */\n  // If value implements `toJSON` method, call it and return early\n  if (value !== null && value !== undefined && typeof value.toJSON === 'function') {\n    return value.toJSON();\n  }\n  /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n\n  // If normalized value is a primitive, there are no branches left to walk, so we can just bail out, as theres no point in going down that branch any further\n  const normalized = normalizeValue(value, key);\n  if (isPrimitive(normalized)) {\n    return normalized;\n  }\n\n  // Create source that we will use for next itterations, either objectified error object (Error type with extracted keys:value pairs) or the input itself\n  const source = getWalkSource(value);\n\n  // Create an accumulator that will act as a parent for all future itterations of that branch\n  const acc = Array.isArray(value) ? [] : {};\n\n  // If we already walked that branch, bail out, as it's circular reference\n  if (memo.memoize(value)) {\n    return '[Circular ~]';\n  }\n\n  // Walk all keys of the source\n  for (const innerKey in source) {\n    // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.\n    if (!Object.prototype.hasOwnProperty.call(source, innerKey)) {\n      continue;\n    }\n    // Recursively walk through all the child nodes\n    (acc as { [key: string]: any })[innerKey] = walk(innerKey, source[innerKey], depth - 1, memo);\n  }\n\n  // Once walked through all the branches, remove the parent from memo storage\n  memo.unmemoize(value);\n\n  // Return accumulated values\n  return acc;\n}\n\n/**\n * normalize()\n *\n * - Creates a copy to prevent original input mutation\n * - Skip non-enumerablers\n * - Calls `toJSON` if implemented\n * - Removes circular references\n * - Translates non-serializeable values (undefined/NaN/Functions) to serializable format\n * - Translates known global objects/Classes to a string representations\n * - Takes care of Error objects serialization\n * - Optionally limit depth of final output\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function normalize(input: any, depth?: number): any {\n  try {\n    return JSON.parse(JSON.stringify(input, (key: string, value: any) => walk(key, value, depth)));\n  } catch (_oO) {\n    return '**non-serializable**';\n  }\n}\n\n/**\n * Given any captured exception, extract its keys and create a sorted\n * and truncated list that will be used inside the event message.\n * eg. `Non-error exception captured with keys: foo, bar, baz`\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function extractExceptionKeysForMessage(exception: any, maxLength: number = 40): string {\n  const keys = Object.keys(getWalkSource(exception));\n  keys.sort();\n\n  if (!keys.length) {\n    return '[object has no keys]';\n  }\n\n  if (keys[0].length >= maxLength) {\n    return truncate(keys[0], maxLength);\n  }\n\n  for (let includedKeys = keys.length; includedKeys > 0; includedKeys--) {\n    const serialized = keys.slice(0, includedKeys).join(', ');\n    if (serialized.length > maxLength) {\n      continue;\n    }\n    if (includedKeys === keys.length) {\n      return serialized;\n    }\n    return truncate(serialized, maxLength);\n  }\n\n  return '';\n}\n\n/**\n * Given any object, return the new object with removed keys that value was `undefined`.\n * Works recursively on objects and arrays.\n */\nexport function dropUndefinedKeys<T>(val: T): T {\n  if (isPlainObject(val)) {\n    const obj = val as { [key: string]: any };\n    const rv: { [key: string]: any } = {};\n    for (const key of Object.keys(obj)) {\n      if (typeof obj[key] !== 'undefined') {\n        rv[key] = dropUndefinedKeys(obj[key]);\n      }\n    }\n    return rv as T;\n  }\n\n  if (Array.isArray(val)) {\n    return (val as any[]).map(dropUndefinedKeys) as any;\n  }\n\n  return val;\n}\n"]},"metadata":{},"sourceType":"module"}