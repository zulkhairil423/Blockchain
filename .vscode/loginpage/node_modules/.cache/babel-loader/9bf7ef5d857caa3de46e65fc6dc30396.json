{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { API, eventToSentryRequest } from '@sentry/core';\nimport { Status } from '@sentry/types';\nimport { logger, parseRetryAfterHeader, PromiseBuffer, SentryError } from '@sentry/utils';\nimport * as fs from 'fs';\nimport * as url from 'url';\nimport { SDK_NAME, SDK_VERSION } from '../version';\n/** Base Transport class implementation */\n\nvar BaseTransport =\n/** @class */\nfunction () {\n  /** Create instance and set this.dsn */\n  function BaseTransport(options) {\n    this.options = options;\n    /** A simple buffer holding all requests. */\n\n    this._buffer = new PromiseBuffer(30);\n    /** Locks transport after receiving 429 response */\n\n    this._disabledUntil = new Date(Date.now());\n    this._api = new API(options.dsn);\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseTransport.prototype.sendEvent = function (_) {\n    throw new SentryError('Transport Class has to implement `sendEvent` method.');\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseTransport.prototype.close = function (timeout) {\n    return this._buffer.drain(timeout);\n  };\n  /** Returns a build request option object used by request */\n\n\n  BaseTransport.prototype._getRequestOptions = function (uri) {\n    var headers = __assign(__assign({}, this._api.getRequestHeaders(SDK_NAME, SDK_VERSION)), this.options.headers);\n\n    var hostname = uri.hostname,\n        pathname = uri.pathname,\n        port = uri.port,\n        protocol = uri.protocol; // See https://github.com/nodejs/node/blob/38146e717fed2fabe3aacb6540d839475e0ce1c6/lib/internal/url.js#L1268-L1290\n    // We ignore the query string on purpose\n\n    var path = \"\" + pathname;\n    return __assign({\n      agent: this.client,\n      headers: headers,\n      hostname: hostname,\n      method: 'POST',\n      path: path,\n      port: port,\n      protocol: protocol\n    }, this.options.caCerts && {\n      ca: fs.readFileSync(this.options.caCerts)\n    });\n  };\n  /** JSDoc */\n\n\n  BaseTransport.prototype._sendWithModule = function (httpModule, event) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        if (new Date(Date.now()) < this._disabledUntil) {\n          return [2\n          /*return*/\n          , Promise.reject(new SentryError(\"Transport locked till \" + this._disabledUntil + \" due to too many requests.\"))];\n        }\n\n        if (!this._buffer.isReady()) {\n          return [2\n          /*return*/\n          , Promise.reject(new SentryError('Not adding Promise due to buffer limit reached.'))];\n        }\n\n        return [2\n        /*return*/\n        , this._buffer.add(new Promise(function (resolve, reject) {\n          var sentryReq = eventToSentryRequest(event, _this._api);\n\n          var options = _this._getRequestOptions(new url.URL(sentryReq.url));\n\n          var req = httpModule.request(options, function (res) {\n            var statusCode = res.statusCode || 500;\n            var status = Status.fromHttpCode(statusCode);\n            res.setEncoding('utf8');\n\n            if (status === Status.Success) {\n              resolve({\n                status: status\n              });\n            } else {\n              if (status === Status.RateLimit) {\n                var now = Date.now();\n                /**\n                 * \"Key-value pairs of header names and values. Header names are lower-cased.\"\n                 * https://nodejs.org/api/http.html#http_message_headers\n                 */\n\n                var retryAfterHeader = res.headers ? res.headers['retry-after'] : '';\n                retryAfterHeader = Array.isArray(retryAfterHeader) ? retryAfterHeader[0] : retryAfterHeader;\n                _this._disabledUntil = new Date(now + parseRetryAfterHeader(now, retryAfterHeader));\n                logger.warn(\"Too many requests, backing off till: \" + _this._disabledUntil);\n              }\n\n              var rejectionMessage = \"HTTP Error (\" + statusCode + \")\";\n\n              if (res.headers && res.headers['x-sentry-error']) {\n                rejectionMessage += \": \" + res.headers['x-sentry-error'];\n              }\n\n              reject(new SentryError(rejectionMessage));\n            } // Force the socket to drain\n\n\n            res.on('data', function () {// Drain\n            });\n            res.on('end', function () {// Drain\n            });\n          });\n          req.on('error', reject);\n          req.end(sentryReq.body);\n        }))];\n      });\n    });\n  };\n\n  return BaseTransport;\n}();\n\nexport { BaseTransport };","map":{"version":3,"mappings":"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","names":["API","eventToSentryRequest","Status","logger","parseRetryAfterHeader","PromiseBuffer","SentryError","fs","url","SDK_NAME","SDK_VERSION","options","Date","now","_api","dsn","BaseTransport","_","timeout","_buffer","drain","uri","headers","getRequestHeaders","pathname","port","protocol","path","agent","client","hostname","method","caCerts","ca","readFileSync","httpModule","event","_disabledUntil","Promise","reject","isReady","add","resolve","sentryReq","_this","_getRequestOptions","URL","req","request","res","statusCode","status","fromHttpCode","setEncoding","Success","RateLimit","retryAfterHeader","Array","isArray","warn","rejectionMessage","on","end","body"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\@sentry\\node\\src\\transports\\base.ts"],"sourcesContent":["import { API, eventToSentryRequest } from '@sentry/core';\nimport { Event, Response, Status, Transport, TransportOptions } from '@sentry/types';\nimport { logger, parseRetryAfterHeader, PromiseBuffer, SentryError } from '@sentry/utils';\nimport * as fs from 'fs';\nimport * as http from 'http';\nimport * as https from 'https';\nimport * as url from 'url';\n\nimport { SDK_NAME, SDK_VERSION } from '../version';\n\n/**\n * Internal used interface for typescript.\n * @hidden\n */\nexport interface HTTPModule {\n  /**\n   * Request wrapper\n   * @param options These are {@see TransportOptions}\n   * @param callback Callback when request is finished\n   */\n  request(\n    options: http.RequestOptions | https.RequestOptions | string | url.URL,\n    callback?: (res: http.IncomingMessage) => void,\n  ): http.ClientRequest;\n\n  // This is the type for nodejs versions that handle the URL argument\n  // (v10.9.0+), but we do not use it just yet because we support older node\n  // versions:\n\n  // request(\n  //   url: string | url.URL,\n  //   options: http.RequestOptions | https.RequestOptions,\n  //   callback?: (res: http.IncomingMessage) => void,\n  // ): http.ClientRequest;\n}\n\n/** Base Transport class implementation */\nexport abstract class BaseTransport implements Transport {\n  /** The Agent used for corresponding transport */\n  public module?: HTTPModule;\n\n  /** The Agent used for corresponding transport */\n  public client?: http.Agent | https.Agent;\n\n  /** API object */\n  protected _api: API;\n\n  /** A simple buffer holding all requests. */\n  protected readonly _buffer: PromiseBuffer<Response> = new PromiseBuffer(30);\n\n  /** Locks transport after receiving 429 response */\n  private _disabledUntil: Date = new Date(Date.now());\n\n  /** Create instance and set this.dsn */\n  public constructor(public options: TransportOptions) {\n    this._api = new API(options.dsn);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(_: Event): PromiseLike<Response> {\n    throw new SentryError('Transport Class has to implement `sendEvent` method.');\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(timeout?: number): PromiseLike<boolean> {\n    return this._buffer.drain(timeout);\n  }\n\n  /** Returns a build request option object used by request */\n  protected _getRequestOptions(uri: url.URL): http.RequestOptions | https.RequestOptions {\n    const headers = {\n      ...this._api.getRequestHeaders(SDK_NAME, SDK_VERSION),\n      ...this.options.headers,\n    };\n    const { hostname, pathname, port, protocol } = uri;\n    // See https://github.com/nodejs/node/blob/38146e717fed2fabe3aacb6540d839475e0ce1c6/lib/internal/url.js#L1268-L1290\n    // We ignore the query string on purpose\n    const path = `${pathname}`;\n\n    return {\n      agent: this.client,\n      headers,\n      hostname,\n      method: 'POST',\n      path,\n      port,\n      protocol,\n      ...(this.options.caCerts && {\n        ca: fs.readFileSync(this.options.caCerts),\n      }),\n    };\n  }\n\n  /** JSDoc */\n  protected async _sendWithModule(httpModule: HTTPModule, event: Event): Promise<Response> {\n    if (new Date(Date.now()) < this._disabledUntil) {\n      return Promise.reject(new SentryError(`Transport locked till ${this._disabledUntil} due to too many requests.`));\n    }\n\n    if (!this._buffer.isReady()) {\n      return Promise.reject(new SentryError('Not adding Promise due to buffer limit reached.'));\n    }\n    return this._buffer.add(\n      new Promise<Response>((resolve, reject) => {\n        const sentryReq = eventToSentryRequest(event, this._api);\n        const options = this._getRequestOptions(new url.URL(sentryReq.url));\n\n        const req = httpModule.request(options, (res: http.IncomingMessage) => {\n          const statusCode = res.statusCode || 500;\n          const status = Status.fromHttpCode(statusCode);\n\n          res.setEncoding('utf8');\n\n          if (status === Status.Success) {\n            resolve({ status });\n          } else {\n            if (status === Status.RateLimit) {\n              const now = Date.now();\n              /**\n               * \"Key-value pairs of header names and values. Header names are lower-cased.\"\n               * https://nodejs.org/api/http.html#http_message_headers\n               */\n              let retryAfterHeader = res.headers ? res.headers['retry-after'] : '';\n              retryAfterHeader = (Array.isArray(retryAfterHeader) ? retryAfterHeader[0] : retryAfterHeader) as string;\n              this._disabledUntil = new Date(now + parseRetryAfterHeader(now, retryAfterHeader));\n              logger.warn(`Too many requests, backing off till: ${this._disabledUntil}`);\n            }\n\n            let rejectionMessage = `HTTP Error (${statusCode})`;\n            if (res.headers && res.headers['x-sentry-error']) {\n              rejectionMessage += `: ${res.headers['x-sentry-error']}`;\n            }\n\n            reject(new SentryError(rejectionMessage));\n          }\n\n          // Force the socket to drain\n          res.on('data', () => {\n            // Drain\n          });\n          res.on('end', () => {\n            // Drain\n          });\n        });\n        req.on('error', reject);\n        req.end(sentryReq.body);\n      }),\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}