{"ast":null,"code":"/*istanbul ignore start*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = Diff;\n/*istanbul ignore end*/\n\nfunction Diff() {}\n\nDiff.prototype = {\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  diff: function diff(oldString, newString) {\n    /*istanbul ignore start*/\n    var\n    /*istanbul ignore end*/\n    options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var callback = options.callback;\n\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    this.options = options;\n    var self = this;\n\n    function done(value) {\n      if (callback) {\n        setTimeout(function () {\n          callback(undefined, value);\n        }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    } // Allow subclasses to massage the input prior to running\n\n\n    oldString = this.castInput(oldString);\n    newString = this.castInput(newString);\n    oldString = this.removeEmpty(this.tokenize(oldString));\n    newString = this.removeEmpty(this.tokenize(newString));\n    var newLen = newString.length,\n        oldLen = oldString.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n    var bestPath = [{\n      newPos: -1,\n      components: []\n    }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      // Identity per the equality and tokenizer\n      return done([{\n        value: this.join(newString),\n        count: newString.length\n      }]);\n    } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n\n    function execEditLength() {\n      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        var basePath =\n        /*istanbul ignore start*/\n        void 0\n        /*istanbul ignore end*/\n        ;\n\n        var addPath = bestPath[diagonalPath - 1],\n            removePath = bestPath[diagonalPath + 1],\n            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        var canAdd = addPath && addPath.newPos + 1 < newLen,\n            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        } // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n\n\n        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n\n        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done\n\n        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n\n      editLength++;\n    } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced.\n\n\n    if (callback) {\n      (function exec() {\n        setTimeout(function () {\n          // This should not happen, but we want to be safe.\n\n          /* istanbul ignore next */\n          if (editLength > maxEditLength) {\n            return callback();\n          }\n\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      })();\n    } else {\n      while (editLength <= maxEditLength) {\n        var ret = execEditLength();\n\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  pushComponent: function pushComponent(components, added, removed) {\n    var last = components[components.length - 1];\n\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {\n        count: last.count + 1,\n        added: added,\n        removed: removed\n      };\n    } else {\n      components.push({\n        count: 1,\n        added: added,\n        removed: removed\n      });\n    }\n  },\n\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n    var newLen = newString.length,\n        oldLen = oldString.length,\n        newPos = basePath.newPos,\n        oldPos = newPos - diagonalPath,\n        commonCount = 0;\n\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.components.push({\n        count: commonCount\n      });\n    }\n\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  equals: function equals(left, right) {\n    if (this.options.comparator) {\n      return this.options.comparator(left, right);\n    } else {\n      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n    }\n  },\n\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  removeEmpty: function removeEmpty(array) {\n    var ret = [];\n\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n\n    return ret;\n  },\n\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  castInput: function castInput(value) {\n    return value;\n  },\n\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  tokenize: function tokenize(value) {\n    return value.split('');\n  },\n\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  join: function join(chars) {\n    return chars.join('');\n  }\n};\n\nfunction buildValues(diff, components, newString, oldString, useLongestToken) {\n  var componentPos = 0,\n      componentLen = components.length,\n      newPos = 0,\n      oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        var value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function (value, i) {\n          var oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n\n      newPos += component.count; // Common case\n\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n\n      if (componentPos && components[componentPos - 1].added) {\n        var tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  } // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n\n\n  var lastComponent = components[componentLen - 1];\n\n  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n    components[componentLen - 2].value += lastComponent.value;\n    components.pop();\n  }\n\n  return components;\n}\n\nfunction clonePath(path) {\n  return {\n    newPos: path.newPos,\n    components: path.components.slice(0)\n  };\n}","map":{"version":3,"mappings":";;;;;;;;;AAAe,SAASA,IAAT,GAAgB,CAAE;;AAEjCA,IAAI,CAACC,SAALD,GAAiB;EAAA;;EAAA;EACfE,IADe,gBACVC,SADU,EACCC,SADD,EAC0B;IAAA;IAAA;IAAA;IAAdC,OAAc,uEAAJ,EAAI;IACvC,IAAIC,QAAQ,GAAGD,OAAO,CAACC,QAAvB;;IACA,IAAI,OAAOD,OAAP,KAAmB,UAAvB,EAAmC;MACjCC,QAAQ,GAAGD,OAAXC;MACAD,OAAO,GAAG,EAAVA;IACD;;IACD,KAAKA,OAAL,GAAeA,OAAf;IAEA,IAAIE,IAAI,GAAG,IAAX;;IAEA,SAASC,IAAT,CAAcC,KAAd,EAAqB;MACnB,IAAIH,QAAJ,EAAc;QACZI,UAAU,CAAC,YAAW;UAAEJ,QAAQ,CAACK,SAAD,EAAYF,KAAZ,CAARH;QAAd,GAA6C,CAA7C,CAAVI;QACA,OAAO,IAAP;MAFF,OAGO;QACL,OAAOD,KAAP;MACD;IAhBoC,EAmBvC;;;IACAN,SAAS,GAAG,KAAKS,SAAL,CAAeT,SAAf,CAAZA;IACAC,SAAS,GAAG,KAAKQ,SAAL,CAAeR,SAAf,CAAZA;IAEAD,SAAS,GAAG,KAAKU,WAAL,CAAiB,KAAKC,QAAL,CAAcX,SAAd,CAAjB,CAAZA;IACAC,SAAS,GAAG,KAAKS,WAAL,CAAiB,KAAKC,QAAL,CAAcV,SAAd,CAAjB,CAAZA;IAEA,IAAIW,MAAM,GAAGX,SAAS,CAACY,MAAvB;IAAA,IAA+BC,MAAM,GAAGd,SAAS,CAACa,MAAlD;IACA,IAAIE,UAAU,GAAG,CAAjB;IACA,IAAIC,aAAa,GAAGJ,MAAM,GAAGE,MAA7B;IACA,IAAIG,QAAQ,GAAG,CAAC;MAAEC,MAAM,EAAE,CAAC,CAAX;MAAcC,UAAU,EAAE;IAA1B,CAAD,CAAf,CA7BuC,CA+BvC;;IACA,IAAIC,MAAM,GAAG,KAAKC,aAAL,CAAmBJ,QAAQ,CAAC,CAAD,CAA3B,EAAgChB,SAAhC,EAA2CD,SAA3C,EAAsD,CAAtD,CAAb;;IACA,IAAIiB,QAAQ,CAAC,CAAD,CAARA,CAAYC,MAAZD,GAAqB,CAArBA,IAA0BL,MAA1BK,IAAoCG,MAAM,GAAG,CAATA,IAAcN,MAAtD,EAA8D;MAC5D;MACA,OAAOT,IAAI,CAAC,CAAC;QAACC,KAAK,EAAE,KAAKgB,IAAL,CAAUrB,SAAV,CAAR;QAA8BsB,KAAK,EAAEtB,SAAS,CAACY;MAA/C,CAAD,CAAD,CAAX;IAnCqC,EAsCvC;;;IACA,SAASW,cAAT,GAA0B;MACxB,KAAK,IAAIC,YAAY,GAAG,CAAC,CAAD,GAAKV,UAA7B,EAAyCU,YAAY,IAAIV,UAAzD,EAAqEU,YAAY,IAAI,CAArF,EAAwF;QACtF,IAAIC,QAAQ;QAAA;QAAA;QAAZ;QAAA;;QACA,IAAIC,OAAO,GAAGV,QAAQ,CAACQ,YAAY,GAAG,CAAhB,CAAtB;QAAA,IACIG,UAAU,GAAGX,QAAQ,CAACQ,YAAY,GAAG,CAAhB,CADzB;QAAA,IAEIL,OAAM,GAAG,CAACQ,UAAU,GAAGA,UAAU,CAACV,MAAd,GAAuB,CAAlC,IAAuCO,YAFpD;;QAGA,IAAIE,OAAJ,EAAa;UACX;UACAV,QAAQ,CAACQ,YAAY,GAAG,CAAhB,CAARR,GAA6BT,SAA7BS;QACD;;QAED,IAAIY,MAAM,GAAGF,OAAO,IAAIA,OAAO,CAACT,MAARS,GAAiB,CAAjBA,GAAqBf,MAA7C;QAAA,IACIkB,SAAS,GAAGF,UAAU,IAAI,KAAKR,OAAnBQ,IAA6BR,OAAM,GAAGN,MADtD;;QAEA,IAAI,CAACe,MAAD,IAAW,CAACC,SAAhB,EAA2B;UACzB;UACAb,QAAQ,CAACQ,YAAD,CAARR,GAAyBT,SAAzBS;UACA;QAfoF,EAkBtF;QACA;QACA;;;QACA,IAAI,CAACY,MAAD,IAAYC,SAAS,IAAIH,OAAO,CAACT,MAARS,GAAiBC,UAAU,CAACV,MAAzD,EAAkE;UAChEQ,QAAQ,GAAGK,SAAS,CAACH,UAAD,CAApBF;UACAtB,IAAI,CAAC4B,aAAL5B,CAAmBsB,QAAQ,CAACP,UAA5Bf,EAAwCI,SAAxCJ,EAAmD,IAAnDA;QAFF,OAGO;UACLsB,QAAQ,GAAGC,OAAXD,CADK,CACe;;UACpBA,QAAQ,CAACR,MAATQ;UACAtB,IAAI,CAAC4B,aAAL5B,CAAmBsB,QAAQ,CAACP,UAA5Bf,EAAwC,IAAxCA,EAA8CI,SAA9CJ;QACD;;QAEDgB,OAAM,GAAGhB,IAAI,CAACiB,aAALjB,CAAmBsB,QAAnBtB,EAA6BH,SAA7BG,EAAwCJ,SAAxCI,EAAmDqB,YAAnDrB,CAATgB,CA9BsF,CAgCtF;;QACA,IAAIM,QAAQ,CAACR,MAATQ,GAAkB,CAAlBA,IAAuBd,MAAvBc,IAAiCN,OAAM,GAAG,CAATA,IAAcN,MAAnD,EAA2D;UACzD,OAAOT,IAAI,CAAC4B,WAAW,CAAC7B,IAAD,EAAOsB,QAAQ,CAACP,UAAhB,EAA4BlB,SAA5B,EAAuCD,SAAvC,EAAkDI,IAAI,CAAC8B,eAAvD,CAAZ,CAAX;QADF,OAEO;UACL;UACAjB,QAAQ,CAACQ,YAAD,CAARR,GAAyBS,QAAzBT;QACD;MACF;;MAEDF,UAAU;IAjF2B,EAoFvC;IACA;IACA;;;IACA,IAAIZ,QAAJ,EAAc;MACX,UAASgC,IAAT,GAAgB;QACf5B,UAAU,CAAC,YAAW;UACpB;;UACA;UACA,IAAIQ,UAAU,GAAGC,aAAjB,EAAgC;YAC9B,OAAOb,QAAQ,EAAf;UACD;;UAED,IAAI,CAACqB,cAAc,EAAnB,EAAuB;YACrBW,IAAI;UACL;QATO,GAUP,CAVO,CAAV5B;MADD;IADH,OAcO;MACL,OAAOQ,UAAU,IAAIC,aAArB,EAAoC;QAClC,IAAIoB,GAAG,GAAGZ,cAAc,EAAxB;;QACA,IAAIY,GAAJ,EAAS;UACP,OAAOA,GAAP;QACD;MACF;IACF;EA7GY;;EAAA;;EAAA;EAgHfJ,aAhHe,yBAgHDb,UAhHC,EAgHWkB,KAhHX,EAgHkBC,OAhHlB,EAgH2B;IACxC,IAAIC,IAAI,GAAGpB,UAAU,CAACA,UAAU,CAACN,MAAXM,GAAoB,CAArB,CAArB;;IACA,IAAIoB,IAAI,IAAIA,IAAI,CAACF,KAALE,KAAeF,KAAvBE,IAAgCA,IAAI,CAACD,OAALC,KAAiBD,OAArD,EAA8D;MAC5D;MACA;MACAnB,UAAU,CAACA,UAAU,CAACN,MAAXM,GAAoB,CAArB,CAAVA,GAAoC;QAACI,KAAK,EAAEgB,IAAI,CAAChB,KAALgB,GAAa,CAArB;QAAwBF,KAAK,EAAEA,KAA/B;QAAsCC,OAAO,EAAEA;MAA/C,CAApCnB;IAHF,OAIO;MACLA,UAAU,CAACqB,IAAXrB,CAAgB;QAACI,KAAK,EAAE,CAAR;QAAWc,KAAK,EAAEA,KAAlB;QAAyBC,OAAO,EAAEA;MAAlC,CAAhBnB;IACD;EAxHY;;EAAA;;EAAA;EA0HfE,aA1He,yBA0HDK,QA1HC,EA0HSzB,SA1HT,EA0HoBD,SA1HpB,EA0H+ByB,YA1H/B,EA0H6C;IAC1D,IAAIb,MAAM,GAAGX,SAAS,CAACY,MAAvB;IAAA,IACIC,MAAM,GAAGd,SAAS,CAACa,MADvB;IAAA,IAEIK,MAAM,GAAGQ,QAAQ,CAACR,MAFtB;IAAA,IAGIE,MAAM,GAAGF,MAAM,GAAGO,YAHtB;IAAA,IAKIgB,WAAW,GAAG,CALlB;;IAMA,OAAOvB,MAAM,GAAG,CAATA,GAAaN,MAAbM,IAAuBE,MAAM,GAAG,CAATA,GAAaN,MAApCI,IAA8C,KAAKwB,MAAL,CAAYzC,SAAS,CAACiB,MAAM,GAAG,CAAV,CAArB,EAAmClB,SAAS,CAACoB,MAAM,GAAG,CAAV,CAA5C,CAArD,EAAgH;MAC9GF,MAAM;MACNE,MAAM;MACNqB,WAAW;IACZ;;IAED,IAAIA,WAAJ,EAAiB;MACff,QAAQ,CAACP,UAATO,CAAoBc,IAApBd,CAAyB;QAACH,KAAK,EAAEkB;MAAR,CAAzBf;IACD;;IAEDA,QAAQ,CAACR,MAATQ,GAAkBR,MAAlBQ;IACA,OAAON,MAAP;EA5Ia;;EAAA;;EAAA;EA+IfsB,MA/Ie,kBA+IRC,IA/IQ,EA+IFC,KA/IE,EA+IK;IAClB,IAAI,KAAK1C,OAAL,CAAa2C,UAAjB,EAA6B;MAC3B,OAAO,KAAK3C,OAAL,CAAa2C,UAAb,CAAwBF,IAAxB,EAA8BC,KAA9B,CAAP;IADF,OAEO;MACL,OAAOD,IAAI,KAAKC,KAATD,IACD,KAAKzC,OAAL,CAAa4C,UAAb,IAA2BH,IAAI,CAACI,WAALJ,OAAuBC,KAAK,CAACG,WAANH,EADxD;IAED;EArJY;;EAAA;;EAAA;EAuJflC,WAvJe,uBAuJHsC,KAvJG,EAuJI;IACjB,IAAIZ,GAAG,GAAG,EAAV;;IACA,KAAK,IAAIa,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACnC,MAA1B,EAAkCoC,CAAC,EAAnC,EAAuC;MACrC,IAAID,KAAK,CAACC,CAAD,CAAT,EAAc;QACZb,GAAG,CAACI,IAAJJ,CAASY,KAAK,CAACC,CAAD,CAAdb;MACD;IACF;;IACD,OAAOA,GAAP;EA9Ja;;EAAA;;EAAA;EAgKf3B,SAhKe,qBAgKLH,KAhKK,EAgKE;IACf,OAAOA,KAAP;EAjKa;;EAAA;;EAAA;EAmKfK,QAnKe,oBAmKNL,KAnKM,EAmKC;IACd,OAAOA,KAAK,CAAC4C,KAAN5C,CAAY,EAAZA,CAAP;EApKa;;EAAA;;EAAA;EAsKfgB,IAtKe,gBAsKV6B,KAtKU,EAsKH;IACV,OAAOA,KAAK,CAAC7B,IAAN6B,CAAW,EAAXA,CAAP;EACD;AAxKc,CAAjBtD;;AA2KA,SAASoC,WAAT,CAAqBlC,IAArB,EAA2BoB,UAA3B,EAAuClB,SAAvC,EAAkDD,SAAlD,EAA6DkC,eAA7D,EAA8E;EAC5E,IAAIkB,YAAY,GAAG,CAAnB;EAAA,IACIC,YAAY,GAAGlC,UAAU,CAACN,MAD9B;EAAA,IAEIK,MAAM,GAAG,CAFb;EAAA,IAGIE,MAAM,GAAG,CAHb;;EAKA,OAAOgC,YAAY,GAAGC,YAAtB,EAAoCD,YAAY,EAAhD,EAAoD;IAClD,IAAIE,SAAS,GAAGnC,UAAU,CAACiC,YAAD,CAA1B;;IACA,IAAI,CAACE,SAAS,CAAChB,OAAf,EAAwB;MACtB,IAAI,CAACgB,SAAS,CAACjB,KAAX,IAAoBH,eAAxB,EAAyC;QACvC,IAAI5B,KAAK,GAAGL,SAAS,CAACsD,KAAVtD,CAAgBiB,MAAhBjB,EAAwBiB,MAAM,GAAGoC,SAAS,CAAC/B,KAA3CtB,CAAZ;QACAK,KAAK,GAAGA,KAAK,CAACkD,GAANlD,CAAU,UAASA,KAAT,EAAgB2C,CAAhB,EAAmB;UACnC,IAAIQ,QAAQ,GAAGzD,SAAS,CAACoB,MAAM,GAAG6B,CAAV,CAAxB;UACA,OAAOQ,QAAQ,CAAC5C,MAAT4C,GAAkBnD,KAAK,CAACO,MAAxB4C,GAAiCA,QAAjCA,GAA4CnD,KAAnD;QAFM,EAARA;QAKAgD,SAAS,CAAChD,KAAVgD,GAAkBvD,IAAI,CAACuB,IAALvB,CAAUO,KAAVP,CAAlBuD;MAPF,OAQO;QACLA,SAAS,CAAChD,KAAVgD,GAAkBvD,IAAI,CAACuB,IAALvB,CAAUE,SAAS,CAACsD,KAAVtD,CAAgBiB,MAAhBjB,EAAwBiB,MAAM,GAAGoC,SAAS,CAAC/B,KAA3CtB,CAAVF,CAAlBuD;MACD;;MACDpC,MAAM,IAAIoC,SAAS,CAAC/B,KAApBL,CAZsB,CActB;;MACA,IAAI,CAACoC,SAAS,CAACjB,KAAf,EAAsB;QACpBjB,MAAM,IAAIkC,SAAS,CAAC/B,KAApBH;MACD;IAjBH,OAkBO;MACLkC,SAAS,CAAChD,KAAVgD,GAAkBvD,IAAI,CAACuB,IAALvB,CAAUC,SAAS,CAACuD,KAAVvD,CAAgBoB,MAAhBpB,EAAwBoB,MAAM,GAAGkC,SAAS,CAAC/B,KAA3CvB,CAAVD,CAAlBuD;MACAlC,MAAM,IAAIkC,SAAS,CAAC/B,KAApBH,CAFK,CAIL;MACA;MACA;;MACA,IAAIgC,YAAY,IAAIjC,UAAU,CAACiC,YAAY,GAAG,CAAhB,CAAVjC,CAA6BkB,KAAjD,EAAwD;QACtD,IAAIqB,GAAG,GAAGvC,UAAU,CAACiC,YAAY,GAAG,CAAhB,CAApB;QACAjC,UAAU,CAACiC,YAAY,GAAG,CAAhB,CAAVjC,GAA+BA,UAAU,CAACiC,YAAD,CAAzCjC;QACAA,UAAU,CAACiC,YAAD,CAAVjC,GAA2BuC,GAA3BvC;MACD;IACF;EAtCyE,EAyC5E;EACA;EACA;;;EACA,IAAIwC,aAAa,GAAGxC,UAAU,CAACkC,YAAY,GAAG,CAAhB,CAA9B;;EACA,IAAIA,YAAY,GAAG,CAAfA,IACG,OAAOM,aAAa,CAACrD,KAArB,KAA+B,QADlC+C,KAEIM,aAAa,CAACtB,KAAdsB,IAAuBA,aAAa,CAACrB,OAFzCe,KAGGtD,IAAI,CAAC2C,MAAL3C,CAAY,EAAZA,EAAgB4D,aAAa,CAACrD,KAA9BP,CAHP,EAG6C;IAC3CoB,UAAU,CAACkC,YAAY,GAAG,CAAhB,CAAVlC,CAA6Bb,KAA7Ba,IAAsCwC,aAAa,CAACrD,KAApDa;IACAA,UAAU,CAACyC,GAAXzC;EACD;;EAED,OAAOA,UAAP;AACD;;AAED,SAASY,SAAT,CAAmB8B,IAAnB,EAAyB;EACvB,OAAO;IAAE3C,MAAM,EAAE2C,IAAI,CAAC3C,MAAf;IAAuBC,UAAU,EAAE0C,IAAI,CAAC1C,UAAL0C,CAAgBN,KAAhBM,CAAsB,CAAtBA;EAAnC,CAAP;AACD","names":["Diff","prototype","diff","oldString","newString","options","callback","self","done","value","setTimeout","undefined","castInput","removeEmpty","tokenize","newLen","length","oldLen","editLength","maxEditLength","bestPath","newPos","components","oldPos","extractCommon","join","count","execEditLength","diagonalPath","basePath","addPath","removePath","canAdd","canRemove","clonePath","pushComponent","buildValues","useLongestToken","exec","ret","added","removed","last","push","commonCount","equals","left","right","comparator","ignoreCase","toLowerCase","array","i","split","chars","componentPos","componentLen","component","slice","map","oldValue","tmp","lastComponent","pop","path"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\diff\\src\\diff\\base.js"],"sourcesContent":["export default function Diff() {}\n\nDiff.prototype = {\n  diff(oldString, newString, options = {}) {\n    let callback = options.callback;\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    this.options = options;\n\n    let self = this;\n\n    function done(value) {\n      if (callback) {\n        setTimeout(function() { callback(undefined, value); }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    }\n\n    // Allow subclasses to massage the input prior to running\n    oldString = this.castInput(oldString);\n    newString = this.castInput(newString);\n\n    oldString = this.removeEmpty(this.tokenize(oldString));\n    newString = this.removeEmpty(this.tokenize(newString));\n\n    let newLen = newString.length, oldLen = oldString.length;\n    let editLength = 1;\n    let maxEditLength = newLen + oldLen;\n    let bestPath = [{ newPos: -1, components: [] }];\n\n    // Seed editLength = 0, i.e. the content starts with the same values\n    let oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      // Identity per the equality and tokenizer\n      return done([{value: this.join(newString), count: newString.length}]);\n    }\n\n    // Main worker method. checks all permutations of a given edit length for acceptance.\n    function execEditLength() {\n      for (let diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        let basePath;\n        let addPath = bestPath[diagonalPath - 1],\n            removePath = bestPath[diagonalPath + 1],\n            oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        let canAdd = addPath && addPath.newPos + 1 < newLen,\n            canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        }\n\n        // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n        if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n\n        oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\n\n        // If we have hit the end of both strings, then we are done\n        if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n\n      editLength++;\n    }\n\n    // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced.\n    if (callback) {\n      (function exec() {\n        setTimeout(function() {\n          // This should not happen, but we want to be safe.\n          /* istanbul ignore next */\n          if (editLength > maxEditLength) {\n            return callback();\n          }\n\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      }());\n    } else {\n      while (editLength <= maxEditLength) {\n        let ret = execEditLength();\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n\n  pushComponent(components, added, removed) {\n    let last = components[components.length - 1];\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {count: last.count + 1, added: added, removed: removed };\n    } else {\n      components.push({count: 1, added: added, removed: removed });\n    }\n  },\n  extractCommon(basePath, newString, oldString, diagonalPath) {\n    let newLen = newString.length,\n        oldLen = oldString.length,\n        newPos = basePath.newPos,\n        oldPos = newPos - diagonalPath,\n\n        commonCount = 0;\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.components.push({count: commonCount});\n    }\n\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n\n  equals(left, right) {\n    if (this.options.comparator) {\n      return this.options.comparator(left, right);\n    } else {\n      return left === right\n        || (this.options.ignoreCase && left.toLowerCase() === right.toLowerCase());\n    }\n  },\n  removeEmpty(array) {\n    let ret = [];\n    for (let i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n    return ret;\n  },\n  castInput(value) {\n    return value;\n  },\n  tokenize(value) {\n    return value.split('');\n  },\n  join(chars) {\n    return chars.join('');\n  }\n};\n\nfunction buildValues(diff, components, newString, oldString, useLongestToken) {\n  let componentPos = 0,\n      componentLen = components.length,\n      newPos = 0,\n      oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    let component = components[componentPos];\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        let value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function(value, i) {\n          let oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n      newPos += component.count;\n\n      // Common case\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count;\n\n      // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n      if (componentPos && components[componentPos - 1].added) {\n        let tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  }\n\n  // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n  let lastComponent = components[componentLen - 1];\n  if (componentLen > 1\n      && typeof lastComponent.value === 'string'\n      && (lastComponent.added || lastComponent.removed)\n      && diff.equals('', lastComponent.value)) {\n    components[componentLen - 2].value += lastComponent.value;\n    components.pop();\n  }\n\n  return components;\n}\n\nfunction clonePath(path) {\n  return { newPos: path.newPos, components: path.components.slice(0) };\n}\n"]},"metadata":{},"sourceType":"script"}