{"ast":null,"code":"'use strict';\n/*\n  Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation\n  by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool\n*/\n\nfunction memcmp(buf1, pos1, buf2, pos2, num) {\n  for (let i = 0; i < num; ++i) {\n    if (buf1[pos1 + i] !== buf2[pos2 + i]) return false;\n  }\n\n  return true;\n}\n\nclass SBMH {\n  constructor(needle, cb) {\n    if (typeof cb !== 'function') throw new Error('Missing match callback');\n    if (typeof needle === 'string') needle = Buffer.from(needle);else if (!Buffer.isBuffer(needle)) throw new Error(`Expected Buffer for needle, got ${typeof needle}`);\n    const needleLen = needle.length;\n    this.maxMatches = Infinity;\n    this.matches = 0;\n    this._cb = cb;\n    this._lookbehindSize = 0;\n    this._needle = needle;\n    this._bufPos = 0;\n    this._lookbehind = Buffer.allocUnsafe(needleLen); // Initialize occurrence table.\n\n    this._occ = [needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen, needleLen]; // Populate occurrence table with analysis of the needle, ignoring the last\n    // letter.\n\n    if (needleLen > 1) {\n      for (let i = 0; i < needleLen - 1; ++i) this._occ[needle[i]] = needleLen - 1 - i;\n    }\n  }\n\n  reset() {\n    this.matches = 0;\n    this._lookbehindSize = 0;\n    this._bufPos = 0;\n  }\n\n  push(chunk, pos) {\n    let result;\n    if (!Buffer.isBuffer(chunk)) chunk = Buffer.from(chunk, 'latin1');\n    const chunkLen = chunk.length;\n    this._bufPos = pos || 0;\n\n    while (result !== chunkLen && this.matches < this.maxMatches) result = feed(this, chunk);\n\n    return result;\n  }\n\n  destroy() {\n    const lbSize = this._lookbehindSize;\n    if (lbSize) this._cb(false, this._lookbehind, 0, lbSize, false);\n    this.reset();\n  }\n\n}\n\nfunction feed(self, data) {\n  const len = data.length;\n  const needle = self._needle;\n  const needleLen = needle.length; // Positive: points to a position in `data`\n  //           pos == 3 points to data[3]\n  // Negative: points to a position in the lookbehind buffer\n  //           pos == -2 points to lookbehind[lookbehindSize - 2]\n\n  let pos = -self._lookbehindSize;\n  const lastNeedleCharPos = needleLen - 1;\n  const lastNeedleChar = needle[lastNeedleCharPos];\n  const end = len - needleLen;\n  const occ = self._occ;\n  const lookbehind = self._lookbehind;\n\n  if (pos < 0) {\n    // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool\n    // search with character lookup code that considers both the\n    // lookbehind buffer and the current round's haystack data.\n    //\n    // Loop until\n    //   there is a match.\n    // or until\n    //   we've moved past the position that requires the\n    //   lookbehind buffer. In this case we switch to the\n    //   optimized loop.\n    // or until\n    //   the character to look at lies outside the haystack.\n    while (pos < 0 && pos <= end) {\n      const nextPos = pos + lastNeedleCharPos;\n      const ch = nextPos < 0 ? lookbehind[self._lookbehindSize + nextPos] : data[nextPos];\n\n      if (ch === lastNeedleChar && matchNeedle(self, data, pos, lastNeedleCharPos)) {\n        self._lookbehindSize = 0;\n        ++self.matches;\n        if (pos > -self._lookbehindSize) self._cb(true, lookbehind, 0, self._lookbehindSize + pos, false);else self._cb(true, undefined, 0, 0, true);\n        return self._bufPos = pos + needleLen;\n      }\n\n      pos += occ[ch];\n    } // No match.\n    // There's too few data for Boyer-Moore-Horspool to run,\n    // so let's use a different algorithm to skip as much as\n    // we can.\n    // Forward pos until\n    //   the trailing part of lookbehind + data\n    //   looks like the beginning of the needle\n    // or until\n    //   pos == 0\n\n\n    while (pos < 0 && !matchNeedle(self, data, pos, len - pos)) ++pos;\n\n    if (pos < 0) {\n      // Cut off part of the lookbehind buffer that has\n      // been processed and append the entire haystack\n      // into it.\n      const bytesToCutOff = self._lookbehindSize + pos;\n\n      if (bytesToCutOff > 0) {\n        // The cut off data is guaranteed not to contain the needle.\n        self._cb(false, lookbehind, 0, bytesToCutOff, false);\n      }\n\n      self._lookbehindSize -= bytesToCutOff;\n      lookbehind.copy(lookbehind, 0, bytesToCutOff, self._lookbehindSize);\n      lookbehind.set(data, self._lookbehindSize);\n      self._lookbehindSize += len;\n      self._bufPos = len;\n      return len;\n    } // Discard lookbehind buffer.\n\n\n    self._cb(false, lookbehind, 0, self._lookbehindSize, false);\n\n    self._lookbehindSize = 0;\n  }\n\n  pos += self._bufPos;\n  const firstNeedleChar = needle[0]; // Lookbehind buffer is now empty. Perform Boyer-Moore-Horspool\n  // search with optimized character lookup code that only considers\n  // the current round's haystack data.\n\n  while (pos <= end) {\n    const ch = data[pos + lastNeedleCharPos];\n\n    if (ch === lastNeedleChar && data[pos] === firstNeedleChar && memcmp(needle, 0, data, pos, lastNeedleCharPos)) {\n      ++self.matches;\n      if (pos > 0) self._cb(true, data, self._bufPos, pos, true);else self._cb(true, undefined, 0, 0, true);\n      return self._bufPos = pos + needleLen;\n    }\n\n    pos += occ[ch];\n  } // There was no match. If there's trailing haystack data that we cannot\n  // match yet using the Boyer-Moore-Horspool algorithm (because the trailing\n  // data is less than the needle size) then match using a modified\n  // algorithm that starts matching from the beginning instead of the end.\n  // Whatever trailing data is left after running this algorithm is added to\n  // the lookbehind buffer.\n\n\n  while (pos < len) {\n    if (data[pos] !== firstNeedleChar || !memcmp(data, pos, needle, 0, len - pos)) {\n      ++pos;\n      continue;\n    }\n\n    data.copy(lookbehind, 0, pos, len);\n    self._lookbehindSize = len - pos;\n    break;\n  } // Everything until `pos` is guaranteed not to contain needle data.\n\n\n  if (pos > 0) self._cb(false, data, self._bufPos, pos < len ? pos : len, true);\n  self._bufPos = len;\n  return len;\n}\n\nfunction matchNeedle(self, data, pos, len) {\n  const lb = self._lookbehind;\n  const lbSize = self._lookbehindSize;\n  const needle = self._needle;\n\n  for (let i = 0; i < len; ++i, ++pos) {\n    const ch = pos < 0 ? lb[lbSize + pos] : data[pos];\n    if (ch !== needle[i]) return false;\n  }\n\n  return true;\n}\n\nmodule.exports = SBMH;","map":{"version":3,"names":["memcmp","buf1","pos1","buf2","pos2","num","i","SBMH","constructor","needle","cb","Error","Buffer","from","isBuffer","needleLen","length","maxMatches","Infinity","matches","_cb","_lookbehindSize","_needle","_bufPos","_lookbehind","allocUnsafe","_occ","reset","push","chunk","pos","result","chunkLen","feed","destroy","lbSize","self","data","len","lastNeedleCharPos","lastNeedleChar","end","occ","lookbehind","nextPos","ch","matchNeedle","undefined","bytesToCutOff","copy","set","firstNeedleChar","lb","module","exports"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/streamsearch/lib/sbmh.js"],"sourcesContent":["'use strict';\n/*\n  Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation\n  by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool\n*/\nfunction memcmp(buf1, pos1, buf2, pos2, num) {\n  for (let i = 0; i < num; ++i) {\n    if (buf1[pos1 + i] !== buf2[pos2 + i])\n      return false;\n  }\n  return true;\n}\n\nclass SBMH {\n  constructor(needle, cb) {\n    if (typeof cb !== 'function')\n      throw new Error('Missing match callback');\n\n    if (typeof needle === 'string')\n      needle = Buffer.from(needle);\n    else if (!Buffer.isBuffer(needle))\n      throw new Error(`Expected Buffer for needle, got ${typeof needle}`);\n\n    const needleLen = needle.length;\n\n    this.maxMatches = Infinity;\n    this.matches = 0;\n\n    this._cb = cb;\n    this._lookbehindSize = 0;\n    this._needle = needle;\n    this._bufPos = 0;\n\n    this._lookbehind = Buffer.allocUnsafe(needleLen);\n\n    // Initialize occurrence table.\n    this._occ = [\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen\n    ];\n\n    // Populate occurrence table with analysis of the needle, ignoring the last\n    // letter.\n    if (needleLen > 1) {\n      for (let i = 0; i < needleLen - 1; ++i)\n        this._occ[needle[i]] = needleLen - 1 - i;\n    }\n  }\n\n  reset() {\n    this.matches = 0;\n    this._lookbehindSize = 0;\n    this._bufPos = 0;\n  }\n\n  push(chunk, pos) {\n    let result;\n    if (!Buffer.isBuffer(chunk))\n      chunk = Buffer.from(chunk, 'latin1');\n    const chunkLen = chunk.length;\n    this._bufPos = pos || 0;\n    while (result !== chunkLen && this.matches < this.maxMatches)\n      result = feed(this, chunk);\n    return result;\n  }\n\n  destroy() {\n    const lbSize = this._lookbehindSize;\n    if (lbSize)\n      this._cb(false, this._lookbehind, 0, lbSize, false);\n    this.reset();\n  }\n}\n\nfunction feed(self, data) {\n  const len = data.length;\n  const needle = self._needle;\n  const needleLen = needle.length;\n\n  // Positive: points to a position in `data`\n  //           pos == 3 points to data[3]\n  // Negative: points to a position in the lookbehind buffer\n  //           pos == -2 points to lookbehind[lookbehindSize - 2]\n  let pos = -self._lookbehindSize;\n  const lastNeedleCharPos = needleLen - 1;\n  const lastNeedleChar = needle[lastNeedleCharPos];\n  const end = len - needleLen;\n  const occ = self._occ;\n  const lookbehind = self._lookbehind;\n\n  if (pos < 0) {\n    // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool\n    // search with character lookup code that considers both the\n    // lookbehind buffer and the current round's haystack data.\n    //\n    // Loop until\n    //   there is a match.\n    // or until\n    //   we've moved past the position that requires the\n    //   lookbehind buffer. In this case we switch to the\n    //   optimized loop.\n    // or until\n    //   the character to look at lies outside the haystack.\n    while (pos < 0 && pos <= end) {\n      const nextPos = pos + lastNeedleCharPos;\n      const ch = (nextPos < 0\n                  ? lookbehind[self._lookbehindSize + nextPos]\n                  : data[nextPos]);\n\n      if (ch === lastNeedleChar\n          && matchNeedle(self, data, pos, lastNeedleCharPos)) {\n        self._lookbehindSize = 0;\n        ++self.matches;\n        if (pos > -self._lookbehindSize)\n          self._cb(true, lookbehind, 0, self._lookbehindSize + pos, false);\n        else\n          self._cb(true, undefined, 0, 0, true);\n\n        return (self._bufPos = pos + needleLen);\n      }\n\n      pos += occ[ch];\n    }\n\n    // No match.\n\n    // There's too few data for Boyer-Moore-Horspool to run,\n    // so let's use a different algorithm to skip as much as\n    // we can.\n    // Forward pos until\n    //   the trailing part of lookbehind + data\n    //   looks like the beginning of the needle\n    // or until\n    //   pos == 0\n    while (pos < 0 && !matchNeedle(self, data, pos, len - pos))\n      ++pos;\n\n    if (pos < 0) {\n      // Cut off part of the lookbehind buffer that has\n      // been processed and append the entire haystack\n      // into it.\n      const bytesToCutOff = self._lookbehindSize + pos;\n\n      if (bytesToCutOff > 0) {\n        // The cut off data is guaranteed not to contain the needle.\n        self._cb(false, lookbehind, 0, bytesToCutOff, false);\n      }\n\n      self._lookbehindSize -= bytesToCutOff;\n      lookbehind.copy(lookbehind, 0, bytesToCutOff, self._lookbehindSize);\n      lookbehind.set(data, self._lookbehindSize);\n      self._lookbehindSize += len;\n\n      self._bufPos = len;\n      return len;\n    }\n\n    // Discard lookbehind buffer.\n    self._cb(false, lookbehind, 0, self._lookbehindSize, false);\n    self._lookbehindSize = 0;\n  }\n\n  pos += self._bufPos;\n\n  const firstNeedleChar = needle[0];\n\n  // Lookbehind buffer is now empty. Perform Boyer-Moore-Horspool\n  // search with optimized character lookup code that only considers\n  // the current round's haystack data.\n  while (pos <= end) {\n    const ch = data[pos + lastNeedleCharPos];\n\n    if (ch === lastNeedleChar\n        && data[pos] === firstNeedleChar\n        && memcmp(needle, 0, data, pos, lastNeedleCharPos)) {\n      ++self.matches;\n      if (pos > 0)\n        self._cb(true, data, self._bufPos, pos, true);\n      else\n        self._cb(true, undefined, 0, 0, true);\n\n      return (self._bufPos = pos + needleLen);\n    }\n\n    pos += occ[ch];\n  }\n\n  // There was no match. If there's trailing haystack data that we cannot\n  // match yet using the Boyer-Moore-Horspool algorithm (because the trailing\n  // data is less than the needle size) then match using a modified\n  // algorithm that starts matching from the beginning instead of the end.\n  // Whatever trailing data is left after running this algorithm is added to\n  // the lookbehind buffer.\n  while (pos < len) {\n    if (data[pos] !== firstNeedleChar\n        || !memcmp(data, pos, needle, 0, len - pos)) {\n      ++pos;\n      continue;\n    }\n    data.copy(lookbehind, 0, pos, len);\n    self._lookbehindSize = len - pos;\n    break;\n  }\n\n  // Everything until `pos` is guaranteed not to contain needle data.\n  if (pos > 0)\n    self._cb(false, data, self._bufPos, pos < len ? pos : len, true);\n\n  self._bufPos = len;\n  return len;\n}\n\nfunction matchNeedle(self, data, pos, len) {\n  const lb = self._lookbehind;\n  const lbSize = self._lookbehindSize;\n  const needle = self._needle;\n\n  for (let i = 0; i < len; ++i, ++pos) {\n    const ch = (pos < 0 ? lb[lbSize + pos] : data[pos]);\n    if (ch !== needle[i])\n      return false;\n  }\n  return true;\n}\n\nmodule.exports = SBMH;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}