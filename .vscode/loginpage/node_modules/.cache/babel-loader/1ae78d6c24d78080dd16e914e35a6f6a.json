{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.weiToHumanReadableString = void 0;\n/**\n * This function turns a wei value in a human readable string. It shows values\n * in ETH, gwei or wei, depending on how large it is.\n *\n * It never show more than 99999 wei or gwei, moving to the larger denominator\n * when necessary.\n *\n * It never shows more than 4 decimal digits. Adapting denominator and\n * truncating as necessary.\n */\n\nfunction weiToHumanReadableString(wei) {\n  if (typeof wei === \"number\") {\n    wei = BigInt(wei);\n  }\n\n  if (wei === 0n) {\n    return \"0 ETH\";\n  }\n\n  if (wei < 100000n) {\n    return `${wei.toString()} wei`;\n  }\n\n  if (wei < 10n ** 14n) {\n    return `${toDecimalString(wei, 9, 4)} gwei`;\n  }\n\n  return `${toDecimalString(wei, 18, 4)} ETH`;\n}\n\nexports.weiToHumanReadableString = weiToHumanReadableString;\n\nfunction toDecimalString(value, digitsToInteger) {\n  let decimalDigits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;\n  const oneUnit = 10n ** BigInt(digitsToInteger);\n  const oneDecimal = 10n ** BigInt(digitsToInteger - decimalDigits);\n  const integer = value / oneUnit;\n  const decimals = value % oneUnit / oneDecimal;\n\n  if (decimals === 0n) {\n    return integer.toString(10);\n  }\n\n  const decimalsString = removeRightZeros(decimals.toString(10).padStart(decimalDigits, \"0\"));\n  return `${integer.toString(10)}.${decimalsString}`;\n}\n\nfunction removeRightZeros(str) {\n  let zeros = 0;\n\n  for (let i = str.length - 1; i >= 0; i--) {\n    if (str.charAt(i) !== \"0\") {\n      break;\n    }\n\n    zeros += 1;\n  }\n\n  return str.substr(0, str.length - zeros);\n}","map":{"version":3,"mappings":";;;;;;AAAA;;;;;;;;;;;AAUA,SAAgBA,wBAAhB,CAAyCC,GAAzC,EAA6D;EAC3D,IAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;IAC3BA,GAAG,GAAGC,MAAM,CAACD,GAAD,CAAZ;EACD;;EAED,IAAIA,GAAG,KAAK,EAAZ,EAAgB;IACd,OAAO,OAAP;EACD;;EAED,IAAIA,GAAG,GAAG,OAAV,EAAoB;IAClB,OAAO,GAAGA,GAAG,CAACE,QAAJ,EAAc,MAAxB;EACD;;EAED,IAAIF,GAAG,GAAG,OAAO,GAAjB,EAAsB;IACpB,OAAO,GAAGG,eAAe,CAACH,GAAD,EAAM,CAAN,EAAS,CAAT,CAAW,OAApC;EACD;;EAED,OAAO,GAAGG,eAAe,CAACH,GAAD,EAAM,EAAN,EAAU,CAAV,CAAY,MAArC;AACD;;AAlBDI;;AAoBA,SAASD,eAAT,CACEE,KADF,EAEEC,eAFF,EAG2B;EAAA,IAAzBC,aAAyB,uEAAD,CAAC;EAEzB,MAAMC,OAAO,GAAG,OAAOP,MAAM,CAACK,eAAD,CAA7B;EACA,MAAMG,UAAU,GAAG,OAAOR,MAAM,CAACK,eAAe,GAAGC,aAAnB,CAAhC;EAEA,MAAMG,OAAO,GAAGL,KAAK,GAAGG,OAAxB;EAEA,MAAMG,QAAQ,GAAIN,KAAK,GAAGG,OAAT,GAAoBC,UAArC;;EACA,IAAIE,QAAQ,KAAK,EAAjB,EAAqB;IACnB,OAAOD,OAAO,CAACR,QAAR,CAAiB,EAAjB,CAAP;EACD;;EAED,MAAMU,cAAc,GAAGC,gBAAgB,CACrCF,QAAQ,CAACT,QAAT,CAAkB,EAAlB,EAAsBY,QAAtB,CAA+BP,aAA/B,EAA8C,GAA9C,CADqC,CAAvC;EAIA,OAAO,GAAGG,OAAO,CAACR,QAAR,CAAiB,EAAjB,CAAoB,IAAIU,cAAc,EAAhD;AACD;;AAED,SAASC,gBAAT,CAA0BE,GAA1B,EAAqC;EACnC,IAAIC,KAAK,GAAG,CAAZ;;EAEA,KAAK,IAAIC,CAAC,GAAGF,GAAG,CAACG,MAAJ,GAAa,CAA1B,EAA6BD,CAAC,IAAI,CAAlC,EAAqCA,CAAC,EAAtC,EAA0C;IACxC,IAAIF,GAAG,CAACI,MAAJ,CAAWF,CAAX,MAAkB,GAAtB,EAA2B;MACzB;IACD;;IAEDD,KAAK,IAAI,CAAT;EACD;;EAED,OAAOD,GAAG,CAACK,MAAJ,CAAW,CAAX,EAAcL,GAAG,CAACG,MAAJ,GAAaF,KAA3B,CAAP;AACD","names":["weiToHumanReadableString","wei","BigInt","toString","toDecimalString","exports","value","digitsToInteger","decimalDigits","oneUnit","oneDecimal","integer","decimals","decimalsString","removeRightZeros","padStart","str","zeros","i","length","charAt","substr"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\hardhat\\src\\internal\\util\\wei-values.ts"],"sourcesContent":["/**\n * This function turns a wei value in a human readable string. It shows values\n * in ETH, gwei or wei, depending on how large it is.\n *\n * It never show more than 99999 wei or gwei, moving to the larger denominator\n * when necessary.\n *\n * It never shows more than 4 decimal digits. Adapting denominator and\n * truncating as necessary.\n */\nexport function weiToHumanReadableString(wei: bigint | number): string {\n  if (typeof wei === \"number\") {\n    wei = BigInt(wei);\n  }\n\n  if (wei === 0n) {\n    return \"0 ETH\";\n  }\n\n  if (wei < 100_000n) {\n    return `${wei.toString()} wei`;\n  }\n\n  if (wei < 10n ** 14n) {\n    return `${toDecimalString(wei, 9, 4)} gwei`;\n  }\n\n  return `${toDecimalString(wei, 18, 4)} ETH`;\n}\n\nfunction toDecimalString(\n  value: bigint,\n  digitsToInteger: number,\n  decimalDigits: number = 4\n): string {\n  const oneUnit = 10n ** BigInt(digitsToInteger);\n  const oneDecimal = 10n ** BigInt(digitsToInteger - decimalDigits);\n\n  const integer = value / oneUnit;\n\n  const decimals = (value % oneUnit) / oneDecimal;\n  if (decimals === 0n) {\n    return integer.toString(10);\n  }\n\n  const decimalsString = removeRightZeros(\n    decimals.toString(10).padStart(decimalDigits, \"0\")\n  );\n\n  return `${integer.toString(10)}.${decimalsString}`;\n}\n\nfunction removeRightZeros(str: string): string {\n  let zeros = 0;\n\n  for (let i = str.length - 1; i >= 0; i--) {\n    if (str.charAt(i) !== \"0\") {\n      break;\n    }\n\n    zeros += 1;\n  }\n\n  return str.substr(0, str.length - zeros);\n}\n"]},"metadata":{},"sourceType":"script"}