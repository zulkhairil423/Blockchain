{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ModulesLogger = void 0;\n\nconst ethereumjs_util_1 = require(\"@nomicfoundation/ethereumjs-util\");\n\nconst ansi_escapes_1 = __importDefault(require(\"ansi-escapes\"));\n\nconst chalk_1 = __importDefault(require(\"chalk\"));\n\nconst util_1 = __importDefault(require(\"util\"));\n\nconst errors_1 = require(\"../../../core/errors\");\n\nconst errors_2 = require(\"../../../core/providers/errors\");\n\nconst wei_values_1 = require(\"../../../util/wei-values\");\n\nconst message_trace_1 = require(\"../../stack-traces/message-trace\");\n\nconst model_1 = require(\"../../stack-traces/model\");\n\nconst solidity_errors_1 = require(\"../../stack-traces/solidity-errors\");\n\nconst solidity_stack_trace_1 = require(\"../../stack-traces/solidity-stack-trace\");\n\nfunction printLine(line) {\n  console.log(line);\n}\n\nfunction replaceLastLine(newLine) {\n  if (process.stdout.isTTY === true) {\n    process.stdout.write( // eslint-disable-next-line prefer-template\n    ansi_escapes_1.default.cursorHide + ansi_escapes_1.default.cursorPrevLine + newLine + ansi_escapes_1.default.eraseEndLine + \"\\n\" + ansi_escapes_1.default.cursorShow);\n  } else {\n    process.stdout.write(`${newLine}\\n`);\n  }\n}\n/**\n * Handles all the logging made from the Hardhat Network.\n *\n * Methods of this class follow this convention:\n * - Methods that start with `log` add those messages to a list of things to log\n * - Methods that start with `print` print to stdout immediately\n */\n\n\nclass ModulesLogger {\n  constructor(_enabled) {\n    let _printLine = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : printLine;\n\n    let _replaceLastLine = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : replaceLastLine;\n\n    this._enabled = _enabled;\n    this._printLine = _printLine;\n    this._replaceLastLine = _replaceLastLine;\n    this._logs = [];\n    this._titleLength = 0;\n    this._currentIndent = 0;\n    this._emptyIntervalMinedBlocksRangeStart = undefined;\n    this._emptyHardhatMinedBlocksRangeStart = undefined;\n    this._methodCollapsedCount = 0;\n  }\n\n  isEnabled() {\n    return this._enabled;\n  }\n\n  setEnabled(enabled) {\n    this._enabled = enabled;\n  }\n\n  isLoggedError(err) {\n    return err instanceof solidity_errors_1.SolidityError || err instanceof errors_2.TransactionExecutionError;\n  }\n\n  logBlockFromAutomine(result, codes, txHashToHighlight) {\n    const {\n      block,\n      blockResult,\n      traces\n    } = result;\n    const {\n      results\n    } = blockResult;\n    (0, errors_1.assertHardhatInvariant)(results.length === codes.length, \"The array of codes should have the same length as the array of results\");\n\n    this._indent(() => {\n      this._logBlockNumber(block);\n\n      this._indent(() => {\n        this._logBaseFeePerGas(block);\n\n        for (let i = 0; i < block.transactions.length; i++) {\n          const tx = block.transactions[i];\n          const txGasUsed = results[i].totalGasSpent;\n          const txTrace = traces[i];\n          const code = codes[i];\n          const highlightTxHash = tx.hash().equals(txHashToHighlight);\n\n          this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n            highlightTxHash\n          });\n\n          this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n        }\n      });\n    });\n  }\n\n  logMinedBlock(result, codes) {\n    const {\n      block,\n      blockResult,\n      traces\n    } = result;\n    const {\n      results\n    } = blockResult;\n    (0, errors_1.assertHardhatInvariant)(results.length === codes.length, \"The array of codes should have the same length as the array of results\");\n    const blockNumber = result.block.header.number;\n    const isEmpty = result.block.transactions.length === 0;\n\n    this._indent(() => {\n      this.logMinedBlockNumber(blockNumber, isEmpty, block.header.baseFeePerGas);\n\n      if (isEmpty) {\n        return;\n      }\n\n      this._indent(() => {\n        this._logBlockHash(block);\n\n        this._indent(() => {\n          this._logBaseFeePerGas(block);\n\n          for (let i = 0; i < block.transactions.length; i++) {\n            const tx = block.transactions[i];\n            const txGasUsed = results[i].totalGasSpent;\n            const txTrace = traces[i];\n            const code = codes[i];\n\n            this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n              highlightTxHash: false\n            });\n\n            this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n          }\n        });\n      });\n    });\n  }\n\n  logIntervalMinedBlock(result, codes) {\n    const {\n      block,\n      blockResult,\n      traces\n    } = result;\n    const {\n      results\n    } = blockResult;\n    (0, errors_1.assertHardhatInvariant)(results.length === codes.length, \"The array of codes should have the same length as the array of results\");\n\n    this._indent(() => {\n      this._logBlockHash(block);\n\n      this._indent(() => {\n        this._logBaseFeePerGas(block);\n\n        for (let i = 0; i < block.transactions.length; i++) {\n          const tx = block.transactions[i];\n          const txGasUsed = results[i].totalGasSpent;\n          const txTrace = traces[i];\n          const code = codes[i];\n\n          this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n            highlightTxHash: false\n          });\n\n          this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n        }\n      });\n    });\n  }\n\n  logSingleTransaction(tx, block, txGasUsed, txTrace, code) {\n    this._indent(() => {\n      this._logContractAndFunctionName(txTrace.trace, code);\n\n      const txHash = (0, ethereumjs_util_1.bufferToHex)(tx.hash());\n\n      this._logWithTitle(\"Transaction\", txHash);\n\n      this._logTxFrom(tx.getSenderAddress().toBuffer());\n\n      this._logTxTo(tx.to?.toBuffer(), txTrace.trace);\n\n      this._logTxValue(tx.value);\n\n      this._logWithTitle(\"Gas used\", `${txGasUsed} of ${tx.gasLimit}`);\n\n      this._logWithTitle(`Block #${block.header.number}`, (0, ethereumjs_util_1.bufferToHex)(block.hash()));\n\n      this._logConsoleLogMessages(txTrace.consoleLogMessages);\n\n      if (txTrace.error !== undefined) {\n        this._logError(txTrace.error);\n      }\n    });\n  }\n\n  logCurrentlySentTransaction(tx, txGasUsed, txTrace, code, block) {\n    this._indent(() => {\n      this._log(\"Currently sent transaction:\");\n\n      this.logEmptyLine();\n\n      this._logContractAndFunctionName(txTrace.trace, code);\n\n      const txHash = (0, ethereumjs_util_1.bufferToHex)(tx.hash());\n\n      this._logWithTitle(\"Transaction\", txHash);\n\n      this._logTxFrom(tx.getSenderAddress().toBuffer());\n\n      this._logTxTo(tx.to?.toBuffer(), txTrace.trace);\n\n      this._logTxValue(tx.value);\n\n      this._logWithTitle(\"Gas used\", `${txGasUsed} of ${tx.gasLimit}`);\n\n      this._logWithTitle(`Block #${block.header.number}`, (0, ethereumjs_util_1.bufferToHex)(block.hash()));\n\n      this._logConsoleLogMessages(txTrace.consoleLogMessages);\n\n      if (txTrace.error !== undefined) {\n        this._logError(txTrace.error);\n      }\n    });\n  }\n\n  logEstimateGasTrace(callParams, code, trace, consoleLogMessages, error) {\n    this._indent(() => {\n      this._logContractAndFunctionName(trace, code, {\n        printNonContractCalled: true\n      });\n\n      this._logTxFrom(callParams.from);\n\n      this._logTxTo(callParams.to, trace);\n\n      this._logTxValue(callParams.value);\n\n      this._logConsoleLogMessages(consoleLogMessages);\n\n      this._logError(error);\n    });\n  }\n\n  logCallTrace(callParams, code, trace, consoleLogMessages, error) {\n    this._indent(() => {\n      this._logContractAndFunctionName(trace, code, {\n        printNonContractCalled: true\n      });\n\n      this._logTxFrom(callParams.from);\n\n      this._logTxTo(callParams.to, trace);\n\n      if (callParams.value > 0n) {\n        this._logTxValue(callParams.value);\n      }\n\n      this._logConsoleLogMessages(consoleLogMessages);\n\n      if (error !== undefined) {\n        // TODO: If throwOnCallFailures is false, this will log the error, but the RPC method won't be red\n        this._logError(error);\n      }\n    });\n  }\n\n  logMinedBlockNumber(blockNumber, isEmpty, baseFeePerGas) {\n    if (isEmpty) {\n      this._log(`Mined empty block #${blockNumber}${baseFeePerGas !== undefined ? ` with base fee ${baseFeePerGas.toString()}` : \"\"}`);\n\n      return;\n    }\n\n    this._log(`Mined block #${blockNumber}`);\n  }\n\n  logMultipleTransactionsWarning() {\n    this._indent(() => {\n      this._log(\"There were other pending transactions mined in the same block:\");\n    });\n\n    this.logEmptyLine();\n  }\n\n  logMultipleBlocksWarning() {\n    this._indent(() => {\n      this._log(\"There were other pending transactions. More than one block had to be mined:\");\n    });\n\n    this.logEmptyLine();\n  }\n\n  logEmptyLine() {\n    this._log(\"\");\n  }\n\n  _logBaseFeePerGas(block) {\n    if (block.header.baseFeePerGas !== undefined) {\n      this._log(`Base fee: ${block.header.baseFeePerGas.toString()}`);\n    }\n  }\n\n  printErrorMessage(errorMessage) {\n    this._indent(() => {\n      this._print(errorMessage);\n    });\n  }\n\n  printFailedMethod(method) {\n    this._print(method, {\n      color: chalk_1.default.red\n    });\n  }\n  /**\n   * Print all accumulated logs\n   */\n\n\n  printLogs() {\n    const logs = this._getLogs();\n\n    if (logs.length === 0) {\n      return false;\n    }\n\n    for (const msg of logs) {\n      this._print(msg);\n    }\n\n    this._clearLogs();\n\n    return true;\n  }\n\n  printIntervalMinedBlockNumber(blockNumber, isEmpty, baseFeePerGas) {\n    if (this._emptyIntervalMinedBlocksRangeStart !== undefined) {\n      this._print(`Mined empty block range #${this._emptyIntervalMinedBlocksRangeStart} to #${blockNumber}`, {\n        collapseIntervalMinedBlock: true,\n        replaceLastLine: true\n      });\n    } else {\n      this._emptyIntervalMinedBlocksRangeStart = blockNumber;\n\n      if (isEmpty) {\n        this._print(`Mined empty block #${blockNumber}${baseFeePerGas !== undefined ? ` with base fee ${baseFeePerGas.toString()}` : \"\"}`, {\n          collapseIntervalMinedBlock: true\n        });\n\n        return;\n      }\n\n      this._print(`Mined block #${blockNumber}`, {\n        collapseIntervalMinedBlock: true\n      });\n    }\n  }\n\n  logEmptyHardhatMinedBlock(blockNumber, baseFeePerGas) {\n    this._indent(() => {\n      if (this._emptyHardhatMinedBlocksRangeStart !== undefined) {\n        this._log(`Mined empty block range #${this._emptyHardhatMinedBlocksRangeStart} to #${blockNumber}`, {\n          collapseHardhatMinedBlock: true,\n          replaceLastLine: true\n        });\n      } else {\n        this._emptyHardhatMinedBlocksRangeStart = blockNumber;\n\n        this._log(`Mined empty block #${blockNumber}${baseFeePerGas !== undefined ? ` with base fee ${baseFeePerGas.toString()}` : \"\"}`, {\n          collapseHardhatMinedBlock: true\n        });\n\n        return;\n      }\n    });\n  }\n\n  printMetaMaskWarning() {\n    const message = \"If you are using MetaMask, you can learn how to fix this error here: https://hardhat.org/metamask-issue\";\n\n    this._indent(() => {\n      this._print(message, {\n        color: chalk_1.default.yellow\n      });\n    });\n  }\n\n  printMethod(method) {\n    if (this._shouldCollapseMethod(method)) {\n      this._methodCollapsedCount += 1;\n\n      this._print(chalk_1.default.green(`${method} (${this._methodCollapsedCount})`), {\n        collapsePrintedMethod: true,\n        replaceLastLine: true\n      });\n    } else {\n      this._startCollapsingMethod(method);\n\n      this._print(method, {\n        color: chalk_1.default.green,\n        collapsePrintedMethod: true\n      });\n    }\n  }\n\n  printMethodNotSupported(method) {\n    this._print(`${method} - Method not supported`, {\n      color: chalk_1.default.red\n    });\n  }\n\n  printEmptyLine() {\n    this._print(\"\");\n  }\n\n  printUnknownError(err) {\n    this._indent(() => {\n      this._printError(err);\n\n      this.printEmptyLine();\n\n      this._print(\"If you think this is a bug in Hardhat, please report it here: https://hardhat.org/report-bug\");\n    });\n  }\n\n  _format(msg) {\n    let {\n      color\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (msg === \"\") {\n      // don't indent empty lines\n      return msg;\n    }\n\n    if (this._currentIndent > 0) {\n      msg = msg.split(\"\\n\").map(line => \" \".repeat(this._currentIndent) + line).join(\"\\n\");\n    }\n\n    if (color !== undefined) {\n      return color(msg);\n    }\n\n    return msg;\n  }\n\n  _indent(cb) {\n    let enabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (enabled) {\n      this._currentIndent += 2;\n    }\n\n    try {\n      return cb();\n    } finally {\n      if (enabled) {\n        this._currentIndent -= 2;\n      }\n    }\n  }\n\n  _indentSingleLine(message) {\n    return \" \".repeat(this._currentIndent) + message;\n  }\n\n  _log(msg) {\n    let printOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (printOptions.collapsePrintedMethod !== true) {\n      this._stopCollapsingMethod();\n    }\n\n    if (printOptions.collapseIntervalMinedBlock !== true) {\n      this._emptyIntervalMinedBlocksRangeStart = undefined;\n    }\n\n    if (printOptions.collapseHardhatMinedBlock !== true) {\n      this._emptyHardhatMinedBlocksRangeStart = undefined;\n    }\n\n    const formattedMessage = this._format(msg, printOptions);\n\n    if (printOptions.replaceLastLine === true) {\n      this._logs[this._logs.length - 1] = formattedMessage;\n    } else {\n      this._logs.push(formattedMessage);\n    }\n  }\n\n  _logError(err) {\n    if (this.isLoggedError(err)) {\n      this.logEmptyLine();\n\n      this._log(util_1.default.inspect(err));\n    }\n  }\n\n  _logTxInsideBlock(tx, txTrace, code, txGasUsed, _ref) {\n    let {\n      highlightTxHash\n    } = _ref;\n    // indentAfterTransactionHash: true,\n    // printTxBlockNumber: false,\n    // startWithTxHash: true,\n    let txHash = (0, ethereumjs_util_1.bufferToHex)(tx.hash());\n\n    if (highlightTxHash) {\n      txHash = chalk_1.default.bold(txHash);\n    }\n\n    this._logWithTitle(\"Transaction\", txHash);\n\n    this._indent(() => {\n      this._logContractAndFunctionName(txTrace.trace, code);\n\n      this._logTxFrom(tx.getSenderAddress().toBuffer());\n\n      this._logTxTo(tx.to?.toBuffer(), txTrace.trace);\n\n      this._logTxValue(tx.value);\n\n      this._logWithTitle(\"Gas used\", `${txGasUsed} of ${tx.gasLimit}`);\n\n      this._logConsoleLogMessages(txTrace.consoleLogMessages);\n\n      if (txTrace.error !== undefined) {\n        this._logError(txTrace.error);\n      }\n    });\n  }\n  /**\n   *  This should be the only function that calls _printLine and\n   *  _replaceLastLine (except for the special console.sol case),\n   *  because it's the only function that checks if the logger\n   *  is enabled.\n   */\n\n\n  _print(msg) {\n    let printOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!this._enabled) {\n      return;\n    }\n\n    if (printOptions.collapsePrintedMethod !== true) {\n      this._stopCollapsingMethod();\n    }\n\n    if (printOptions.collapseIntervalMinedBlock !== true) {\n      this._emptyIntervalMinedBlocksRangeStart = undefined;\n    }\n\n    if (printOptions.collapseHardhatMinedBlock !== true) {\n      this._emptyHardhatMinedBlocksRangeStart = undefined;\n    }\n\n    const formattedMessage = this._format(msg, printOptions);\n\n    if (printOptions.replaceLastLine === true) {\n      this._replaceLastLine(formattedMessage);\n    } else {\n      this._printLine(formattedMessage);\n    }\n  }\n\n  _printError(err) {\n    if (this.isLoggedError(err)) {\n      this.printEmptyLine();\n\n      this._print(util_1.default.inspect(err));\n    }\n  }\n\n  _logContractAndFunctionName(trace, code) {\n    let {\n      printNonContractCalled = false\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (trace === undefined) {\n      return;\n    }\n\n    if ((0, message_trace_1.isPrecompileTrace)(trace)) {\n      this._logWithTitle(\"Precompile call\", `<PrecompileContract ${trace.precompile}>`);\n\n      return;\n    }\n\n    if ((0, message_trace_1.isCreateTrace)(trace)) {\n      if (trace.bytecode === undefined) {\n        this._logWithTitle(\"Contract deployment\", solidity_stack_trace_1.UNRECOGNIZED_CONTRACT_NAME);\n      } else {\n        this._logWithTitle(\"Contract deployment\", trace.bytecode.contract.name);\n      }\n\n      if (trace.deployedContract !== undefined && trace.error === undefined) {\n        this._logWithTitle(\"Contract address\", (0, ethereumjs_util_1.bufferToHex)(trace.deployedContract));\n      }\n\n      return;\n    }\n\n    if (code.length === 0) {\n      if (printNonContractCalled) {\n        this._log(`WARNING: Calling an account which is not a contract`);\n      }\n\n      return;\n    }\n\n    if (trace.bytecode === undefined) {\n      this._logWithTitle(\"Contract call\", solidity_stack_trace_1.UNRECOGNIZED_CONTRACT_NAME);\n\n      return;\n    }\n\n    const func = trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4));\n    const functionName = func === undefined ? solidity_stack_trace_1.UNRECOGNIZED_FUNCTION_NAME : func.type === model_1.ContractFunctionType.FALLBACK ? solidity_stack_trace_1.FALLBACK_FUNCTION_NAME : func.type === model_1.ContractFunctionType.RECEIVE ? solidity_stack_trace_1.RECEIVE_FUNCTION_NAME : func.name;\n\n    this._logWithTitle(\"Contract call\", `${trace.bytecode.contract.name}#${functionName}`);\n  }\n\n  _shouldCollapseMethod(method) {\n    return method === this._methodBeingCollapsed && !this._hasLogs() && this._methodCollapsedCount > 0;\n  }\n\n  _startCollapsingMethod(method) {\n    this._methodBeingCollapsed = method;\n    this._methodCollapsedCount = 1;\n  }\n\n  _stopCollapsingMethod() {\n    this._methodBeingCollapsed = undefined;\n    this._methodCollapsedCount = 0;\n  }\n\n  _logTxTo(to, trace) {\n    if (trace !== undefined && (0, message_trace_1.isCreateTrace)(trace)) {\n      return;\n    }\n\n    if (to === undefined) {\n      // only for the type-checker, since `to` is undefined only when\n      // the message is a create trace\n      return;\n    }\n\n    const toString = (0, ethereumjs_util_1.bufferToHex)(to);\n\n    this._logWithTitle(\"To\", toString);\n  }\n\n  _logTxValue(value) {\n    this._logWithTitle(\"Value\", (0, wei_values_1.weiToHumanReadableString)(value));\n  }\n\n  _logTxFrom(from) {\n    this._logWithTitle(\"From\", (0, ethereumjs_util_1.bufferToHex)(from));\n  }\n\n  _logBlockNumber(block) {\n    this._log(`Block #${block.header.number}: ${(0, ethereumjs_util_1.bufferToHex)(block.hash())}`);\n  }\n\n  _logEmptyLineBetweenTransactions(currentIndex, totalTransactions) {\n    if (currentIndex + 1 < totalTransactions && totalTransactions > 1) {\n      this.logEmptyLine();\n    }\n  }\n\n  _logBlockHash(block) {\n    this._log(`Block: ${(0, ethereumjs_util_1.bufferToHex)(block.hash())}`);\n  }\n\n  _logConsoleLogMessages(messages) {\n    // This is a especial case, as we always want to print the console.log\n    // messages. The difference is how.\n    // If we have a logger, we should use that, so that logs are printed in\n    // order. If we don't, we just print the messages here.\n    if (!this._enabled) {\n      for (const msg of messages) {\n        this._printLine(msg);\n      }\n\n      return;\n    }\n\n    if (messages.length === 0) {\n      return;\n    }\n\n    this.logEmptyLine();\n\n    this._log(\"console.log:\");\n\n    for (const msg of messages) {\n      this._log(`  ${msg}`);\n    }\n  }\n\n  _logWithTitle(title, message) {\n    title = this._indentSingleLine(title); // We always use the max title length we've seen. Otherwise the value move\n    // a lot with each tx/call.\n\n    if (title.length > this._titleLength) {\n      this._titleLength = title.length;\n    }\n\n    this._logs.push([title, message]);\n  }\n\n  _clearLogs() {\n    this._logs = [];\n  }\n\n  _hasLogs() {\n    return this._logs.length > 0;\n  }\n\n  _getLogs() {\n    return this._logs.map(l => {\n      if (typeof l === \"string\") {\n        return l;\n      }\n\n      const title = `${l[0]}:`;\n      return `${title.padEnd(this._titleLength + 1)} ${l[1]}`;\n    });\n  }\n\n}\n\nexports.ModulesLogger = ModulesLogger;","map":{"version":3,"mappings":"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","names":["printLine","line","console","log","replaceLastLine","newLine","process","stdout","isTTY","write","ansi_escapes_1","cursorHide","cursorPrevLine","eraseEndLine","cursorShow","ModulesLogger","constructor","_enabled","_printLine","_replaceLastLine","undefined","isEnabled","setEnabled","enabled","isLoggedError","err","solidity_errors_1","errors_2","logBlockFromAutomine","result","codes","txHashToHighlight","block","blockResult","traces","results","length","_indent","_logBlockNumber","_logBaseFeePerGas","i","transactions","tx","txGasUsed","totalGasSpent","txTrace","code","highlightTxHash","hash","equals","_logTxInsideBlock","_logEmptyLineBetweenTransactions","logMinedBlock","blockNumber","header","number","isEmpty","logMinedBlockNumber","baseFeePerGas","_logBlockHash","logIntervalMinedBlock","logSingleTransaction","_logContractAndFunctionName","trace","txHash","_logWithTitle","_logTxFrom","getSenderAddress","toBuffer","_logTxTo","to","_logTxValue","value","gasLimit","_logConsoleLogMessages","consoleLogMessages","error","_logError","logCurrentlySentTransaction","_log","logEmptyLine","logEstimateGasTrace","callParams","printNonContractCalled","from","logCallTrace","toString","logMultipleTransactionsWarning","logMultipleBlocksWarning","printErrorMessage","errorMessage","_print","printFailedMethod","method","color","chalk_1","red","printLogs","logs","_getLogs","msg","_clearLogs","printIntervalMinedBlockNumber","_emptyIntervalMinedBlocksRangeStart","collapseIntervalMinedBlock","logEmptyHardhatMinedBlock","_emptyHardhatMinedBlocksRangeStart","collapseHardhatMinedBlock","printMetaMaskWarning","message","yellow","printMethod","_shouldCollapseMethod","_methodCollapsedCount","green","collapsePrintedMethod","_startCollapsingMethod","printMethodNotSupported","printEmptyLine","printUnknownError","_printError","_format","_currentIndent","split","map","repeat","join","cb","_indentSingleLine","printOptions","_stopCollapsingMethod","formattedMessage","_logs","push","util_1","inspect","bold","precompile","bytecode","solidity_stack_trace_1","contract","name","deployedContract","func","getFunctionFromSelector","calldata","slice","functionName","type","model_1","FALLBACK","RECEIVE","_methodBeingCollapsed","_hasLogs","currentIndex","totalTransactions","messages","title","_titleLength","l","padEnd","exports"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\hardhat\\src\\internal\\hardhat-network\\provider\\modules\\logger.ts"],"sourcesContent":["import { Block } from \"@nomicfoundation/ethereumjs-block\";\nimport { TypedTransaction } from \"@nomicfoundation/ethereumjs-tx\";\nimport { bufferToHex } from \"@nomicfoundation/ethereumjs-util\";\nimport ansiEscapes from \"ansi-escapes\";\nimport chalk, { Chalk } from \"chalk\";\nimport util from \"util\";\n\nimport { assertHardhatInvariant } from \"../../../core/errors\";\nimport { TransactionExecutionError } from \"../../../core/providers/errors\";\nimport { weiToHumanReadableString } from \"../../../util/wei-values\";\nimport {\n  isCreateTrace,\n  isPrecompileTrace,\n  MessageTrace,\n} from \"../../stack-traces/message-trace\";\nimport { ContractFunctionType } from \"../../stack-traces/model\";\nimport { SolidityError } from \"../../stack-traces/solidity-errors\";\nimport {\n  FALLBACK_FUNCTION_NAME,\n  RECEIVE_FUNCTION_NAME,\n  UNRECOGNIZED_CONTRACT_NAME,\n  UNRECOGNIZED_FUNCTION_NAME,\n} from \"../../stack-traces/solidity-stack-trace\";\nimport { CallParams, GatherTracesResult, MineBlockResult } from \"../node-types\";\n\ninterface PrintOptions {\n  color?: Chalk;\n  replaceLastLine?: boolean;\n  collapsePrintedMethod?: boolean;\n  collapseIntervalMinedBlock?: boolean;\n  collapseHardhatMinedBlock?: boolean;\n}\n\nfunction printLine(line: string) {\n  console.log(line);\n}\n\nfunction replaceLastLine(newLine: string) {\n  if (process.stdout.isTTY === true) {\n    process.stdout.write(\n      // eslint-disable-next-line prefer-template\n      ansiEscapes.cursorHide +\n        ansiEscapes.cursorPrevLine +\n        newLine +\n        ansiEscapes.eraseEndLine +\n        \"\\n\" +\n        ansiEscapes.cursorShow\n    );\n  } else {\n    process.stdout.write(`${newLine}\\n`);\n  }\n}\n\n/**\n * Handles all the logging made from the Hardhat Network.\n *\n * Methods of this class follow this convention:\n * - Methods that start with `log` add those messages to a list of things to log\n * - Methods that start with `print` print to stdout immediately\n */\nexport class ModulesLogger {\n  private _logs: Array<string | [string, string]> = [];\n  private _titleLength = 0;\n  private _currentIndent = 0;\n  private _emptyIntervalMinedBlocksRangeStart: bigint | undefined = undefined;\n  private _emptyHardhatMinedBlocksRangeStart: bigint | undefined = undefined;\n  private _methodBeingCollapsed?: string;\n  private _methodCollapsedCount: number = 0;\n\n  constructor(\n    private _enabled: boolean,\n    private _printLine = printLine,\n    private _replaceLastLine = replaceLastLine\n  ) {}\n\n  public isEnabled() {\n    return this._enabled;\n  }\n\n  public setEnabled(enabled: boolean) {\n    this._enabled = enabled;\n  }\n\n  public isLoggedError(err: Error) {\n    return (\n      err instanceof SolidityError || err instanceof TransactionExecutionError\n    );\n  }\n\n  public logBlockFromAutomine(\n    result: MineBlockResult,\n    codes: Buffer[],\n    txHashToHighlight: Buffer\n  ) {\n    const { block, blockResult, traces } = result;\n    const { results } = blockResult;\n\n    assertHardhatInvariant(\n      results.length === codes.length,\n      \"The array of codes should have the same length as the array of results\"\n    );\n\n    this._indent(() => {\n      this._logBlockNumber(block);\n\n      this._indent(() => {\n        this._logBaseFeePerGas(block);\n\n        for (let i = 0; i < block.transactions.length; i++) {\n          const tx = block.transactions[i];\n\n          const txGasUsed = results[i].totalGasSpent;\n          const txTrace = traces[i];\n          const code = codes[i];\n\n          const highlightTxHash = tx.hash().equals(txHashToHighlight);\n\n          this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n            highlightTxHash,\n          });\n\n          this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n        }\n      });\n    });\n  }\n\n  public logMinedBlock(result: MineBlockResult, codes: Buffer[]) {\n    const { block, blockResult, traces } = result;\n    const { results } = blockResult;\n\n    assertHardhatInvariant(\n      results.length === codes.length,\n      \"The array of codes should have the same length as the array of results\"\n    );\n\n    const blockNumber = result.block.header.number;\n    const isEmpty = result.block.transactions.length === 0;\n\n    this._indent(() => {\n      this.logMinedBlockNumber(\n        blockNumber,\n        isEmpty,\n        block.header.baseFeePerGas\n      );\n\n      if (isEmpty) {\n        return;\n      }\n\n      this._indent(() => {\n        this._logBlockHash(block);\n\n        this._indent(() => {\n          this._logBaseFeePerGas(block);\n\n          for (let i = 0; i < block.transactions.length; i++) {\n            const tx = block.transactions[i];\n            const txGasUsed = results[i].totalGasSpent;\n            const txTrace = traces[i];\n            const code = codes[i];\n\n            this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n              highlightTxHash: false,\n            });\n\n            this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n          }\n        });\n      });\n    });\n  }\n\n  public logIntervalMinedBlock(result: MineBlockResult, codes: Buffer[]) {\n    const { block, blockResult, traces } = result;\n    const { results } = blockResult;\n\n    assertHardhatInvariant(\n      results.length === codes.length,\n      \"The array of codes should have the same length as the array of results\"\n    );\n\n    this._indent(() => {\n      this._logBlockHash(block);\n\n      this._indent(() => {\n        this._logBaseFeePerGas(block);\n\n        for (let i = 0; i < block.transactions.length; i++) {\n          const tx = block.transactions[i];\n          const txGasUsed = results[i].totalGasSpent;\n          const txTrace = traces[i];\n          const code = codes[i];\n\n          this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n            highlightTxHash: false,\n          });\n\n          this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n        }\n      });\n    });\n  }\n\n  public logSingleTransaction(\n    tx: TypedTransaction,\n    block: Block,\n    txGasUsed: bigint,\n    txTrace: GatherTracesResult,\n    code: Buffer\n  ) {\n    this._indent(() => {\n      this._logContractAndFunctionName(txTrace.trace, code);\n\n      const txHash = bufferToHex(tx.hash());\n\n      this._logWithTitle(\"Transaction\", txHash);\n\n      this._logTxFrom(tx.getSenderAddress().toBuffer());\n      this._logTxTo(tx.to?.toBuffer(), txTrace.trace);\n      this._logTxValue(tx.value);\n      this._logWithTitle(\"Gas used\", `${txGasUsed} of ${tx.gasLimit}`);\n\n      this._logWithTitle(\n        `Block #${block.header.number}`,\n        bufferToHex(block.hash())\n      );\n\n      this._logConsoleLogMessages(txTrace.consoleLogMessages);\n\n      if (txTrace.error !== undefined) {\n        this._logError(txTrace.error);\n      }\n    });\n  }\n\n  public logCurrentlySentTransaction(\n    tx: TypedTransaction,\n    txGasUsed: bigint,\n    txTrace: GatherTracesResult,\n    code: Buffer,\n    block: Block\n  ) {\n    this._indent(() => {\n      this._log(\"Currently sent transaction:\");\n      this.logEmptyLine();\n\n      this._logContractAndFunctionName(txTrace.trace, code);\n\n      const txHash = bufferToHex(tx.hash());\n\n      this._logWithTitle(\"Transaction\", txHash);\n\n      this._logTxFrom(tx.getSenderAddress().toBuffer());\n      this._logTxTo(tx.to?.toBuffer(), txTrace.trace);\n      this._logTxValue(tx.value);\n      this._logWithTitle(\"Gas used\", `${txGasUsed} of ${tx.gasLimit}`);\n\n      this._logWithTitle(\n        `Block #${block.header.number}`,\n        bufferToHex(block.hash())\n      );\n\n      this._logConsoleLogMessages(txTrace.consoleLogMessages);\n\n      if (txTrace.error !== undefined) {\n        this._logError(txTrace.error);\n      }\n    });\n  }\n\n  public logEstimateGasTrace(\n    callParams: CallParams,\n    code: Buffer,\n    trace: MessageTrace | undefined,\n    consoleLogMessages: string[],\n    error: Error\n  ) {\n    this._indent(() => {\n      this._logContractAndFunctionName(trace, code, {\n        printNonContractCalled: true,\n      });\n\n      this._logTxFrom(callParams.from);\n      this._logTxTo(callParams.to, trace);\n      this._logTxValue(callParams.value);\n\n      this._logConsoleLogMessages(consoleLogMessages);\n\n      this._logError(error);\n    });\n  }\n\n  public logCallTrace(\n    callParams: CallParams,\n    code: Buffer,\n    trace: MessageTrace | undefined,\n    consoleLogMessages: string[],\n    error: Error | undefined\n  ) {\n    this._indent(() => {\n      this._logContractAndFunctionName(trace, code, {\n        printNonContractCalled: true,\n      });\n\n      this._logTxFrom(callParams.from);\n      this._logTxTo(callParams.to, trace);\n      if (callParams.value > 0n) {\n        this._logTxValue(callParams.value);\n      }\n\n      this._logConsoleLogMessages(consoleLogMessages);\n\n      if (error !== undefined) {\n        // TODO: If throwOnCallFailures is false, this will log the error, but the RPC method won't be red\n        this._logError(error);\n      }\n    });\n  }\n\n  public logMinedBlockNumber(\n    blockNumber: bigint,\n    isEmpty: boolean,\n    baseFeePerGas?: bigint\n  ) {\n    if (isEmpty) {\n      this._log(\n        `Mined empty block #${blockNumber}${\n          baseFeePerGas !== undefined\n            ? ` with base fee ${baseFeePerGas.toString()}`\n            : \"\"\n        }`\n      );\n\n      return;\n    }\n\n    this._log(`Mined block #${blockNumber}`);\n  }\n\n  public logMultipleTransactionsWarning() {\n    this._indent(() => {\n      this._log(\n        \"There were other pending transactions mined in the same block:\"\n      );\n    });\n    this.logEmptyLine();\n  }\n\n  public logMultipleBlocksWarning() {\n    this._indent(() => {\n      this._log(\n        \"There were other pending transactions. More than one block had to be mined:\"\n      );\n    });\n    this.logEmptyLine();\n  }\n\n  public logEmptyLine() {\n    this._log(\"\");\n  }\n\n  private _logBaseFeePerGas(block: Block) {\n    if (block.header.baseFeePerGas !== undefined) {\n      this._log(`Base fee: ${block.header.baseFeePerGas.toString()}`);\n    }\n  }\n\n  public printErrorMessage(errorMessage: string) {\n    this._indent(() => {\n      this._print(errorMessage);\n    });\n  }\n\n  public printFailedMethod(method: string) {\n    this._print(method, { color: chalk.red });\n  }\n\n  /**\n   * Print all accumulated logs\n   */\n  public printLogs(): boolean {\n    const logs = this._getLogs();\n    if (logs.length === 0) {\n      return false;\n    }\n\n    for (const msg of logs) {\n      this._print(msg);\n    }\n\n    this._clearLogs();\n\n    return true;\n  }\n\n  public printIntervalMinedBlockNumber(\n    blockNumber: bigint,\n    isEmpty: boolean,\n    baseFeePerGas?: bigint\n  ) {\n    if (this._emptyIntervalMinedBlocksRangeStart !== undefined) {\n      this._print(\n        `Mined empty block range #${this._emptyIntervalMinedBlocksRangeStart} to #${blockNumber}`,\n        { collapseIntervalMinedBlock: true, replaceLastLine: true }\n      );\n    } else {\n      this._emptyIntervalMinedBlocksRangeStart = blockNumber;\n\n      if (isEmpty) {\n        this._print(\n          `Mined empty block #${blockNumber}${\n            baseFeePerGas !== undefined\n              ? ` with base fee ${baseFeePerGas.toString()}`\n              : \"\"\n          }`,\n          {\n            collapseIntervalMinedBlock: true,\n          }\n        );\n\n        return;\n      }\n\n      this._print(`Mined block #${blockNumber}`, {\n        collapseIntervalMinedBlock: true,\n      });\n    }\n  }\n\n  public logEmptyHardhatMinedBlock(\n    blockNumber: bigint,\n    baseFeePerGas?: bigint\n  ) {\n    this._indent(() => {\n      if (this._emptyHardhatMinedBlocksRangeStart !== undefined) {\n        this._log(\n          `Mined empty block range #${this._emptyHardhatMinedBlocksRangeStart} to #${blockNumber}`,\n          { collapseHardhatMinedBlock: true, replaceLastLine: true }\n        );\n      } else {\n        this._emptyHardhatMinedBlocksRangeStart = blockNumber;\n\n        this._log(\n          `Mined empty block #${blockNumber}${\n            baseFeePerGas !== undefined\n              ? ` with base fee ${baseFeePerGas.toString()}`\n              : \"\"\n          }`,\n          {\n            collapseHardhatMinedBlock: true,\n          }\n        );\n\n        return;\n      }\n    });\n  }\n\n  public printMetaMaskWarning() {\n    const message =\n      \"If you are using MetaMask, you can learn how to fix this error here: https://hardhat.org/metamask-issue\";\n\n    this._indent(() => {\n      this._print(message, { color: chalk.yellow });\n    });\n  }\n\n  public printMethod(method: string) {\n    if (this._shouldCollapseMethod(method)) {\n      this._methodCollapsedCount += 1;\n\n      this._print(chalk.green(`${method} (${this._methodCollapsedCount})`), {\n        collapsePrintedMethod: true,\n        replaceLastLine: true,\n      });\n    } else {\n      this._startCollapsingMethod(method);\n      this._print(method, { color: chalk.green, collapsePrintedMethod: true });\n    }\n  }\n\n  public printMethodNotSupported(method: string) {\n    this._print(`${method} - Method not supported`, { color: chalk.red });\n  }\n\n  public printEmptyLine() {\n    this._print(\"\");\n  }\n\n  public printUnknownError(err: Error) {\n    this._indent(() => {\n      this._printError(err);\n      this.printEmptyLine();\n\n      this._print(\n        \"If you think this is a bug in Hardhat, please report it here: https://hardhat.org/report-bug\"\n      );\n    });\n  }\n\n  private _format(msg: string, { color }: PrintOptions = {}): string {\n    if (msg === \"\") {\n      // don't indent empty lines\n      return msg;\n    }\n\n    if (this._currentIndent > 0) {\n      msg = msg\n        .split(\"\\n\")\n        .map((line) => \" \".repeat(this._currentIndent) + line)\n        .join(\"\\n\");\n    }\n\n    if (color !== undefined) {\n      return color(msg);\n    }\n\n    return msg;\n  }\n\n  private _indent<T>(cb: () => T, enabled = true) {\n    if (enabled) {\n      this._currentIndent += 2;\n    }\n    try {\n      return cb();\n    } finally {\n      if (enabled) {\n        this._currentIndent -= 2;\n      }\n    }\n  }\n\n  private _indentSingleLine(message: string): string {\n    return \" \".repeat(this._currentIndent) + message;\n  }\n\n  private _log(msg: string, printOptions: PrintOptions = {}) {\n    if (printOptions.collapsePrintedMethod !== true) {\n      this._stopCollapsingMethod();\n    }\n    if (printOptions.collapseIntervalMinedBlock !== true) {\n      this._emptyIntervalMinedBlocksRangeStart = undefined;\n    }\n    if (printOptions.collapseHardhatMinedBlock !== true) {\n      this._emptyHardhatMinedBlocksRangeStart = undefined;\n    }\n    const formattedMessage = this._format(msg, printOptions);\n\n    if (printOptions.replaceLastLine === true) {\n      this._logs[this._logs.length - 1] = formattedMessage;\n    } else {\n      this._logs.push(formattedMessage);\n    }\n  }\n\n  private _logError(err: Error) {\n    if (this.isLoggedError(err)) {\n      this.logEmptyLine();\n      this._log(util.inspect(err));\n    }\n  }\n\n  private _logTxInsideBlock(\n    tx: TypedTransaction,\n    txTrace: GatherTracesResult,\n    code: Buffer,\n    txGasUsed: bigint,\n    {\n      highlightTxHash,\n    }: {\n      highlightTxHash: boolean;\n    }\n  ) {\n    // indentAfterTransactionHash: true,\n    // printTxBlockNumber: false,\n    // startWithTxHash: true,\n    let txHash = bufferToHex(tx.hash());\n\n    if (highlightTxHash) {\n      txHash = chalk.bold(txHash);\n    }\n\n    this._logWithTitle(\"Transaction\", txHash);\n\n    this._indent(() => {\n      this._logContractAndFunctionName(txTrace.trace, code);\n      this._logTxFrom(tx.getSenderAddress().toBuffer());\n      this._logTxTo(tx.to?.toBuffer(), txTrace.trace);\n      this._logTxValue(tx.value);\n      this._logWithTitle(\"Gas used\", `${txGasUsed} of ${tx.gasLimit}`);\n\n      this._logConsoleLogMessages(txTrace.consoleLogMessages);\n\n      if (txTrace.error !== undefined) {\n        this._logError(txTrace.error);\n      }\n    });\n  }\n\n  /**\n   *  This should be the only function that calls _printLine and\n   *  _replaceLastLine (except for the special console.sol case),\n   *  because it's the only function that checks if the logger\n   *  is enabled.\n   */\n  private _print(msg: string, printOptions: PrintOptions = {}) {\n    if (!this._enabled) {\n      return;\n    }\n\n    if (printOptions.collapsePrintedMethod !== true) {\n      this._stopCollapsingMethod();\n    }\n    if (printOptions.collapseIntervalMinedBlock !== true) {\n      this._emptyIntervalMinedBlocksRangeStart = undefined;\n    }\n    if (printOptions.collapseHardhatMinedBlock !== true) {\n      this._emptyHardhatMinedBlocksRangeStart = undefined;\n    }\n    const formattedMessage = this._format(msg, printOptions);\n\n    if (printOptions.replaceLastLine === true) {\n      this._replaceLastLine(formattedMessage);\n    } else {\n      this._printLine(formattedMessage);\n    }\n  }\n\n  private _printError(err: Error) {\n    if (this.isLoggedError(err)) {\n      this.printEmptyLine();\n      this._print(util.inspect(err));\n    }\n  }\n\n  private _logContractAndFunctionName(\n    trace: MessageTrace | undefined,\n    code: Buffer,\n    {\n      printNonContractCalled = false,\n    }: { printNonContractCalled?: boolean } = {}\n  ) {\n    if (trace === undefined) {\n      return;\n    }\n\n    if (isPrecompileTrace(trace)) {\n      this._logWithTitle(\n        \"Precompile call\",\n        `<PrecompileContract ${trace.precompile}>`\n      );\n      return;\n    }\n\n    if (isCreateTrace(trace)) {\n      if (trace.bytecode === undefined) {\n        this._logWithTitle(\"Contract deployment\", UNRECOGNIZED_CONTRACT_NAME);\n      } else {\n        this._logWithTitle(\"Contract deployment\", trace.bytecode.contract.name);\n      }\n\n      if (trace.deployedContract !== undefined && trace.error === undefined) {\n        this._logWithTitle(\n          \"Contract address\",\n          bufferToHex(trace.deployedContract)\n        );\n      }\n\n      return;\n    }\n\n    if (code.length === 0) {\n      if (printNonContractCalled) {\n        this._log(`WARNING: Calling an account which is not a contract`);\n      }\n\n      return;\n    }\n\n    if (trace.bytecode === undefined) {\n      this._logWithTitle(\"Contract call\", UNRECOGNIZED_CONTRACT_NAME);\n      return;\n    }\n\n    const func = trace.bytecode.contract.getFunctionFromSelector(\n      trace.calldata.slice(0, 4)\n    );\n\n    const functionName: string =\n      func === undefined\n        ? UNRECOGNIZED_FUNCTION_NAME\n        : func.type === ContractFunctionType.FALLBACK\n        ? FALLBACK_FUNCTION_NAME\n        : func.type === ContractFunctionType.RECEIVE\n        ? RECEIVE_FUNCTION_NAME\n        : func.name;\n\n    this._logWithTitle(\n      \"Contract call\",\n      `${trace.bytecode.contract.name}#${functionName}`\n    );\n  }\n\n  private _shouldCollapseMethod(method: string) {\n    return (\n      method === this._methodBeingCollapsed &&\n      !this._hasLogs() &&\n      this._methodCollapsedCount > 0\n    );\n  }\n\n  private _startCollapsingMethod(method: string) {\n    this._methodBeingCollapsed = method;\n    this._methodCollapsedCount = 1;\n  }\n\n  private _stopCollapsingMethod() {\n    this._methodBeingCollapsed = undefined;\n    this._methodCollapsedCount = 0;\n  }\n\n  private _logTxTo(to: Buffer | undefined, trace?: MessageTrace) {\n    if (trace !== undefined && isCreateTrace(trace)) {\n      return;\n    }\n    if (to === undefined) {\n      // only for the type-checker, since `to` is undefined only when\n      // the message is a create trace\n      return;\n    }\n\n    const toString = bufferToHex(to);\n\n    this._logWithTitle(\"To\", toString);\n  }\n\n  private _logTxValue(value: bigint) {\n    this._logWithTitle(\"Value\", weiToHumanReadableString(value));\n  }\n\n  private _logTxFrom(from: Buffer) {\n    this._logWithTitle(\"From\", bufferToHex(from));\n  }\n\n  private _logBlockNumber(block: Block) {\n    this._log(`Block #${block.header.number}: ${bufferToHex(block.hash())}`);\n  }\n\n  private _logEmptyLineBetweenTransactions(\n    currentIndex: number,\n    totalTransactions: number\n  ) {\n    if (currentIndex + 1 < totalTransactions && totalTransactions > 1) {\n      this.logEmptyLine();\n    }\n  }\n\n  private _logBlockHash(block: Block) {\n    this._log(`Block: ${bufferToHex(block.hash())}`);\n  }\n\n  private _logConsoleLogMessages(messages: string[]) {\n    // This is a especial case, as we always want to print the console.log\n    // messages. The difference is how.\n    // If we have a logger, we should use that, so that logs are printed in\n    // order. If we don't, we just print the messages here.\n    if (!this._enabled) {\n      for (const msg of messages) {\n        this._printLine(msg);\n      }\n      return;\n    }\n\n    if (messages.length === 0) {\n      return;\n    }\n\n    this.logEmptyLine();\n    this._log(\"console.log:\");\n\n    for (const msg of messages) {\n      this._log(`  ${msg}`);\n    }\n  }\n\n  private _logWithTitle(title: string, message: string) {\n    title = this._indentSingleLine(title);\n\n    // We always use the max title length we've seen. Otherwise the value move\n    // a lot with each tx/call.\n    if (title.length > this._titleLength) {\n      this._titleLength = title.length;\n    }\n\n    this._logs.push([title, message]);\n  }\n\n  private _clearLogs() {\n    this._logs = [];\n  }\n\n  private _hasLogs(): boolean {\n    return this._logs.length > 0;\n  }\n\n  private _getLogs(): string[] {\n    return this._logs.map((l) => {\n      if (typeof l === \"string\") {\n        return l;\n      }\n\n      const title = `${l[0]}:`;\n\n      return `${title.padEnd(this._titleLength + 1)} ${l[1]}`;\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"script"}