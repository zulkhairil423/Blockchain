{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSwcOptions = exports.targetMapping = exports.create = void 0;\n\nfunction create(createOptions) {\n  const {\n    swc,\n    service: {\n      config,\n      projectLocalResolveHelper\n    },\n    transpilerConfigLocalResolveHelper,\n    nodeModuleEmitKind\n  } = createOptions; // Load swc compiler\n\n  let swcInstance; // Used later in diagnostics; merely needs to be human-readable.\n\n  let swcDepName = 'swc';\n\n  if (typeof swc === 'string') {\n    swcDepName = swc;\n    swcInstance = require(transpilerConfigLocalResolveHelper(swc, true));\n  } else if (swc == null) {\n    let swcResolved;\n\n    try {\n      swcDepName = '@swc/core';\n      swcResolved = transpilerConfigLocalResolveHelper(swcDepName, true);\n    } catch (e) {\n      try {\n        swcDepName = '@swc/wasm';\n        swcResolved = transpilerConfigLocalResolveHelper(swcDepName, true);\n      } catch (e) {\n        throw new Error('swc compiler requires either @swc/core or @swc/wasm to be installed as a dependency.  See https://typestrong.org/ts-node/docs/transpilers');\n      }\n    }\n\n    swcInstance = require(swcResolved);\n  } else {\n    swcInstance = swc;\n  } // Prepare SWC options derived from typescript compiler options\n\n\n  const {\n    nonTsxOptions,\n    tsxOptions\n  } = createSwcOptions(config.options, nodeModuleEmitKind, swcInstance, swcDepName);\n\n  const transpile = (input, transpileOptions) => {\n    const {\n      fileName\n    } = transpileOptions;\n    const swcOptions = fileName.endsWith('.tsx') || fileName.endsWith('.jsx') ? tsxOptions : nonTsxOptions;\n    const {\n      code,\n      map\n    } = swcInstance.transformSync(input, { ...swcOptions,\n      filename: fileName\n    });\n    return {\n      outputText: code,\n      sourceMapText: map\n    };\n  };\n\n  return {\n    transpile\n  };\n}\n\nexports.create = create;\n/** @internal */\n\nexports.targetMapping = new Map();\nexports.targetMapping.set(\n/* ts.ScriptTarget.ES3 */\n0, 'es3');\nexports.targetMapping.set(\n/* ts.ScriptTarget.ES5 */\n1, 'es5');\nexports.targetMapping.set(\n/* ts.ScriptTarget.ES2015 */\n2, 'es2015');\nexports.targetMapping.set(\n/* ts.ScriptTarget.ES2016 */\n3, 'es2016');\nexports.targetMapping.set(\n/* ts.ScriptTarget.ES2017 */\n4, 'es2017');\nexports.targetMapping.set(\n/* ts.ScriptTarget.ES2018 */\n5, 'es2018');\nexports.targetMapping.set(\n/* ts.ScriptTarget.ES2019 */\n6, 'es2019');\nexports.targetMapping.set(\n/* ts.ScriptTarget.ES2020 */\n7, 'es2020');\nexports.targetMapping.set(\n/* ts.ScriptTarget.ES2021 */\n8, 'es2021');\nexports.targetMapping.set(\n/* ts.ScriptTarget.ES2022 */\n9, 'es2022');\nexports.targetMapping.set(\n/* ts.ScriptTarget.ESNext */\n99, 'es2022');\n/**\n * @internal\n * We use this list to downgrade to a prior target when we probe swc to detect if it supports a particular target\n */\n\nconst swcTargets = ['es3', 'es5', 'es2015', 'es2016', 'es2017', 'es2018', 'es2019', 'es2020', 'es2021', 'es2022'];\nconst ModuleKind = {\n  None: 0,\n  CommonJS: 1,\n  AMD: 2,\n  UMD: 3,\n  System: 4,\n  ES2015: 5,\n  ES2020: 6,\n  ESNext: 99,\n  Node16: 100,\n  NodeNext: 199\n};\nconst JsxEmit = {\n  ReactJSX:\n  /* ts.JsxEmit.ReactJSX */\n  4,\n  ReactJSXDev:\n  /* ts.JsxEmit.ReactJSXDev */\n  5\n};\n/**\n * Prepare SWC options derived from typescript compiler options.\n * @internal exported for testing\n */\n\nfunction createSwcOptions(compilerOptions, nodeModuleEmitKind, swcInstance, swcDepName) {\n  var _a;\n\n  const {\n    esModuleInterop,\n    sourceMap,\n    importHelpers,\n    experimentalDecorators,\n    emitDecoratorMetadata,\n    target,\n    module,\n    jsx,\n    jsxFactory,\n    jsxFragmentFactory,\n    strict,\n    alwaysStrict,\n    noImplicitUseStrict\n  } = compilerOptions;\n  let swcTarget = (_a = exports.targetMapping.get(target)) !== null && _a !== void 0 ? _a : 'es3'; // Downgrade to lower target if swc does not support the selected target.\n  // Perhaps project has an older version of swc.\n  // TODO cache the results of this; slightly faster\n\n  let swcTargetIndex = swcTargets.indexOf(swcTarget);\n\n  for (; swcTargetIndex >= 0; swcTargetIndex--) {\n    try {\n      swcInstance.transformSync('', {\n        jsc: {\n          target: swcTargets[swcTargetIndex]\n        }\n      });\n      break;\n    } catch (e) {}\n  }\n\n  swcTarget = swcTargets[swcTargetIndex];\n  const keepClassNames = target >=\n  /* ts.ScriptTarget.ES2016 */\n  3;\n  const isNodeModuleKind = module === ModuleKind.Node16 || module === ModuleKind.NodeNext; // swc only supports these 4x module options [MUST_UPDATE_FOR_NEW_MODULEKIND]\n\n  const moduleType = module === ModuleKind.CommonJS ? 'commonjs' : module === ModuleKind.AMD ? 'amd' : module === ModuleKind.UMD ? 'umd' : isNodeModuleKind && nodeModuleEmitKind === 'nodecjs' ? 'commonjs' : isNodeModuleKind && nodeModuleEmitKind === 'nodeesm' ? 'es6' : 'es6'; // In swc:\n  //   strictMode means `\"use strict\"` is *always* emitted for non-ES module, *never* for ES module where it is assumed it can be omitted.\n  //   (this assumption is invalid, but that's the way swc behaves)\n  // tsc is a bit more complex:\n  //   alwaysStrict will force emitting it always unless `import`/`export` syntax is emitted which implies it per the JS spec.\n  //   if not alwaysStrict, will emit implicitly whenever module target is non-ES *and* transformed module syntax is emitted.\n  // For node, best option is to assume that all scripts are modules (commonjs or esm) and thus should get tsc's implicit strict behavior.\n  // Always set strictMode, *unless* alwaysStrict is disabled and noImplicitUseStrict is enabled\n\n  const strictMode = // if `alwaysStrict` is disabled, remembering that `strict` defaults `alwaysStrict` to true\n  (alwaysStrict === false || alwaysStrict !== true && strict !== true) && // if noImplicitUseStrict is enabled\n  noImplicitUseStrict === true ? false : true;\n  const jsxRuntime = jsx === JsxEmit.ReactJSX || jsx === JsxEmit.ReactJSXDev ? 'automatic' : undefined;\n  const jsxDevelopment = jsx === JsxEmit.ReactJSXDev ? true : undefined;\n  const nonTsxOptions = createVariant(false);\n  const tsxOptions = createVariant(true);\n  return {\n    nonTsxOptions,\n    tsxOptions\n  };\n\n  function createVariant(isTsx) {\n    const swcOptions = {\n      sourceMaps: sourceMap,\n      // isModule: true,\n      module: moduleType ? {\n        noInterop: !esModuleInterop,\n        type: moduleType,\n        strictMode,\n        // For NodeNext and Node12, emit as CJS but do not transform dynamic imports\n        ignoreDynamic: nodeModuleEmitKind === 'nodecjs'\n      } : undefined,\n      swcrc: false,\n      jsc: {\n        externalHelpers: importHelpers,\n        parser: {\n          syntax: 'typescript',\n          tsx: isTsx,\n          decorators: experimentalDecorators,\n          dynamicImport: true,\n          importAssertions: true\n        },\n        target: swcTarget,\n        transform: {\n          decoratorMetadata: emitDecoratorMetadata,\n          legacyDecorator: true,\n          react: {\n            throwIfNamespace: false,\n            development: jsxDevelopment,\n            useBuiltins: false,\n            pragma: jsxFactory,\n            pragmaFrag: jsxFragmentFactory,\n            runtime: jsxRuntime\n          }\n        },\n        keepClassNames,\n        experimental: {\n          keepImportAssertions: true\n        }\n      }\n    }; // Throw a helpful error if swc version is old, for example, if it rejects `ignoreDynamic`\n\n    try {\n      swcInstance.transformSync('', swcOptions);\n    } catch (e) {\n      throw new Error(`${swcDepName} threw an error when attempting to validate swc compiler options.\\n` + 'You may be using an old version of swc which does not support the options used by ts-node.\\n' + 'Try upgrading to the latest version of swc.\\n' + 'Error message from swc:\\n' + (e === null || e === void 0 ? void 0 : e.message));\n    }\n\n    return swcOptions;\n  }\n}\n\nexports.createSwcOptions = createSwcOptions;","map":{"version":3,"mappings":";;;;;;;AAgBA,SAAgBA,MAAhB,CAAuBC,aAAvB,EAA0D;EACxD,MAAM;IACJC,GADI;IAEJC,OAAO,EAAE;MAAEC,MAAF;MAAUC;IAAV,CAFL;IAGJC,kCAHI;IAIJC;EAJI,IAKFN,aALJ,CADwD,CAQxD;;EACA,IAAIO,WAAJ,CATwD,CAUxD;;EACA,IAAIC,UAAU,GAAW,KAAzB;;EACA,IAAI,OAAOP,GAAP,KAAe,QAAnB,EAA6B;IAC3BO,UAAU,GAAGP,GAAb;IACAM,WAAW,GAAGE,OAAO,CAACJ,kCAAkC,CACtDJ,GADsD,EAEtD,IAFsD,CAAnC,CAArB;EAID,CAND,MAMO,IAAIA,GAAG,IAAI,IAAX,EAAiB;IACtB,IAAIS,WAAJ;;IACA,IAAI;MACFF,UAAU,GAAG,WAAb;MACAE,WAAW,GAAGL,kCAAkC,CAACG,UAAD,EAAa,IAAb,CAAhD;IACD,CAHD,CAGE,OAAOG,CAAP,EAAU;MACV,IAAI;QACFH,UAAU,GAAG,WAAb;QACAE,WAAW,GAAGL,kCAAkC,CAACG,UAAD,EAAa,IAAb,CAAhD;MACD,CAHD,CAGE,OAAOG,CAAP,EAAU;QACV,MAAM,IAAIC,KAAJ,CACJ,2IADI,CAAN;MAGD;IACF;;IACDL,WAAW,GAAGE,OAAO,CAACC,WAAD,CAArB;EACD,CAhBM,MAgBA;IACLH,WAAW,GAAGN,GAAd;EACD,CApCuD,CAsCxD;;;EACA,MAAM;IAAEY,aAAF;IAAiBC;EAAjB,IAAgCC,gBAAgB,CACpDZ,MAAM,CAACa,OAD6C,EAEpDV,kBAFoD,EAGpDC,WAHoD,EAIpDC,UAJoD,CAAtD;;EAOA,MAAMS,SAAS,GAA4B,CAACC,KAAD,EAAQC,gBAAR,KAA4B;IACrE,MAAM;MAAEC;IAAF,IAAeD,gBAArB;IACA,MAAME,UAAU,GACdD,QAAQ,CAACE,QAAT,CAAkB,MAAlB,KAA6BF,QAAQ,CAACE,QAAT,CAAkB,MAAlB,CAA7B,GACIR,UADJ,GAEID,aAHN;IAIA,MAAM;MAAEU,IAAF;MAAQC;IAAR,IAAgBjB,WAAW,CAACkB,aAAZ,CAA0BP,KAA1B,EAAiC,EACrD,GAAGG,UADkD;MAErDK,QAAQ,EAAEN;IAF2C,CAAjC,CAAtB;IAIA,OAAO;MAAEO,UAAU,EAAEJ,IAAd;MAAoBK,aAAa,EAAEJ;IAAnC,CAAP;EACD,CAXD;;EAaA,OAAO;IACLP;EADK,CAAP;AAGD;;AA9DDY;AAgEA;;AACaA,wBAAgB,IAAIC,GAAJ,EAAhB;AACbD,sBAAcE,GAAd;AAAkB;AAA0B,CAA5C,EAA+C,KAA/C;AACAF,sBAAcE,GAAd;AAAkB;AAA0B,CAA5C,EAA+C,KAA/C;AACAF,sBAAcE,GAAd;AAAkB;AAA6B,CAA/C,EAAkD,QAAlD;AACAF,sBAAcE,GAAd;AAAkB;AAA6B,CAA/C,EAAkD,QAAlD;AACAF,sBAAcE,GAAd;AAAkB;AAA6B,CAA/C,EAAkD,QAAlD;AACAF,sBAAcE,GAAd;AAAkB;AAA6B,CAA/C,EAAkD,QAAlD;AACAF,sBAAcE,GAAd;AAAkB;AAA6B,CAA/C,EAAkD,QAAlD;AACAF,sBAAcE,GAAd;AAAkB;AAA6B,CAA/C,EAAkD,QAAlD;AACAF,sBAAcE,GAAd;AAAkB;AAA6B,CAA/C,EAAkD,QAAlD;AACAF,sBAAcE,GAAd;AAAkB;AAA6B,CAA/C,EAAkD,QAAlD;AACAF,sBAAcE,GAAd;AAAkB;AAA6B,EAA/C,EAAmD,QAAnD;AAGA;;;;;AAIA,MAAMC,UAAU,GAAG,CACjB,KADiB,EAEjB,KAFiB,EAGjB,QAHiB,EAIjB,QAJiB,EAKjB,QALiB,EAMjB,QANiB,EAOjB,QAPiB,EAQjB,QARiB,EASjB,QATiB,EAUjB,QAViB,CAAnB;AAaA,MAAMC,UAAU,GAAG;EACjBC,IAAI,EAAE,CADW;EAEjBC,QAAQ,EAAE,CAFO;EAGjBC,GAAG,EAAE,CAHY;EAIjBC,GAAG,EAAE,CAJY;EAKjBC,MAAM,EAAE,CALS;EAMjBC,MAAM,EAAE,CANS;EAOjBC,MAAM,EAAE,CAPS;EAQjBC,MAAM,EAAE,EARS;EASjBC,MAAM,EAAE,GATS;EAUjBC,QAAQ,EAAE;AAVO,CAAnB;AAaA,MAAMC,OAAO,GAAG;EACdC,QAAQ;EAAE;EAA0B,CADtB;EAEdC,WAAW;EAAE;EAA6B;AAF5B,CAAhB;AAKA;;;;;AAIA,SAAgB/B,gBAAhB,CACEgC,eADF,EAEEzC,kBAFF,EAGEC,WAHF,EAIEC,UAJF,EAIoB;;;EAElB,MAAM;IACJwC,eADI;IAEJC,SAFI;IAGJC,aAHI;IAIJC,sBAJI;IAKJC,qBALI;IAMJC,MANI;IAOJC,MAPI;IAQJC,GARI;IASJC,UATI;IAUJC,kBAVI;IAWJC,MAXI;IAYJC,YAZI;IAaJC;EAbI,IAcFb,eAdJ;EAgBA,IAAIc,SAAS,GAAG,4BAAcC,GAAd,CAAkBT,MAAlB,OAA0B,IAA1B,IAA0BU,aAA1B,GAA0BA,EAA1B,GAA8B,KAA9C,CAlBkB,CAmBlB;EACA;EACA;;EACA,IAAIC,cAAc,GAAGhC,UAAU,CAACiC,OAAX,CAAmBJ,SAAnB,CAArB;;EACA,OAAOG,cAAc,IAAI,CAAzB,EAA4BA,cAAc,EAA1C,EAA8C;IAC5C,IAAI;MACFzD,WAAW,CAACkB,aAAZ,CAA0B,EAA1B,EAA8B;QAC5ByC,GAAG,EAAE;UAAEb,MAAM,EAAErB,UAAU,CAACgC,cAAD;QAApB;MADuB,CAA9B;MAGA;IACD,CALD,CAKE,OAAOrD,CAAP,EAAU,CAAE;EACf;;EACDkD,SAAS,GAAG7B,UAAU,CAACgC,cAAD,CAAtB;EACA,MAAMG,cAAc,GAAGd,MAAO;EAAI;EAA6B,CAA/D;EACA,MAAMe,gBAAgB,GACpBd,MAAM,KAAKrB,UAAU,CAACS,MAAtB,IAAgCY,MAAM,KAAKrB,UAAU,CAACU,QADxD,CAjCkB,CAmClB;;EACA,MAAM0B,UAAU,GACdf,MAAM,KAAKrB,UAAU,CAACE,QAAtB,GACI,UADJ,GAEImB,MAAM,KAAKrB,UAAU,CAACG,GAAtB,GACA,KADA,GAEAkB,MAAM,KAAKrB,UAAU,CAACI,GAAtB,GACA,KADA,GAEA+B,gBAAgB,IAAI9D,kBAAkB,KAAK,SAA3C,GACA,UADA,GAEA8D,gBAAgB,IAAI9D,kBAAkB,KAAK,SAA3C,GACA,KADA,GAEA,KAXN,CApCkB,CAgDlB;EACA;EACA;EACA;EACA;EACA;EACA;EAEA;;EACA,MAAMgE,UAAU,GACd;EACA,CAACX,YAAY,KAAK,KAAjB,IAA2BA,YAAY,KAAK,IAAjB,IAAyBD,MAAM,KAAK,IAAhE,KACA;EACAE,mBAAmB,KAAK,IAFxB,GAGI,KAHJ,GAII,IANN;EAQA,MAAMW,UAAU,GACdhB,GAAG,KAAKX,OAAO,CAACC,QAAhB,IAA4BU,GAAG,KAAKX,OAAO,CAACE,WAA5C,GACI,WADJ,GAEI0B,SAHN;EAIA,MAAMC,cAAc,GAClBlB,GAAG,KAAKX,OAAO,CAACE,WAAhB,GAA8B,IAA9B,GAAqC0B,SADvC;EAGA,MAAM3D,aAAa,GAAG6D,aAAa,CAAC,KAAD,CAAnC;EACA,MAAM5D,UAAU,GAAG4D,aAAa,CAAC,IAAD,CAAhC;EACA,OAAO;IAAE7D,aAAF;IAAiBC;EAAjB,CAAP;;EAEA,SAAS4D,aAAT,CAAuBC,KAAvB,EAAqC;IACnC,MAAMtD,UAAU,GAAqB;MACnCuD,UAAU,EAAE3B,SADuB;MAEnC;MACAK,MAAM,EAAEe,UAAU,GACb;QACCQ,SAAS,EAAE,CAAC7B,eADb;QAEC8B,IAAI,EAAET,UAFP;QAGCC,UAHD;QAIC;QACAS,aAAa,EAAEzE,kBAAkB,KAAK;MALvC,CADa,GAQdkE,SAX+B;MAYnCQ,KAAK,EAAE,KAZ4B;MAanCd,GAAG,EAAE;QACHe,eAAe,EAAE/B,aADd;QAEHgC,MAAM,EAAE;UACNC,MAAM,EAAE,YADF;UAENC,GAAG,EAAET,KAFC;UAGNU,UAAU,EAAElC,sBAHN;UAINmC,aAAa,EAAE,IAJT;UAKNC,gBAAgB,EAAE;QALZ,CAFL;QASHlC,MAAM,EAAEQ,SATL;QAUH2B,SAAS,EAAE;UACTC,iBAAiB,EAAErC,qBADV;UAETsC,eAAe,EAAE,IAFR;UAGTC,KAAK,EAAE;YACLC,gBAAgB,EAAE,KADb;YAELC,WAAW,EAAEpB,cAFR;YAGLqB,WAAW,EAAE,KAHR;YAILC,MAAM,EAAEvC,UAJH;YAKLwC,UAAU,EAAEvC,kBALP;YAMLwC,OAAO,EAAE1B;UANJ;QAHE,CAVR;QAsBHJ,cAtBG;QAuBH+B,YAAY,EAAE;UACZC,oBAAoB,EAAE;QADV;MAvBX;IAb8B,CAArC,CADmC,CA2CnC;;IACA,IAAI;MACF5F,WAAW,CAACkB,aAAZ,CAA0B,EAA1B,EAA8BJ,UAA9B;IACD,CAFD,CAEE,OAAOV,CAAP,EAAU;MACV,MAAM,IAAIC,KAAJ,CACJ,GAAGJ,UAAU,qEAAb,GACE,8FADF,GAEE,+CAFF,GAGE,2BAHF,IAIGG,CAAW,SAAX,KAAC,WAAD,GAAC,MAAD,IAAC,CAAYyF,OAJhB,CADI,CAAN;IAOD;;IAED,OAAO/E,UAAP;EACD;AACF;;AA1IDQ","names":["create","createOptions","swc","service","config","projectLocalResolveHelper","transpilerConfigLocalResolveHelper","nodeModuleEmitKind","swcInstance","swcDepName","require","swcResolved","e","Error","nonTsxOptions","tsxOptions","createSwcOptions","options","transpile","input","transpileOptions","fileName","swcOptions","endsWith","code","map","transformSync","filename","outputText","sourceMapText","exports","Map","set","swcTargets","ModuleKind","None","CommonJS","AMD","UMD","System","ES2015","ES2020","ESNext","Node16","NodeNext","JsxEmit","ReactJSX","ReactJSXDev","compilerOptions","esModuleInterop","sourceMap","importHelpers","experimentalDecorators","emitDecoratorMetadata","target","module","jsx","jsxFactory","jsxFragmentFactory","strict","alwaysStrict","noImplicitUseStrict","swcTarget","get","_a","swcTargetIndex","indexOf","jsc","keepClassNames","isNodeModuleKind","moduleType","strictMode","jsxRuntime","undefined","jsxDevelopment","createVariant","isTsx","sourceMaps","noInterop","type","ignoreDynamic","swcrc","externalHelpers","parser","syntax","tsx","decorators","dynamicImport","importAssertions","transform","decoratorMetadata","legacyDecorator","react","throwIfNamespace","development","useBuiltins","pragma","pragmaFrag","runtime","experimental","keepImportAssertions","message"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\ts-node\\src\\transpilers\\swc.ts"],"sourcesContent":["import type * as ts from 'typescript';\nimport type * as swcWasm from '@swc/wasm';\nimport type * as swcTypes from '@swc/core';\nimport type { CreateTranspilerOptions, Transpiler } from './types';\nimport type { NodeModuleEmitKind } from '..';\n\ntype SwcInstance = typeof swcWasm;\nexport interface SwcTranspilerOptions extends CreateTranspilerOptions {\n  /**\n   * swc compiler to use for compilation\n   * Set to '@swc/wasm' to use swc's WASM compiler\n   * Default: '@swc/core', falling back to '@swc/wasm'\n   */\n  swc?: string | typeof swcWasm;\n}\n\nexport function create(createOptions: SwcTranspilerOptions): Transpiler {\n  const {\n    swc,\n    service: { config, projectLocalResolveHelper },\n    transpilerConfigLocalResolveHelper,\n    nodeModuleEmitKind,\n  } = createOptions;\n\n  // Load swc compiler\n  let swcInstance: SwcInstance;\n  // Used later in diagnostics; merely needs to be human-readable.\n  let swcDepName: string = 'swc';\n  if (typeof swc === 'string') {\n    swcDepName = swc;\n    swcInstance = require(transpilerConfigLocalResolveHelper(\n      swc,\n      true\n    )) as typeof swcWasm;\n  } else if (swc == null) {\n    let swcResolved;\n    try {\n      swcDepName = '@swc/core';\n      swcResolved = transpilerConfigLocalResolveHelper(swcDepName, true);\n    } catch (e) {\n      try {\n        swcDepName = '@swc/wasm';\n        swcResolved = transpilerConfigLocalResolveHelper(swcDepName, true);\n      } catch (e) {\n        throw new Error(\n          'swc compiler requires either @swc/core or @swc/wasm to be installed as a dependency.  See https://typestrong.org/ts-node/docs/transpilers'\n        );\n      }\n    }\n    swcInstance = require(swcResolved) as typeof swcWasm;\n  } else {\n    swcInstance = swc;\n  }\n\n  // Prepare SWC options derived from typescript compiler options\n  const { nonTsxOptions, tsxOptions } = createSwcOptions(\n    config.options,\n    nodeModuleEmitKind,\n    swcInstance,\n    swcDepName\n  );\n\n  const transpile: Transpiler['transpile'] = (input, transpileOptions) => {\n    const { fileName } = transpileOptions;\n    const swcOptions =\n      fileName.endsWith('.tsx') || fileName.endsWith('.jsx')\n        ? tsxOptions\n        : nonTsxOptions;\n    const { code, map } = swcInstance.transformSync(input, {\n      ...swcOptions,\n      filename: fileName,\n    });\n    return { outputText: code, sourceMapText: map };\n  };\n\n  return {\n    transpile,\n  };\n}\n\n/** @internal */\nexport const targetMapping = new Map<ts.ScriptTarget, SwcTarget>();\ntargetMapping.set(/* ts.ScriptTarget.ES3 */ 0, 'es3');\ntargetMapping.set(/* ts.ScriptTarget.ES5 */ 1, 'es5');\ntargetMapping.set(/* ts.ScriptTarget.ES2015 */ 2, 'es2015');\ntargetMapping.set(/* ts.ScriptTarget.ES2016 */ 3, 'es2016');\ntargetMapping.set(/* ts.ScriptTarget.ES2017 */ 4, 'es2017');\ntargetMapping.set(/* ts.ScriptTarget.ES2018 */ 5, 'es2018');\ntargetMapping.set(/* ts.ScriptTarget.ES2019 */ 6, 'es2019');\ntargetMapping.set(/* ts.ScriptTarget.ES2020 */ 7, 'es2020');\ntargetMapping.set(/* ts.ScriptTarget.ES2021 */ 8, 'es2021');\ntargetMapping.set(/* ts.ScriptTarget.ES2022 */ 9, 'es2022');\ntargetMapping.set(/* ts.ScriptTarget.ESNext */ 99, 'es2022');\n\ntype SwcTarget = typeof swcTargets[number];\n/**\n * @internal\n * We use this list to downgrade to a prior target when we probe swc to detect if it supports a particular target\n */\nconst swcTargets = [\n  'es3',\n  'es5',\n  'es2015',\n  'es2016',\n  'es2017',\n  'es2018',\n  'es2019',\n  'es2020',\n  'es2021',\n  'es2022',\n] as const;\n\nconst ModuleKind = {\n  None: 0,\n  CommonJS: 1,\n  AMD: 2,\n  UMD: 3,\n  System: 4,\n  ES2015: 5,\n  ES2020: 6,\n  ESNext: 99,\n  Node16: 100,\n  NodeNext: 199,\n} as const;\n\nconst JsxEmit = {\n  ReactJSX: /* ts.JsxEmit.ReactJSX */ 4,\n  ReactJSXDev: /* ts.JsxEmit.ReactJSXDev */ 5,\n} as const;\n\n/**\n * Prepare SWC options derived from typescript compiler options.\n * @internal exported for testing\n */\nexport function createSwcOptions(\n  compilerOptions: ts.CompilerOptions,\n  nodeModuleEmitKind: NodeModuleEmitKind | undefined,\n  swcInstance: SwcInstance,\n  swcDepName: string\n) {\n  const {\n    esModuleInterop,\n    sourceMap,\n    importHelpers,\n    experimentalDecorators,\n    emitDecoratorMetadata,\n    target,\n    module,\n    jsx,\n    jsxFactory,\n    jsxFragmentFactory,\n    strict,\n    alwaysStrict,\n    noImplicitUseStrict,\n  } = compilerOptions;\n\n  let swcTarget = targetMapping.get(target!) ?? 'es3';\n  // Downgrade to lower target if swc does not support the selected target.\n  // Perhaps project has an older version of swc.\n  // TODO cache the results of this; slightly faster\n  let swcTargetIndex = swcTargets.indexOf(swcTarget);\n  for (; swcTargetIndex >= 0; swcTargetIndex--) {\n    try {\n      swcInstance.transformSync('', {\n        jsc: { target: swcTargets[swcTargetIndex] },\n      });\n      break;\n    } catch (e) {}\n  }\n  swcTarget = swcTargets[swcTargetIndex];\n  const keepClassNames = target! >= /* ts.ScriptTarget.ES2016 */ 3;\n  const isNodeModuleKind =\n    module === ModuleKind.Node16 || module === ModuleKind.NodeNext;\n  // swc only supports these 4x module options [MUST_UPDATE_FOR_NEW_MODULEKIND]\n  const moduleType =\n    module === ModuleKind.CommonJS\n      ? 'commonjs'\n      : module === ModuleKind.AMD\n      ? 'amd'\n      : module === ModuleKind.UMD\n      ? 'umd'\n      : isNodeModuleKind && nodeModuleEmitKind === 'nodecjs'\n      ? 'commonjs'\n      : isNodeModuleKind && nodeModuleEmitKind === 'nodeesm'\n      ? 'es6'\n      : 'es6';\n  // In swc:\n  //   strictMode means `\"use strict\"` is *always* emitted for non-ES module, *never* for ES module where it is assumed it can be omitted.\n  //   (this assumption is invalid, but that's the way swc behaves)\n  // tsc is a bit more complex:\n  //   alwaysStrict will force emitting it always unless `import`/`export` syntax is emitted which implies it per the JS spec.\n  //   if not alwaysStrict, will emit implicitly whenever module target is non-ES *and* transformed module syntax is emitted.\n  // For node, best option is to assume that all scripts are modules (commonjs or esm) and thus should get tsc's implicit strict behavior.\n\n  // Always set strictMode, *unless* alwaysStrict is disabled and noImplicitUseStrict is enabled\n  const strictMode =\n    // if `alwaysStrict` is disabled, remembering that `strict` defaults `alwaysStrict` to true\n    (alwaysStrict === false || (alwaysStrict !== true && strict !== true)) &&\n    // if noImplicitUseStrict is enabled\n    noImplicitUseStrict === true\n      ? false\n      : true;\n\n  const jsxRuntime: swcTypes.ReactConfig['runtime'] =\n    jsx === JsxEmit.ReactJSX || jsx === JsxEmit.ReactJSXDev\n      ? 'automatic'\n      : undefined;\n  const jsxDevelopment: swcTypes.ReactConfig['development'] =\n    jsx === JsxEmit.ReactJSXDev ? true : undefined;\n\n  const nonTsxOptions = createVariant(false);\n  const tsxOptions = createVariant(true);\n  return { nonTsxOptions, tsxOptions };\n\n  function createVariant(isTsx: boolean): swcTypes.Options {\n    const swcOptions: swcTypes.Options = {\n      sourceMaps: sourceMap,\n      // isModule: true,\n      module: moduleType\n        ? ({\n            noInterop: !esModuleInterop,\n            type: moduleType,\n            strictMode,\n            // For NodeNext and Node12, emit as CJS but do not transform dynamic imports\n            ignoreDynamic: nodeModuleEmitKind === 'nodecjs',\n          } as swcTypes.ModuleConfig)\n        : undefined,\n      swcrc: false,\n      jsc: {\n        externalHelpers: importHelpers,\n        parser: {\n          syntax: 'typescript',\n          tsx: isTsx,\n          decorators: experimentalDecorators,\n          dynamicImport: true,\n          importAssertions: true,\n        },\n        target: swcTarget,\n        transform: {\n          decoratorMetadata: emitDecoratorMetadata,\n          legacyDecorator: true,\n          react: {\n            throwIfNamespace: false,\n            development: jsxDevelopment,\n            useBuiltins: false,\n            pragma: jsxFactory!,\n            pragmaFrag: jsxFragmentFactory!,\n            runtime: jsxRuntime,\n          } as swcTypes.ReactConfig,\n        },\n        keepClassNames,\n        experimental: {\n          keepImportAssertions: true,\n        },\n      } as swcTypes.JscConfig,\n    };\n\n    // Throw a helpful error if swc version is old, for example, if it rejects `ignoreDynamic`\n    try {\n      swcInstance.transformSync('', swcOptions);\n    } catch (e) {\n      throw new Error(\n        `${swcDepName} threw an error when attempting to validate swc compiler options.\\n` +\n          'You may be using an old version of swc which does not support the options used by ts-node.\\n' +\n          'Try upgrading to the latest version of swc.\\n' +\n          'Error message from swc:\\n' +\n          (e as Error)?.message\n      );\n    }\n\n    return swcOptions;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}