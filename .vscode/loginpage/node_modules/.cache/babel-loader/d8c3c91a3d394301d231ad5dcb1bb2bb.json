{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CompilerDownloader = exports.CompilerPlatform = void 0;\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst os_1 = __importDefault(require(\"os\"));\n\nconst child_process_1 = require(\"child_process\");\n\nconst util_1 = require(\"util\");\n\nconst download_1 = require(\"../../util/download\");\n\nconst errors_1 = require(\"../../core/errors\");\n\nconst errors_list_1 = require(\"../../core/errors-list\");\n\nconst await_semaphore_1 = require(\"../../vendor/await-semaphore\");\n\nconst log = (0, debug_1.default)(\"hardhat:core:solidity:downloader\");\nconst COMPILER_REPOSITORY_URL = \"https://binaries.soliditylang.org\";\nvar CompilerPlatform;\n\n(function (CompilerPlatform) {\n  CompilerPlatform[\"LINUX\"] = \"linux-amd64\";\n  CompilerPlatform[\"WINDOWS\"] = \"windows-amd64\";\n  CompilerPlatform[\"MACOS\"] = \"macosx-amd64\";\n  CompilerPlatform[\"WASM\"] = \"wasm\";\n})(CompilerPlatform = exports.CompilerPlatform || (exports.CompilerPlatform = {}));\n/**\n * Default implementation of ICompilerDownloader.\n *\n * Important things to note:\n *   1. If a compiler version is not found, this downloader may fail.\n *    1.1. It only re-downloads the list of compilers once every X time.\n *      1.1.1 If a user tries to download a new compiler before X amount of time\n *      has passed since its release, they may need to clean the cache, as\n *      indicated in the error messages.\n */\n\n\nclass CompilerDownloader {\n  /**\n   * Use CompilerDownloader.getConcurrencySafeDownloader instead\n   */\n  constructor(_platform, _compilersDir) {\n    let _compilerListCachePeriodMs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : CompilerDownloader.defaultCompilerListCachePeriod;\n\n    let _downloadFunction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : download_1.download;\n\n    this._platform = _platform;\n    this._compilersDir = _compilersDir;\n    this._compilerListCachePeriodMs = _compilerListCachePeriodMs;\n    this._downloadFunction = _downloadFunction;\n    this._mutex = new await_semaphore_1.Mutex();\n  }\n\n  static getCompilerPlatform() {\n    // TODO: This check is seriously wrong. It doesn't take into account\n    //  the architecture nor the toolchain. This should check the triplet of\n    //  system instead (see: https://wiki.osdev.org/Target_Triplet).\n    //\n    //  The only reason this downloader works is that it validates if the\n    //  binaries actually run.\n    switch (os_1.default.platform()) {\n      case \"win32\":\n        return CompilerPlatform.WINDOWS;\n\n      case \"linux\":\n        return CompilerPlatform.LINUX;\n\n      case \"darwin\":\n        return CompilerPlatform.MACOS;\n\n      default:\n        return CompilerPlatform.WASM;\n    }\n  }\n\n  static getConcurrencySafeDownloader(platform, compilersDir) {\n    const key = platform + compilersDir;\n\n    if (!this._downloaderPerPlatform.has(key)) {\n      this._downloaderPerPlatform.set(key, new CompilerDownloader(platform, compilersDir));\n    }\n\n    return this._downloaderPerPlatform.get(key);\n  }\n\n  async isCompilerDownloaded(version) {\n    const build = await this._getCompilerBuild(version);\n\n    if (build === undefined) {\n      return false;\n    }\n\n    const downloadPath = this._getCompilerBinaryPathFromBuild(build);\n\n    return fs_extra_1.default.pathExists(downloadPath);\n  }\n\n  async downloadCompiler(version) {\n    await this._mutex.use(async () => {\n      let build = await this._getCompilerBuild(version);\n\n      if (build === undefined && (await this._shouldDownloadCompilerList())) {\n        try {\n          await this._downloadCompilerList();\n        } catch (e) {\n          throw new errors_1.HardhatError(errors_list_1.ERRORS.SOLC.VERSION_LIST_DOWNLOAD_FAILED, {}, e);\n        }\n\n        build = await this._getCompilerBuild(version);\n      }\n\n      if (build === undefined) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.SOLC.INVALID_VERSION, {\n          version\n        });\n      }\n\n      let downloadPath;\n\n      try {\n        downloadPath = await this._downloadCompiler(build);\n      } catch (e) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.SOLC.DOWNLOAD_FAILED, {\n          remoteVersion: build.longVersion\n        }, e);\n      }\n\n      const verified = await this._verifyCompilerDownload(build, downloadPath);\n\n      if (!verified) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.SOLC.INVALID_DOWNLOAD, {\n          remoteVersion: build.longVersion\n        });\n      }\n\n      await this._postProcessCompilerDownload(build, downloadPath);\n    });\n  }\n\n  async getCompiler(version) {\n    const build = await this._getCompilerBuild(version);\n    (0, errors_1.assertHardhatInvariant)(build !== undefined, \"Trying to get a compiler before it was downloaded\");\n\n    const compilerPath = this._getCompilerBinaryPathFromBuild(build);\n\n    (0, errors_1.assertHardhatInvariant)(await fs_extra_1.default.pathExists(compilerPath), \"Trying to get a compiler before it was downloaded\");\n\n    if (await fs_extra_1.default.pathExists(this._getCompilerDoesntWorkFile(build))) {\n      return undefined;\n    }\n\n    return {\n      version,\n      longVersion: build.longVersion,\n      compilerPath,\n      isSolcJs: this._platform === CompilerPlatform.WASM\n    };\n  }\n\n  async _getCompilerBuild(version) {\n    const listPath = this._getCompilerListPath();\n\n    if (!(await fs_extra_1.default.pathExists(listPath))) {\n      return undefined;\n    }\n\n    const list = await this._readCompilerList(listPath);\n    return list.builds.find(b => b.version === version);\n  }\n\n  _getCompilerListPath() {\n    return path_1.default.join(this._compilersDir, this._platform, \"list.json\");\n  }\n\n  async _readCompilerList(listPath) {\n    return fs_extra_1.default.readJSON(listPath);\n  }\n\n  _getCompilerDownloadPathFromBuild(build) {\n    return path_1.default.join(this._compilersDir, this._platform, build.path);\n  }\n\n  _getCompilerBinaryPathFromBuild(build) {\n    const downloadPath = this._getCompilerDownloadPathFromBuild(build);\n\n    if (this._platform !== CompilerPlatform.WINDOWS || !downloadPath.endsWith(\".zip\")) {\n      return downloadPath;\n    }\n\n    return path_1.default.join(this._compilersDir, build.version, \"solc.exe\");\n  }\n\n  _getCompilerDoesntWorkFile(build) {\n    return `${this._getCompilerBinaryPathFromBuild(build)}.does.not.work`;\n  }\n\n  async _shouldDownloadCompilerList() {\n    const listPath = this._getCompilerListPath();\n\n    if (!(await fs_extra_1.default.pathExists(listPath))) {\n      return true;\n    }\n\n    const stats = await fs_extra_1.default.stat(listPath);\n    const age = new Date().valueOf() - stats.ctimeMs;\n    return age > this._compilerListCachePeriodMs;\n  }\n\n  async _downloadCompilerList() {\n    log(`Downloading compiler list for platform ${this._platform}`);\n    const url = `${COMPILER_REPOSITORY_URL}/${this._platform}/list.json`;\n\n    const downloadPath = this._getCompilerListPath();\n\n    await this._downloadFunction(url, downloadPath);\n  }\n\n  async _downloadCompiler(build) {\n    log(`Downloading compiler ${build.longVersion}`);\n    const url = `${COMPILER_REPOSITORY_URL}/${this._platform}/${build.path}`;\n\n    const downloadPath = this._getCompilerDownloadPathFromBuild(build);\n\n    await this._downloadFunction(url, downloadPath);\n    return downloadPath;\n  }\n\n  async _verifyCompilerDownload(build, downloadPath) {\n    const ethereumjsUtil = await Promise.resolve().then(() => __importStar(require(\"@nomicfoundation/ethereumjs-util\")));\n    const {\n      keccak256\n    } = await Promise.resolve().then(() => __importStar(require(\"../../util/keccak\")));\n    const expectedKeccak256 = build.keccak256;\n    const compiler = await fs_extra_1.default.readFile(downloadPath);\n    const compilerKeccak256 = ethereumjsUtil.bufferToHex(keccak256(compiler));\n\n    if (expectedKeccak256 !== compilerKeccak256) {\n      await fs_extra_1.default.unlink(downloadPath);\n      return false;\n    }\n\n    return true;\n  }\n\n  async _postProcessCompilerDownload(build, downloadPath) {\n    if (this._platform === CompilerPlatform.WASM) {\n      return;\n    }\n\n    if (this._platform === CompilerPlatform.LINUX || this._platform === CompilerPlatform.MACOS) {\n      fs_extra_1.default.chmodSync(downloadPath, 0o755);\n    } else if (this._platform === CompilerPlatform.WINDOWS && downloadPath.endsWith(\".zip\")) {\n      // some window builds are zipped, some are not\n      const {\n        default: AdmZip\n      } = await Promise.resolve().then(() => __importStar(require(\"adm-zip\")));\n      const solcFolder = path_1.default.join(this._compilersDir, build.version);\n      await fs_extra_1.default.ensureDir(solcFolder);\n      const zip = new AdmZip(downloadPath);\n      zip.extractAllTo(solcFolder);\n    }\n\n    log(\"Checking native solc binary\");\n    const nativeSolcWorks = await this._checkNativeSolc(build);\n\n    if (nativeSolcWorks) {\n      return;\n    }\n\n    await fs_extra_1.default.createFile(this._getCompilerDoesntWorkFile(build));\n  }\n\n  async _checkNativeSolc(build) {\n    const solcPath = this._getCompilerBinaryPathFromBuild(build);\n\n    const execFileP = (0, util_1.promisify)(child_process_1.execFile);\n\n    try {\n      await execFileP(solcPath, [\"--version\"]);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n}\n\nexports.CompilerDownloader = CompilerDownloader;\nCompilerDownloader._downloaderPerPlatform = new Map();\nCompilerDownloader.defaultCompilerListCachePeriod = 360000;","map":{"version":3,"mappings":"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","names":["log","COMPILER_REPOSITORY_URL","CompilerPlatform","exports","CompilerDownloader","constructor","_platform","_compilersDir","_compilerListCachePeriodMs","defaultCompilerListCachePeriod","_downloadFunction","download_1","await_semaphore_1","getCompilerPlatform","os_1","platform","WINDOWS","LINUX","MACOS","WASM","getConcurrencySafeDownloader","compilersDir","key","_downloaderPerPlatform","has","set","get","isCompilerDownloaded","version","build","_getCompilerBuild","undefined","downloadPath","_getCompilerBinaryPathFromBuild","fs_extra_1","pathExists","downloadCompiler","_mutex","use","_shouldDownloadCompilerList","_downloadCompilerList","e","errors_1","errors_list_1","SOLC","VERSION_LIST_DOWNLOAD_FAILED","INVALID_VERSION","_downloadCompiler","DOWNLOAD_FAILED","remoteVersion","longVersion","verified","_verifyCompilerDownload","INVALID_DOWNLOAD","_postProcessCompilerDownload","getCompiler","compilerPath","_getCompilerDoesntWorkFile","isSolcJs","listPath","_getCompilerListPath","list","_readCompilerList","builds","find","b","path_1","join","readJSON","_getCompilerDownloadPathFromBuild","path","endsWith","stats","stat","age","Date","valueOf","ctimeMs","url","ethereumjsUtil","keccak256","expectedKeccak256","compiler","readFile","compilerKeccak256","bufferToHex","unlink","chmodSync","default","AdmZip","solcFolder","ensureDir","zip","extractAllTo","nativeSolcWorks","_checkNativeSolc","createFile","solcPath","execFileP","child_process_1","Map"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\hardhat\\src\\internal\\solidity\\compiler\\downloader.ts"],"sourcesContent":["import path from \"path\";\nimport fsExtra from \"fs-extra\";\nimport debug from \"debug\";\nimport os from \"os\";\nimport { execFile } from \"child_process\";\nimport { promisify } from \"util\";\n\nimport { download } from \"../../util/download\";\nimport { assertHardhatInvariant, HardhatError } from \"../../core/errors\";\nimport { ERRORS } from \"../../core/errors-list\";\nimport { Mutex } from \"../../vendor/await-semaphore\";\n\nconst log = debug(\"hardhat:core:solidity:downloader\");\n\nconst COMPILER_REPOSITORY_URL = \"https://binaries.soliditylang.org\";\n\nexport enum CompilerPlatform {\n  LINUX = \"linux-amd64\",\n  WINDOWS = \"windows-amd64\",\n  MACOS = \"macosx-amd64\",\n  WASM = \"wasm\",\n}\n\nexport interface Compiler {\n  version: string;\n  longVersion: string;\n  compilerPath: string;\n  isSolcJs: boolean;\n}\n\ninterface CompilerBuild {\n  path: string;\n  version: string;\n  build: string;\n  longVersion: string;\n  keccak256: string;\n  urls: string[];\n  platform: CompilerPlatform;\n}\n\ninterface CompilerList {\n  builds: CompilerBuild[];\n  releases: { [version: string]: string };\n  latestRelease: string;\n}\n\n/**\n * A compiler downloader which must be specialized per-platform. It can't and\n * shouldn't support multiple platforms at the same time.\n */\nexport interface ICompilerDownloader {\n  /**\n   * Returns true if the compiler has been downloaded.\n   *\n   * This function access the filesystem, but doesn't modify it.\n   */\n  isCompilerDownloaded(version: string): Promise<boolean>;\n\n  /**\n   * Downloads the compiler for a given version, which can later be obtained\n   * with getCompiler.\n   */\n  downloadCompiler(version: string): Promise<void>;\n\n  /**\n   * Returns the compiler, which MUST be downloaded before calling this function.\n   *\n   * Returns undefined if the compiler has been downloaded but can't be run.\n   *\n   * This function access the filesystem, but doesn't modify it.\n   */\n  getCompiler(version: string): Promise<Compiler | undefined>;\n}\n\n/**\n * Default implementation of ICompilerDownloader.\n *\n * Important things to note:\n *   1. If a compiler version is not found, this downloader may fail.\n *    1.1. It only re-downloads the list of compilers once every X time.\n *      1.1.1 If a user tries to download a new compiler before X amount of time\n *      has passed since its release, they may need to clean the cache, as\n *      indicated in the error messages.\n */\nexport class CompilerDownloader implements ICompilerDownloader {\n  public static getCompilerPlatform(): CompilerPlatform {\n    // TODO: This check is seriously wrong. It doesn't take into account\n    //  the architecture nor the toolchain. This should check the triplet of\n    //  system instead (see: https://wiki.osdev.org/Target_Triplet).\n    //\n    //  The only reason this downloader works is that it validates if the\n    //  binaries actually run.\n    switch (os.platform()) {\n      case \"win32\":\n        return CompilerPlatform.WINDOWS;\n      case \"linux\":\n        return CompilerPlatform.LINUX;\n      case \"darwin\":\n        return CompilerPlatform.MACOS;\n      default:\n        return CompilerPlatform.WASM;\n    }\n  }\n\n  private static _downloaderPerPlatform: Map<string, CompilerDownloader> =\n    new Map();\n\n  public static getConcurrencySafeDownloader(\n    platform: CompilerPlatform,\n    compilersDir: string\n  ) {\n    const key = platform + compilersDir;\n\n    if (!this._downloaderPerPlatform.has(key)) {\n      this._downloaderPerPlatform.set(\n        key,\n        new CompilerDownloader(platform, compilersDir)\n      );\n    }\n\n    return this._downloaderPerPlatform.get(key)!;\n  }\n\n  public static defaultCompilerListCachePeriod = 3_600_00;\n  private readonly _mutex = new Mutex();\n\n  /**\n   * Use CompilerDownloader.getConcurrencySafeDownloader instead\n   */\n  constructor(\n    private readonly _platform: CompilerPlatform,\n    private readonly _compilersDir: string,\n    private readonly _compilerListCachePeriodMs = CompilerDownloader.defaultCompilerListCachePeriod,\n    private readonly _downloadFunction: typeof download = download\n  ) {}\n\n  public async isCompilerDownloaded(version: string): Promise<boolean> {\n    const build = await this._getCompilerBuild(version);\n\n    if (build === undefined) {\n      return false;\n    }\n\n    const downloadPath = this._getCompilerBinaryPathFromBuild(build);\n\n    return fsExtra.pathExists(downloadPath);\n  }\n\n  public async downloadCompiler(version: string): Promise<void> {\n    await this._mutex.use(async () => {\n      let build = await this._getCompilerBuild(version);\n\n      if (build === undefined && (await this._shouldDownloadCompilerList())) {\n        try {\n          await this._downloadCompilerList();\n        } catch (e: any) {\n          throw new HardhatError(\n            ERRORS.SOLC.VERSION_LIST_DOWNLOAD_FAILED,\n            {},\n            e\n          );\n        }\n\n        build = await this._getCompilerBuild(version);\n      }\n\n      if (build === undefined) {\n        throw new HardhatError(ERRORS.SOLC.INVALID_VERSION, { version });\n      }\n\n      let downloadPath: string;\n      try {\n        downloadPath = await this._downloadCompiler(build);\n      } catch (e: any) {\n        throw new HardhatError(\n          ERRORS.SOLC.DOWNLOAD_FAILED,\n          {\n            remoteVersion: build.longVersion,\n          },\n          e\n        );\n      }\n\n      const verified = await this._verifyCompilerDownload(build, downloadPath);\n      if (!verified) {\n        throw new HardhatError(ERRORS.SOLC.INVALID_DOWNLOAD, {\n          remoteVersion: build.longVersion,\n        });\n      }\n\n      await this._postProcessCompilerDownload(build, downloadPath);\n    });\n  }\n\n  public async getCompiler(version: string): Promise<Compiler | undefined> {\n    const build = await this._getCompilerBuild(version);\n\n    assertHardhatInvariant(\n      build !== undefined,\n      \"Trying to get a compiler before it was downloaded\"\n    );\n\n    const compilerPath = this._getCompilerBinaryPathFromBuild(build);\n\n    assertHardhatInvariant(\n      await fsExtra.pathExists(compilerPath),\n      \"Trying to get a compiler before it was downloaded\"\n    );\n\n    if (await fsExtra.pathExists(this._getCompilerDoesntWorkFile(build))) {\n      return undefined;\n    }\n\n    return {\n      version,\n      longVersion: build.longVersion,\n      compilerPath,\n      isSolcJs: this._platform === CompilerPlatform.WASM,\n    };\n  }\n\n  private async _getCompilerBuild(\n    version: string\n  ): Promise<CompilerBuild | undefined> {\n    const listPath = this._getCompilerListPath();\n    if (!(await fsExtra.pathExists(listPath))) {\n      return undefined;\n    }\n\n    const list = await this._readCompilerList(listPath);\n    return list.builds.find((b) => b.version === version);\n  }\n\n  private _getCompilerListPath(): string {\n    return path.join(this._compilersDir, this._platform, \"list.json\");\n  }\n\n  private async _readCompilerList(listPath: string): Promise<CompilerList> {\n    return fsExtra.readJSON(listPath);\n  }\n\n  private _getCompilerDownloadPathFromBuild(build: CompilerBuild): string {\n    return path.join(this._compilersDir, this._platform, build.path);\n  }\n\n  private _getCompilerBinaryPathFromBuild(build: CompilerBuild): string {\n    const downloadPath = this._getCompilerDownloadPathFromBuild(build);\n\n    if (\n      this._platform !== CompilerPlatform.WINDOWS ||\n      !downloadPath.endsWith(\".zip\")\n    ) {\n      return downloadPath;\n    }\n\n    return path.join(this._compilersDir, build.version, \"solc.exe\");\n  }\n\n  private _getCompilerDoesntWorkFile(build: CompilerBuild): string {\n    return `${this._getCompilerBinaryPathFromBuild(build)}.does.not.work`;\n  }\n\n  private async _shouldDownloadCompilerList(): Promise<boolean> {\n    const listPath = this._getCompilerListPath();\n    if (!(await fsExtra.pathExists(listPath))) {\n      return true;\n    }\n\n    const stats = await fsExtra.stat(listPath);\n    const age = new Date().valueOf() - stats.ctimeMs;\n\n    return age > this._compilerListCachePeriodMs;\n  }\n\n  private async _downloadCompilerList(): Promise<void> {\n    log(`Downloading compiler list for platform ${this._platform}`);\n    const url = `${COMPILER_REPOSITORY_URL}/${this._platform}/list.json`;\n    const downloadPath = this._getCompilerListPath();\n\n    await this._downloadFunction(url, downloadPath);\n  }\n\n  private async _downloadCompiler(build: CompilerBuild): Promise<string> {\n    log(`Downloading compiler ${build.longVersion}`);\n    const url = `${COMPILER_REPOSITORY_URL}/${this._platform}/${build.path}`;\n    const downloadPath = this._getCompilerDownloadPathFromBuild(build);\n\n    await this._downloadFunction(url, downloadPath);\n\n    return downloadPath;\n  }\n\n  private async _verifyCompilerDownload(\n    build: CompilerBuild,\n    downloadPath: string\n  ): Promise<boolean> {\n    const ethereumjsUtil = await import(\"@nomicfoundation/ethereumjs-util\");\n    const { keccak256 } = await import(\"../../util/keccak\");\n\n    const expectedKeccak256 = build.keccak256;\n    const compiler = await fsExtra.readFile(downloadPath);\n\n    const compilerKeccak256 = ethereumjsUtil.bufferToHex(keccak256(compiler));\n\n    if (expectedKeccak256 !== compilerKeccak256) {\n      await fsExtra.unlink(downloadPath);\n      return false;\n    }\n\n    return true;\n  }\n\n  private async _postProcessCompilerDownload(\n    build: CompilerBuild,\n    downloadPath: string\n  ): Promise<void> {\n    if (this._platform === CompilerPlatform.WASM) {\n      return;\n    }\n\n    if (\n      this._platform === CompilerPlatform.LINUX ||\n      this._platform === CompilerPlatform.MACOS\n    ) {\n      fsExtra.chmodSync(downloadPath, 0o755);\n    } else if (\n      this._platform === CompilerPlatform.WINDOWS &&\n      downloadPath.endsWith(\".zip\")\n    ) {\n      // some window builds are zipped, some are not\n      const { default: AdmZip } = await import(\"adm-zip\");\n\n      const solcFolder = path.join(this._compilersDir, build.version);\n      await fsExtra.ensureDir(solcFolder);\n\n      const zip = new AdmZip(downloadPath);\n      zip.extractAllTo(solcFolder);\n    }\n\n    log(\"Checking native solc binary\");\n    const nativeSolcWorks = await this._checkNativeSolc(build);\n\n    if (nativeSolcWorks) {\n      return;\n    }\n\n    await fsExtra.createFile(this._getCompilerDoesntWorkFile(build));\n  }\n\n  private async _checkNativeSolc(build: CompilerBuild) {\n    const solcPath = this._getCompilerBinaryPathFromBuild(build);\n    const execFileP = promisify(execFile);\n\n    try {\n      await execFileP(solcPath, [\"--version\"]);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}