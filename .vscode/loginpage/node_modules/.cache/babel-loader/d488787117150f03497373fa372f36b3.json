{"ast":null,"code":"// Copied from https://raw.githubusercontent.com/nodejs/node/v15.3.0/lib/internal/modules/esm/resolve.js\n'use strict';\n\nconst {\n  versionGteLt\n} = require('../dist/util'); // Test for node >14.13.1 || (>=12.20.0 && <13)\n\n\nconst builtinModuleProtocol = versionGteLt(process.versions.node, '14.13.1') || versionGteLt(process.versions.node, '12.20.0', '13.0.0') ? 'node:' : 'nodejs:';\n\nconst {\n  ArrayIsArray,\n  ArrayPrototypeJoin,\n  ArrayPrototypeShift,\n  JSONParse,\n  JSONStringify,\n  ObjectFreeze,\n  ObjectGetOwnPropertyNames,\n  ObjectPrototypeHasOwnProperty,\n  RegExpPrototypeTest,\n  SafeMap,\n  SafeSet,\n  StringPrototypeEndsWith,\n  StringPrototypeIndexOf,\n  StringPrototypeLastIndexOf,\n  StringPrototypeReplace,\n  StringPrototypeSlice,\n  StringPrototypeSplit,\n  StringPrototypeStartsWith,\n  StringPrototypeSubstr\n} = require('./node-primordials'); // const internalFS = require('internal/fs/utils');\n\n\nconst Module = require('module');\n\nconst {\n  NativeModule\n} = require('./node-nativemodule');\n\nconst {\n  realpathSync,\n  statSync,\n  Stats\n} = require('fs'); // const { getOptionValue } = require('internal/options');\n\n\nconst {\n  getOptionValue\n} = require('./node-options'); // // Do not eagerly grab .manifest, it may be in TDZ\n// const policy = getOptionValue('--experimental-policy') ?\n//   require('internal/process/policy') :\n//   null;\n// disabled for now.  I am not sure if/how we should support this\n\n\nconst policy = null;\n\nconst {\n  sep,\n  relative\n} = require('path');\n\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\nconst typeFlag = getOptionValue('--input-type'); // const { URL, pathToFileURL, fileURLToPath } = require('internal/url');\n\nconst {\n  URL,\n  pathToFileURL,\n  fileURLToPath\n} = require('url');\n\nconst {\n  ERR_INPUT_TYPE_NOT_ALLOWED,\n  ERR_INVALID_ARG_VALUE,\n  ERR_INVALID_MODULE_SPECIFIER,\n  ERR_INVALID_PACKAGE_CONFIG,\n  ERR_INVALID_PACKAGE_TARGET,\n  ERR_MANIFEST_DEPENDENCY_MISSING,\n  ERR_MODULE_NOT_FOUND,\n  ERR_PACKAGE_IMPORT_NOT_DEFINED,\n  ERR_PACKAGE_PATH_NOT_EXPORTED,\n  ERR_UNSUPPORTED_DIR_IMPORT,\n  ERR_UNSUPPORTED_ESM_URL_SCHEME // } = require('internal/errors').codes;\n\n} = require('./node-internal-errors').codes; // const { Module: CJSModule } = require('internal/modules/cjs/loader');\n\n\nconst CJSModule = Module; // const packageJsonReader = require('internal/modules/package_json_reader');\n\nconst packageJsonReader = require('./node-internal-modules-package_json_reader');\n\nconst userConditions = getOptionValue('--conditions');\nconst DEFAULT_CONDITIONS = ObjectFreeze(['node', 'import', ...userConditions]);\nconst DEFAULT_CONDITIONS_SET = new SafeSet(DEFAULT_CONDITIONS);\nconst pendingDeprecation = getOptionValue('--pending-deprecation');\n/**\n * @param {{\n *  extensions: import('../src/file-extensions').Extensions,\n *  preferTsExts: boolean | undefined;\n *  tsNodeExperimentalSpecifierResolution: import('../src/index').ExperimentalSpecifierResolution | undefined;\n * }} opts\n */\n\nfunction createResolve(opts) {\n  // TODO receive cached fs implementations here\n  const {\n    preferTsExts,\n    tsNodeExperimentalSpecifierResolution,\n    extensions\n  } = opts;\n  const esrnExtensions = extensions.experimentalSpecifierResolutionAddsIfOmitted;\n  const {\n    legacyMainResolveAddsIfOmitted,\n    replacementsForCjs,\n    replacementsForJs,\n    replacementsForMjs,\n    replacementsForJsx\n  } = extensions; // const experimentalSpecifierResolution = tsNodeExperimentalSpecifierResolution ?? getOptionValue('--experimental-specifier-resolution');\n\n  const experimentalSpecifierResolution = tsNodeExperimentalSpecifierResolution != null ? tsNodeExperimentalSpecifierResolution : getOptionValue('--experimental-specifier-resolution');\n  const emittedPackageWarnings = new SafeSet();\n\n  function emitFolderMapDeprecation(match, pjsonUrl, isExports, base) {\n    const pjsonPath = fileURLToPath(pjsonUrl);\n\n    if (!pendingDeprecation) {\n      const nodeModulesIndex = StringPrototypeLastIndexOf(pjsonPath, '/node_modules/');\n\n      if (nodeModulesIndex !== -1) {\n        const afterNodeModulesPath = StringPrototypeSlice(pjsonPath, nodeModulesIndex + 14, -13);\n\n        try {\n          const {\n            packageSubpath\n          } = parsePackageName(afterNodeModulesPath);\n          if (packageSubpath === '.') return;\n        } catch {}\n      }\n    }\n\n    if (emittedPackageWarnings.has(pjsonPath + '|' + match)) return;\n    emittedPackageWarnings.add(pjsonPath + '|' + match);\n    process.emitWarning(`Use of deprecated folder mapping \"${match}\" in the ${isExports ? '\"exports\"' : '\"imports\"'} field module resolution of the package at ${pjsonPath}${base ? ` imported from ${fileURLToPath(base)}` : ''}.\\n` + `Update this package.json to use a subpath pattern like \"${match}*\".`, 'DeprecationWarning', 'DEP0148');\n  }\n\n  function getConditionsSet(conditions) {\n    if (conditions !== undefined && conditions !== DEFAULT_CONDITIONS) {\n      if (!ArrayIsArray(conditions)) {\n        throw new ERR_INVALID_ARG_VALUE('conditions', conditions, 'expected an array');\n      }\n\n      return new SafeSet(conditions);\n    }\n\n    return DEFAULT_CONDITIONS_SET;\n  }\n\n  const realpathCache = new SafeMap();\n  const packageJSONCache = new SafeMap();\n  /* string -> PackageConfig */\n\n  const statSupportsThrowIfNoEntry = versionGteLt(process.versions.node, '15.3.0') || versionGteLt(process.versions.node, '14.17.0', '15.0.0');\n  const tryStatSync = statSupportsThrowIfNoEntry ? tryStatSyncWithoutErrors : tryStatSyncWithErrors;\n  const statsIfNotFound = new Stats();\n\n  function tryStatSyncWithoutErrors(path) {\n    const stats = statSync(path, {\n      throwIfNoEntry: false\n    });\n    if (stats != null) return stats;\n    return statsIfNotFound;\n  }\n\n  function tryStatSyncWithErrors(path) {\n    try {\n      return statSync(path);\n    } catch {\n      return statsIfNotFound;\n    }\n  }\n\n  function getPackageConfig(path, specifier, base) {\n    const existing = packageJSONCache.get(path);\n\n    if (existing !== undefined) {\n      return existing;\n    }\n\n    const source = packageJsonReader.read(path).string;\n\n    if (source === undefined) {\n      const packageConfig = {\n        pjsonPath: path,\n        exists: false,\n        main: undefined,\n        name: undefined,\n        type: 'none',\n        exports: undefined,\n        imports: undefined\n      };\n      packageJSONCache.set(path, packageConfig);\n      return packageConfig;\n    }\n\n    let packageJSON;\n\n    try {\n      packageJSON = JSONParse(source);\n    } catch (error) {\n      throw new ERR_INVALID_PACKAGE_CONFIG(path, (base ? `\"${specifier}\" from ` : '') + fileURLToPath(base || specifier), error.message);\n    }\n\n    let {\n      imports,\n      main,\n      name,\n      type\n    } = packageJSON;\n    const {\n      exports\n    } = packageJSON;\n    if (typeof imports !== 'object' || imports === null) imports = undefined;\n    if (typeof main !== 'string') main = undefined;\n    if (typeof name !== 'string') name = undefined; // Ignore unknown types for forwards compatibility\n\n    if (type !== 'module' && type !== 'commonjs') type = 'none';\n    const packageConfig = {\n      pjsonPath: path,\n      exists: true,\n      main,\n      name,\n      type,\n      exports,\n      imports\n    };\n    packageJSONCache.set(path, packageConfig);\n    return packageConfig;\n  }\n\n  function getPackageScopeConfig(resolved) {\n    let packageJSONUrl = new URL('./package.json', resolved);\n\n    while (true) {\n      const packageJSONPath = packageJSONUrl.pathname;\n      if (StringPrototypeEndsWith(packageJSONPath, 'node_modules/package.json')) break;\n      const packageConfig = getPackageConfig(fileURLToPath(packageJSONUrl), resolved);\n      if (packageConfig.exists) return packageConfig;\n      const lastPackageJSONUrl = packageJSONUrl;\n      packageJSONUrl = new URL('../package.json', packageJSONUrl); // Terminates at root where ../package.json equals ../../package.json\n      // (can't just check \"/package.json\" for Windows support).\n\n      if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) break;\n    }\n\n    const packageJSONPath = fileURLToPath(packageJSONUrl);\n    const packageConfig = {\n      pjsonPath: packageJSONPath,\n      exists: false,\n      main: undefined,\n      name: undefined,\n      type: 'none',\n      exports: undefined,\n      imports: undefined\n    };\n    packageJSONCache.set(packageJSONPath, packageConfig);\n    return packageConfig;\n  }\n  /*\n   * Legacy CommonJS main resolution:\n   * 1. let M = pkg_url + (json main field)\n   * 2. TRY(M, M.js, M.json, M.node)\n   * 3. TRY(M/index.js, M/index.json, M/index.node)\n   * 4. TRY(pkg_url/index.js, pkg_url/index.json, pkg_url/index.node)\n   * 5. NOT_FOUND\n   */\n\n\n  function fileExists(url) {\n    return tryStatSync(fileURLToPath(url)).isFile();\n  }\n\n  function legacyMainResolve(packageJSONUrl, packageConfig, base) {\n    let guess;\n\n    if (packageConfig.main !== undefined) {\n      // Note: fs check redundances will be handled by Descriptor cache here.\n      if (guess = resolveReplacementExtensions(new URL(`./${packageConfig.main}`, packageJSONUrl))) {\n        return guess;\n      }\n\n      if (fileExists(guess = new URL(`./${packageConfig.main}`, packageJSONUrl))) {\n        return guess;\n      }\n\n      for (const extension of legacyMainResolveAddsIfOmitted) {\n        if (fileExists(guess = new URL(`./${packageConfig.main}${extension}`, packageJSONUrl))) {\n          return guess;\n        }\n      }\n\n      for (const extension of legacyMainResolveAddsIfOmitted) {\n        if (fileExists(guess = new URL(`./${packageConfig.main}/index${extension}`, packageJSONUrl))) {\n          return guess;\n        }\n      } // Fallthrough.\n\n    }\n\n    for (const extension of legacyMainResolveAddsIfOmitted) {\n      if (fileExists(guess = new URL(`./index${extension}`, packageJSONUrl))) {\n        return guess;\n      }\n    } // Not found.\n\n\n    throw new ERR_MODULE_NOT_FOUND(fileURLToPath(new URL('.', packageJSONUrl)), fileURLToPath(base));\n  }\n  /** attempts replacement extensions, then tries exact name, then attempts appending extensions */\n\n\n  function resolveExtensionsWithTryExactName(search) {\n    const resolvedReplacementExtension = resolveReplacementExtensions(search);\n    if (resolvedReplacementExtension) return resolvedReplacementExtension;\n    if (fileExists(search)) return search;\n    return resolveExtensions(search);\n  } // This appends missing extensions\n\n\n  function resolveExtensions(search) {\n    for (let i = 0; i < esrnExtensions.length; i++) {\n      const extension = esrnExtensions[i];\n      const guess = new URL(`${search.pathname}${extension}`, search);\n      if (fileExists(guess)) return guess;\n    }\n\n    return undefined;\n  }\n  /** This replaces JS with TS extensions */\n\n\n  function resolveReplacementExtensions(search) {\n    const lastDotIndex = search.pathname.lastIndexOf('.');\n\n    if (lastDotIndex >= 0) {\n      const ext = search.pathname.slice(lastDotIndex);\n\n      if (ext === '.js' || ext === '.jsx' || ext === '.mjs' || ext === '.cjs') {\n        const pathnameWithoutExtension = search.pathname.slice(0, lastDotIndex);\n        const replacementExts = ext === '.js' ? replacementsForJs : ext === '.jsx' ? replacementsForJsx : ext === '.mjs' ? replacementsForMjs : replacementsForCjs;\n        const guess = new URL(search.toString());\n\n        for (let i = 0; i < replacementExts.length; i++) {\n          const extension = replacementExts[i];\n          guess.pathname = `${pathnameWithoutExtension}${extension}`;\n          if (fileExists(guess)) return guess;\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  function resolveIndex(search) {\n    return resolveExtensions(new URL('index', search));\n  }\n\n  const encodedSepRegEx = /%2F|%2C/i;\n\n  function finalizeResolution(resolved, base) {\n    if (RegExpPrototypeTest(encodedSepRegEx, resolved.pathname)) throw new ERR_INVALID_MODULE_SPECIFIER(resolved.pathname, 'must not include encoded \"/\" or \"\\\\\" characters', fileURLToPath(base));\n\n    if (experimentalSpecifierResolution === 'node') {\n      const path = fileURLToPath(resolved);\n      let file = resolveExtensionsWithTryExactName(resolved);\n      if (file !== undefined) return file;\n\n      if (!StringPrototypeEndsWith(path, '/')) {\n        file = resolveIndex(new URL(`${resolved}/`));\n        if (file !== undefined) return file;\n      } else {\n        return resolveIndex(resolved) || resolved;\n      }\n\n      throw new ERR_MODULE_NOT_FOUND(resolved.pathname, fileURLToPath(base), 'module');\n    }\n\n    const file = resolveReplacementExtensions(resolved) || resolved;\n    const path = fileURLToPath(file);\n    const stats = tryStatSync(StringPrototypeEndsWith(path, '/') ? StringPrototypeSlice(path, -1) : path);\n\n    if (stats.isDirectory()) {\n      const err = new ERR_UNSUPPORTED_DIR_IMPORT(path, fileURLToPath(base));\n      err.url = String(resolved);\n      throw err;\n    } else if (!stats.isFile()) {\n      throw new ERR_MODULE_NOT_FOUND(path || resolved.pathname, fileURLToPath(base), 'module');\n    }\n\n    return file;\n  }\n\n  function throwImportNotDefined(specifier, packageJSONUrl, base) {\n    throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(specifier, packageJSONUrl && fileURLToPath(new URL('.', packageJSONUrl)), fileURLToPath(base));\n  }\n\n  function throwExportsNotFound(subpath, packageJSONUrl, base) {\n    throw new ERR_PACKAGE_PATH_NOT_EXPORTED(fileURLToPath(new URL('.', packageJSONUrl)), subpath, base && fileURLToPath(base));\n  }\n\n  function throwInvalidSubpath(subpath, packageJSONUrl, internal, base) {\n    const reason = `request is not a valid subpath for the \"${internal ? 'imports' : 'exports'}\" resolution of ${fileURLToPath(packageJSONUrl)}`;\n    throw new ERR_INVALID_MODULE_SPECIFIER(subpath, reason, base && fileURLToPath(base));\n  }\n\n  function throwInvalidPackageTarget(subpath, target, packageJSONUrl, internal, base) {\n    if (typeof target === 'object' && target !== null) {\n      target = JSONStringify(target, null, '');\n    } else {\n      target = `${target}`;\n    }\n\n    throw new ERR_INVALID_PACKAGE_TARGET(fileURLToPath(new URL('.', packageJSONUrl)), subpath, target, internal, base && fileURLToPath(base));\n  }\n\n  const invalidSegmentRegEx = /(^|\\\\|\\/)(\\.\\.?|node_modules)(\\\\|\\/|$)/;\n  const patternRegEx = /\\*/g;\n\n  function resolvePackageTargetString(target, subpath, match, packageJSONUrl, base, pattern, internal, conditions) {\n    if (subpath !== '' && !pattern && target[target.length - 1] !== '/') throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);\n\n    if (!StringPrototypeStartsWith(target, './')) {\n      if (internal && !StringPrototypeStartsWith(target, '../') && !StringPrototypeStartsWith(target, '/')) {\n        let isURL = false;\n\n        try {\n          new URL(target);\n          isURL = true;\n        } catch {}\n\n        if (!isURL) {\n          const exportTarget = pattern ? StringPrototypeReplace(target, patternRegEx, subpath) : target + subpath;\n          return packageResolve(exportTarget, packageJSONUrl, conditions);\n        }\n      }\n\n      throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);\n    }\n\n    if (RegExpPrototypeTest(invalidSegmentRegEx, StringPrototypeSlice(target, 2))) throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);\n    const resolved = new URL(target, packageJSONUrl);\n    const resolvedPath = resolved.pathname;\n    const packagePath = new URL('.', packageJSONUrl).pathname;\n    if (!StringPrototypeStartsWith(resolvedPath, packagePath)) throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);\n    if (subpath === '') return resolved;\n    if (RegExpPrototypeTest(invalidSegmentRegEx, subpath)) throwInvalidSubpath(match + subpath, packageJSONUrl, internal, base);\n    if (pattern) return new URL(StringPrototypeReplace(resolved.href, patternRegEx, subpath));\n    return new URL(subpath, resolved);\n  }\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n\n\n  function isArrayIndex(key) {\n    const keyNum = +key;\n    if (`${keyNum}` !== key) return false;\n    return keyNum >= 0 && keyNum < 0xFFFF_FFFF;\n  }\n\n  function resolvePackageTarget(packageJSONUrl, target, subpath, packageSubpath, base, pattern, internal, conditions) {\n    if (typeof target === 'string') {\n      return resolvePackageTargetString(target, subpath, packageSubpath, packageJSONUrl, base, pattern, internal, conditions);\n    } else if (ArrayIsArray(target)) {\n      if (target.length === 0) return null;\n      let lastException;\n\n      for (let i = 0; i < target.length; i++) {\n        const targetItem = target[i];\n        let resolved;\n\n        try {\n          resolved = resolvePackageTarget(packageJSONUrl, targetItem, subpath, packageSubpath, base, pattern, internal, conditions);\n        } catch (e) {\n          lastException = e;\n          if (e.code === 'ERR_INVALID_PACKAGE_TARGET') continue;\n          throw e;\n        }\n\n        if (resolved === undefined) continue;\n\n        if (resolved === null) {\n          lastException = null;\n          continue;\n        }\n\n        return resolved;\n      }\n\n      if (lastException === undefined || lastException === null) return lastException;\n      throw lastException;\n    } else if (typeof target === 'object' && target !== null) {\n      const keys = ObjectGetOwnPropertyNames(target);\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n\n        if (isArrayIndex(key)) {\n          throw new ERR_INVALID_PACKAGE_CONFIG(fileURLToPath(packageJSONUrl), base, '\"exports\" cannot contain numeric property keys.');\n        }\n      }\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n\n        if (key === 'default' || conditions.has(key)) {\n          const conditionalTarget = target[key];\n          const resolved = resolvePackageTarget(packageJSONUrl, conditionalTarget, subpath, packageSubpath, base, pattern, internal, conditions);\n          if (resolved === undefined) continue;\n          return resolved;\n        }\n      }\n\n      return undefined;\n    } else if (target === null) {\n      return null;\n    }\n\n    throwInvalidPackageTarget(packageSubpath, target, packageJSONUrl, internal, base);\n  }\n\n  function isConditionalExportsMainSugar(exports, packageJSONUrl, base) {\n    if (typeof exports === 'string' || ArrayIsArray(exports)) return true;\n    if (typeof exports !== 'object' || exports === null) return false;\n    const keys = ObjectGetOwnPropertyNames(exports);\n    let isConditionalSugar = false;\n    let i = 0;\n\n    for (let j = 0; j < keys.length; j++) {\n      const key = keys[j];\n      const curIsConditionalSugar = key === '' || key[0] !== '.';\n\n      if (i++ === 0) {\n        isConditionalSugar = curIsConditionalSugar;\n      } else if (isConditionalSugar !== curIsConditionalSugar) {\n        throw new ERR_INVALID_PACKAGE_CONFIG(fileURLToPath(packageJSONUrl), base, '\"exports\" cannot contain some keys starting with \\'.\\' and some not.' + ' The exports object must either be an object of package subpath keys' + ' or an object of main entry condition name keys only.');\n      }\n    }\n\n    return isConditionalSugar;\n  }\n  /**\n   * @param {URL} packageJSONUrl\n   * @param {string} packageSubpath\n   * @param {object} packageConfig\n   * @param {string} base\n   * @param {Set<string>} conditions\n   * @returns {{resolved: URL, exact: boolean}}\n   */\n\n\n  function packageExportsResolve(packageJSONUrl, packageSubpath, packageConfig, base, conditions) {\n    let exports = packageConfig.exports;\n    if (isConditionalExportsMainSugar(exports, packageJSONUrl, base)) exports = {\n      '.': exports\n    };\n\n    if (ObjectPrototypeHasOwnProperty(exports, packageSubpath)) {\n      const target = exports[packageSubpath];\n      const resolved = resolvePackageTarget(packageJSONUrl, target, '', packageSubpath, base, false, false, conditions);\n      if (resolved === null || resolved === undefined) throwExportsNotFound(packageSubpath, packageJSONUrl, base);\n      return {\n        resolved,\n        exact: true\n      };\n    }\n\n    let bestMatch = '';\n    const keys = ObjectGetOwnPropertyNames(exports);\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n\n      if (key[key.length - 1] === '*' && StringPrototypeStartsWith(packageSubpath, StringPrototypeSlice(key, 0, -1)) && packageSubpath.length >= key.length && key.length > bestMatch.length) {\n        bestMatch = key;\n      } else if (key[key.length - 1] === '/' && StringPrototypeStartsWith(packageSubpath, key) && key.length > bestMatch.length) {\n        bestMatch = key;\n      }\n    }\n\n    if (bestMatch) {\n      const target = exports[bestMatch];\n      const pattern = bestMatch[bestMatch.length - 1] === '*';\n      const subpath = StringPrototypeSubstr(packageSubpath, bestMatch.length - (pattern ? 1 : 0));\n      const resolved = resolvePackageTarget(packageJSONUrl, target, subpath, bestMatch, base, pattern, false, conditions);\n      if (resolved === null || resolved === undefined) throwExportsNotFound(packageSubpath, packageJSONUrl, base);\n      if (!pattern) emitFolderMapDeprecation(bestMatch, packageJSONUrl, true, base);\n      return {\n        resolved,\n        exact: pattern\n      };\n    }\n\n    throwExportsNotFound(packageSubpath, packageJSONUrl, base);\n  }\n\n  function packageImportsResolve(name, base, conditions) {\n    if (name === '#' || StringPrototypeStartsWith(name, '#/')) {\n      const reason = 'is not a valid internal imports specifier name';\n      throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, fileURLToPath(base));\n    }\n\n    let packageJSONUrl;\n    const packageConfig = getPackageScopeConfig(base);\n\n    if (packageConfig.exists) {\n      packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n      const imports = packageConfig.imports;\n\n      if (imports) {\n        if (ObjectPrototypeHasOwnProperty(imports, name)) {\n          const resolved = resolvePackageTarget(packageJSONUrl, imports[name], '', name, base, false, true, conditions);\n          if (resolved !== null) return {\n            resolved,\n            exact: true\n          };\n        } else {\n          let bestMatch = '';\n          const keys = ObjectGetOwnPropertyNames(imports);\n\n          for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n\n            if (key[key.length - 1] === '*' && StringPrototypeStartsWith(name, StringPrototypeSlice(key, 0, -1)) && name.length >= key.length && key.length > bestMatch.length) {\n              bestMatch = key;\n            } else if (key[key.length - 1] === '/' && StringPrototypeStartsWith(name, key) && key.length > bestMatch.length) {\n              bestMatch = key;\n            }\n          }\n\n          if (bestMatch) {\n            const target = imports[bestMatch];\n            const pattern = bestMatch[bestMatch.length - 1] === '*';\n            const subpath = StringPrototypeSubstr(name, bestMatch.length - (pattern ? 1 : 0));\n            const resolved = resolvePackageTarget(packageJSONUrl, target, subpath, bestMatch, base, pattern, true, conditions);\n\n            if (resolved !== null) {\n              if (!pattern) emitFolderMapDeprecation(bestMatch, packageJSONUrl, false, base);\n              return {\n                resolved,\n                exact: pattern\n              };\n            }\n          }\n        }\n      }\n    }\n\n    throwImportNotDefined(name, packageJSONUrl, base);\n  }\n\n  function getPackageType(url) {\n    const packageConfig = getPackageScopeConfig(url);\n    return packageConfig.type;\n  }\n\n  function parsePackageName(specifier, base) {\n    let separatorIndex = StringPrototypeIndexOf(specifier, '/');\n    let validPackageName = true;\n    let isScoped = false;\n\n    if (specifier[0] === '@') {\n      isScoped = true;\n\n      if (separatorIndex === -1 || specifier.length === 0) {\n        validPackageName = false;\n      } else {\n        separatorIndex = StringPrototypeIndexOf(specifier, '/', separatorIndex + 1);\n      }\n    }\n\n    const packageName = separatorIndex === -1 ? specifier : StringPrototypeSlice(specifier, 0, separatorIndex); // Package name cannot have leading . and cannot have percent-encoding or\n    // separators.\n\n    for (let i = 0; i < packageName.length; i++) {\n      if (packageName[i] === '%' || packageName[i] === '\\\\') {\n        validPackageName = false;\n        break;\n      }\n    }\n\n    if (!validPackageName) {\n      throw new ERR_INVALID_MODULE_SPECIFIER(specifier, 'is not a valid package name', fileURLToPath(base));\n    }\n\n    const packageSubpath = '.' + (separatorIndex === -1 ? '' : StringPrototypeSlice(specifier, separatorIndex));\n    return {\n      packageName,\n      packageSubpath,\n      isScoped\n    };\n  }\n  /**\n   * @param {string} specifier\n   * @param {URL} base\n   * @param {Set<string>} conditions\n   * @returns {URL}\n   */\n\n\n  function packageResolve(specifier, base, conditions) {\n    const {\n      packageName,\n      packageSubpath,\n      isScoped\n    } = parsePackageName(specifier, base); // ResolveSelf\n\n    const packageConfig = getPackageScopeConfig(base);\n\n    if (packageConfig.exists) {\n      const packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n\n      if (packageConfig.name === packageName && packageConfig.exports !== undefined && packageConfig.exports !== null) {\n        return packageExportsResolve(packageJSONUrl, packageSubpath, packageConfig, base, conditions).resolved;\n      }\n    }\n\n    let packageJSONUrl = new URL('./node_modules/' + packageName + '/package.json', base);\n    let packageJSONPath = fileURLToPath(packageJSONUrl);\n    let lastPath;\n\n    do {\n      const stat = tryStatSync(StringPrototypeSlice(packageJSONPath, 0, packageJSONPath.length - 13));\n\n      if (!stat.isDirectory()) {\n        lastPath = packageJSONPath;\n        packageJSONUrl = new URL((isScoped ? '../../../../node_modules/' : '../../../node_modules/') + packageName + '/package.json', packageJSONUrl);\n        packageJSONPath = fileURLToPath(packageJSONUrl);\n        continue;\n      } // Package match.\n\n\n      const packageConfig = getPackageConfig(packageJSONPath, specifier, base);\n      if (packageConfig.exports !== undefined && packageConfig.exports !== null) return packageExportsResolve(packageJSONUrl, packageSubpath, packageConfig, base, conditions).resolved;\n      if (packageSubpath === '.') return legacyMainResolve(packageJSONUrl, packageConfig, base);\n      return new URL(packageSubpath, packageJSONUrl); // Cross-platform root check.\n    } while (packageJSONPath.length !== lastPath.length); // eslint can't handle the above code.\n    // eslint-disable-next-line no-unreachable\n\n\n    throw new ERR_MODULE_NOT_FOUND(packageName, fileURLToPath(base));\n  }\n\n  function isBareSpecifier(specifier) {\n    return specifier[0] && specifier[0] !== '/' && specifier[0] !== '.';\n  }\n\n  function isRelativeSpecifier(specifier) {\n    if (specifier[0] === '.') {\n      if (specifier.length === 1 || specifier[1] === '/') return true;\n\n      if (specifier[1] === '.') {\n        if (specifier.length === 2 || specifier[2] === '/') return true;\n      }\n    }\n\n    return false;\n  }\n\n  function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {\n    if (specifier === '') return false;\n    if (specifier[0] === '/') return true;\n    return isRelativeSpecifier(specifier);\n  }\n  /**\n   * @param {string} specifier\n   * @param {URL} base\n   * @param {Set<string>} conditions\n   * @returns {URL}\n   */\n\n\n  function moduleResolve(specifier, base, conditions) {\n    // Order swapped from spec for minor perf gain.\n    // Ok since relative URLs cannot parse as URLs.\n    let resolved;\n\n    if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n      resolved = new URL(specifier, base);\n    } else if (specifier[0] === '#') {\n      ({\n        resolved\n      } = packageImportsResolve(specifier, base, conditions));\n    } else {\n      try {\n        resolved = new URL(specifier);\n      } catch {\n        resolved = packageResolve(specifier, base, conditions);\n      }\n    }\n\n    return finalizeResolution(resolved, base);\n  }\n  /**\n   * Try to resolve an import as a CommonJS module\n   * @param {string} specifier\n   * @param {string} parentURL\n   * @returns {boolean|string}\n   */\n\n\n  function resolveAsCommonJS(specifier, parentURL) {\n    try {\n      const parent = fileURLToPath(parentURL);\n      const tmpModule = new CJSModule(parent, null);\n      tmpModule.paths = CJSModule._nodeModulePaths(parent);\n\n      let found = CJSModule._resolveFilename(specifier, tmpModule, false); // If it is a relative specifier return the relative path\n      // to the parent\n\n\n      if (isRelativeSpecifier(specifier)) {\n        found = relative(parent, found); // Add '.separator if the path does not start with '..separator'\n        // This should be a safe assumption because when loading\n        // esm modules there should be always a file specified so\n        // there should not be a specifier like '..' or '.'\n\n        if (!StringPrototypeStartsWith(found, `..${sep}`)) {\n          found = `.${sep}${found}`;\n        }\n      } else if (isBareSpecifier(specifier)) {\n        // If it is a bare specifier return the relative path within the\n        // module\n        const pkg = StringPrototypeSplit(specifier, '/')[0];\n        const index = StringPrototypeIndexOf(found, pkg);\n\n        if (index !== -1) {\n          found = StringPrototypeSlice(found, index);\n        }\n      } // Normalize the path separator to give a valid suggestion\n      // on Windows\n\n\n      if (process.platform === 'win32') {\n        found = StringPrototypeReplace(found, new RegExp(`\\\\${sep}`, 'g'), '/');\n      }\n\n      return found;\n    } catch {\n      return false;\n    }\n  }\n\n  function defaultResolve(specifier) {\n    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let defaultResolveUnused = arguments.length > 2 ? arguments[2] : undefined;\n    let {\n      parentURL,\n      conditions\n    } = context;\n\n    if (parentURL && policy != null && policy.manifest) {\n      const redirects = policy.manifest.getDependencyMapper(parentURL);\n\n      if (redirects) {\n        const {\n          resolve,\n          reaction\n        } = redirects;\n        const destination = resolve(specifier, new SafeSet(conditions));\n        let missing = true;\n\n        if (destination === true) {\n          missing = false;\n        } else if (destination) {\n          const href = destination.href;\n          return {\n            url: href\n          };\n        }\n\n        if (missing) {\n          reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(parentURL, specifier, ArrayPrototypeJoin([...conditions], ', ')));\n        }\n      }\n    }\n\n    let parsed;\n\n    try {\n      parsed = new URL(specifier);\n\n      if (parsed.protocol === 'data:') {\n        return {\n          url: specifier\n        };\n      }\n    } catch {}\n\n    if (parsed && parsed.protocol === builtinModuleProtocol) return {\n      url: specifier\n    };\n    if (parsed && parsed.protocol !== 'file:' && parsed.protocol !== 'data:') throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed);\n\n    if (NativeModule.canBeRequiredByUsers(specifier)) {\n      return {\n        url: builtinModuleProtocol + specifier\n      };\n    }\n\n    if (parentURL && StringPrototypeStartsWith(parentURL, 'data:')) {\n      // This is gonna blow up, we want the error\n      new URL(specifier, parentURL);\n    }\n\n    const isMain = parentURL === undefined;\n\n    if (isMain) {\n      parentURL = pathToFileURL(`${process.cwd()}/`).href; // This is the initial entry point to the program, and --input-type has\n      // been passed as an option; but --input-type can only be used with\n      // --eval, --print or STDIN string input. It is not allowed with file\n      // input, to avoid user confusion over how expansive the effect of the\n      // flag should be (i.e. entry point only, package scope surrounding the\n      // entry point, etc.).\n\n      if (typeFlag) throw new ERR_INPUT_TYPE_NOT_ALLOWED();\n    }\n\n    conditions = getConditionsSet(conditions);\n    let url;\n\n    try {\n      url = moduleResolve(specifier, parentURL, conditions);\n    } catch (error) {\n      // Try to give the user a hint of what would have been the\n      // resolved CommonJS module\n      if (error.code === 'ERR_MODULE_NOT_FOUND' || error.code === 'ERR_UNSUPPORTED_DIR_IMPORT') {\n        if (StringPrototypeStartsWith(specifier, 'file://')) {\n          specifier = fileURLToPath(specifier);\n        }\n\n        const found = resolveAsCommonJS(specifier, parentURL);\n\n        if (found) {\n          // Modify the stack and message string to include the hint\n          const lines = StringPrototypeSplit(error.stack, '\\n');\n          const hint = `Did you mean to import ${found}?`;\n          error.stack = ArrayPrototypeShift(lines) + '\\n' + hint + '\\n' + ArrayPrototypeJoin(lines, '\\n');\n          error.message += `\\n${hint}`;\n        }\n      }\n\n      throw error;\n    }\n\n    if (isMain ? !preserveSymlinksMain : !preserveSymlinks) {\n      const urlPath = fileURLToPath(url);\n      const real = realpathSync(urlPath, {// [internalFS.realpathCacheKey]: realpathCache\n      });\n      const old = url;\n      url = pathToFileURL(real + (StringPrototypeEndsWith(urlPath, sep) ? '/' : ''));\n      url.search = old.search;\n      url.hash = old.hash;\n    }\n\n    return {\n      url: `${url}`\n    };\n  }\n\n  return {\n    DEFAULT_CONDITIONS,\n    defaultResolve,\n    encodedSepRegEx,\n    getPackageType,\n    packageExportsResolve,\n    packageImportsResolve\n  };\n}\n\nmodule.exports = {\n  createResolve\n};","map":{"version":3,"names":["versionGteLt","require","builtinModuleProtocol","process","versions","node","ArrayIsArray","ArrayPrototypeJoin","ArrayPrototypeShift","JSONParse","JSONStringify","ObjectFreeze","ObjectGetOwnPropertyNames","ObjectPrototypeHasOwnProperty","RegExpPrototypeTest","SafeMap","SafeSet","StringPrototypeEndsWith","StringPrototypeIndexOf","StringPrototypeLastIndexOf","StringPrototypeReplace","StringPrototypeSlice","StringPrototypeSplit","StringPrototypeStartsWith","StringPrototypeSubstr","Module","NativeModule","realpathSync","statSync","Stats","getOptionValue","policy","sep","relative","preserveSymlinks","preserveSymlinksMain","typeFlag","URL","pathToFileURL","fileURLToPath","ERR_INPUT_TYPE_NOT_ALLOWED","ERR_INVALID_ARG_VALUE","ERR_INVALID_MODULE_SPECIFIER","ERR_INVALID_PACKAGE_CONFIG","ERR_INVALID_PACKAGE_TARGET","ERR_MANIFEST_DEPENDENCY_MISSING","ERR_MODULE_NOT_FOUND","ERR_PACKAGE_IMPORT_NOT_DEFINED","ERR_PACKAGE_PATH_NOT_EXPORTED","ERR_UNSUPPORTED_DIR_IMPORT","ERR_UNSUPPORTED_ESM_URL_SCHEME","codes","CJSModule","packageJsonReader","userConditions","DEFAULT_CONDITIONS","DEFAULT_CONDITIONS_SET","pendingDeprecation","createResolve","opts","preferTsExts","tsNodeExperimentalSpecifierResolution","extensions","esrnExtensions","experimentalSpecifierResolutionAddsIfOmitted","legacyMainResolveAddsIfOmitted","replacementsForCjs","replacementsForJs","replacementsForMjs","replacementsForJsx","experimentalSpecifierResolution","emittedPackageWarnings","emitFolderMapDeprecation","match","pjsonUrl","isExports","base","pjsonPath","nodeModulesIndex","afterNodeModulesPath","packageSubpath","parsePackageName","has","add","emitWarning","getConditionsSet","conditions","undefined","realpathCache","packageJSONCache","statSupportsThrowIfNoEntry","tryStatSync","tryStatSyncWithoutErrors","tryStatSyncWithErrors","statsIfNotFound","path","stats","throwIfNoEntry","getPackageConfig","specifier","existing","get","source","read","string","packageConfig","exists","main","name","type","exports","imports","set","packageJSON","error","message","getPackageScopeConfig","resolved","packageJSONUrl","packageJSONPath","pathname","lastPackageJSONUrl","fileExists","url","isFile","legacyMainResolve","guess","resolveReplacementExtensions","extension","resolveExtensionsWithTryExactName","search","resolvedReplacementExtension","resolveExtensions","i","length","lastDotIndex","lastIndexOf","ext","slice","pathnameWithoutExtension","replacementExts","toString","resolveIndex","encodedSepRegEx","finalizeResolution","file","isDirectory","err","String","throwImportNotDefined","throwExportsNotFound","subpath","throwInvalidSubpath","internal","reason","throwInvalidPackageTarget","target","invalidSegmentRegEx","patternRegEx","resolvePackageTargetString","pattern","isURL","exportTarget","packageResolve","resolvedPath","packagePath","href","isArrayIndex","key","keyNum","resolvePackageTarget","lastException","targetItem","e","code","keys","conditionalTarget","isConditionalExportsMainSugar","isConditionalSugar","j","curIsConditionalSugar","packageExportsResolve","exact","bestMatch","packageImportsResolve","getPackageType","separatorIndex","validPackageName","isScoped","packageName","lastPath","stat","isBareSpecifier","isRelativeSpecifier","shouldBeTreatedAsRelativeOrAbsolutePath","moduleResolve","resolveAsCommonJS","parentURL","parent","tmpModule","paths","_nodeModulePaths","found","_resolveFilename","pkg","index","platform","RegExp","defaultResolve","context","defaultResolveUnused","manifest","redirects","getDependencyMapper","resolve","reaction","destination","missing","parsed","protocol","canBeRequiredByUsers","isMain","cwd","lines","stack","hint","urlPath","real","old","hash","module"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/ts-node/dist-raw/node-internal-modules-esm-resolve.js"],"sourcesContent":["// Copied from https://raw.githubusercontent.com/nodejs/node/v15.3.0/lib/internal/modules/esm/resolve.js\n\n'use strict';\n\nconst {versionGteLt} = require('../dist/util');\n\n// Test for node >14.13.1 || (>=12.20.0 && <13)\nconst builtinModuleProtocol =\n  versionGteLt(process.versions.node, '14.13.1') ||\n  versionGteLt(process.versions.node, '12.20.0', '13.0.0')\n    ? 'node:'\n    : 'nodejs:';\n\nconst {\n  ArrayIsArray,\n  ArrayPrototypeJoin,\n  ArrayPrototypeShift,\n  JSONParse,\n  JSONStringify,\n  ObjectFreeze,\n  ObjectGetOwnPropertyNames,\n  ObjectPrototypeHasOwnProperty,\n  RegExpPrototypeTest,\n  SafeMap,\n  SafeSet,\n  StringPrototypeEndsWith,\n  StringPrototypeIndexOf,\n  StringPrototypeLastIndexOf,\n  StringPrototypeReplace,\n  StringPrototypeSlice,\n  StringPrototypeSplit,\n  StringPrototypeStartsWith,\n  StringPrototypeSubstr,\n} = require('./node-primordials');\n\n// const internalFS = require('internal/fs/utils');\nconst Module = require('module');\nconst { NativeModule } = require('./node-nativemodule');\nconst {\n  realpathSync,\n  statSync,\n  Stats,\n} = require('fs');\n// const { getOptionValue } = require('internal/options');\nconst { getOptionValue } = require('./node-options');\n// // Do not eagerly grab .manifest, it may be in TDZ\n// const policy = getOptionValue('--experimental-policy') ?\n//   require('internal/process/policy') :\n//   null;\n// disabled for now.  I am not sure if/how we should support this\nconst policy = null;\nconst { sep, relative } = require('path');\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\nconst typeFlag = getOptionValue('--input-type');\n// const { URL, pathToFileURL, fileURLToPath } = require('internal/url');\nconst { URL, pathToFileURL, fileURLToPath } = require('url');\nconst {\n  ERR_INPUT_TYPE_NOT_ALLOWED,\n  ERR_INVALID_ARG_VALUE,\n  ERR_INVALID_MODULE_SPECIFIER,\n  ERR_INVALID_PACKAGE_CONFIG,\n  ERR_INVALID_PACKAGE_TARGET,\n  ERR_MANIFEST_DEPENDENCY_MISSING,\n  ERR_MODULE_NOT_FOUND,\n  ERR_PACKAGE_IMPORT_NOT_DEFINED,\n  ERR_PACKAGE_PATH_NOT_EXPORTED,\n  ERR_UNSUPPORTED_DIR_IMPORT,\n  ERR_UNSUPPORTED_ESM_URL_SCHEME,\n// } = require('internal/errors').codes;\n} = require('./node-internal-errors').codes;\n\n// const { Module: CJSModule } = require('internal/modules/cjs/loader');\nconst CJSModule = Module;\n\n// const packageJsonReader = require('internal/modules/package_json_reader');\nconst packageJsonReader = require('./node-internal-modules-package_json_reader');\nconst userConditions = getOptionValue('--conditions');\nconst DEFAULT_CONDITIONS = ObjectFreeze(['node', 'import', ...userConditions]);\nconst DEFAULT_CONDITIONS_SET = new SafeSet(DEFAULT_CONDITIONS);\n\nconst pendingDeprecation = getOptionValue('--pending-deprecation');\n\n/**\n * @param {{\n *  extensions: import('../src/file-extensions').Extensions,\n *  preferTsExts: boolean | undefined;\n *  tsNodeExperimentalSpecifierResolution: import('../src/index').ExperimentalSpecifierResolution | undefined;\n * }} opts\n */\nfunction createResolve(opts) {\n// TODO receive cached fs implementations here\nconst {preferTsExts, tsNodeExperimentalSpecifierResolution, extensions} = opts;\nconst esrnExtensions = extensions.experimentalSpecifierResolutionAddsIfOmitted;\nconst {legacyMainResolveAddsIfOmitted, replacementsForCjs, replacementsForJs, replacementsForMjs, replacementsForJsx} = extensions;\n// const experimentalSpecifierResolution = tsNodeExperimentalSpecifierResolution ?? getOptionValue('--experimental-specifier-resolution');\nconst experimentalSpecifierResolution = tsNodeExperimentalSpecifierResolution != null ? tsNodeExperimentalSpecifierResolution : getOptionValue('--experimental-specifier-resolution');\n\nconst emittedPackageWarnings = new SafeSet();\nfunction emitFolderMapDeprecation(match, pjsonUrl, isExports, base) {\n  const pjsonPath = fileURLToPath(pjsonUrl);\n  if (!pendingDeprecation) {\n    const nodeModulesIndex = StringPrototypeLastIndexOf(pjsonPath,\n                                                        '/node_modules/');\n    if (nodeModulesIndex !== -1) {\n      const afterNodeModulesPath = StringPrototypeSlice(pjsonPath,\n                                                        nodeModulesIndex + 14,\n                                                        -13);\n      try {\n        const { packageSubpath } = parsePackageName(afterNodeModulesPath);\n        if (packageSubpath === '.')\n          return;\n      } catch {}\n    }\n  }\n  if (emittedPackageWarnings.has(pjsonPath + '|' + match))\n    return;\n  emittedPackageWarnings.add(pjsonPath + '|' + match);\n  process.emitWarning(\n    `Use of deprecated folder mapping \"${match}\" in the ${isExports ?\n      '\"exports\"' : '\"imports\"'} field module resolution of the package at ${\n      pjsonPath}${base ? ` imported from ${fileURLToPath(base)}` : ''}.\\n` +\n      `Update this package.json to use a subpath pattern like \"${match}*\".`,\n    'DeprecationWarning',\n    'DEP0148'\n  );\n}\n\nfunction getConditionsSet(conditions) {\n  if (conditions !== undefined && conditions !== DEFAULT_CONDITIONS) {\n    if (!ArrayIsArray(conditions)) {\n      throw new ERR_INVALID_ARG_VALUE('conditions', conditions,\n                                      'expected an array');\n    }\n    return new SafeSet(conditions);\n  }\n  return DEFAULT_CONDITIONS_SET;\n}\n\nconst realpathCache = new SafeMap();\nconst packageJSONCache = new SafeMap();  /* string -> PackageConfig */\n\nconst statSupportsThrowIfNoEntry = versionGteLt(process.versions.node, '15.3.0') ||\n  versionGteLt(process.versions.node, '14.17.0', '15.0.0');\nconst tryStatSync = statSupportsThrowIfNoEntry ? tryStatSyncWithoutErrors : tryStatSyncWithErrors;\nconst statsIfNotFound = new Stats();\nfunction tryStatSyncWithoutErrors(path) {\n  const stats = statSync(path, { throwIfNoEntry: false });\n  if(stats != null) return stats;\n  return statsIfNotFound;\n}\nfunction tryStatSyncWithErrors(path) {\n  try {\n    return statSync(path);\n  } catch {\n    return statsIfNotFound;\n  }\n}\n\nfunction getPackageConfig(path, specifier, base) {\n  const existing = packageJSONCache.get(path);\n  if (existing !== undefined) {\n    return existing;\n  }\n  const source = packageJsonReader.read(path).string;\n  if (source === undefined) {\n    const packageConfig = {\n      pjsonPath: path,\n      exists: false,\n      main: undefined,\n      name: undefined,\n      type: 'none',\n      exports: undefined,\n      imports: undefined,\n    };\n    packageJSONCache.set(path, packageConfig);\n    return packageConfig;\n  }\n\n  let packageJSON;\n  try {\n    packageJSON = JSONParse(source);\n  } catch (error) {\n    throw new ERR_INVALID_PACKAGE_CONFIG(\n      path,\n      (base ? `\"${specifier}\" from ` : '') + fileURLToPath(base || specifier),\n      error.message\n    );\n  }\n\n  let { imports, main, name, type } = packageJSON;\n  const { exports } = packageJSON;\n  if (typeof imports !== 'object' || imports === null) imports = undefined;\n  if (typeof main !== 'string') main = undefined;\n  if (typeof name !== 'string') name = undefined;\n  // Ignore unknown types for forwards compatibility\n  if (type !== 'module' && type !== 'commonjs') type = 'none';\n\n  const packageConfig = {\n    pjsonPath: path,\n    exists: true,\n    main,\n    name,\n    type,\n    exports,\n    imports,\n  };\n  packageJSONCache.set(path, packageConfig);\n  return packageConfig;\n}\n\nfunction getPackageScopeConfig(resolved) {\n  let packageJSONUrl = new URL('./package.json', resolved);\n  while (true) {\n    const packageJSONPath = packageJSONUrl.pathname;\n    if (StringPrototypeEndsWith(packageJSONPath, 'node_modules/package.json'))\n      break;\n    const packageConfig = getPackageConfig(fileURLToPath(packageJSONUrl),\n                                           resolved);\n    if (packageConfig.exists) return packageConfig;\n\n    const lastPackageJSONUrl = packageJSONUrl;\n    packageJSONUrl = new URL('../package.json', packageJSONUrl);\n\n    // Terminates at root where ../package.json equals ../../package.json\n    // (can't just check \"/package.json\" for Windows support).\n    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) break;\n  }\n  const packageJSONPath = fileURLToPath(packageJSONUrl);\n  const packageConfig = {\n    pjsonPath: packageJSONPath,\n    exists: false,\n    main: undefined,\n    name: undefined,\n    type: 'none',\n    exports: undefined,\n    imports: undefined,\n  };\n  packageJSONCache.set(packageJSONPath, packageConfig);\n  return packageConfig;\n}\n\n/*\n * Legacy CommonJS main resolution:\n * 1. let M = pkg_url + (json main field)\n * 2. TRY(M, M.js, M.json, M.node)\n * 3. TRY(M/index.js, M/index.json, M/index.node)\n * 4. TRY(pkg_url/index.js, pkg_url/index.json, pkg_url/index.node)\n * 5. NOT_FOUND\n */\nfunction fileExists(url) {\n  return tryStatSync(fileURLToPath(url)).isFile();\n}\n\nfunction legacyMainResolve(packageJSONUrl, packageConfig, base) {\n  let guess;\n  if (packageConfig.main !== undefined) {\n    // Note: fs check redundances will be handled by Descriptor cache here.\n    if(guess = resolveReplacementExtensions(new URL(`./${packageConfig.main}`, packageJSONUrl))) {\n      return guess;\n    }\n    if (fileExists(guess = new URL(`./${packageConfig.main}`,\n                                   packageJSONUrl))) {\n      return guess;\n    }\n    for(const extension of legacyMainResolveAddsIfOmitted) {\n      if (fileExists(guess = new URL(`./${packageConfig.main}${extension}`,\n                                    packageJSONUrl))) {\n        return guess;\n      }\n    }\n    for(const extension of legacyMainResolveAddsIfOmitted) {\n      if (fileExists(guess = new URL(`./${packageConfig.main}/index${extension}`,\n                                    packageJSONUrl))) {\n        return guess;\n      }\n    }\n    // Fallthrough.\n  }\n  for(const extension of legacyMainResolveAddsIfOmitted) {\n    if (fileExists(guess = new URL(`./index${extension}`, packageJSONUrl))) {\n      return guess;\n    }\n  }\n  // Not found.\n  throw new ERR_MODULE_NOT_FOUND(\n    fileURLToPath(new URL('.', packageJSONUrl)), fileURLToPath(base));\n}\n\n/** attempts replacement extensions, then tries exact name, then attempts appending extensions */\nfunction resolveExtensionsWithTryExactName(search) {\n  const resolvedReplacementExtension = resolveReplacementExtensions(search);\n  if(resolvedReplacementExtension) return resolvedReplacementExtension;\n  if (fileExists(search)) return search;\n  return resolveExtensions(search);\n}\n\n// This appends missing extensions\nfunction resolveExtensions(search) {\n  for (let i = 0; i < esrnExtensions.length; i++) {\n    const extension = esrnExtensions[i];\n    const guess = new URL(`${search.pathname}${extension}`, search);\n    if (fileExists(guess)) return guess;\n  }\n  return undefined;\n}\n\n/** This replaces JS with TS extensions */\nfunction resolveReplacementExtensions(search) {\n  const lastDotIndex = search.pathname.lastIndexOf('.');\n  if(lastDotIndex >= 0) {\n    const ext = search.pathname.slice(lastDotIndex);\n    if (ext === '.js' || ext === '.jsx' || ext === '.mjs' || ext === '.cjs') {\n      const pathnameWithoutExtension = search.pathname.slice(0, lastDotIndex);\n      const replacementExts =\n        ext === '.js' ? replacementsForJs\n        : ext === '.jsx' ? replacementsForJsx\n        : ext === '.mjs' ? replacementsForMjs\n        : replacementsForCjs;\n      const guess = new URL(search.toString());\n      for (let i = 0; i < replacementExts.length; i++) {\n        const extension = replacementExts[i];\n        guess.pathname = `${pathnameWithoutExtension}${extension}`;\n        if (fileExists(guess)) return guess;\n      }\n    }\n  }\n  return undefined;\n}\n\nfunction resolveIndex(search) {\n  return resolveExtensions(new URL('index', search));\n}\n\nconst encodedSepRegEx = /%2F|%2C/i;\nfunction finalizeResolution(resolved, base) {\n  if (RegExpPrototypeTest(encodedSepRegEx, resolved.pathname))\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved.pathname, 'must not include encoded \"/\" or \"\\\\\" characters',\n      fileURLToPath(base));\n\n  if (experimentalSpecifierResolution === 'node') {\n    const path = fileURLToPath(resolved);\n    let file = resolveExtensionsWithTryExactName(resolved);\n    if (file !== undefined) return file;\n    if (!StringPrototypeEndsWith(path, '/')) {\n      file = resolveIndex(new URL(`${resolved}/`));\n      if (file !== undefined) return file;\n    } else {\n      return resolveIndex(resolved) || resolved;\n    }\n    throw new ERR_MODULE_NOT_FOUND(\n      resolved.pathname, fileURLToPath(base), 'module');\n  }\n\n  const file = resolveReplacementExtensions(resolved) || resolved;\n  const path = fileURLToPath(file);\n\n  const stats = tryStatSync(StringPrototypeEndsWith(path, '/') ?\n    StringPrototypeSlice(path, -1) : path);\n  if (stats.isDirectory()) {\n    const err = new ERR_UNSUPPORTED_DIR_IMPORT(path, fileURLToPath(base));\n    err.url = String(resolved);\n    throw err;\n  } else if (!stats.isFile()) {\n    throw new ERR_MODULE_NOT_FOUND(\n      path || resolved.pathname, fileURLToPath(base), 'module');\n  }\n\n  return file;\n}\n\nfunction throwImportNotDefined(specifier, packageJSONUrl, base) {\n  throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(\n    specifier, packageJSONUrl && fileURLToPath(new URL('.', packageJSONUrl)),\n    fileURLToPath(base));\n}\n\nfunction throwExportsNotFound(subpath, packageJSONUrl, base) {\n  throw new ERR_PACKAGE_PATH_NOT_EXPORTED(\n    fileURLToPath(new URL('.', packageJSONUrl)), subpath,\n    base && fileURLToPath(base));\n}\n\nfunction throwInvalidSubpath(subpath, packageJSONUrl, internal, base) {\n  const reason = `request is not a valid subpath for the \"${internal ?\n    'imports' : 'exports'}\" resolution of ${fileURLToPath(packageJSONUrl)}`;\n  throw new ERR_INVALID_MODULE_SPECIFIER(subpath, reason,\n                                         base && fileURLToPath(base));\n}\n\nfunction throwInvalidPackageTarget(\n  subpath, target, packageJSONUrl, internal, base) {\n  if (typeof target === 'object' && target !== null) {\n    target = JSONStringify(target, null, '');\n  } else {\n    target = `${target}`;\n  }\n  throw new ERR_INVALID_PACKAGE_TARGET(\n    fileURLToPath(new URL('.', packageJSONUrl)), subpath, target,\n    internal, base && fileURLToPath(base));\n}\n\nconst invalidSegmentRegEx = /(^|\\\\|\\/)(\\.\\.?|node_modules)(\\\\|\\/|$)/;\nconst patternRegEx = /\\*/g;\n\nfunction resolvePackageTargetString(\n  target, subpath, match, packageJSONUrl, base, pattern, internal, conditions) {\n  if (subpath !== '' && !pattern && target[target.length - 1] !== '/')\n    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);\n\n  if (!StringPrototypeStartsWith(target, './')) {\n    if (internal && !StringPrototypeStartsWith(target, '../') &&\n        !StringPrototypeStartsWith(target, '/')) {\n      let isURL = false;\n      try {\n        new URL(target);\n        isURL = true;\n      } catch {}\n      if (!isURL) {\n        const exportTarget = pattern ?\n          StringPrototypeReplace(target, patternRegEx, subpath) :\n          target + subpath;\n        return packageResolve(exportTarget, packageJSONUrl, conditions);\n      }\n    }\n    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);\n  }\n\n  if (RegExpPrototypeTest(invalidSegmentRegEx, StringPrototypeSlice(target, 2)))\n    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);\n\n  const resolved = new URL(target, packageJSONUrl);\n  const resolvedPath = resolved.pathname;\n  const packagePath = new URL('.', packageJSONUrl).pathname;\n\n  if (!StringPrototypeStartsWith(resolvedPath, packagePath))\n    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);\n\n  if (subpath === '') return resolved;\n\n  if (RegExpPrototypeTest(invalidSegmentRegEx, subpath))\n    throwInvalidSubpath(match + subpath, packageJSONUrl, internal, base);\n\n  if (pattern)\n    return new URL(StringPrototypeReplace(resolved.href, patternRegEx,\n                                          subpath));\n  return new URL(subpath, resolved);\n}\n\n/**\n * @param {string} key\n * @returns {boolean}\n */\nfunction isArrayIndex(key) {\n  const keyNum = +key;\n  if (`${keyNum}` !== key) return false;\n  return keyNum >= 0 && keyNum < 0xFFFF_FFFF;\n}\n\nfunction resolvePackageTarget(packageJSONUrl, target, subpath, packageSubpath,\n                              base, pattern, internal, conditions) {\n  if (typeof target === 'string') {\n    return resolvePackageTargetString(\n      target, subpath, packageSubpath, packageJSONUrl, base, pattern, internal,\n      conditions);\n  } else if (ArrayIsArray(target)) {\n    if (target.length === 0)\n      return null;\n\n    let lastException;\n    for (let i = 0; i < target.length; i++) {\n      const targetItem = target[i];\n      let resolved;\n      try {\n        resolved = resolvePackageTarget(\n          packageJSONUrl, targetItem, subpath, packageSubpath, base, pattern,\n          internal, conditions);\n      } catch (e) {\n        lastException = e;\n        if (e.code === 'ERR_INVALID_PACKAGE_TARGET')\n          continue;\n        throw e;\n      }\n      if (resolved === undefined)\n        continue;\n      if (resolved === null) {\n        lastException = null;\n        continue;\n      }\n      return resolved;\n    }\n    if (lastException === undefined || lastException === null)\n      return lastException;\n    throw lastException;\n  } else if (typeof target === 'object' && target !== null) {\n    const keys = ObjectGetOwnPropertyNames(target);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (isArrayIndex(key)) {\n        throw new ERR_INVALID_PACKAGE_CONFIG(\n          fileURLToPath(packageJSONUrl), base,\n          '\"exports\" cannot contain numeric property keys.');\n      }\n    }\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (key === 'default' || conditions.has(key)) {\n        const conditionalTarget = target[key];\n        const resolved = resolvePackageTarget(\n          packageJSONUrl, conditionalTarget, subpath, packageSubpath, base,\n          pattern, internal, conditions);\n        if (resolved === undefined)\n          continue;\n        return resolved;\n      }\n    }\n    return undefined;\n  } else if (target === null) {\n    return null;\n  }\n  throwInvalidPackageTarget(packageSubpath, target, packageJSONUrl, internal,\n                            base);\n}\n\nfunction isConditionalExportsMainSugar(exports, packageJSONUrl, base) {\n  if (typeof exports === 'string' || ArrayIsArray(exports)) return true;\n  if (typeof exports !== 'object' || exports === null) return false;\n\n  const keys = ObjectGetOwnPropertyNames(exports);\n  let isConditionalSugar = false;\n  let i = 0;\n  for (let j = 0; j < keys.length; j++) {\n    const key = keys[j];\n    const curIsConditionalSugar = key === '' || key[0] !== '.';\n    if (i++ === 0) {\n      isConditionalSugar = curIsConditionalSugar;\n    } else if (isConditionalSugar !== curIsConditionalSugar) {\n      throw new ERR_INVALID_PACKAGE_CONFIG(\n        fileURLToPath(packageJSONUrl), base,\n        '\"exports\" cannot contain some keys starting with \\'.\\' and some not.' +\n        ' The exports object must either be an object of package subpath keys' +\n        ' or an object of main entry condition name keys only.');\n    }\n  }\n  return isConditionalSugar;\n}\n\n/**\n * @param {URL} packageJSONUrl\n * @param {string} packageSubpath\n * @param {object} packageConfig\n * @param {string} base\n * @param {Set<string>} conditions\n * @returns {{resolved: URL, exact: boolean}}\n */\nfunction packageExportsResolve(\n  packageJSONUrl, packageSubpath, packageConfig, base, conditions) {\n  let exports = packageConfig.exports;\n  if (isConditionalExportsMainSugar(exports, packageJSONUrl, base))\n    exports = { '.': exports };\n\n  if (ObjectPrototypeHasOwnProperty(exports, packageSubpath)) {\n    const target = exports[packageSubpath];\n    const resolved = resolvePackageTarget(\n      packageJSONUrl, target, '', packageSubpath, base, false, false, conditions\n    );\n    if (resolved === null || resolved === undefined)\n      throwExportsNotFound(packageSubpath, packageJSONUrl, base);\n    return { resolved, exact: true };\n  }\n\n  let bestMatch = '';\n  const keys = ObjectGetOwnPropertyNames(exports);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (key[key.length - 1] === '*' &&\n        StringPrototypeStartsWith(packageSubpath,\n                                  StringPrototypeSlice(key, 0, -1)) &&\n        packageSubpath.length >= key.length &&\n        key.length > bestMatch.length) {\n      bestMatch = key;\n    } else if (key[key.length - 1] === '/' &&\n      StringPrototypeStartsWith(packageSubpath, key) &&\n      key.length > bestMatch.length) {\n      bestMatch = key;\n    }\n  }\n\n  if (bestMatch) {\n    const target = exports[bestMatch];\n    const pattern = bestMatch[bestMatch.length - 1] === '*';\n    const subpath = StringPrototypeSubstr(packageSubpath, bestMatch.length -\n      (pattern ? 1 : 0));\n    const resolved = resolvePackageTarget(packageJSONUrl, target, subpath,\n                                          bestMatch, base, pattern, false,\n                                          conditions);\n    if (resolved === null || resolved === undefined)\n      throwExportsNotFound(packageSubpath, packageJSONUrl, base);\n    if (!pattern)\n      emitFolderMapDeprecation(bestMatch, packageJSONUrl, true, base);\n    return { resolved, exact: pattern };\n  }\n\n  throwExportsNotFound(packageSubpath, packageJSONUrl, base);\n}\n\nfunction packageImportsResolve(name, base, conditions) {\n  if (name === '#' || StringPrototypeStartsWith(name, '#/')) {\n    const reason = 'is not a valid internal imports specifier name';\n    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, fileURLToPath(base));\n  }\n  let packageJSONUrl;\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n    const imports = packageConfig.imports;\n    if (imports) {\n      if (ObjectPrototypeHasOwnProperty(imports, name)) {\n        const resolved = resolvePackageTarget(\n          packageJSONUrl, imports[name], '', name, base, false, true, conditions\n        );\n        if (resolved !== null)\n          return { resolved, exact: true };\n      } else {\n        let bestMatch = '';\n        const keys = ObjectGetOwnPropertyNames(imports);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          if (key[key.length - 1] === '*' &&\n              StringPrototypeStartsWith(name,\n                                        StringPrototypeSlice(key, 0, -1)) &&\n              name.length >= key.length &&\n              key.length > bestMatch.length) {\n            bestMatch = key;\n          } else if (key[key.length - 1] === '/' &&\n            StringPrototypeStartsWith(name, key) &&\n            key.length > bestMatch.length) {\n            bestMatch = key;\n          }\n        }\n\n        if (bestMatch) {\n          const target = imports[bestMatch];\n          const pattern = bestMatch[bestMatch.length - 1] === '*';\n          const subpath = StringPrototypeSubstr(name, bestMatch.length -\n            (pattern ? 1 : 0));\n          const resolved = resolvePackageTarget(\n            packageJSONUrl, target, subpath, bestMatch, base, pattern, true,\n            conditions);\n          if (resolved !== null) {\n            if (!pattern)\n              emitFolderMapDeprecation(bestMatch, packageJSONUrl, false, base);\n            return { resolved, exact: pattern };\n          }\n        }\n      }\n    }\n  }\n  throwImportNotDefined(name, packageJSONUrl, base);\n}\n\nfunction getPackageType(url) {\n  const packageConfig = getPackageScopeConfig(url);\n  return packageConfig.type;\n}\n\nfunction parsePackageName(specifier, base) {\n  let separatorIndex = StringPrototypeIndexOf(specifier, '/');\n  let validPackageName = true;\n  let isScoped = false;\n  if (specifier[0] === '@') {\n    isScoped = true;\n    if (separatorIndex === -1 || specifier.length === 0) {\n      validPackageName = false;\n    } else {\n      separatorIndex = StringPrototypeIndexOf(\n        specifier, '/', separatorIndex + 1);\n    }\n  }\n\n  const packageName = separatorIndex === -1 ?\n    specifier : StringPrototypeSlice(specifier, 0, separatorIndex);\n\n  // Package name cannot have leading . and cannot have percent-encoding or\n  // separators.\n  for (let i = 0; i < packageName.length; i++) {\n    if (packageName[i] === '%' || packageName[i] === '\\\\') {\n      validPackageName = false;\n      break;\n    }\n  }\n\n  if (!validPackageName) {\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      specifier, 'is not a valid package name', fileURLToPath(base));\n  }\n\n  const packageSubpath = '.' + (separatorIndex === -1 ? '' :\n    StringPrototypeSlice(specifier, separatorIndex));\n\n  return { packageName, packageSubpath, isScoped };\n}\n\n/**\n * @param {string} specifier\n * @param {URL} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction packageResolve(specifier, base, conditions) {\n  const { packageName, packageSubpath, isScoped } =\n    parsePackageName(specifier, base);\n\n  // ResolveSelf\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    const packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n    if (packageConfig.name === packageName &&\n        packageConfig.exports !== undefined && packageConfig.exports !== null) {\n      return packageExportsResolve(\n        packageJSONUrl, packageSubpath, packageConfig, base, conditions\n      ).resolved;\n    }\n  }\n\n  let packageJSONUrl =\n    new URL('./node_modules/' + packageName + '/package.json', base);\n  let packageJSONPath = fileURLToPath(packageJSONUrl);\n  let lastPath;\n  do {\n    const stat = tryStatSync(StringPrototypeSlice(packageJSONPath, 0,\n                                                  packageJSONPath.length - 13));\n    if (!stat.isDirectory()) {\n      lastPath = packageJSONPath;\n      packageJSONUrl = new URL((isScoped ?\n        '../../../../node_modules/' : '../../../node_modules/') +\n        packageName + '/package.json', packageJSONUrl);\n      packageJSONPath = fileURLToPath(packageJSONUrl);\n      continue;\n    }\n\n    // Package match.\n    const packageConfig = getPackageConfig(packageJSONPath, specifier, base);\n    if (packageConfig.exports !== undefined && packageConfig.exports !== null)\n      return packageExportsResolve(\n        packageJSONUrl, packageSubpath, packageConfig, base, conditions\n      ).resolved;\n    if (packageSubpath === '.')\n      return legacyMainResolve(packageJSONUrl, packageConfig, base);\n    return new URL(packageSubpath, packageJSONUrl);\n    // Cross-platform root check.\n  } while (packageJSONPath.length !== lastPath.length);\n\n  // eslint can't handle the above code.\n  // eslint-disable-next-line no-unreachable\n  throw new ERR_MODULE_NOT_FOUND(packageName, fileURLToPath(base));\n}\n\nfunction isBareSpecifier(specifier) {\n  return specifier[0] && specifier[0] !== '/' && specifier[0] !== '.';\n}\n\nfunction isRelativeSpecifier(specifier) {\n  if (specifier[0] === '.') {\n    if (specifier.length === 1 || specifier[1] === '/') return true;\n    if (specifier[1] === '.') {\n      if (specifier.length === 2 || specifier[2] === '/') return true;\n    }\n  }\n  return false;\n}\n\nfunction shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {\n  if (specifier === '') return false;\n  if (specifier[0] === '/') return true;\n  return isRelativeSpecifier(specifier);\n}\n\n/**\n * @param {string} specifier\n * @param {URL} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction moduleResolve(specifier, base, conditions) {\n  // Order swapped from spec for minor perf gain.\n  // Ok since relative URLs cannot parse as URLs.\n  let resolved;\n  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n    resolved = new URL(specifier, base);\n  } else if (specifier[0] === '#') {\n    ({ resolved } = packageImportsResolve(specifier, base, conditions));\n  } else {\n    try {\n      resolved = new URL(specifier);\n    } catch {\n      resolved = packageResolve(specifier, base, conditions);\n    }\n  }\n  return finalizeResolution(resolved, base);\n}\n\n/**\n * Try to resolve an import as a CommonJS module\n * @param {string} specifier\n * @param {string} parentURL\n * @returns {boolean|string}\n */\nfunction resolveAsCommonJS(specifier, parentURL) {\n  try {\n    const parent = fileURLToPath(parentURL);\n    const tmpModule = new CJSModule(parent, null);\n    tmpModule.paths = CJSModule._nodeModulePaths(parent);\n\n    let found = CJSModule._resolveFilename(specifier, tmpModule, false);\n\n    // If it is a relative specifier return the relative path\n    // to the parent\n    if (isRelativeSpecifier(specifier)) {\n      found = relative(parent, found);\n      // Add '.separator if the path does not start with '..separator'\n      // This should be a safe assumption because when loading\n      // esm modules there should be always a file specified so\n      // there should not be a specifier like '..' or '.'\n      if (!StringPrototypeStartsWith(found, `..${sep}`)) {\n        found = `.${sep}${found}`;\n      }\n    } else if (isBareSpecifier(specifier)) {\n      // If it is a bare specifier return the relative path within the\n      // module\n      const pkg = StringPrototypeSplit(specifier, '/')[0];\n      const index = StringPrototypeIndexOf(found, pkg);\n      if (index !== -1) {\n        found = StringPrototypeSlice(found, index);\n      }\n    }\n    // Normalize the path separator to give a valid suggestion\n    // on Windows\n    if (process.platform === 'win32') {\n      found = StringPrototypeReplace(found, new RegExp(`\\\\${sep}`, 'g'), '/');\n    }\n    return found;\n  } catch {\n    return false;\n  }\n}\n\nfunction defaultResolve(specifier, context = {}, defaultResolveUnused) {\n  let { parentURL, conditions } = context;\n  if (parentURL && policy != null && policy.manifest) {\n    const redirects = policy.manifest.getDependencyMapper(parentURL);\n    if (redirects) {\n      const { resolve, reaction } = redirects;\n      const destination = resolve(specifier, new SafeSet(conditions));\n      let missing = true;\n      if (destination === true) {\n        missing = false;\n      } else if (destination) {\n        const href = destination.href;\n        return { url: href };\n      }\n      if (missing) {\n        reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(\n          parentURL,\n          specifier,\n          ArrayPrototypeJoin([...conditions], ', '))\n        );\n      }\n    }\n  }\n  let parsed;\n  try {\n    parsed = new URL(specifier);\n    if (parsed.protocol === 'data:') {\n      return {\n        url: specifier\n      };\n    }\n  } catch {}\n  if (parsed && parsed.protocol === builtinModuleProtocol)\n    return { url: specifier };\n  if (parsed && parsed.protocol !== 'file:' && parsed.protocol !== 'data:')\n    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed);\n  if (NativeModule.canBeRequiredByUsers(specifier)) {\n    return {\n      url: builtinModuleProtocol + specifier\n    };\n  }\n  if (parentURL && StringPrototypeStartsWith(parentURL, 'data:')) {\n    // This is gonna blow up, we want the error\n    new URL(specifier, parentURL);\n  }\n\n  const isMain = parentURL === undefined;\n  if (isMain) {\n    parentURL = pathToFileURL(`${process.cwd()}/`).href;\n\n    // This is the initial entry point to the program, and --input-type has\n    // been passed as an option; but --input-type can only be used with\n    // --eval, --print or STDIN string input. It is not allowed with file\n    // input, to avoid user confusion over how expansive the effect of the\n    // flag should be (i.e. entry point only, package scope surrounding the\n    // entry point, etc.).\n    if (typeFlag)\n      throw new ERR_INPUT_TYPE_NOT_ALLOWED();\n  }\n\n  conditions = getConditionsSet(conditions);\n  let url;\n  try {\n    url = moduleResolve(specifier, parentURL, conditions);\n  } catch (error) {\n    // Try to give the user a hint of what would have been the\n    // resolved CommonJS module\n    if (error.code === 'ERR_MODULE_NOT_FOUND' ||\n        error.code === 'ERR_UNSUPPORTED_DIR_IMPORT') {\n      if (StringPrototypeStartsWith(specifier, 'file://')) {\n        specifier = fileURLToPath(specifier);\n      }\n      const found = resolveAsCommonJS(specifier, parentURL);\n      if (found) {\n        // Modify the stack and message string to include the hint\n        const lines = StringPrototypeSplit(error.stack, '\\n');\n        const hint = `Did you mean to import ${found}?`;\n        error.stack =\n          ArrayPrototypeShift(lines) + '\\n' +\n          hint + '\\n' +\n          ArrayPrototypeJoin(lines, '\\n');\n        error.message += `\\n${hint}`;\n      }\n    }\n    throw error;\n  }\n\n  if (isMain ? !preserveSymlinksMain : !preserveSymlinks) {\n    const urlPath = fileURLToPath(url);\n    const real = realpathSync(urlPath, {\n      // [internalFS.realpathCacheKey]: realpathCache\n    });\n    const old = url;\n    url = pathToFileURL(\n      real + (StringPrototypeEndsWith(urlPath, sep) ? '/' : ''));\n    url.search = old.search;\n    url.hash = old.hash;\n  }\n\n  return { url: `${url}` };\n}\n\nreturn {\n  DEFAULT_CONDITIONS,\n  defaultResolve,\n  encodedSepRegEx,\n  getPackageType,\n  packageExportsResolve,\n  packageImportsResolve\n};\n}\nmodule.exports = {\n  createResolve\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}