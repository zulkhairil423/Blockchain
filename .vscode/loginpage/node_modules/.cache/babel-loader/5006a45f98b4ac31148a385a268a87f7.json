{"ast":null,"code":"/**\n * A doubly linked list-based Least Recently Used (LRU) cache. Will keep most\n * recently used items while discarding least recently used items when its limit\n * is reached.\n *\n * Licensed under MIT. Copyright (c) 2010 Rasmus Andersson <http://hunch.se/>\n * See README.md for details.\n *\n * Illustration of the design:\n *\n *       entry             entry             entry             entry\n *       ______            ______            ______            ______\n *      | head |.newer => |      |.newer => |      |.newer => | tail |\n *      |  A   |          |  B   |          |  C   |          |  D   |\n *      |______| <= older.|______| <= older.|______| <= older.|______|\n *\n *  removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added\n */\n(function (g, f) {\n  const e = typeof exports == 'object' ? exports : typeof g == 'object' ? g : {};\n  f(e);\n\n  if (typeof define == 'function' && define.amd) {\n    define('lru', e);\n  }\n})(this, function (exports) {\n  const NEWER = Symbol('newer');\n  const OLDER = Symbol('older');\n\n  function LRUMap(limit, entries) {\n    if (typeof limit !== 'number') {\n      // called as (entries)\n      entries = limit;\n      limit = 0;\n    }\n\n    this.size = 0;\n    this.limit = limit;\n    this.oldest = this.newest = undefined;\n    this._keymap = new Map();\n\n    if (entries) {\n      this.assign(entries);\n\n      if (limit < 1) {\n        this.limit = this.size;\n      }\n    }\n  }\n\n  exports.LRUMap = LRUMap;\n\n  function Entry(key, value) {\n    this.key = key;\n    this.value = value;\n    this[NEWER] = undefined;\n    this[OLDER] = undefined;\n  }\n\n  LRUMap.prototype._markEntryAsUsed = function (entry) {\n    if (entry === this.newest) {\n      // Already the most recenlty used entry, so no need to update the list\n      return;\n    } // HEAD--------------TAIL\n    //   <.older   .newer>\n    //  <--- add direction --\n    //   A  B  C  <D>  E\n\n\n    if (entry[NEWER]) {\n      if (entry === this.oldest) {\n        this.oldest = entry[NEWER];\n      }\n\n      entry[NEWER][OLDER] = entry[OLDER]; // C <-- E.\n    }\n\n    if (entry[OLDER]) {\n      entry[OLDER][NEWER] = entry[NEWER]; // C. --> E\n    }\n\n    entry[NEWER] = undefined; // D --x\n\n    entry[OLDER] = this.newest; // D. --> E\n\n    if (this.newest) {\n      this.newest[NEWER] = entry; // E. <-- D\n    }\n\n    this.newest = entry;\n  };\n\n  LRUMap.prototype.assign = function (entries) {\n    let entry,\n        limit = this.limit || Number.MAX_VALUE;\n\n    this._keymap.clear();\n\n    let it = entries[Symbol.iterator]();\n\n    for (let itv = it.next(); !itv.done; itv = it.next()) {\n      let e = new Entry(itv.value[0], itv.value[1]);\n\n      this._keymap.set(e.key, e);\n\n      if (!entry) {\n        this.oldest = e;\n      } else {\n        entry[NEWER] = e;\n        e[OLDER] = entry;\n      }\n\n      entry = e;\n\n      if (limit-- == 0) {\n        throw new Error('overflow');\n      }\n    }\n\n    this.newest = entry;\n    this.size = this._keymap.size;\n  };\n\n  LRUMap.prototype.get = function (key) {\n    // First, find our cache entry\n    var entry = this._keymap.get(key);\n\n    if (!entry) return; // Not cached. Sorry.\n    // As <key> was found in the cache, register it as being requested recently\n\n    this._markEntryAsUsed(entry);\n\n    return entry.value;\n  };\n\n  LRUMap.prototype.set = function (key, value) {\n    var entry = this._keymap.get(key);\n\n    if (entry) {\n      // update existing\n      entry.value = value;\n\n      this._markEntryAsUsed(entry);\n\n      return this;\n    } // new entry\n\n\n    this._keymap.set(key, entry = new Entry(key, value));\n\n    if (this.newest) {\n      // link previous tail to the new tail (entry)\n      this.newest[NEWER] = entry;\n      entry[OLDER] = this.newest;\n    } else {\n      // we're first in -- yay\n      this.oldest = entry;\n    } // add new entry to the end of the linked list -- it's now the freshest entry.\n\n\n    this.newest = entry;\n    ++this.size;\n\n    if (this.size > this.limit) {\n      // we hit the limit -- remove the head\n      this.shift();\n    }\n\n    return this;\n  };\n\n  LRUMap.prototype.shift = function () {\n    // todo: handle special case when limit == 1\n    var entry = this.oldest;\n\n    if (entry) {\n      if (this.oldest[NEWER]) {\n        // advance the list\n        this.oldest = this.oldest[NEWER];\n        this.oldest[OLDER] = undefined;\n      } else {\n        // the cache is exhausted\n        this.oldest = undefined;\n        this.newest = undefined;\n      } // Remove last strong reference to <entry> and remove links from the purged\n      // entry being returned:\n\n\n      entry[NEWER] = entry[OLDER] = undefined;\n\n      this._keymap.delete(entry.key);\n\n      --this.size;\n      return [entry.key, entry.value];\n    }\n  }; // ----------------------------------------------------------------------------\n  // Following code is optional and can be removed without breaking the core\n  // functionality.\n\n\n  LRUMap.prototype.find = function (key) {\n    let e = this._keymap.get(key);\n\n    return e ? e.value : undefined;\n  };\n\n  LRUMap.prototype.has = function (key) {\n    return this._keymap.has(key);\n  };\n\n  LRUMap.prototype['delete'] = function (key) {\n    var entry = this._keymap.get(key);\n\n    if (!entry) return;\n\n    this._keymap.delete(entry.key);\n\n    if (entry[NEWER] && entry[OLDER]) {\n      // relink the older entry with the newer entry\n      entry[OLDER][NEWER] = entry[NEWER];\n      entry[NEWER][OLDER] = entry[OLDER];\n    } else if (entry[NEWER]) {\n      // remove the link to us\n      entry[NEWER][OLDER] = undefined; // link the newer entry to head\n\n      this.oldest = entry[NEWER];\n    } else if (entry[OLDER]) {\n      // remove the link to us\n      entry[OLDER][NEWER] = undefined; // link the newer entry to head\n\n      this.newest = entry[OLDER];\n    } else {\n      // if(entry[OLDER] === undefined && entry.newer === undefined) {\n      this.oldest = this.newest = undefined;\n    }\n\n    this.size--;\n    return entry.value;\n  };\n\n  LRUMap.prototype.clear = function () {\n    // Not clearing links should be safe, as we don't expose live links to user\n    this.oldest = this.newest = undefined;\n    this.size = 0;\n\n    this._keymap.clear();\n  };\n\n  function EntryIterator(oldestEntry) {\n    this.entry = oldestEntry;\n  }\n\n  EntryIterator.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n\n  EntryIterator.prototype.next = function () {\n    let ent = this.entry;\n\n    if (ent) {\n      this.entry = ent[NEWER];\n      return {\n        done: false,\n        value: [ent.key, ent.value]\n      };\n    } else {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n  };\n\n  function KeyIterator(oldestEntry) {\n    this.entry = oldestEntry;\n  }\n\n  KeyIterator.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n\n  KeyIterator.prototype.next = function () {\n    let ent = this.entry;\n\n    if (ent) {\n      this.entry = ent[NEWER];\n      return {\n        done: false,\n        value: ent.key\n      };\n    } else {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n  };\n\n  function ValueIterator(oldestEntry) {\n    this.entry = oldestEntry;\n  }\n\n  ValueIterator.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n\n  ValueIterator.prototype.next = function () {\n    let ent = this.entry;\n\n    if (ent) {\n      this.entry = ent[NEWER];\n      return {\n        done: false,\n        value: ent.value\n      };\n    } else {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n  };\n\n  LRUMap.prototype.keys = function () {\n    return new KeyIterator(this.oldest);\n  };\n\n  LRUMap.prototype.values = function () {\n    return new ValueIterator(this.oldest);\n  };\n\n  LRUMap.prototype.entries = function () {\n    return this;\n  };\n\n  LRUMap.prototype[Symbol.iterator] = function () {\n    return new EntryIterator(this.oldest);\n  };\n\n  LRUMap.prototype.forEach = function (fun, thisObj) {\n    if (typeof thisObj !== 'object') {\n      thisObj = this;\n    }\n\n    let entry = this.oldest;\n\n    while (entry) {\n      fun.call(thisObj, entry.value, entry.key, this);\n      entry = entry[NEWER];\n    }\n  };\n  /** Returns a JSON (array) representation */\n\n\n  LRUMap.prototype.toJSON = function () {\n    var s = new Array(this.size),\n        i = 0,\n        entry = this.oldest;\n\n    while (entry) {\n      s[i++] = {\n        key: entry.key,\n        value: entry.value\n      };\n      entry = entry[NEWER];\n    }\n\n    return s;\n  };\n  /** Returns a String representation */\n\n\n  LRUMap.prototype.toString = function () {\n    var s = '',\n        entry = this.oldest;\n\n    while (entry) {\n      s += String(entry.key) + ':' + entry.value;\n      entry = entry[NEWER];\n\n      if (entry) {\n        s += ' < ';\n      }\n    }\n\n    return s;\n  };\n});","map":{"version":3,"names":["g","f","e","exports","define","amd","NEWER","Symbol","OLDER","LRUMap","limit","entries","size","oldest","newest","undefined","_keymap","Map","assign","Entry","key","value","prototype","_markEntryAsUsed","entry","Number","MAX_VALUE","clear","it","iterator","itv","next","done","set","Error","get","shift","delete","find","has","EntryIterator","oldestEntry","ent","KeyIterator","ValueIterator","keys","values","forEach","fun","thisObj","call","toJSON","s","Array","i","toString","String"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/lru_map/lru.js"],"sourcesContent":["/**\n * A doubly linked list-based Least Recently Used (LRU) cache. Will keep most\n * recently used items while discarding least recently used items when its limit\n * is reached.\n *\n * Licensed under MIT. Copyright (c) 2010 Rasmus Andersson <http://hunch.se/>\n * See README.md for details.\n *\n * Illustration of the design:\n *\n *       entry             entry             entry             entry\n *       ______            ______            ______            ______\n *      | head |.newer => |      |.newer => |      |.newer => | tail |\n *      |  A   |          |  B   |          |  C   |          |  D   |\n *      |______| <= older.|______| <= older.|______| <= older.|______|\n *\n *  removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added\n */\n(function(g,f){\n  const e = typeof exports == 'object' ? exports : typeof g == 'object' ? g : {};\n  f(e);\n  if (typeof define == 'function' && define.amd) { define('lru', e); }\n})(this, function(exports) {\n\nconst NEWER = Symbol('newer');\nconst OLDER = Symbol('older');\n\nfunction LRUMap(limit, entries) {\n  if (typeof limit !== 'number') {\n    // called as (entries)\n    entries = limit;\n    limit = 0;\n  }\n\n  this.size = 0;\n  this.limit = limit;\n  this.oldest = this.newest = undefined;\n  this._keymap = new Map();\n\n  if (entries) {\n    this.assign(entries);\n    if (limit < 1) {\n      this.limit = this.size;\n    }\n  }\n}\n\nexports.LRUMap = LRUMap;\n\nfunction Entry(key, value) {\n  this.key = key;\n  this.value = value;\n  this[NEWER] = undefined;\n  this[OLDER] = undefined;\n}\n\n\nLRUMap.prototype._markEntryAsUsed = function(entry) {\n  if (entry === this.newest) {\n    // Already the most recenlty used entry, so no need to update the list\n    return;\n  }\n  // HEAD--------------TAIL\n  //   <.older   .newer>\n  //  <--- add direction --\n  //   A  B  C  <D>  E\n  if (entry[NEWER]) {\n    if (entry === this.oldest) {\n      this.oldest = entry[NEWER];\n    }\n    entry[NEWER][OLDER] = entry[OLDER]; // C <-- E.\n  }\n  if (entry[OLDER]) {\n    entry[OLDER][NEWER] = entry[NEWER]; // C. --> E\n  }\n  entry[NEWER] = undefined; // D --x\n  entry[OLDER] = this.newest; // D. --> E\n  if (this.newest) {\n    this.newest[NEWER] = entry; // E. <-- D\n  }\n  this.newest = entry;\n};\n\nLRUMap.prototype.assign = function(entries) {\n  let entry, limit = this.limit || Number.MAX_VALUE;\n  this._keymap.clear();\n  let it = entries[Symbol.iterator]();\n  for (let itv = it.next(); !itv.done; itv = it.next()) {\n    let e = new Entry(itv.value[0], itv.value[1]);\n    this._keymap.set(e.key, e);\n    if (!entry) {\n      this.oldest = e;\n    } else {\n      entry[NEWER] = e;\n      e[OLDER] = entry;\n    }\n    entry = e;\n    if (limit-- == 0) {\n      throw new Error('overflow');\n    }\n  }\n  this.newest = entry;\n  this.size = this._keymap.size;\n};\n\nLRUMap.prototype.get = function(key) {\n  // First, find our cache entry\n  var entry = this._keymap.get(key);\n  if (!entry) return; // Not cached. Sorry.\n  // As <key> was found in the cache, register it as being requested recently\n  this._markEntryAsUsed(entry);\n  return entry.value;\n};\n\nLRUMap.prototype.set = function(key, value) {\n  var entry = this._keymap.get(key);\n\n  if (entry) {\n    // update existing\n    entry.value = value;\n    this._markEntryAsUsed(entry);\n    return this;\n  }\n\n  // new entry\n  this._keymap.set(key, (entry = new Entry(key, value)));\n\n  if (this.newest) {\n    // link previous tail to the new tail (entry)\n    this.newest[NEWER] = entry;\n    entry[OLDER] = this.newest;\n  } else {\n    // we're first in -- yay\n    this.oldest = entry;\n  }\n\n  // add new entry to the end of the linked list -- it's now the freshest entry.\n  this.newest = entry;\n  ++this.size;\n  if (this.size > this.limit) {\n    // we hit the limit -- remove the head\n    this.shift();\n  }\n\n  return this;\n};\n\nLRUMap.prototype.shift = function() {\n  // todo: handle special case when limit == 1\n  var entry = this.oldest;\n  if (entry) {\n    if (this.oldest[NEWER]) {\n      // advance the list\n      this.oldest = this.oldest[NEWER];\n      this.oldest[OLDER] = undefined;\n    } else {\n      // the cache is exhausted\n      this.oldest = undefined;\n      this.newest = undefined;\n    }\n    // Remove last strong reference to <entry> and remove links from the purged\n    // entry being returned:\n    entry[NEWER] = entry[OLDER] = undefined;\n    this._keymap.delete(entry.key);\n    --this.size;\n    return [entry.key, entry.value];\n  }\n};\n\n// ----------------------------------------------------------------------------\n// Following code is optional and can be removed without breaking the core\n// functionality.\n\nLRUMap.prototype.find = function(key) {\n  let e = this._keymap.get(key);\n  return e ? e.value : undefined;\n};\n\nLRUMap.prototype.has = function(key) {\n  return this._keymap.has(key);\n};\n\nLRUMap.prototype['delete'] = function(key) {\n  var entry = this._keymap.get(key);\n  if (!entry) return;\n  this._keymap.delete(entry.key);\n  if (entry[NEWER] && entry[OLDER]) {\n    // relink the older entry with the newer entry\n    entry[OLDER][NEWER] = entry[NEWER];\n    entry[NEWER][OLDER] = entry[OLDER];\n  } else if (entry[NEWER]) {\n    // remove the link to us\n    entry[NEWER][OLDER] = undefined;\n    // link the newer entry to head\n    this.oldest = entry[NEWER];\n  } else if (entry[OLDER]) {\n    // remove the link to us\n    entry[OLDER][NEWER] = undefined;\n    // link the newer entry to head\n    this.newest = entry[OLDER];\n  } else {// if(entry[OLDER] === undefined && entry.newer === undefined) {\n    this.oldest = this.newest = undefined;\n  }\n\n  this.size--;\n  return entry.value;\n};\n\nLRUMap.prototype.clear = function() {\n  // Not clearing links should be safe, as we don't expose live links to user\n  this.oldest = this.newest = undefined;\n  this.size = 0;\n  this._keymap.clear();\n};\n\n\nfunction EntryIterator(oldestEntry) { this.entry = oldestEntry; }\nEntryIterator.prototype[Symbol.iterator] = function() { return this; }\nEntryIterator.prototype.next = function() {\n  let ent = this.entry;\n  if (ent) {\n    this.entry = ent[NEWER];\n    return { done: false, value: [ent.key, ent.value] };\n  } else {\n    return { done: true, value: undefined };\n  }\n};\n\n\nfunction KeyIterator(oldestEntry) { this.entry = oldestEntry; }\nKeyIterator.prototype[Symbol.iterator] = function() { return this; }\nKeyIterator.prototype.next = function() {\n  let ent = this.entry;\n  if (ent) {\n    this.entry = ent[NEWER];\n    return { done: false, value: ent.key };\n  } else {\n    return { done: true, value: undefined };\n  }\n};\n\nfunction ValueIterator(oldestEntry) { this.entry = oldestEntry; }\nValueIterator.prototype[Symbol.iterator] = function() { return this; }\nValueIterator.prototype.next = function() {\n  let ent = this.entry;\n  if (ent) {\n    this.entry = ent[NEWER];\n    return { done: false, value: ent.value };\n  } else {\n    return { done: true, value: undefined };\n  }\n};\n\n\nLRUMap.prototype.keys = function() {\n  return new KeyIterator(this.oldest);\n};\n\nLRUMap.prototype.values = function() {\n  return new ValueIterator(this.oldest);\n};\n\nLRUMap.prototype.entries = function() {\n  return this;\n};\n\nLRUMap.prototype[Symbol.iterator] = function() {\n  return new EntryIterator(this.oldest);\n};\n\nLRUMap.prototype.forEach = function(fun, thisObj) {\n  if (typeof thisObj !== 'object') {\n    thisObj = this;\n  }\n  let entry = this.oldest;\n  while (entry) {\n    fun.call(thisObj, entry.value, entry.key, this);\n    entry = entry[NEWER];\n  }\n};\n\n/** Returns a JSON (array) representation */\nLRUMap.prototype.toJSON = function() {\n  var s = new Array(this.size), i = 0, entry = this.oldest;\n  while (entry) {\n    s[i++] = { key: entry.key, value: entry.value };\n    entry = entry[NEWER];\n  }\n  return s;\n};\n\n/** Returns a String representation */\nLRUMap.prototype.toString = function() {\n  var s = '', entry = this.oldest;\n  while (entry) {\n    s += String(entry.key)+':'+entry.value;\n    entry = entry[NEWER];\n    if (entry) {\n      s += ' < ';\n    }\n  }\n  return s;\n};\n\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}