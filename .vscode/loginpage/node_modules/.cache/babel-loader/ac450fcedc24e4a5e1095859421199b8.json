{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPatternFromSpec = exports.createTsInternals = void 0;\n\nconst path_1 = require(\"path\");\n\nconst util_1 = require(\"./util\");\n/** @internal */\n\n\nexports.createTsInternals = (0, util_1.cachedLookup)(createTsInternalsUncached);\n/**\n * Given a reference to the TS compiler, return some TS internal functions that we\n * could not or did not want to grab off the `ts` object.\n * These have been copy-pasted from TS's source and tweaked as necessary.\n *\n * NOTE: This factory returns *only* functions which need a reference to the TS\n * compiler.  Other functions do not need a reference to the TS compiler so are\n * exported directly from this file.\n */\n\nfunction createTsInternalsUncached(_ts) {\n  const ts = _ts;\n  /**\n   * Copied from:\n   * https://github.com/microsoft/TypeScript/blob/v4.3.2/src/compiler/commandLineParser.ts#L2821-L2846\n   */\n\n  function getExtendsConfigPath(extendedConfig, host, basePath, errors, createDiagnostic) {\n    extendedConfig = (0, util_1.normalizeSlashes)(extendedConfig);\n\n    if (isRootedDiskPath(extendedConfig) || startsWith(extendedConfig, './') || startsWith(extendedConfig, '../')) {\n      let extendedConfigPath = getNormalizedAbsolutePath(extendedConfig, basePath);\n\n      if (!host.fileExists(extendedConfigPath) && !endsWith(extendedConfigPath, ts.Extension.Json)) {\n        extendedConfigPath = `${extendedConfigPath}.json`;\n\n        if (!host.fileExists(extendedConfigPath)) {\n          errors.push(createDiagnostic(ts.Diagnostics.File_0_not_found, extendedConfig));\n          return undefined;\n        }\n      }\n\n      return extendedConfigPath;\n    } // If the path isn't a rooted or relative path, resolve like a module\n\n\n    const resolved = ts.nodeModuleNameResolver(extendedConfig, combinePaths(basePath, 'tsconfig.json'), {\n      moduleResolution: ts.ModuleResolutionKind.NodeJs\n    }, host,\n    /*cache*/\n    undefined,\n    /*projectRefs*/\n    undefined,\n    /*lookupConfig*/\n    true);\n\n    if (resolved.resolvedModule) {\n      return resolved.resolvedModule.resolvedFileName;\n    }\n\n    errors.push(createDiagnostic(ts.Diagnostics.File_0_not_found, extendedConfig));\n    return undefined;\n  }\n\n  return {\n    getExtendsConfigPath\n  };\n} // These functions have alternative implementation to avoid copying too much from TS\n\n\nfunction isRootedDiskPath(path) {\n  return (0, path_1.isAbsolute)(path);\n}\n\nfunction combinePaths(path) {\n  for (var _len = arguments.length, paths = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    paths[_key - 1] = arguments[_key];\n  }\n\n  return (0, util_1.normalizeSlashes)((0, path_1.resolve)(path, ...paths.filter(path => path)));\n}\n\nfunction getNormalizedAbsolutePath(fileName, currentDirectory) {\n  return (0, util_1.normalizeSlashes)(currentDirectory != null ? (0, path_1.resolve)(currentDirectory, fileName) : (0, path_1.resolve)(fileName));\n}\n\nfunction startsWith(str, prefix) {\n  return str.lastIndexOf(prefix, 0) === 0;\n}\n\nfunction endsWith(str, suffix) {\n  const expectedPos = str.length - suffix.length;\n  return expectedPos >= 0 && str.indexOf(suffix, expectedPos) === expectedPos;\n} // Reserved characters, forces escaping of any non-word (or digit), non-whitespace character.\n// It may be inefficient (we could just match (/[-[\\]{}()*+?.,\\\\^$|#\\s]/g), but this is future\n// proof.\n\n\nconst reservedCharacterPattern = /[^\\w\\s\\/]/g;\n/**\n * @internal\n * See also: getRegularExpressionForWildcard, which seems to do almost the same thing\n */\n\nfunction getPatternFromSpec(spec, basePath) {\n  const pattern = spec && getSubPatternFromSpec(spec, basePath, excludeMatcher);\n  return pattern && `^(${pattern})${'($|/)'}`;\n}\n\nexports.getPatternFromSpec = getPatternFromSpec;\n\nfunction getSubPatternFromSpec(spec, basePath, _ref) {\n  let {\n    singleAsteriskRegexFragment,\n    doubleAsteriskRegexFragment,\n    replaceWildcardCharacter\n  } = _ref;\n  let subpattern = '';\n  let hasWrittenComponent = false;\n  const components = getNormalizedPathComponents(spec, basePath);\n  const lastComponent = last(components); // getNormalizedPathComponents includes the separator for the root component.\n  // We need to remove to create our regex correctly.\n\n  components[0] = removeTrailingDirectorySeparator(components[0]);\n\n  if (isImplicitGlob(lastComponent)) {\n    components.push('**', '*');\n  }\n\n  let optionalCount = 0;\n\n  for (let component of components) {\n    if (component === '**') {\n      subpattern += doubleAsteriskRegexFragment;\n    } else {\n      if (hasWrittenComponent) {\n        subpattern += directorySeparator;\n      }\n\n      subpattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter);\n    }\n\n    hasWrittenComponent = true;\n  }\n\n  while (optionalCount > 0) {\n    subpattern += ')?';\n    optionalCount--;\n  }\n\n  return subpattern;\n}\n\nconst directoriesMatcher = {\n  singleAsteriskRegexFragment: '[^/]*',\n\n  /**\n   * Regex for the ** wildcard. Matches any num of subdirectories. When used for including\n   * files or directories, does not match subdirectories that start with a . character\n   */\n  doubleAsteriskRegexFragment: `(/[^/.][^/]*)*?`,\n  replaceWildcardCharacter: match => replaceWildcardCharacter(match, directoriesMatcher.singleAsteriskRegexFragment)\n};\nconst excludeMatcher = {\n  singleAsteriskRegexFragment: '[^/]*',\n  doubleAsteriskRegexFragment: '(/.+?)?',\n  replaceWildcardCharacter: match => replaceWildcardCharacter(match, excludeMatcher.singleAsteriskRegexFragment)\n};\n\nfunction getNormalizedPathComponents(path, currentDirectory) {\n  return reducePathComponents(getPathComponents(path, currentDirectory));\n}\n\nfunction getPathComponents(path) {\n  let currentDirectory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  path = combinePaths(currentDirectory, path);\n  return pathComponents(path, getRootLength(path));\n}\n\nfunction reducePathComponents(components) {\n  if (!some(components)) return [];\n  const reduced = [components[0]];\n\n  for (let i = 1; i < components.length; i++) {\n    const component = components[i];\n    if (!component) continue;\n    if (component === '.') continue;\n\n    if (component === '..') {\n      if (reduced.length > 1) {\n        if (reduced[reduced.length - 1] !== '..') {\n          reduced.pop();\n          continue;\n        }\n      } else if (reduced[0]) continue;\n    }\n\n    reduced.push(component);\n  }\n\n  return reduced;\n}\n\nfunction getRootLength(path) {\n  const rootLength = getEncodedRootLength(path);\n  return rootLength < 0 ? ~rootLength : rootLength;\n}\n\nfunction getEncodedRootLength(path) {\n  if (!path) return 0;\n  const ch0 = path.charCodeAt(0); // POSIX or UNC\n\n  if (ch0 === 47\n  /* CharacterCodes.slash */\n  || ch0 === 92\n  /* CharacterCodes.backslash */\n  ) {\n    if (path.charCodeAt(1) !== ch0) return 1; // POSIX: \"/\" (or non-normalized \"\\\")\n\n    const p1 = path.indexOf(ch0 === 47\n    /* CharacterCodes.slash */\n    ? directorySeparator : altDirectorySeparator, 2);\n    if (p1 < 0) return path.length; // UNC: \"//server\" or \"\\\\server\"\n\n    return p1 + 1; // UNC: \"//server/\" or \"\\\\server\\\"\n  } // DOS\n\n\n  if (isVolumeCharacter(ch0) && path.charCodeAt(1) === 58\n  /* CharacterCodes.colon */\n  ) {\n    const ch2 = path.charCodeAt(2);\n    if (ch2 === 47\n    /* CharacterCodes.slash */\n    || ch2 === 92\n    /* CharacterCodes.backslash */\n    ) return 3; // DOS: \"c:/\" or \"c:\\\"\n\n    if (path.length === 2) return 2; // DOS: \"c:\" (but not \"c:d\")\n  } // URL\n\n\n  const schemeEnd = path.indexOf(urlSchemeSeparator);\n\n  if (schemeEnd !== -1) {\n    const authorityStart = schemeEnd + urlSchemeSeparator.length;\n    const authorityEnd = path.indexOf(directorySeparator, authorityStart);\n\n    if (authorityEnd !== -1) {\n      // URL: \"file:///\", \"file://server/\", \"file://server/path\"\n      // For local \"file\" URLs, include the leading DOS volume (if present).\n      // Per https://www.ietf.org/rfc/rfc1738.txt, a host of \"\" or \"localhost\" is a\n      // special case interpreted as \"the machine from which the URL is being interpreted\".\n      const scheme = path.slice(0, schemeEnd);\n      const authority = path.slice(authorityStart, authorityEnd);\n\n      if (scheme === 'file' && (authority === '' || authority === 'localhost') && isVolumeCharacter(path.charCodeAt(authorityEnd + 1))) {\n        const volumeSeparatorEnd = getFileUrlVolumeSeparatorEnd(path, authorityEnd + 2);\n\n        if (volumeSeparatorEnd !== -1) {\n          if (path.charCodeAt(volumeSeparatorEnd) === 47\n          /* CharacterCodes.slash */\n          ) {\n            // URL: \"file:///c:/\", \"file://localhost/c:/\", \"file:///c%3a/\", \"file://localhost/c%3a/\"\n            return ~(volumeSeparatorEnd + 1);\n          }\n\n          if (volumeSeparatorEnd === path.length) {\n            // URL: \"file:///c:\", \"file://localhost/c:\", \"file:///c$3a\", \"file://localhost/c%3a\"\n            // but not \"file:///c:d\" or \"file:///c%3ad\"\n            return ~volumeSeparatorEnd;\n          }\n        }\n      }\n\n      return ~(authorityEnd + 1); // URL: \"file://server/\", \"http://server/\"\n    }\n\n    return ~path.length; // URL: \"file://server\", \"http://server\"\n  } // relative\n\n\n  return 0;\n}\n\nfunction ensureTrailingDirectorySeparator(path) {\n  if (!hasTrailingDirectorySeparator(path)) {\n    return path + directorySeparator;\n  }\n\n  return path;\n}\n\nfunction hasTrailingDirectorySeparator(path) {\n  return path.length > 0 && isAnyDirectorySeparator(path.charCodeAt(path.length - 1));\n}\n\nfunction isAnyDirectorySeparator(charCode) {\n  return charCode === 47\n  /* CharacterCodes.slash */\n  || charCode === 92\n  /* CharacterCodes.backslash */\n  ;\n}\n\nfunction removeTrailingDirectorySeparator(path) {\n  if (hasTrailingDirectorySeparator(path)) {\n    return path.substr(0, path.length - 1);\n  }\n\n  return path;\n}\n\nconst directorySeparator = '/';\nconst altDirectorySeparator = '\\\\';\nconst urlSchemeSeparator = '://';\n\nfunction isVolumeCharacter(charCode) {\n  return charCode >= 97\n  /* CharacterCodes.a */\n  && charCode <= 122\n  /* CharacterCodes.z */\n  || charCode >= 65\n  /* CharacterCodes.A */\n  && charCode <= 90\n  /* CharacterCodes.Z */\n  ;\n}\n\nfunction getFileUrlVolumeSeparatorEnd(url, start) {\n  const ch0 = url.charCodeAt(start);\n  if (ch0 === 58\n  /* CharacterCodes.colon */\n  ) return start + 1;\n\n  if (ch0 === 37\n  /* CharacterCodes.percent */\n  && url.charCodeAt(start + 1) === 51\n  /* CharacterCodes._3 */\n  ) {\n    const ch2 = url.charCodeAt(start + 2);\n    if (ch2 === 97\n    /* CharacterCodes.a */\n    || ch2 === 65\n    /* CharacterCodes.A */\n    ) return start + 3;\n  }\n\n  return -1;\n}\n\nfunction some(array, predicate) {\n  if (array) {\n    if (predicate) {\n      for (const v of array) {\n        if (predicate(v)) {\n          return true;\n        }\n      }\n    } else {\n      return array.length > 0;\n    }\n  }\n\n  return false;\n}\n\nfunction pathComponents(path, rootLength) {\n  const root = path.substring(0, rootLength);\n  const rest = path.substring(rootLength).split(directorySeparator);\n  if (rest.length && !lastOrUndefined(rest)) rest.pop();\n  return [root, ...rest];\n}\n\nfunction lastOrUndefined(array) {\n  return array.length === 0 ? undefined : array[array.length - 1];\n}\n\nfunction last(array) {\n  // Debug.assert(array.length !== 0);\n  return array[array.length - 1];\n}\n\nfunction replaceWildcardCharacter(match, singleAsteriskRegexFragment) {\n  return match === '*' ? singleAsteriskRegexFragment : match === '?' ? '[^/]' : '\\\\' + match;\n}\n/**\n * An \"includes\" path \"foo\" is implicitly a glob \"foo/** /*\" (without the space) if its last component has no extension,\n * and does not contain any glob characters itself.\n */\n\n\nfunction isImplicitGlob(lastPathComponent) {\n  return !/[.*?]/.test(lastPathComponent);\n}","map":{"version":3,"mappings":"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","names":["exports","createTsInternalsUncached","_ts","ts","getExtendsConfigPath","extendedConfig","host","basePath","errors","createDiagnostic","isRootedDiskPath","startsWith","extendedConfigPath","getNormalizedAbsolutePath","fileExists","endsWith","Extension","Json","push","Diagnostics","File_0_not_found","undefined","resolved","nodeModuleNameResolver","combinePaths","moduleResolution","ModuleResolutionKind","NodeJs","resolvedModule","resolvedFileName","path","paths","filter","fileName","currentDirectory","str","prefix","lastIndexOf","suffix","expectedPos","length","indexOf","reservedCharacterPattern","getPatternFromSpec","spec","pattern","getSubPatternFromSpec","excludeMatcher","singleAsteriskRegexFragment","doubleAsteriskRegexFragment","replaceWildcardCharacter","subpattern","hasWrittenComponent","components","getNormalizedPathComponents","lastComponent","last","removeTrailingDirectorySeparator","isImplicitGlob","optionalCount","component","directorySeparator","replace","directoriesMatcher","match","reducePathComponents","getPathComponents","pathComponents","getRootLength","some","reduced","i","pop","rootLength","getEncodedRootLength","ch0","charCodeAt","p1","altDirectorySeparator","isVolumeCharacter","ch2","schemeEnd","urlSchemeSeparator","authorityStart","authorityEnd","scheme","slice","authority","volumeSeparatorEnd","getFileUrlVolumeSeparatorEnd","ensureTrailingDirectorySeparator","hasTrailingDirectorySeparator","isAnyDirectorySeparator","charCode","substr","url","start","array","predicate","v","root","substring","rest","split","lastOrUndefined","lastPathComponent","test"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\ts-node\\src\\ts-internals.ts"],"sourcesContent":["import { isAbsolute, resolve } from 'path';\nimport { cachedLookup, normalizeSlashes } from './util';\nimport type * as _ts from 'typescript';\nimport type { TSCommon, TSInternal } from './ts-compiler-types';\n\n/** @internal */\nexport const createTsInternals = cachedLookup(createTsInternalsUncached);\n/**\n * Given a reference to the TS compiler, return some TS internal functions that we\n * could not or did not want to grab off the `ts` object.\n * These have been copy-pasted from TS's source and tweaked as necessary.\n *\n * NOTE: This factory returns *only* functions which need a reference to the TS\n * compiler.  Other functions do not need a reference to the TS compiler so are\n * exported directly from this file.\n */\nfunction createTsInternalsUncached(_ts: TSCommon) {\n  const ts = _ts as TSCommon & TSInternal;\n  /**\n   * Copied from:\n   * https://github.com/microsoft/TypeScript/blob/v4.3.2/src/compiler/commandLineParser.ts#L2821-L2846\n   */\n  function getExtendsConfigPath(\n    extendedConfig: string,\n    host: _ts.ParseConfigHost,\n    basePath: string,\n    errors: _ts.Push<_ts.Diagnostic>,\n    createDiagnostic: (\n      message: _ts.DiagnosticMessage,\n      arg1?: string\n    ) => _ts.Diagnostic\n  ) {\n    extendedConfig = normalizeSlashes(extendedConfig);\n    if (\n      isRootedDiskPath(extendedConfig) ||\n      startsWith(extendedConfig, './') ||\n      startsWith(extendedConfig, '../')\n    ) {\n      let extendedConfigPath = getNormalizedAbsolutePath(\n        extendedConfig,\n        basePath\n      );\n      if (\n        !host.fileExists(extendedConfigPath) &&\n        !endsWith(extendedConfigPath, ts.Extension.Json)\n      ) {\n        extendedConfigPath = `${extendedConfigPath}.json`;\n        if (!host.fileExists(extendedConfigPath)) {\n          errors.push(\n            createDiagnostic(ts.Diagnostics.File_0_not_found, extendedConfig)\n          );\n          return undefined;\n        }\n      }\n      return extendedConfigPath;\n    }\n    // If the path isn't a rooted or relative path, resolve like a module\n    const resolved = ts.nodeModuleNameResolver(\n      extendedConfig,\n      combinePaths(basePath, 'tsconfig.json'),\n      { moduleResolution: ts.ModuleResolutionKind.NodeJs },\n      host,\n      /*cache*/ undefined,\n      /*projectRefs*/ undefined,\n      /*lookupConfig*/ true\n    );\n    if (resolved.resolvedModule) {\n      return resolved.resolvedModule.resolvedFileName;\n    }\n    errors.push(\n      createDiagnostic(ts.Diagnostics.File_0_not_found, extendedConfig)\n    );\n    return undefined;\n  }\n\n  return { getExtendsConfigPath };\n}\n\n// These functions have alternative implementation to avoid copying too much from TS\nfunction isRootedDiskPath(path: string) {\n  return isAbsolute(path);\n}\nfunction combinePaths(path: string, ...paths: (string | undefined)[]): string {\n  return normalizeSlashes(\n    resolve(path, ...(paths.filter((path) => path) as string[]))\n  );\n}\nfunction getNormalizedAbsolutePath(\n  fileName: string,\n  currentDirectory: string | undefined\n) {\n  return normalizeSlashes(\n    currentDirectory != null\n      ? resolve(currentDirectory!, fileName)\n      : resolve(fileName)\n  );\n}\n\nfunction startsWith(str: string, prefix: string): boolean {\n  return str.lastIndexOf(prefix, 0) === 0;\n}\n\nfunction endsWith(str: string, suffix: string): boolean {\n  const expectedPos = str.length - suffix.length;\n  return expectedPos >= 0 && str.indexOf(suffix, expectedPos) === expectedPos;\n}\n// Reserved characters, forces escaping of any non-word (or digit), non-whitespace character.\n// It may be inefficient (we could just match (/[-[\\]{}()*+?.,\\\\^$|#\\s]/g), but this is future\n// proof.\nconst reservedCharacterPattern = /[^\\w\\s\\/]/g;\n\n/**\n * @internal\n * See also: getRegularExpressionForWildcard, which seems to do almost the same thing\n */\nexport function getPatternFromSpec(spec: string, basePath: string) {\n  const pattern = spec && getSubPatternFromSpec(spec, basePath, excludeMatcher);\n  return pattern && `^(${pattern})${'($|/)'}`;\n}\nfunction getSubPatternFromSpec(\n  spec: string,\n  basePath: string,\n  {\n    singleAsteriskRegexFragment,\n    doubleAsteriskRegexFragment,\n    replaceWildcardCharacter,\n  }: WildcardMatcher\n): string {\n  let subpattern = '';\n  let hasWrittenComponent = false;\n  const components = getNormalizedPathComponents(spec, basePath);\n  const lastComponent = last(components);\n\n  // getNormalizedPathComponents includes the separator for the root component.\n  // We need to remove to create our regex correctly.\n  components[0] = removeTrailingDirectorySeparator(components[0]);\n\n  if (isImplicitGlob(lastComponent)) {\n    components.push('**', '*');\n  }\n\n  let optionalCount = 0;\n  for (let component of components) {\n    if (component === '**') {\n      subpattern += doubleAsteriskRegexFragment;\n    } else {\n      if (hasWrittenComponent) {\n        subpattern += directorySeparator;\n      }\n      subpattern += component.replace(\n        reservedCharacterPattern,\n        replaceWildcardCharacter\n      );\n    }\n\n    hasWrittenComponent = true;\n  }\n\n  while (optionalCount > 0) {\n    subpattern += ')?';\n    optionalCount--;\n  }\n\n  return subpattern;\n}\ninterface WildcardMatcher {\n  singleAsteriskRegexFragment: string;\n  doubleAsteriskRegexFragment: string;\n  replaceWildcardCharacter: (match: string) => string;\n}\nconst directoriesMatcher: WildcardMatcher = {\n  singleAsteriskRegexFragment: '[^/]*',\n  /**\n   * Regex for the ** wildcard. Matches any num of subdirectories. When used for including\n   * files or directories, does not match subdirectories that start with a . character\n   */\n  doubleAsteriskRegexFragment: `(/[^/.][^/]*)*?`,\n  replaceWildcardCharacter: (match) =>\n    replaceWildcardCharacter(\n      match,\n      directoriesMatcher.singleAsteriskRegexFragment\n    ),\n};\nconst excludeMatcher: WildcardMatcher = {\n  singleAsteriskRegexFragment: '[^/]*',\n  doubleAsteriskRegexFragment: '(/.+?)?',\n  replaceWildcardCharacter: (match) =>\n    replaceWildcardCharacter(match, excludeMatcher.singleAsteriskRegexFragment),\n};\nfunction getNormalizedPathComponents(\n  path: string,\n  currentDirectory: string | undefined\n) {\n  return reducePathComponents(getPathComponents(path, currentDirectory));\n}\nfunction getPathComponents(path: string, currentDirectory = '') {\n  path = combinePaths(currentDirectory, path);\n  return pathComponents(path, getRootLength(path));\n}\nfunction reducePathComponents(components: readonly string[]) {\n  if (!some(components)) return [];\n  const reduced = [components[0]];\n  for (let i = 1; i < components.length; i++) {\n    const component = components[i];\n    if (!component) continue;\n    if (component === '.') continue;\n    if (component === '..') {\n      if (reduced.length > 1) {\n        if (reduced[reduced.length - 1] !== '..') {\n          reduced.pop();\n          continue;\n        }\n      } else if (reduced[0]) continue;\n    }\n    reduced.push(component);\n  }\n  return reduced;\n}\nfunction getRootLength(path: string) {\n  const rootLength = getEncodedRootLength(path);\n  return rootLength < 0 ? ~rootLength : rootLength;\n}\nfunction getEncodedRootLength(path: string): number {\n  if (!path) return 0;\n  const ch0 = path.charCodeAt(0);\n\n  // POSIX or UNC\n  if (ch0 === CharacterCodes.slash || ch0 === CharacterCodes.backslash) {\n    if (path.charCodeAt(1) !== ch0) return 1; // POSIX: \"/\" (or non-normalized \"\\\")\n\n    const p1 = path.indexOf(\n      ch0 === CharacterCodes.slash ? directorySeparator : altDirectorySeparator,\n      2\n    );\n    if (p1 < 0) return path.length; // UNC: \"//server\" or \"\\\\server\"\n\n    return p1 + 1; // UNC: \"//server/\" or \"\\\\server\\\"\n  }\n\n  // DOS\n  if (isVolumeCharacter(ch0) && path.charCodeAt(1) === CharacterCodes.colon) {\n    const ch2 = path.charCodeAt(2);\n    if (ch2 === CharacterCodes.slash || ch2 === CharacterCodes.backslash)\n      return 3; // DOS: \"c:/\" or \"c:\\\"\n    if (path.length === 2) return 2; // DOS: \"c:\" (but not \"c:d\")\n  }\n\n  // URL\n  const schemeEnd = path.indexOf(urlSchemeSeparator);\n  if (schemeEnd !== -1) {\n    const authorityStart = schemeEnd + urlSchemeSeparator.length;\n    const authorityEnd = path.indexOf(directorySeparator, authorityStart);\n    if (authorityEnd !== -1) {\n      // URL: \"file:///\", \"file://server/\", \"file://server/path\"\n      // For local \"file\" URLs, include the leading DOS volume (if present).\n      // Per https://www.ietf.org/rfc/rfc1738.txt, a host of \"\" or \"localhost\" is a\n      // special case interpreted as \"the machine from which the URL is being interpreted\".\n      const scheme = path.slice(0, schemeEnd);\n      const authority = path.slice(authorityStart, authorityEnd);\n      if (\n        scheme === 'file' &&\n        (authority === '' || authority === 'localhost') &&\n        isVolumeCharacter(path.charCodeAt(authorityEnd + 1))\n      ) {\n        const volumeSeparatorEnd = getFileUrlVolumeSeparatorEnd(\n          path,\n          authorityEnd + 2\n        );\n        if (volumeSeparatorEnd !== -1) {\n          if (path.charCodeAt(volumeSeparatorEnd) === CharacterCodes.slash) {\n            // URL: \"file:///c:/\", \"file://localhost/c:/\", \"file:///c%3a/\", \"file://localhost/c%3a/\"\n            return ~(volumeSeparatorEnd + 1);\n          }\n          if (volumeSeparatorEnd === path.length) {\n            // URL: \"file:///c:\", \"file://localhost/c:\", \"file:///c$3a\", \"file://localhost/c%3a\"\n            // but not \"file:///c:d\" or \"file:///c%3ad\"\n            return ~volumeSeparatorEnd;\n          }\n        }\n      }\n      return ~(authorityEnd + 1); // URL: \"file://server/\", \"http://server/\"\n    }\n    return ~path.length; // URL: \"file://server\", \"http://server\"\n  }\n\n  // relative\n  return 0;\n}\nfunction ensureTrailingDirectorySeparator(path: string) {\n  if (!hasTrailingDirectorySeparator(path)) {\n    return path + directorySeparator;\n  }\n\n  return path;\n}\nfunction hasTrailingDirectorySeparator(path: string) {\n  return (\n    path.length > 0 && isAnyDirectorySeparator(path.charCodeAt(path.length - 1))\n  );\n}\nfunction isAnyDirectorySeparator(charCode: number): boolean {\n  return (\n    charCode === CharacterCodes.slash || charCode === CharacterCodes.backslash\n  );\n}\nfunction removeTrailingDirectorySeparator(path: string) {\n  if (hasTrailingDirectorySeparator(path)) {\n    return path.substr(0, path.length - 1);\n  }\n\n  return path;\n}\nconst directorySeparator = '/';\nconst altDirectorySeparator = '\\\\';\nconst urlSchemeSeparator = '://';\nfunction isVolumeCharacter(charCode: number) {\n  return (\n    (charCode >= CharacterCodes.a && charCode <= CharacterCodes.z) ||\n    (charCode >= CharacterCodes.A && charCode <= CharacterCodes.Z)\n  );\n}\nfunction getFileUrlVolumeSeparatorEnd(url: string, start: number) {\n  const ch0 = url.charCodeAt(start);\n  if (ch0 === CharacterCodes.colon) return start + 1;\n  if (\n    ch0 === CharacterCodes.percent &&\n    url.charCodeAt(start + 1) === CharacterCodes._3\n  ) {\n    const ch2 = url.charCodeAt(start + 2);\n    if (ch2 === CharacterCodes.a || ch2 === CharacterCodes.A) return start + 3;\n  }\n  return -1;\n}\nfunction some<T>(array: readonly T[] | undefined): array is readonly T[];\nfunction some<T>(\n  array: readonly T[] | undefined,\n  predicate: (value: T) => boolean\n): boolean;\nfunction some<T>(\n  array: readonly T[] | undefined,\n  predicate?: (value: T) => boolean\n): boolean {\n  if (array) {\n    if (predicate) {\n      for (const v of array) {\n        if (predicate(v)) {\n          return true;\n        }\n      }\n    } else {\n      return array.length > 0;\n    }\n  }\n  return false;\n}\n/* @internal */\nconst enum CharacterCodes {\n  _3 = 0x33,\n  a = 0x61,\n  z = 0x7a,\n  A = 0x41,\n  Z = 0x5a,\n  asterisk = 0x2a, // *\n  backslash = 0x5c, // \\\n  colon = 0x3a, // :\n  percent = 0x25, // %\n  question = 0x3f, // ?\n  slash = 0x2f, // /\n}\nfunction pathComponents(path: string, rootLength: number) {\n  const root = path.substring(0, rootLength);\n  const rest = path.substring(rootLength).split(directorySeparator);\n  if (rest.length && !lastOrUndefined(rest)) rest.pop();\n  return [root, ...rest];\n}\nfunction lastOrUndefined<T>(array: readonly T[]): T | undefined {\n  return array.length === 0 ? undefined : array[array.length - 1];\n}\nfunction last<T>(array: readonly T[]): T {\n  // Debug.assert(array.length !== 0);\n  return array[array.length - 1];\n}\nfunction replaceWildcardCharacter(\n  match: string,\n  singleAsteriskRegexFragment: string\n) {\n  return match === '*'\n    ? singleAsteriskRegexFragment\n    : match === '?'\n    ? '[^/]'\n    : '\\\\' + match;\n}\n/**\n * An \"includes\" path \"foo\" is implicitly a glob \"foo/** /*\" (without the space) if its last component has no extension,\n * and does not contain any glob characters itself.\n */\nfunction isImplicitGlob(lastPathComponent: string): boolean {\n  return !/[.*?]/.test(lastPathComponent);\n}\n"]},"metadata":{},"sourceType":"script"}