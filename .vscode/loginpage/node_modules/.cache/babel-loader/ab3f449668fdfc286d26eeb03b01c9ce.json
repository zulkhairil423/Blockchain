{"ast":null,"code":"\"use strict\";\n\nvar _a, _b;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createEsmHooks = exports.createFromPreloadedConfig = exports.create = exports.register = exports.TSError = exports.DEFAULTS = exports.VERSION = exports.debug = exports.INSPECT_CUSTOM = exports.env = exports.REGISTER_INSTANCE = exports.createRepl = void 0;\n\nconst path_1 = require(\"path\");\n\nconst module_1 = require(\"module\");\n\nconst util = require(\"util\");\n\nconst url_1 = require(\"url\");\n\nconst make_error_1 = require(\"make-error\");\n\nconst util_1 = require(\"./util\");\n\nconst configuration_1 = require(\"./configuration\");\n\nconst module_type_classifier_1 = require(\"./module-type-classifier\");\n\nconst resolver_functions_1 = require(\"./resolver-functions\");\n\nconst cjs_resolve_hooks_1 = require(\"./cjs-resolve-hooks\");\n\nconst node_module_type_classifier_1 = require(\"./node-module-type-classifier\");\n\nconst file_extensions_1 = require(\"./file-extensions\");\n\nconst ts_transpile_module_1 = require(\"./ts-transpile-module\");\n\nvar repl_1 = require(\"./repl\");\n\nObject.defineProperty(exports, \"createRepl\", {\n  enumerable: true,\n  get: function () {\n    return repl_1.createRepl;\n  }\n});\n/**\n * Does this version of node obey the package.json \"type\" field\n * and throw ERR_REQUIRE_ESM when attempting to require() an ESM modules.\n */\n\nconst engineSupportsPackageTypeField = parseInt(process.versions.node.split('.')[0], 10) >= 12;\n/**\n * Assert that script can be loaded as CommonJS when we attempt to require it.\n * If it should be loaded as ESM, throw ERR_REQUIRE_ESM like node does.\n *\n * Loaded conditionally so we don't need to support older node versions\n */\n\nlet assertScriptCanLoadAsCJS = engineSupportsPackageTypeField ? require('../dist-raw/node-internal-modules-cjs-loader').assertScriptCanLoadAsCJSImpl : () => {\n  /* noop */\n};\n/**\n * Registered `ts-node` instance information.\n */\n\nexports.REGISTER_INSTANCE = Symbol.for('ts-node.register.instance');\n/** @internal */\n\nexports.env = process.env;\n/**\n * @internal\n */\n\nexports.INSPECT_CUSTOM = util.inspect.custom || 'inspect';\n/**\n * Debugging `ts-node`.\n */\n\nconst shouldDebug = (0, util_1.yn)(exports.env.TS_NODE_DEBUG);\n/** @internal */\n\nexports.debug = shouldDebug ? function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return console.log(`[ts-node ${new Date().toISOString()}]`, ...args);\n} : () => undefined;\nconst debugFn = shouldDebug ? (key, fn) => {\n  let i = 0;\n  return x => {\n    (0, exports.debug)(key, x, ++i);\n    return fn(x);\n  };\n} : (_, fn) => fn;\n/**\n * Export the current version.\n */\n\nexports.VERSION = require('../package.json').version;\n/**\n * Default register options, including values specified via environment\n * variables.\n * @internal\n */\n\nexports.DEFAULTS = {\n  cwd: (_a = exports.env.TS_NODE_CWD) !== null && _a !== void 0 ? _a : exports.env.TS_NODE_DIR,\n  emit: (0, util_1.yn)(exports.env.TS_NODE_EMIT),\n  scope: (0, util_1.yn)(exports.env.TS_NODE_SCOPE),\n  scopeDir: exports.env.TS_NODE_SCOPE_DIR,\n  files: (0, util_1.yn)(exports.env.TS_NODE_FILES),\n  pretty: (0, util_1.yn)(exports.env.TS_NODE_PRETTY),\n  compiler: exports.env.TS_NODE_COMPILER,\n  compilerOptions: (0, util_1.parse)(exports.env.TS_NODE_COMPILER_OPTIONS),\n  ignore: (0, util_1.split)(exports.env.TS_NODE_IGNORE),\n  project: exports.env.TS_NODE_PROJECT,\n  skipProject: (0, util_1.yn)(exports.env.TS_NODE_SKIP_PROJECT),\n  skipIgnore: (0, util_1.yn)(exports.env.TS_NODE_SKIP_IGNORE),\n  preferTsExts: (0, util_1.yn)(exports.env.TS_NODE_PREFER_TS_EXTS),\n  ignoreDiagnostics: (0, util_1.split)(exports.env.TS_NODE_IGNORE_DIAGNOSTICS),\n  transpileOnly: (0, util_1.yn)(exports.env.TS_NODE_TRANSPILE_ONLY),\n  typeCheck: (0, util_1.yn)(exports.env.TS_NODE_TYPE_CHECK),\n  compilerHost: (0, util_1.yn)(exports.env.TS_NODE_COMPILER_HOST),\n  logError: (0, util_1.yn)(exports.env.TS_NODE_LOG_ERROR),\n  experimentalReplAwait: (_b = (0, util_1.yn)(exports.env.TS_NODE_EXPERIMENTAL_REPL_AWAIT)) !== null && _b !== void 0 ? _b : undefined,\n  tsTrace: console.log.bind(console)\n};\n/**\n * TypeScript diagnostics error.\n */\n\nclass TSError extends make_error_1.BaseError {\n  constructor(diagnosticText, diagnosticCodes) {\n    let diagnostics = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    super(`тип Unable to compile TypeScript:\\n${diagnosticText}`);\n    this.diagnosticCodes = diagnosticCodes;\n    this.name = 'TSError';\n    Object.defineProperty(this, 'diagnosticText', {\n      configurable: true,\n      writable: true,\n      value: diagnosticText\n    });\n    Object.defineProperty(this, 'diagnostics', {\n      configurable: true,\n      writable: true,\n      value: diagnostics\n    });\n  }\n  /**\n   * @internal\n   */\n\n\n  [exports.INSPECT_CUSTOM]() {\n    return this.diagnosticText;\n  }\n\n}\n\nexports.TSError = TSError;\nconst TS_NODE_SERVICE_BRAND = Symbol('TS_NODE_SERVICE_BRAND');\n\nfunction register(serviceOrOpts) {\n  // Is this a Service or a RegisterOptions?\n  let service = serviceOrOpts;\n\n  if (!(serviceOrOpts === null || serviceOrOpts === void 0 ? void 0 : serviceOrOpts[TS_NODE_SERVICE_BRAND])) {\n    // Not a service; is options\n    service = create(serviceOrOpts !== null && serviceOrOpts !== void 0 ? serviceOrOpts : {});\n  }\n\n  const originalJsHandler = require.extensions['.js']; // Expose registered instance globally.\n\n  process[exports.REGISTER_INSTANCE] = service; // Register the extensions.\n\n  registerExtensions(service.options.preferTsExts, service.extensions.compiled, service, originalJsHandler);\n  (0, cjs_resolve_hooks_1.installCommonjsResolveHooksIfNecessary)(service); // Require specified modules before start-up.\n\n  module_1.Module._preloadModules(service.options.require);\n\n  return service;\n}\n\nexports.register = register;\n/**\n * Create TypeScript compiler instance.\n *\n * @category Basic\n */\n\nfunction create() {\n  let rawOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const foundConfigResult = (0, configuration_1.findAndReadConfig)(rawOptions);\n  return createFromPreloadedConfig(foundConfigResult);\n}\n\nexports.create = create;\n/** @internal */\n\nfunction createFromPreloadedConfig(foundConfigResult) {\n  var _a, _b, _c, _d;\n\n  const {\n    configFilePath,\n    cwd,\n    options,\n    config,\n    compiler,\n    projectLocalResolveDir,\n    optionBasePaths\n  } = foundConfigResult;\n  const projectLocalResolveHelper = (0, util_1.createProjectLocalResolveHelper)(projectLocalResolveDir);\n  const ts = (0, configuration_1.loadCompiler)(compiler); // Experimental REPL await is not compatible targets lower than ES2018\n\n  const targetSupportsTla = config.options.target >= ts.ScriptTarget.ES2018;\n\n  if (options.experimentalReplAwait === true && !targetSupportsTla) {\n    throw new Error('Experimental REPL await is not compatible with targets lower than ES2018');\n  } // Top-level await was added in TS 3.8\n\n\n  const tsVersionSupportsTla = (0, util_1.versionGteLt)(ts.version, '3.8.0');\n\n  if (options.experimentalReplAwait === true && !tsVersionSupportsTla) {\n    throw new Error('Experimental REPL await is not compatible with TypeScript versions older than 3.8');\n  }\n\n  const shouldReplAwait = options.experimentalReplAwait !== false && tsVersionSupportsTla && targetSupportsTla; // swc implies two other options\n  // typeCheck option was implemented specifically to allow overriding tsconfig transpileOnly from the command-line\n  // So we should allow using typeCheck to override swc\n\n  if (options.swc && !options.typeCheck) {\n    if (options.transpileOnly === false) {\n      throw new Error(\"Cannot enable 'swc' option with 'transpileOnly: false'.  'swc' implies 'transpileOnly'.\");\n    }\n\n    if (options.transpiler) {\n      throw new Error(\"Cannot specify both 'swc' and 'transpiler' options.  'swc' uses the built-in swc transpiler.\");\n    }\n  }\n\n  const readFile = options.readFile || ts.sys.readFile;\n  const fileExists = options.fileExists || ts.sys.fileExists; // typeCheck can override transpileOnly, useful for CLI flag to override config file\n\n  const transpileOnly = (options.transpileOnly === true || options.swc === true) && options.typeCheck !== true;\n  let transpiler = undefined;\n  let transpilerBasePath = undefined;\n\n  if (options.transpiler) {\n    transpiler = options.transpiler;\n    transpilerBasePath = optionBasePaths.transpiler;\n  } else if (options.swc) {\n    transpiler = require.resolve('./transpilers/swc.js');\n    transpilerBasePath = optionBasePaths.swc;\n  }\n\n  const transformers = options.transformers || undefined;\n  const diagnosticFilters = [{\n    appliesToAllFiles: true,\n    filenamesAbsolute: [],\n    diagnosticsIgnored: [6059, 18002, 18003, ...(options.experimentalTsImportSpecifiers ? [2691 // \"An import path cannot end with a '.ts' extension. Consider importing '<specifier without ext>' instead.\"\n    ] : []), ...(options.ignoreDiagnostics || [])].map(Number)\n  }];\n  const configDiagnosticList = filterDiagnostics(config.errors, diagnosticFilters);\n  const outputCache = new Map();\n  const configFileDirname = configFilePath ? (0, path_1.dirname)(configFilePath) : null;\n  const scopeDir = (_c = (_b = (_a = options.scopeDir) !== null && _a !== void 0 ? _a : config.options.rootDir) !== null && _b !== void 0 ? _b : configFileDirname) !== null && _c !== void 0 ? _c : cwd;\n  const ignoreBaseDir = configFileDirname !== null && configFileDirname !== void 0 ? configFileDirname : cwd;\n  const isScoped = options.scope ? fileName => (0, path_1.relative)(scopeDir, fileName).charAt(0) !== '.' : () => true;\n  const shouldIgnore = createIgnore(ignoreBaseDir, options.skipIgnore ? [] : (options.ignore || ['(?:^|/)node_modules/']).map(str => new RegExp(str)));\n  const diagnosticHost = {\n    getNewLine: () => ts.sys.newLine,\n    getCurrentDirectory: () => cwd,\n    // TODO switch to getCanonicalFileName we already create later in scope\n    getCanonicalFileName: ts.sys.useCaseSensitiveFileNames ? x => x : x => x.toLowerCase()\n  };\n\n  if (options.transpileOnly && typeof transformers === 'function') {\n    throw new TypeError('Transformers function is unavailable in \"--transpile-only\"');\n  }\n\n  let createTranspiler = initializeTranspilerFactory();\n\n  function initializeTranspilerFactory() {\n    var _a;\n\n    if (transpiler) {\n      if (!transpileOnly) throw new Error('Custom transpiler can only be used when transpileOnly is enabled.');\n      const transpilerName = typeof transpiler === 'string' ? transpiler : transpiler[0];\n      const transpilerOptions = typeof transpiler === 'string' ? {} : (_a = transpiler[1]) !== null && _a !== void 0 ? _a : {};\n      const transpilerConfigLocalResolveHelper = transpilerBasePath ? (0, util_1.createProjectLocalResolveHelper)(transpilerBasePath) : projectLocalResolveHelper;\n      const transpilerPath = transpilerConfigLocalResolveHelper(transpilerName, true);\n\n      const transpilerFactory = require(transpilerPath).create;\n\n      return createTranspiler;\n\n      function createTranspiler(compilerOptions, nodeModuleEmitKind) {\n        return transpilerFactory === null || transpilerFactory === void 0 ? void 0 : transpilerFactory({\n          service: {\n            options,\n            config: { ...config,\n              options: compilerOptions\n            },\n            projectLocalResolveHelper\n          },\n          transpilerConfigLocalResolveHelper,\n          nodeModuleEmitKind,\n          ...transpilerOptions\n        });\n      }\n    }\n  }\n  /**\n   * True if require() hooks should interop with experimental ESM loader.\n   * Enabled explicitly via a flag since it is a breaking change.\n   */\n\n\n  let experimentalEsmLoader = false;\n\n  function enableExperimentalEsmLoaderInterop() {\n    experimentalEsmLoader = true;\n  } // Install source map support and read from memory cache.\n\n\n  installSourceMapSupport();\n\n  function installSourceMapSupport() {\n    const sourceMapSupport = require('@cspotcode/source-map-support');\n\n    sourceMapSupport.install({\n      environment: 'node',\n\n      retrieveFile(pathOrUrl) {\n        var _a;\n\n        let path = pathOrUrl; // If it's a file URL, convert to local path\n        // Note: fileURLToPath does not exist on early node v10\n        // I could not find a way to handle non-URLs except to swallow an error\n\n        if (experimentalEsmLoader && path.startsWith('file://')) {\n          try {\n            path = (0, url_1.fileURLToPath)(path);\n          } catch (e) {\n            /* swallow error */\n          }\n        }\n\n        path = (0, util_1.normalizeSlashes)(path);\n        return ((_a = outputCache.get(path)) === null || _a === void 0 ? void 0 : _a.content) || '';\n      },\n\n      redirectConflictingLibrary: true,\n\n      onConflictingLibraryRedirect(request, parent, isMain, options, redirectedRequest) {\n        (0, exports.debug)(`Redirected an attempt to require source-map-support to instead receive @cspotcode/source-map-support.  \"${parent.filename}\" attempted to require or resolve \"${request}\" and was redirected to \"${redirectedRequest}\".`);\n      }\n\n    });\n  }\n\n  const shouldHavePrettyErrors = options.pretty === undefined ? process.stdout.isTTY : options.pretty;\n  const formatDiagnostics = shouldHavePrettyErrors ? ts.formatDiagnosticsWithColorAndContext || ts.formatDiagnostics : ts.formatDiagnostics;\n\n  function createTSError(diagnostics) {\n    const diagnosticText = formatDiagnostics(diagnostics, diagnosticHost);\n    const diagnosticCodes = diagnostics.map(x => x.code);\n    return new TSError(diagnosticText, diagnosticCodes, diagnostics);\n  }\n\n  function reportTSError(configDiagnosticList) {\n    const error = createTSError(configDiagnosticList);\n\n    if (options.logError) {\n      // Print error in red color and continue execution.\n      console.error('\\x1b[31m%s\\x1b[0m', error);\n    } else {\n      // Throw error and exit the script.\n      throw error;\n    }\n  } // Render the configuration errors.\n\n\n  if (configDiagnosticList.length) reportTSError(configDiagnosticList);\n  const jsxEmitPreserve = config.options.jsx === ts.JsxEmit.Preserve;\n  /**\n   * Get the extension for a transpiled file.\n   * [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n   */\n\n  function getEmitExtension(path) {\n    const lastDotIndex = path.lastIndexOf('.');\n\n    if (lastDotIndex >= 0) {\n      const ext = path.slice(lastDotIndex);\n\n      switch (ext) {\n        case '.js':\n        case '.ts':\n          return '.js';\n\n        case '.jsx':\n        case '.tsx':\n          return jsxEmitPreserve ? '.jsx' : '.js';\n\n        case '.mjs':\n        case '.mts':\n          return '.mjs';\n\n        case '.cjs':\n        case '.cts':\n          return '.cjs';\n      }\n    }\n\n    return '.js';\n  }\n  /**\n   * Get output from TS compiler w/typechecking.  `undefined` in `transpileOnly`\n   * mode.\n   */\n\n\n  let getOutput;\n  let getTypeInfo;\n  const getCanonicalFileName = ts.createGetCanonicalFileName(ts.sys.useCaseSensitiveFileNames);\n  const moduleTypeClassifier = (0, module_type_classifier_1.createModuleTypeClassifier)({\n    basePath: (_d = options.optionBasePaths) === null || _d === void 0 ? void 0 : _d.moduleTypes,\n    patterns: options.moduleTypes\n  });\n  const extensions = (0, file_extensions_1.getExtensions)(config, options, ts.version); // Use full language services when the fast option is disabled.\n\n  if (!transpileOnly) {\n    const fileContents = new Map();\n    const rootFileNames = new Set(config.fileNames);\n    const cachedReadFile = (0, util_1.cachedLookup)(debugFn('readFile', readFile)); // Use language services by default\n\n    if (!options.compilerHost) {\n      let projectVersion = 1;\n      const fileVersions = new Map(Array.from(rootFileNames).map(fileName => [fileName, 0]));\n\n      const getCustomTransformers = () => {\n        if (typeof transformers === 'function') {\n          const program = service.getProgram();\n          return program ? transformers(program) : undefined;\n        }\n\n        return transformers;\n      }; // Create the compiler host for type checking.\n\n\n      const serviceHost = {\n        getProjectVersion: () => String(projectVersion),\n        getScriptFileNames: () => Array.from(rootFileNames),\n        getScriptVersion: fileName => {\n          const version = fileVersions.get(fileName);\n          return version ? version.toString() : '';\n        },\n\n        getScriptSnapshot(fileName) {\n          // TODO ordering of this with getScriptVersion?  Should they sync up?\n          let contents = fileContents.get(fileName); // Read contents into TypeScript memory cache.\n\n          if (contents === undefined) {\n            contents = cachedReadFile(fileName);\n            if (contents === undefined) return;\n            fileVersions.set(fileName, 1);\n            fileContents.set(fileName, contents);\n            projectVersion++;\n          }\n\n          return ts.ScriptSnapshot.fromString(contents);\n        },\n\n        readFile: cachedReadFile,\n        readDirectory: ts.sys.readDirectory,\n        getDirectories: (0, util_1.cachedLookup)(debugFn('getDirectories', ts.sys.getDirectories)),\n        fileExists: (0, util_1.cachedLookup)(debugFn('fileExists', fileExists)),\n        directoryExists: (0, util_1.cachedLookup)(debugFn('directoryExists', ts.sys.directoryExists)),\n        realpath: ts.sys.realpath ? (0, util_1.cachedLookup)(debugFn('realpath', ts.sys.realpath)) : undefined,\n        getNewLine: () => ts.sys.newLine,\n        useCaseSensitiveFileNames: () => ts.sys.useCaseSensitiveFileNames,\n        getCurrentDirectory: () => cwd,\n        getCompilationSettings: () => config.options,\n        getDefaultLibFileName: () => ts.getDefaultLibFilePath(config.options),\n        getCustomTransformers: getCustomTransformers,\n        trace: options.tsTrace\n      };\n      const {\n        resolveModuleNames,\n        getResolvedModuleWithFailedLookupLocationsFromCache,\n        resolveTypeReferenceDirectives,\n        isFileKnownToBeInternal,\n        markBucketOfFilenameInternal\n      } = (0, resolver_functions_1.createResolverFunctions)({\n        host: serviceHost,\n        getCanonicalFileName,\n        ts,\n        cwd,\n        config,\n        projectLocalResolveHelper,\n        options,\n        extensions\n      });\n      serviceHost.resolveModuleNames = resolveModuleNames;\n      serviceHost.getResolvedModuleWithFailedLookupLocationsFromCache = getResolvedModuleWithFailedLookupLocationsFromCache;\n      serviceHost.resolveTypeReferenceDirectives = resolveTypeReferenceDirectives;\n      const registry = ts.createDocumentRegistry(ts.sys.useCaseSensitiveFileNames, cwd);\n      const service = ts.createLanguageService(serviceHost, registry);\n\n      const updateMemoryCache = (contents, fileName) => {\n        // Add to `rootFiles` as necessary, either to make TS include a file it has not seen,\n        // or to trigger a re-classification of files from external to internal.\n        if (!rootFileNames.has(fileName) && !isFileKnownToBeInternal(fileName)) {\n          markBucketOfFilenameInternal(fileName);\n          rootFileNames.add(fileName); // Increment project version for every change to rootFileNames.\n\n          projectVersion++;\n        }\n\n        const previousVersion = fileVersions.get(fileName) || 0;\n        const previousContents = fileContents.get(fileName); // Avoid incrementing cache when nothing has changed.\n\n        if (contents !== previousContents) {\n          fileVersions.set(fileName, previousVersion + 1);\n          fileContents.set(fileName, contents); // Increment project version for every file change.\n\n          projectVersion++;\n        }\n      };\n\n      let previousProgram = undefined;\n\n      getOutput = (code, fileName) => {\n        updateMemoryCache(code, fileName);\n        const programBefore = service.getProgram();\n\n        if (programBefore !== previousProgram) {\n          (0, exports.debug)(`compiler rebuilt Program instance when getting output for ${fileName}`);\n        }\n\n        const output = service.getEmitOutput(fileName); // Get the relevant diagnostics - this is 3x faster than `getPreEmitDiagnostics`.\n\n        const diagnostics = service.getSemanticDiagnostics(fileName).concat(service.getSyntacticDiagnostics(fileName));\n        const programAfter = service.getProgram();\n        (0, exports.debug)('invariant: Is service.getProject() identical before and after getting emit output and diagnostics? (should always be true) ', programBefore === programAfter);\n        previousProgram = programAfter;\n        const diagnosticList = filterDiagnostics(diagnostics, diagnosticFilters);\n        if (diagnosticList.length) reportTSError(diagnosticList);\n\n        if (output.emitSkipped) {\n          return [undefined, undefined, true];\n        } // Throw an error when requiring `.d.ts` files.\n\n\n        if (output.outputFiles.length === 0) {\n          throw new TypeError(`Unable to require file: ${(0, path_1.relative)(cwd, fileName)}\\n` + 'This is usually the result of a faulty configuration or import. ' + 'Make sure there is a `.js`, `.json` or other executable extension with ' + 'loader attached before `ts-node` available.');\n        }\n\n        return [output.outputFiles[1].text, output.outputFiles[0].text, false];\n      };\n\n      getTypeInfo = (code, fileName, position) => {\n        const normalizedFileName = (0, util_1.normalizeSlashes)(fileName);\n        updateMemoryCache(code, normalizedFileName);\n        const info = service.getQuickInfoAtPosition(normalizedFileName, position);\n        const name = ts.displayPartsToString(info ? info.displayParts : []);\n        const comment = ts.displayPartsToString(info ? info.documentation : []);\n        return {\n          name,\n          comment\n        };\n      };\n    } else {\n      const sys = { ...ts.sys,\n        ...diagnosticHost,\n        readFile: fileName => {\n          const cacheContents = fileContents.get(fileName);\n          if (cacheContents !== undefined) return cacheContents;\n          const contents = cachedReadFile(fileName);\n          if (contents) fileContents.set(fileName, contents);\n          return contents;\n        },\n        readDirectory: ts.sys.readDirectory,\n        getDirectories: (0, util_1.cachedLookup)(debugFn('getDirectories', ts.sys.getDirectories)),\n        fileExists: (0, util_1.cachedLookup)(debugFn('fileExists', fileExists)),\n        directoryExists: (0, util_1.cachedLookup)(debugFn('directoryExists', ts.sys.directoryExists)),\n        resolvePath: (0, util_1.cachedLookup)(debugFn('resolvePath', ts.sys.resolvePath)),\n        realpath: ts.sys.realpath ? (0, util_1.cachedLookup)(debugFn('realpath', ts.sys.realpath)) : undefined\n      };\n      const host = ts.createIncrementalCompilerHost ? ts.createIncrementalCompilerHost(config.options, sys) : { ...sys,\n        getSourceFile: (fileName, languageVersion) => {\n          const contents = sys.readFile(fileName);\n          if (contents === undefined) return;\n          return ts.createSourceFile(fileName, contents, languageVersion);\n        },\n        getDefaultLibLocation: () => (0, util_1.normalizeSlashes)((0, path_1.dirname)(compiler)),\n        getDefaultLibFileName: () => (0, util_1.normalizeSlashes)((0, path_1.join)((0, path_1.dirname)(compiler), ts.getDefaultLibFileName(config.options))),\n        useCaseSensitiveFileNames: () => sys.useCaseSensitiveFileNames\n      };\n      host.trace = options.tsTrace;\n      const {\n        resolveModuleNames,\n        resolveTypeReferenceDirectives,\n        isFileKnownToBeInternal,\n        markBucketOfFilenameInternal\n      } = (0, resolver_functions_1.createResolverFunctions)({\n        host,\n        cwd,\n        config,\n        ts,\n        getCanonicalFileName,\n        projectLocalResolveHelper,\n        options,\n        extensions\n      });\n      host.resolveModuleNames = resolveModuleNames;\n      host.resolveTypeReferenceDirectives = resolveTypeReferenceDirectives; // Fallback for older TypeScript releases without incremental API.\n\n      let builderProgram = ts.createIncrementalProgram ? ts.createIncrementalProgram({\n        rootNames: Array.from(rootFileNames),\n        options: config.options,\n        host,\n        configFileParsingDiagnostics: config.errors,\n        projectReferences: config.projectReferences\n      }) : ts.createEmitAndSemanticDiagnosticsBuilderProgram(Array.from(rootFileNames), config.options, host, undefined, config.errors, config.projectReferences); // Read and cache custom transformers.\n\n      const customTransformers = typeof transformers === 'function' ? transformers(builderProgram.getProgram()) : transformers; // Set the file contents into cache manually.\n\n      const updateMemoryCache = (contents, fileName) => {\n        const previousContents = fileContents.get(fileName);\n        const contentsChanged = previousContents !== contents;\n\n        if (contentsChanged) {\n          fileContents.set(fileName, contents);\n        } // Add to `rootFiles` when discovered by compiler for the first time.\n\n\n        let addedToRootFileNames = false;\n\n        if (!rootFileNames.has(fileName) && !isFileKnownToBeInternal(fileName)) {\n          markBucketOfFilenameInternal(fileName);\n          rootFileNames.add(fileName);\n          addedToRootFileNames = true;\n        } // Update program when file changes.\n\n\n        if (addedToRootFileNames || contentsChanged) {\n          builderProgram = ts.createEmitAndSemanticDiagnosticsBuilderProgram(Array.from(rootFileNames), config.options, host, builderProgram, config.errors, config.projectReferences);\n        }\n      };\n\n      getOutput = (code, fileName) => {\n        let outText = '';\n        let outMap = '';\n        updateMemoryCache(code, fileName);\n        const sourceFile = builderProgram.getSourceFile(fileName);\n        if (!sourceFile) throw new TypeError(`Unable to read file: ${fileName}`);\n        const program = builderProgram.getProgram();\n        const diagnostics = ts.getPreEmitDiagnostics(program, sourceFile);\n        const diagnosticList = filterDiagnostics(diagnostics, diagnosticFilters);\n        if (diagnosticList.length) reportTSError(diagnosticList);\n        const result = builderProgram.emit(sourceFile, (path, file, writeByteOrderMark) => {\n          if (path.endsWith('.map')) {\n            outMap = file;\n          } else {\n            outText = file;\n          }\n\n          if (options.emit) sys.writeFile(path, file, writeByteOrderMark);\n        }, undefined, undefined, customTransformers);\n\n        if (result.emitSkipped) {\n          return [undefined, undefined, true];\n        } // Throw an error when requiring files that cannot be compiled.\n\n\n        if (outText === '') {\n          if (program.isSourceFileFromExternalLibrary(sourceFile)) {\n            throw new TypeError(`Unable to compile file from external library: ${(0, path_1.relative)(cwd, fileName)}`);\n          }\n\n          throw new TypeError(`Unable to require file: ${(0, path_1.relative)(cwd, fileName)}\\n` + 'This is usually the result of a faulty configuration or import. ' + 'Make sure there is a `.js`, `.json` or other executable extension with ' + 'loader attached before `ts-node` available.');\n        }\n\n        return [outText, outMap, false];\n      };\n\n      getTypeInfo = (code, fileName, position) => {\n        const normalizedFileName = (0, util_1.normalizeSlashes)(fileName);\n        updateMemoryCache(code, normalizedFileName);\n        const sourceFile = builderProgram.getSourceFile(normalizedFileName);\n        if (!sourceFile) throw new TypeError(`Unable to read file: ${fileName}`);\n        const node = getTokenAtPosition(ts, sourceFile, position);\n        const checker = builderProgram.getProgram().getTypeChecker();\n        const symbol = checker.getSymbolAtLocation(node);\n        if (!symbol) return {\n          name: '',\n          comment: ''\n        };\n        const type = checker.getTypeOfSymbolAtLocation(symbol, node);\n        const signatures = [...type.getConstructSignatures(), ...type.getCallSignatures()];\n        return {\n          name: signatures.length ? signatures.map(x => checker.signatureToString(x)).join('\\n') : checker.typeToString(type),\n          comment: ts.displayPartsToString(symbol ? symbol.getDocumentationComment(checker) : [])\n        };\n      }; // Write `.tsbuildinfo` when `--build` is enabled.\n\n\n      if (options.emit && config.options.incremental) {\n        process.on('exit', () => {\n          // Emits `.tsbuildinfo` to filesystem.\n          builderProgram.getProgram().emitBuildInfo();\n        });\n      }\n    }\n  } else {\n    getTypeInfo = () => {\n      throw new TypeError('Type information is unavailable in \"--transpile-only\"');\n    };\n  }\n\n  function createTranspileOnlyGetOutputFunction(overrideModuleType, nodeModuleEmitKind) {\n    const compilerOptions = { ...config.options\n    };\n    if (overrideModuleType !== undefined) compilerOptions.module = overrideModuleType;\n    let customTranspiler = createTranspiler === null || createTranspiler === void 0 ? void 0 : createTranspiler(compilerOptions, nodeModuleEmitKind);\n    let tsTranspileModule = (0, util_1.versionGteLt)(ts.version, '4.7.0') ? (0, ts_transpile_module_1.createTsTranspileModule)(ts, {\n      compilerOptions,\n      reportDiagnostics: true,\n      transformers: transformers\n    }) : undefined;\n    return (code, fileName) => {\n      let result;\n\n      if (customTranspiler) {\n        result = customTranspiler.transpile(code, {\n          fileName\n        });\n      } else if (tsTranspileModule) {\n        result = tsTranspileModule(code, {\n          fileName\n        }, nodeModuleEmitKind === 'nodeesm' ? 'module' : 'commonjs');\n      } else {\n        result = ts.transpileModule(code, {\n          fileName,\n          compilerOptions,\n          reportDiagnostics: true,\n          transformers: transformers\n        });\n      }\n\n      const diagnosticList = filterDiagnostics(result.diagnostics || [], diagnosticFilters);\n      if (diagnosticList.length) reportTSError(diagnosticList);\n      return [result.outputText, result.sourceMapText, false];\n    };\n  } // When true, these mean that a `moduleType` override will cause a different emit\n  // than the TypeScript compiler, so we *must* overwrite the emit.\n\n\n  const shouldOverwriteEmitWhenForcingCommonJS = config.options.module !== ts.ModuleKind.CommonJS; // [MUST_UPDATE_FOR_NEW_MODULEKIND]\n\n  const shouldOverwriteEmitWhenForcingEsm = !(config.options.module === ts.ModuleKind.ES2015 || ts.ModuleKind.ES2020 && config.options.module === ts.ModuleKind.ES2020 || ts.ModuleKind.ES2022 && config.options.module === ts.ModuleKind.ES2022 || config.options.module === ts.ModuleKind.ESNext);\n  /**\n   * node16 or nodenext\n   * [MUST_UPDATE_FOR_NEW_MODULEKIND]\n   */\n\n  const isNodeModuleType = ts.ModuleKind.Node16 && config.options.module === ts.ModuleKind.Node16 || ts.ModuleKind.NodeNext && config.options.module === ts.ModuleKind.NodeNext;\n  const getOutputForceCommonJS = createTranspileOnlyGetOutputFunction(ts.ModuleKind.CommonJS);\n  const getOutputForceNodeCommonJS = createTranspileOnlyGetOutputFunction(ts.ModuleKind.NodeNext, 'nodecjs');\n  const getOutputForceNodeESM = createTranspileOnlyGetOutputFunction(ts.ModuleKind.NodeNext, 'nodeesm'); // [MUST_UPDATE_FOR_NEW_MODULEKIND]\n\n  const getOutputForceESM = createTranspileOnlyGetOutputFunction(ts.ModuleKind.ES2022 || ts.ModuleKind.ES2020 || ts.ModuleKind.ES2015);\n  const getOutputTranspileOnly = createTranspileOnlyGetOutputFunction(); // Create a simple TypeScript compiler proxy.\n\n  function compile(code, fileName) {\n    let lineOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const normalizedFileName = (0, util_1.normalizeSlashes)(fileName);\n    const classification = moduleTypeClassifier.classifyModuleByModuleTypeOverrides(normalizedFileName);\n    let value = '';\n    let sourceMap = '';\n    let emitSkipped = true;\n\n    if (getOutput) {\n      // Must always call normal getOutput to throw typechecking errors\n      [value, sourceMap, emitSkipped] = getOutput(code, normalizedFileName);\n    } // If module classification contradicts the above, call the relevant transpiler\n\n\n    if (classification.moduleType === 'cjs' && (shouldOverwriteEmitWhenForcingCommonJS || emitSkipped)) {\n      [value, sourceMap] = getOutputForceCommonJS(code, normalizedFileName);\n    } else if (classification.moduleType === 'esm' && (shouldOverwriteEmitWhenForcingEsm || emitSkipped)) {\n      [value, sourceMap] = getOutputForceESM(code, normalizedFileName);\n    } else if (emitSkipped) {\n      // Happens when ts compiler skips emit or in transpileOnly mode\n      const classification = (0, node_module_type_classifier_1.classifyModule)(fileName, isNodeModuleType);\n      [value, sourceMap] = classification === 'nodecjs' ? getOutputForceNodeCommonJS(code, normalizedFileName) : classification === 'nodeesm' ? getOutputForceNodeESM(code, normalizedFileName) : classification === 'cjs' ? getOutputForceCommonJS(code, normalizedFileName) : classification === 'esm' ? getOutputForceESM(code, normalizedFileName) : getOutputTranspileOnly(code, normalizedFileName);\n    }\n\n    const output = updateOutput(value, normalizedFileName, sourceMap, getEmitExtension);\n    outputCache.set(normalizedFileName, {\n      content: output\n    });\n    return output;\n  }\n\n  let active = true;\n\n  const enabled = enabled => enabled === undefined ? active : active = !!enabled;\n\n  const ignored = fileName => {\n    if (!active) return true;\n    const ext = (0, path_1.extname)(fileName);\n\n    if (extensions.compiled.includes(ext)) {\n      return !isScoped(fileName) || shouldIgnore(fileName);\n    }\n\n    return true;\n  };\n\n  function addDiagnosticFilter(filter) {\n    diagnosticFilters.push({ ...filter,\n      filenamesAbsolute: filter.filenamesAbsolute.map(f => (0, util_1.normalizeSlashes)(f))\n    });\n  }\n\n  const getNodeEsmResolver = (0, util_1.once)(() => require('../dist-raw/node-internal-modules-esm-resolve').createResolve({\n    extensions,\n    preferTsExts: options.preferTsExts,\n    tsNodeExperimentalSpecifierResolution: options.experimentalSpecifierResolution\n  }));\n  const getNodeEsmGetFormat = (0, util_1.once)(() => require('../dist-raw/node-internal-modules-esm-get_format').createGetFormat(options.experimentalSpecifierResolution, getNodeEsmResolver()));\n  const getNodeCjsLoader = (0, util_1.once)(() => require('../dist-raw/node-internal-modules-cjs-loader').createCjsLoader({\n    extensions,\n    preferTsExts: options.preferTsExts,\n    nodeEsmResolver: getNodeEsmResolver()\n  }));\n  return {\n    [TS_NODE_SERVICE_BRAND]: true,\n    ts,\n    compilerPath: compiler,\n    config,\n    compile,\n    getTypeInfo,\n    ignored,\n    enabled,\n    options,\n    configFilePath,\n    moduleTypeClassifier,\n    shouldReplAwait,\n    addDiagnosticFilter,\n    installSourceMapSupport,\n    enableExperimentalEsmLoaderInterop,\n    transpileOnly,\n    projectLocalResolveHelper,\n    getNodeEsmResolver,\n    getNodeEsmGetFormat,\n    getNodeCjsLoader,\n    extensions\n  };\n}\n\nexports.createFromPreloadedConfig = createFromPreloadedConfig;\n/**\n * Check if the filename should be ignored.\n */\n\nfunction createIgnore(ignoreBaseDir, ignore) {\n  return fileName => {\n    const relname = (0, path_1.relative)(ignoreBaseDir, fileName);\n    const path = (0, util_1.normalizeSlashes)(relname);\n    return ignore.some(x => x.test(path));\n  };\n}\n/**\n * Register the extensions to support when importing files.\n */\n\n\nfunction registerExtensions(preferTsExts, extensions, service, originalJsHandler) {\n  const exts = new Set(extensions); // Can't add these extensions cuz would allow omitting file extension; node requires ext for .cjs and .mjs\n  // Unless they're already registered by something else (nyc does this):\n  // then we *must* hook them or else our transformer will not be called.\n\n  for (const cannotAdd of ['.mts', '.cts', '.mjs', '.cjs']) {\n    if (exts.has(cannotAdd) && !(0, util_1.hasOwnProperty)(require.extensions, cannotAdd)) {\n      // Unrecognized file exts can be transformed via the `.js` handler.\n      exts.add('.js');\n      exts.delete(cannotAdd);\n    }\n  } // Register new extensions.\n\n\n  for (const ext of exts) {\n    registerExtension(ext, service, originalJsHandler);\n  }\n\n  if (preferTsExts) {\n    const preferredExtensions = new Set([...exts, ...Object.keys(require.extensions)]); // Re-sort iteration order of Object.keys()\n\n    for (const ext of preferredExtensions) {\n      const old = Object.getOwnPropertyDescriptor(require.extensions, ext);\n      delete require.extensions[ext];\n      Object.defineProperty(require.extensions, ext, old);\n    }\n  }\n}\n/**\n * Register the extension for node.\n */\n\n\nfunction registerExtension(ext, service, originalHandler) {\n  const old = require.extensions[ext] || originalHandler;\n\n  require.extensions[ext] = function (m, filename) {\n    if (service.ignored(filename)) return old(m, filename);\n    assertScriptCanLoadAsCJS(service, m, filename);\n    const _compile = m._compile;\n\n    m._compile = function (code, fileName) {\n      (0, exports.debug)('module._compile', fileName);\n      const result = service.compile(code, fileName);\n      return _compile.call(this, result, fileName);\n    };\n\n    return old(m, filename);\n  };\n}\n/**\n * Update the output remapping the source map.\n */\n\n\nfunction updateOutput(outputText, fileName, sourceMap, getEmitExtension) {\n  const base64Map = Buffer.from(updateSourceMap(sourceMap, fileName), 'utf8').toString('base64');\n  const sourceMapContent = `//# sourceMappingURL=data:application/json;charset=utf-8;base64,${base64Map}`; // Expected form: `//# sourceMappingURL=foo bar.js.map` or `//# sourceMappingURL=foo%20bar.js.map` for input file \"foo bar.tsx\"\n  // Percent-encoding behavior added in TS 4.1.1: https://github.com/microsoft/TypeScript/issues/40951\n\n  const prefix = '//# sourceMappingURL=';\n  const prefixLength = prefix.length;\n  const baseName =\n  /*foo.tsx*/\n  (0, path_1.basename)(fileName);\n  const extName =\n  /*.tsx*/\n  (0, path_1.extname)(fileName);\n  const extension =\n  /*.js*/\n  getEmitExtension(fileName);\n  const sourcemapFilename = baseName.slice(0, -extName.length) + extension + '.map';\n  const sourceMapLengthWithoutPercentEncoding = prefixLength + sourcemapFilename.length;\n  /*\n   * Only rewrite if existing directive exists at the location we expect, to support:\n   *   a) compilers that do not append a sourcemap directive\n   *   b) situations where we did the math wrong\n   *     Not ideal, but appending our sourcemap *after* a pre-existing sourcemap still overrides, so the end-user is happy.\n   */\n\n  if (outputText.substr(-sourceMapLengthWithoutPercentEncoding, prefixLength) === prefix) {\n    return outputText.slice(0, -sourceMapLengthWithoutPercentEncoding) + sourceMapContent;\n  } // If anyone asks why we're not using URL, the URL equivalent is: `u = new URL('http://d'); u.pathname = \"/\" + sourcemapFilename; return u.pathname.slice(1);\n\n\n  const sourceMapLengthWithPercentEncoding = prefixLength + encodeURI(sourcemapFilename).length;\n\n  if (outputText.substr(-sourceMapLengthWithPercentEncoding, prefixLength) === prefix) {\n    return outputText.slice(0, -sourceMapLengthWithPercentEncoding) + sourceMapContent;\n  }\n\n  return `${outputText}\\n${sourceMapContent}`;\n}\n/**\n * Update the source map contents for improved output.\n */\n\n\nfunction updateSourceMap(sourceMapText, fileName) {\n  const sourceMap = JSON.parse(sourceMapText);\n  sourceMap.file = fileName;\n  sourceMap.sources = [fileName];\n  delete sourceMap.sourceRoot;\n  return JSON.stringify(sourceMap);\n}\n/**\n * Filter diagnostics.\n */\n\n\nfunction filterDiagnostics(diagnostics, filters) {\n  return diagnostics.filter(d => filters.every(f => {\n    var _a;\n\n    return !f.appliesToAllFiles && f.filenamesAbsolute.indexOf((_a = d.file) === null || _a === void 0 ? void 0 : _a.fileName) === -1 || f.diagnosticsIgnored.indexOf(d.code) === -1;\n  }));\n}\n/**\n * Get token at file position.\n *\n * Reference: https://github.com/microsoft/TypeScript/blob/fcd9334f57d85b73dd66ad2d21c02e84822f4841/src/services/utilities.ts#L705-L731\n */\n\n\nfunction getTokenAtPosition(ts, sourceFile, position) {\n  let current = sourceFile;\n\n  outer: while (true) {\n    for (const child of current.getChildren(sourceFile)) {\n      const start = child.getFullStart();\n      if (start > position) break;\n      const end = child.getEnd();\n\n      if (position <= end) {\n        current = child;\n        continue outer;\n      }\n    }\n\n    return current;\n  }\n}\n/**\n * Create an implementation of node's ESM loader hooks.\n *\n * This may be useful if you\n * want to wrap or compose the loader hooks to add additional functionality or\n * combine with another loader.\n *\n * Node changed the hooks API, so there are two possible APIs.  This function\n * detects your node version and returns the appropriate API.\n *\n * @category ESM Loader\n */\n\n\nconst createEsmHooks = tsNodeService => require('./esm').createEsmHooks(tsNodeService);\n\nexports.createEsmHooks = createEsmHooks;","map":{"version":3,"mappings":"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","names":["Object","enumerable","get","engineSupportsPackageTypeField","parseInt","process","versions","node","split","assertScriptCanLoadAsCJS","require","assertScriptCanLoadAsCJSImpl","exports","Symbol","for","env","util","inspect","custom","shouldDebug","TS_NODE_DEBUG","args","console","log","Date","toISOString","undefined","debugFn","key","fn","i","x","_","version","cwd","TS_NODE_CWD","_a","TS_NODE_DIR","emit","TS_NODE_EMIT","scope","TS_NODE_SCOPE","scopeDir","TS_NODE_SCOPE_DIR","files","TS_NODE_FILES","pretty","TS_NODE_PRETTY","compiler","TS_NODE_COMPILER","compilerOptions","TS_NODE_COMPILER_OPTIONS","ignore","TS_NODE_IGNORE","project","TS_NODE_PROJECT","skipProject","TS_NODE_SKIP_PROJECT","skipIgnore","TS_NODE_SKIP_IGNORE","preferTsExts","TS_NODE_PREFER_TS_EXTS","ignoreDiagnostics","TS_NODE_IGNORE_DIAGNOSTICS","transpileOnly","TS_NODE_TRANSPILE_ONLY","typeCheck","TS_NODE_TYPE_CHECK","compilerHost","TS_NODE_COMPILER_HOST","logError","TS_NODE_LOG_ERROR","experimentalReplAwait","TS_NODE_EXPERIMENTAL_REPL_AWAIT","_b","tsTrace","bind","TSError","make_error_1","constructor","diagnosticText","diagnosticCodes","diagnostics","defineProperty","configurable","writable","value","TS_NODE_SERVICE_BRAND","register","serviceOrOpts","service","create","originalJsHandler","extensions","registerExtensions","options","compiled","module_1","_preloadModules","rawOptions","foundConfigResult","createFromPreloadedConfig","configFilePath","config","projectLocalResolveDir","optionBasePaths","projectLocalResolveHelper","ts","targetSupportsTla","target","ScriptTarget","ES2018","Error","tsVersionSupportsTla","shouldReplAwait","swc","transpiler","readFile","sys","fileExists","transpilerBasePath","resolve","transformers","diagnosticFilters","appliesToAllFiles","filenamesAbsolute","diagnosticsIgnored","experimentalTsImportSpecifiers","map","Number","configDiagnosticList","filterDiagnostics","errors","outputCache","Map","configFileDirname","rootDir","_c","ignoreBaseDir","isScoped","fileName","charAt","shouldIgnore","createIgnore","str","RegExp","diagnosticHost","getNewLine","newLine","getCurrentDirectory","getCanonicalFileName","useCaseSensitiveFileNames","toLowerCase","TypeError","createTranspiler","initializeTranspilerFactory","transpilerName","transpilerOptions","transpilerConfigLocalResolveHelper","transpilerPath","transpilerFactory","nodeModuleEmitKind","experimentalEsmLoader","enableExperimentalEsmLoaderInterop","installSourceMapSupport","sourceMapSupport","install","environment","retrieveFile","pathOrUrl","path","startsWith","e","content","redirectConflictingLibrary","onConflictingLibraryRedirect","request","parent","isMain","redirectedRequest","filename","shouldHavePrettyErrors","stdout","isTTY","formatDiagnostics","formatDiagnosticsWithColorAndContext","createTSError","code","reportTSError","error","length","jsxEmitPreserve","jsx","JsxEmit","Preserve","getEmitExtension","lastDotIndex","lastIndexOf","ext","slice","getOutput","getTypeInfo","createGetCanonicalFileName","moduleTypeClassifier","basePath","_d","moduleTypes","patterns","fileContents","rootFileNames","Set","fileNames","cachedReadFile","projectVersion","fileVersions","Array","from","getCustomTransformers","program","getProgram","serviceHost","getProjectVersion","String","getScriptFileNames","getScriptVersion","toString","getScriptSnapshot","contents","set","ScriptSnapshot","fromString","readDirectory","getDirectories","directoryExists","realpath","getCompilationSettings","getDefaultLibFileName","getDefaultLibFilePath","trace","resolveModuleNames","getResolvedModuleWithFailedLookupLocationsFromCache","resolveTypeReferenceDirectives","isFileKnownToBeInternal","markBucketOfFilenameInternal","host","registry","createDocumentRegistry","createLanguageService","updateMemoryCache","has","add","previousVersion","previousContents","previousProgram","programBefore","output","getEmitOutput","getSemanticDiagnostics","concat","getSyntacticDiagnostics","programAfter","diagnosticList","emitSkipped","outputFiles","text","position","normalizedFileName","info","getQuickInfoAtPosition","name","displayPartsToString","displayParts","comment","documentation","cacheContents","resolvePath","createIncrementalCompilerHost","getSourceFile","languageVersion","createSourceFile","getDefaultLibLocation","builderProgram","createIncrementalProgram","rootNames","configFileParsingDiagnostics","projectReferences","createEmitAndSemanticDiagnosticsBuilderProgram","customTransformers","contentsChanged","addedToRootFileNames","outText","outMap","sourceFile","getPreEmitDiagnostics","result","file","writeByteOrderMark","endsWith","writeFile","isSourceFileFromExternalLibrary","getTokenAtPosition","checker","getTypeChecker","symbol","getSymbolAtLocation","type","getTypeOfSymbolAtLocation","signatures","getConstructSignatures","getCallSignatures","signatureToString","join","typeToString","getDocumentationComment","incremental","on","emitBuildInfo","createTranspileOnlyGetOutputFunction","overrideModuleType","module","customTranspiler","tsTranspileModule","reportDiagnostics","transpile","transpileModule","outputText","sourceMapText","shouldOverwriteEmitWhenForcingCommonJS","ModuleKind","CommonJS","shouldOverwriteEmitWhenForcingEsm","ES2015","ES2020","ES2022","ESNext","isNodeModuleType","Node16","NodeNext","getOutputForceCommonJS","getOutputForceNodeCommonJS","getOutputForceNodeESM","getOutputForceESM","getOutputTranspileOnly","compile","lineOffset","classification","classifyModuleByModuleTypeOverrides","sourceMap","moduleType","updateOutput","active","enabled","ignored","includes","addDiagnosticFilter","filter","push","f","getNodeEsmResolver","createResolve","tsNodeExperimentalSpecifierResolution","experimentalSpecifierResolution","getNodeEsmGetFormat","createGetFormat","getNodeCjsLoader","createCjsLoader","nodeEsmResolver","compilerPath","relname","some","test","exts","cannotAdd","delete","registerExtension","preferredExtensions","keys","old","getOwnPropertyDescriptor","originalHandler","m","_compile","call","base64Map","Buffer","updateSourceMap","sourceMapContent","prefix","prefixLength","baseName","extName","extension","sourcemapFilename","sourceMapLengthWithoutPercentEncoding","substr","sourceMapLengthWithPercentEncoding","encodeURI","JSON","parse","sources","sourceRoot","stringify","filters","d","every","indexOf","current","outer","child","getChildren","start","getFullStart","end","getEnd","createEsmHooks","tsNodeService"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\ts-node\\src\\index.ts"],"sourcesContent":["import { relative, basename, extname, dirname, join } from 'path';\nimport { Module } from 'module';\nimport * as util from 'util';\nimport { fileURLToPath } from 'url';\n\nimport type * as _sourceMapSupport from '@cspotcode/source-map-support';\nimport { BaseError } from 'make-error';\nimport type * as _ts from 'typescript';\n\nimport type { Transpiler, TranspilerFactory } from './transpilers/types';\nimport {\n  cachedLookup,\n  createProjectLocalResolveHelper,\n  hasOwnProperty,\n  normalizeSlashes,\n  once,\n  parse,\n  ProjectLocalResolveHelper,\n  split,\n  versionGteLt,\n  yn,\n} from './util';\nimport { findAndReadConfig, loadCompiler } from './configuration';\nimport type { TSCommon, TSInternal } from './ts-compiler-types';\nimport {\n  createModuleTypeClassifier,\n  ModuleTypeClassifier,\n} from './module-type-classifier';\nimport { createResolverFunctions } from './resolver-functions';\nimport type { createEsmHooks as createEsmHooksFn } from './esm';\nimport {\n  installCommonjsResolveHooksIfNecessary,\n  ModuleConstructorWithInternals,\n} from './cjs-resolve-hooks';\nimport { classifyModule } from './node-module-type-classifier';\nimport type * as _nodeInternalModulesEsmResolve from '../dist-raw/node-internal-modules-esm-resolve';\nimport type * as _nodeInternalModulesEsmGetFormat from '../dist-raw/node-internal-modules-esm-get_format';\nimport type * as _nodeInternalModulesCjsLoader from '../dist-raw/node-internal-modules-cjs-loader';\nimport { Extensions, getExtensions } from './file-extensions';\nimport { createTsTranspileModule } from './ts-transpile-module';\n\nexport { TSCommon };\nexport {\n  createRepl,\n  CreateReplOptions,\n  ReplService,\n  EvalAwarePartialHost,\n} from './repl';\nexport type {\n  TranspilerModule,\n  TranspilerFactory,\n  CreateTranspilerOptions,\n  TranspileOutput,\n  TranspileOptions,\n  Transpiler,\n} from './transpilers/types';\nexport type {\n  NodeLoaderHooksAPI1,\n  NodeLoaderHooksAPI2,\n  NodeLoaderHooksFormat,\n} from './esm';\n\n/**\n * Does this version of node obey the package.json \"type\" field\n * and throw ERR_REQUIRE_ESM when attempting to require() an ESM modules.\n */\nconst engineSupportsPackageTypeField =\n  parseInt(process.versions.node.split('.')[0], 10) >= 12;\n\n/**\n * Assert that script can be loaded as CommonJS when we attempt to require it.\n * If it should be loaded as ESM, throw ERR_REQUIRE_ESM like node does.\n *\n * Loaded conditionally so we don't need to support older node versions\n */\nlet assertScriptCanLoadAsCJS: (\n  service: Service,\n  module: NodeJS.Module,\n  filename: string\n) => void = engineSupportsPackageTypeField\n  ? (\n      require('../dist-raw/node-internal-modules-cjs-loader') as typeof _nodeInternalModulesCjsLoader\n    ).assertScriptCanLoadAsCJSImpl\n  : () => {\n      /* noop */\n    };\n\n/**\n * Registered `ts-node` instance information.\n */\nexport const REGISTER_INSTANCE = Symbol.for('ts-node.register.instance');\n\n/**\n * Expose `REGISTER_INSTANCE` information on node.js `process`.\n */\ndeclare global {\n  namespace NodeJS {\n    interface Process {\n      [REGISTER_INSTANCE]?: Service;\n    }\n  }\n}\n\n/** @internal */\nexport const env = process.env as ProcessEnv;\n/**\n * Declare all env vars, to aid discoverability.\n * If an env var affects ts-node's behavior, it should not be buried somewhere in our codebase.\n * @internal\n */\nexport interface ProcessEnv {\n  TS_NODE_DEBUG?: string;\n  TS_NODE_CWD?: string;\n  /** @deprecated */\n  TS_NODE_DIR?: string;\n  TS_NODE_EMIT?: string;\n  TS_NODE_SCOPE?: string;\n  TS_NODE_SCOPE_DIR?: string;\n  TS_NODE_FILES?: string;\n  TS_NODE_PRETTY?: string;\n  TS_NODE_COMPILER?: string;\n  TS_NODE_COMPILER_OPTIONS?: string;\n  TS_NODE_IGNORE?: string;\n  TS_NODE_PROJECT?: string;\n  TS_NODE_SKIP_PROJECT?: string;\n  TS_NODE_SKIP_IGNORE?: string;\n  TS_NODE_PREFER_TS_EXTS?: string;\n  TS_NODE_IGNORE_DIAGNOSTICS?: string;\n  TS_NODE_TRANSPILE_ONLY?: string;\n  TS_NODE_TYPE_CHECK?: string;\n  TS_NODE_COMPILER_HOST?: string;\n  TS_NODE_LOG_ERROR?: string;\n  TS_NODE_HISTORY?: string;\n  TS_NODE_EXPERIMENTAL_REPL_AWAIT?: string;\n\n  NODE_NO_READLINE?: string;\n}\n\n/**\n * @internal\n */\nexport const INSPECT_CUSTOM = util.inspect.custom || 'inspect';\n\n/**\n * Debugging `ts-node`.\n */\nconst shouldDebug = yn(env.TS_NODE_DEBUG);\n/** @internal */\nexport const debug = shouldDebug\n  ? (...args: any) =>\n      console.log(`[ts-node ${new Date().toISOString()}]`, ...args)\n  : () => undefined;\nconst debugFn = shouldDebug\n  ? <T, U>(key: string, fn: (arg: T) => U) => {\n      let i = 0;\n      return (x: T) => {\n        debug(key, x, ++i);\n        return fn(x);\n      };\n    }\n  : <T, U>(_: string, fn: (arg: T) => U) => fn;\n\n/**\n * Export the current version.\n */\nexport const VERSION = require('../package.json').version;\n\n/**\n * Options for creating a new TypeScript compiler instance.\n\n * @category Basic\n */\nexport interface CreateOptions {\n  /**\n   * Behave as if invoked within this working directory.  Roughly equivalent to `cd $dir && ts-node ...`\n   *\n   * @default process.cwd()\n   */\n  cwd?: string;\n  /**\n   * Legacy alias for `cwd`\n   *\n   * @deprecated use `projectSearchDir` or `cwd`\n   */\n  dir?: string;\n  /**\n   * Emit output files into `.ts-node` directory.\n   *\n   * @default false\n   */\n  emit?: boolean;\n  /**\n   * Scope compiler to files within `scopeDir`.\n   *\n   * @default false\n   */\n  scope?: boolean;\n  /**\n   * @default First of: `tsconfig.json` \"rootDir\" if specified, directory containing `tsconfig.json`, or cwd if no `tsconfig.json` is loaded.\n   */\n  scopeDir?: string;\n  /**\n   * Use pretty diagnostic formatter.\n   *\n   * @default false\n   */\n  pretty?: boolean;\n  /**\n   * Use TypeScript's faster `transpileModule`.\n   *\n   * @default false\n   */\n  transpileOnly?: boolean;\n  /**\n   * **DEPRECATED** Specify type-check is enabled (e.g. `transpileOnly == false`).\n   *\n   * @default true\n   */\n  typeCheck?: boolean;\n  /**\n   * Use TypeScript's compiler host API instead of the language service API.\n   *\n   * @default false\n   */\n  compilerHost?: boolean;\n  /**\n   * Logs TypeScript errors to stderr instead of throwing exceptions.\n   *\n   * @default false\n   */\n  logError?: boolean;\n  /**\n   * Load \"files\" and \"include\" from `tsconfig.json` on startup.\n   *\n   * Default is to override `tsconfig.json` \"files\" and \"include\" to only include the entrypoint script.\n   *\n   * @default false\n   */\n  files?: boolean;\n  /**\n   * Specify a custom TypeScript compiler.\n   *\n   * @default \"typescript\"\n   */\n  compiler?: string;\n  /**\n   * Specify a custom transpiler for use with transpileOnly\n   */\n  transpiler?: string | [string, object];\n  /**\n   * Transpile with swc instead of the TypeScript compiler, and skip typechecking.\n   *\n   * Equivalent to setting both `transpileOnly: true` and `transpiler: 'ts-node/transpilers/swc'`\n   *\n   * For complete instructions: https://typestrong.org/ts-node/docs/transpilers\n   */\n  swc?: boolean;\n  /**\n   * Paths which should not be compiled.\n   *\n   * Each string in the array is converted to a regular expression via `new RegExp()` and tested against source paths prior to compilation.\n   *\n   * Source paths are normalized to posix-style separators, relative to the directory containing `tsconfig.json` or to cwd if no `tsconfig.json` is loaded.\n   *\n   * Default is to ignore all node_modules subdirectories.\n   *\n   * @default [\"(?:^|/)node_modules/\"]\n   */\n  ignore?: string[];\n  /**\n   * Path to TypeScript config file or directory containing a `tsconfig.json`.\n   * Similar to the `tsc --project` flag: https://www.typescriptlang.org/docs/handbook/compiler-options.html\n   */\n  project?: string;\n  /**\n   * Search for TypeScript config file (`tsconfig.json`) in this or parent directories.\n   */\n  projectSearchDir?: string;\n  /**\n   * Skip project config resolution and loading.\n   *\n   * @default false\n   */\n  skipProject?: boolean;\n  /**\n   * Skip ignore check, so that compilation will be attempted for all files with matching extensions.\n   *\n   * @default false\n   */\n  skipIgnore?: boolean;\n  /**\n   * JSON object to merge with TypeScript `compilerOptions`.\n   *\n   * @allOf [{\"$ref\": \"https://schemastore.azurewebsites.net/schemas/json/tsconfig.json#definitions/compilerOptionsDefinition/properties/compilerOptions\"}]\n   */\n  compilerOptions?: object;\n  /**\n   * Ignore TypeScript warnings by diagnostic code.\n   */\n  ignoreDiagnostics?: Array<number | string>;\n  /**\n   * Modules to require, like node's `--require` flag.\n   *\n   * If specified in `tsconfig.json`, the modules will be resolved relative to the `tsconfig.json` file.\n   *\n   * If specified programmatically, each input string should be pre-resolved to an absolute path for\n   * best results.\n   */\n  require?: Array<string>;\n  readFile?: (path: string) => string | undefined;\n  fileExists?: (path: string) => boolean;\n  transformers?:\n    | _ts.CustomTransformers\n    | ((p: _ts.Program) => _ts.CustomTransformers);\n  /**\n   * Allows the usage of top level await in REPL.\n   *\n   * Uses node's implementation which accomplishes this with an AST syntax transformation.\n   *\n   * Enabled by default when tsconfig target is es2018 or above. Set to false to disable.\n   *\n   * **Note**: setting to `true` when tsconfig target is too low will throw an Error.  Leave as `undefined`\n   * to get default, automatic behavior.\n   */\n  experimentalReplAwait?: boolean;\n  /**\n   * Override certain paths to be compiled and executed as CommonJS or ECMAScript modules.\n   * When overridden, the tsconfig \"module\" and package.json \"type\" fields are overridden, and\n   * the file extension is ignored.\n   * This is useful if you cannot use .mts, .cts, .mjs, or .cjs file extensions;\n   * it achieves the same effect.\n   *\n   * Each key is a glob pattern following the same rules as tsconfig's \"include\" array.\n   * When multiple patterns match the same file, the last pattern takes precedence.\n   *\n   * `cjs` overrides matches files to compile and execute as CommonJS.\n   * `esm` overrides matches files to compile and execute as native ECMAScript modules.\n   * `package` overrides either of the above to default behavior, which obeys package.json \"type\" and\n   * tsconfig.json \"module\" options.\n   */\n  moduleTypes?: ModuleTypes;\n  /**\n   * @internal\n   * Set by our configuration loader whenever a config file contains options that\n   * are relative to the config file they came from, *and* when other logic needs\n   * to know this.  Some options can be eagerly resolved to absolute paths by\n   * the configuration loader, so it is *not* necessary for their source to be set here.\n   */\n  optionBasePaths?: OptionBasePaths;\n  /**\n   * A function to collect trace messages from the TypeScript compiler, for example when `traceResolution` is enabled.\n   *\n   * @default console.log\n   */\n  tsTrace?: (str: string) => void;\n  /**\n   * Enable native ESM support.\n   *\n   * For details, see https://typestrong.org/ts-node/docs/imports#native-ecmascript-modules\n   */\n  esm?: boolean;\n  /**\n   * Re-order file extensions so that TypeScript imports are preferred.\n   *\n   * For example, when both `index.js` and `index.ts` exist, enabling this option causes `require('./index')` to resolve to `index.ts` instead of `index.js`\n   *\n   * @default false\n   */\n  preferTsExts?: boolean;\n  /**\n   * Like node's `--experimental-specifier-resolution`, , but can also be set in your `tsconfig.json` for convenience.\n   *\n   * For details, see https://nodejs.org/dist/latest-v18.x/docs/api/esm.html#customizing-esm-specifier-resolution-algorithm\n   */\n  experimentalSpecifierResolution?: 'node' | 'explicit';\n  /**\n   * Allow using voluntary `.ts` file extension in import specifiers.\n   *\n   * Typically, in ESM projects, import specifiers must have an emit extension, `.js`, `.cjs`, or `.mjs`,\n   * and we automatically map to the corresponding `.ts`, `.cts`, or `.mts` source file.  This is the\n   * recommended approach.\n   *\n   * However, if you really want to use `.ts` in import specifiers, and are aware that this may\n   * break tooling, you can enable this flag.\n   */\n  experimentalTsImportSpecifiers?: boolean;\n}\n\nexport type ModuleTypes = Record<string, ModuleTypeOverride>;\nexport type ModuleTypeOverride = 'cjs' | 'esm' | 'package';\n\n/** @internal */\nexport interface OptionBasePaths {\n  moduleTypes?: string;\n  transpiler?: string;\n  compiler?: string;\n  swc?: string;\n}\n\n/**\n * Options for registering a TypeScript compiler instance globally.\n\n * @category Basic\n */\nexport interface RegisterOptions extends CreateOptions {\n  /**\n   * Enable experimental features that re-map imports and require calls to support:\n   * `baseUrl`, `paths`, `rootDirs`, `.js` to `.ts` file extension mappings,\n   * `outDir` to `rootDir` mappings for composite projects and monorepos.\n   *\n   * For details, see https://github.com/TypeStrong/ts-node/issues/1514\n   */\n  experimentalResolver?: boolean;\n}\n\nexport type ExperimentalSpecifierResolution = 'node' | 'explicit';\n\n/**\n * Must be an interface to support `typescript-json-schema`.\n */\nexport interface TsConfigOptions\n  extends Omit<\n    RegisterOptions,\n    | 'transformers'\n    | 'readFile'\n    | 'fileExists'\n    | 'skipProject'\n    | 'project'\n    | 'dir'\n    | 'cwd'\n    | 'projectSearchDir'\n    | 'optionBasePaths'\n    | 'tsTrace'\n  > {}\n\n/**\n * Information retrieved from type info check.\n */\nexport interface TypeInfo {\n  name: string;\n  comment: string;\n}\n\n/**\n * Default register options, including values specified via environment\n * variables.\n * @internal\n */\nexport const DEFAULTS: RegisterOptions = {\n  cwd: env.TS_NODE_CWD ?? env.TS_NODE_DIR,\n  emit: yn(env.TS_NODE_EMIT),\n  scope: yn(env.TS_NODE_SCOPE),\n  scopeDir: env.TS_NODE_SCOPE_DIR,\n  files: yn(env.TS_NODE_FILES),\n  pretty: yn(env.TS_NODE_PRETTY),\n  compiler: env.TS_NODE_COMPILER,\n  compilerOptions: parse(env.TS_NODE_COMPILER_OPTIONS),\n  ignore: split(env.TS_NODE_IGNORE),\n  project: env.TS_NODE_PROJECT,\n  skipProject: yn(env.TS_NODE_SKIP_PROJECT),\n  skipIgnore: yn(env.TS_NODE_SKIP_IGNORE),\n  preferTsExts: yn(env.TS_NODE_PREFER_TS_EXTS),\n  ignoreDiagnostics: split(env.TS_NODE_IGNORE_DIAGNOSTICS),\n  transpileOnly: yn(env.TS_NODE_TRANSPILE_ONLY),\n  typeCheck: yn(env.TS_NODE_TYPE_CHECK),\n  compilerHost: yn(env.TS_NODE_COMPILER_HOST),\n  logError: yn(env.TS_NODE_LOG_ERROR),\n  experimentalReplAwait: yn(env.TS_NODE_EXPERIMENTAL_REPL_AWAIT) ?? undefined,\n  tsTrace: console.log.bind(console),\n};\n\n/**\n * TypeScript diagnostics error.\n */\nexport class TSError extends BaseError {\n  name = 'TSError';\n  diagnosticText!: string;\n  diagnostics!: ReadonlyArray<_ts.Diagnostic>;\n\n  constructor(\n    diagnosticText: string,\n    public diagnosticCodes: number[],\n    diagnostics: ReadonlyArray<_ts.Diagnostic> = []\n  ) {\n    super(`тип Unable to compile TypeScript:\\n${diagnosticText}`);\n    Object.defineProperty(this, 'diagnosticText', {\n      configurable: true,\n      writable: true,\n      value: diagnosticText,\n    });\n    Object.defineProperty(this, 'diagnostics', {\n      configurable: true,\n      writable: true,\n      value: diagnostics,\n    });\n  }\n\n  /**\n   * @internal\n   */\n  [INSPECT_CUSTOM]() {\n    return this.diagnosticText;\n  }\n}\n\nconst TS_NODE_SERVICE_BRAND = Symbol('TS_NODE_SERVICE_BRAND');\n\n/**\n * Primary ts-node service, which wraps the TypeScript API and can compile TypeScript to JavaScript\n */\nexport interface Service {\n  /** @internal */\n  [TS_NODE_SERVICE_BRAND]: true;\n  ts: TSCommon;\n  /** @internal */\n  compilerPath: string;\n  config: _ts.ParsedCommandLine;\n  options: RegisterOptions;\n  enabled(enabled?: boolean): boolean;\n  ignored(fileName: string): boolean;\n  compile(code: string, fileName: string, lineOffset?: number): string;\n  getTypeInfo(code: string, fileName: string, position: number): TypeInfo;\n  /** @internal */\n  configFilePath: string | undefined;\n  /** @internal */\n  moduleTypeClassifier: ModuleTypeClassifier;\n  /** @internal */\n  readonly shouldReplAwait: boolean;\n  /** @internal */\n  addDiagnosticFilter(filter: DiagnosticFilter): void;\n  /** @internal */\n  installSourceMapSupport(): void;\n  /** @internal */\n  enableExperimentalEsmLoaderInterop(): void;\n  /** @internal */\n  transpileOnly: boolean;\n  /** @internal */\n  projectLocalResolveHelper: ProjectLocalResolveHelper;\n  /** @internal */\n  getNodeEsmResolver: () => ReturnType<\n    typeof import('../dist-raw/node-internal-modules-esm-resolve').createResolve\n  >;\n  /** @internal */\n  getNodeEsmGetFormat: () => ReturnType<\n    typeof import('../dist-raw/node-internal-modules-esm-get_format').createGetFormat\n  >;\n  /** @internal */\n  getNodeCjsLoader: () => ReturnType<\n    typeof import('../dist-raw/node-internal-modules-cjs-loader').createCjsLoader\n  >;\n  /** @internal */\n  extensions: Extensions;\n}\n\n/**\n * Re-export of `Service` interface for backwards-compatibility\n * @deprecated use `Service` instead\n * @see {Service}\n */\nexport type Register = Service;\n\n/** @internal */\nexport interface DiagnosticFilter {\n  /** if true, filter applies to all files */\n  appliesToAllFiles: boolean;\n  /** Filter applies onto to these filenames.  Only used if appliesToAllFiles is false */\n  filenamesAbsolute: string[];\n  /** these diagnostic codes are ignored */\n  diagnosticsIgnored: number[];\n}\n\n/**\n * Create a new TypeScript compiler instance and register it onto node.js\n *\n * @category Basic\n */\nexport function register(opts?: RegisterOptions): Service;\n/**\n * Register TypeScript compiler instance onto node.js\n\n * @category Basic\n */\nexport function register(service: Service): Service;\nexport function register(\n  serviceOrOpts: Service | RegisterOptions | undefined\n): Service {\n  // Is this a Service or a RegisterOptions?\n  let service = serviceOrOpts as Service;\n  if (!(serviceOrOpts as Service)?.[TS_NODE_SERVICE_BRAND]) {\n    // Not a service; is options\n    service = create((serviceOrOpts ?? {}) as RegisterOptions);\n  }\n\n  const originalJsHandler = require.extensions['.js'];\n\n  // Expose registered instance globally.\n  process[REGISTER_INSTANCE] = service;\n\n  // Register the extensions.\n  registerExtensions(\n    service.options.preferTsExts,\n    service.extensions.compiled,\n    service,\n    originalJsHandler\n  );\n\n  installCommonjsResolveHooksIfNecessary(service);\n\n  // Require specified modules before start-up.\n  (Module as ModuleConstructorWithInternals)._preloadModules(\n    service.options.require\n  );\n\n  return service;\n}\n\n/**\n * Create TypeScript compiler instance.\n *\n * @category Basic\n */\nexport function create(rawOptions: CreateOptions = {}): Service {\n  const foundConfigResult = findAndReadConfig(rawOptions);\n  return createFromPreloadedConfig(foundConfigResult);\n}\n\n/** @internal */\nexport function createFromPreloadedConfig(\n  foundConfigResult: ReturnType<typeof findAndReadConfig>\n): Service {\n  const {\n    configFilePath,\n    cwd,\n    options,\n    config,\n    compiler,\n    projectLocalResolveDir,\n    optionBasePaths,\n  } = foundConfigResult;\n\n  const projectLocalResolveHelper = createProjectLocalResolveHelper(\n    projectLocalResolveDir\n  );\n\n  const ts = loadCompiler(compiler);\n\n  // Experimental REPL await is not compatible targets lower than ES2018\n  const targetSupportsTla = config.options.target! >= ts.ScriptTarget.ES2018;\n  if (options.experimentalReplAwait === true && !targetSupportsTla) {\n    throw new Error(\n      'Experimental REPL await is not compatible with targets lower than ES2018'\n    );\n  }\n  // Top-level await was added in TS 3.8\n  const tsVersionSupportsTla = versionGteLt(ts.version, '3.8.0');\n  if (options.experimentalReplAwait === true && !tsVersionSupportsTla) {\n    throw new Error(\n      'Experimental REPL await is not compatible with TypeScript versions older than 3.8'\n    );\n  }\n\n  const shouldReplAwait =\n    options.experimentalReplAwait !== false &&\n    tsVersionSupportsTla &&\n    targetSupportsTla;\n\n  // swc implies two other options\n  // typeCheck option was implemented specifically to allow overriding tsconfig transpileOnly from the command-line\n  // So we should allow using typeCheck to override swc\n  if (options.swc && !options.typeCheck) {\n    if (options.transpileOnly === false) {\n      throw new Error(\n        \"Cannot enable 'swc' option with 'transpileOnly: false'.  'swc' implies 'transpileOnly'.\"\n      );\n    }\n    if (options.transpiler) {\n      throw new Error(\n        \"Cannot specify both 'swc' and 'transpiler' options.  'swc' uses the built-in swc transpiler.\"\n      );\n    }\n  }\n\n  const readFile = options.readFile || ts.sys.readFile;\n  const fileExists = options.fileExists || ts.sys.fileExists;\n  // typeCheck can override transpileOnly, useful for CLI flag to override config file\n  const transpileOnly =\n    (options.transpileOnly === true || options.swc === true) &&\n    options.typeCheck !== true;\n  let transpiler: RegisterOptions['transpiler'] | undefined = undefined;\n  let transpilerBasePath: string | undefined = undefined;\n  if (options.transpiler) {\n    transpiler = options.transpiler;\n    transpilerBasePath = optionBasePaths.transpiler;\n  } else if (options.swc) {\n    transpiler = require.resolve('./transpilers/swc.js');\n    transpilerBasePath = optionBasePaths.swc;\n  }\n  const transformers = options.transformers || undefined;\n  const diagnosticFilters: Array<DiagnosticFilter> = [\n    {\n      appliesToAllFiles: true,\n      filenamesAbsolute: [],\n      diagnosticsIgnored: [\n        6059, // \"'rootDir' is expected to contain all source files.\"\n        18002, // \"The 'files' list in config file is empty.\"\n        18003, // \"No inputs were found in config file.\"\n        ...(options.experimentalTsImportSpecifiers\n          ? [\n              2691, // \"An import path cannot end with a '.ts' extension. Consider importing '<specifier without ext>' instead.\"\n            ]\n          : []),\n        ...(options.ignoreDiagnostics || []),\n      ].map(Number),\n    },\n  ];\n\n  const configDiagnosticList = filterDiagnostics(\n    config.errors,\n    diagnosticFilters\n  );\n  const outputCache = new Map<\n    string,\n    {\n      content: string;\n    }\n  >();\n\n  const configFileDirname = configFilePath ? dirname(configFilePath) : null;\n  const scopeDir =\n    options.scopeDir ?? config.options.rootDir ?? configFileDirname ?? cwd;\n  const ignoreBaseDir = configFileDirname ?? cwd;\n  const isScoped = options.scope\n    ? (fileName: string) => relative(scopeDir, fileName).charAt(0) !== '.'\n    : () => true;\n  const shouldIgnore = createIgnore(\n    ignoreBaseDir,\n    options.skipIgnore\n      ? []\n      : (options.ignore || ['(?:^|/)node_modules/']).map(\n          (str) => new RegExp(str)\n        )\n  );\n\n  const diagnosticHost: _ts.FormatDiagnosticsHost = {\n    getNewLine: () => ts.sys.newLine,\n    getCurrentDirectory: () => cwd,\n    // TODO switch to getCanonicalFileName we already create later in scope\n    getCanonicalFileName: ts.sys.useCaseSensitiveFileNames\n      ? (x) => x\n      : (x) => x.toLowerCase(),\n  };\n\n  if (options.transpileOnly && typeof transformers === 'function') {\n    throw new TypeError(\n      'Transformers function is unavailable in \"--transpile-only\"'\n    );\n  }\n  let createTranspiler = initializeTranspilerFactory();\n  function initializeTranspilerFactory() {\n    if (transpiler) {\n      if (!transpileOnly)\n        throw new Error(\n          'Custom transpiler can only be used when transpileOnly is enabled.'\n        );\n      const transpilerName =\n        typeof transpiler === 'string' ? transpiler : transpiler[0];\n      const transpilerOptions =\n        typeof transpiler === 'string' ? {} : transpiler[1] ?? {};\n      const transpilerConfigLocalResolveHelper = transpilerBasePath\n        ? createProjectLocalResolveHelper(transpilerBasePath)\n        : projectLocalResolveHelper;\n      const transpilerPath = transpilerConfigLocalResolveHelper(\n        transpilerName,\n        true\n      );\n      const transpilerFactory = require(transpilerPath)\n        .create as TranspilerFactory;\n      return createTranspiler;\n\n      function createTranspiler(\n        compilerOptions: TSCommon.CompilerOptions,\n        nodeModuleEmitKind?: NodeModuleEmitKind\n      ) {\n        return transpilerFactory?.({\n          service: {\n            options,\n            config: {\n              ...config,\n              options: compilerOptions,\n            },\n            projectLocalResolveHelper,\n          },\n          transpilerConfigLocalResolveHelper,\n          nodeModuleEmitKind,\n          ...transpilerOptions,\n        });\n      }\n    }\n  }\n\n  /**\n   * True if require() hooks should interop with experimental ESM loader.\n   * Enabled explicitly via a flag since it is a breaking change.\n   */\n  let experimentalEsmLoader = false;\n  function enableExperimentalEsmLoaderInterop() {\n    experimentalEsmLoader = true;\n  }\n\n  // Install source map support and read from memory cache.\n  installSourceMapSupport();\n  function installSourceMapSupport() {\n    const sourceMapSupport =\n      require('@cspotcode/source-map-support') as typeof _sourceMapSupport;\n    sourceMapSupport.install({\n      environment: 'node',\n      retrieveFile(pathOrUrl: string) {\n        let path = pathOrUrl;\n        // If it's a file URL, convert to local path\n        // Note: fileURLToPath does not exist on early node v10\n        // I could not find a way to handle non-URLs except to swallow an error\n        if (experimentalEsmLoader && path.startsWith('file://')) {\n          try {\n            path = fileURLToPath(path);\n          } catch (e) {\n            /* swallow error */\n          }\n        }\n        path = normalizeSlashes(path);\n        return outputCache.get(path)?.content || '';\n      },\n      redirectConflictingLibrary: true,\n      onConflictingLibraryRedirect(\n        request,\n        parent,\n        isMain,\n        options,\n        redirectedRequest\n      ) {\n        debug(\n          `Redirected an attempt to require source-map-support to instead receive @cspotcode/source-map-support.  \"${\n            (parent as NodeJS.Module).filename\n          }\" attempted to require or resolve \"${request}\" and was redirected to \"${redirectedRequest}\".`\n        );\n      },\n    });\n  }\n\n  const shouldHavePrettyErrors =\n    options.pretty === undefined ? process.stdout.isTTY : options.pretty;\n\n  const formatDiagnostics = shouldHavePrettyErrors\n    ? ts.formatDiagnosticsWithColorAndContext || ts.formatDiagnostics\n    : ts.formatDiagnostics;\n\n  function createTSError(diagnostics: ReadonlyArray<_ts.Diagnostic>) {\n    const diagnosticText = formatDiagnostics(diagnostics, diagnosticHost);\n    const diagnosticCodes = diagnostics.map((x) => x.code);\n    return new TSError(diagnosticText, diagnosticCodes, diagnostics);\n  }\n\n  function reportTSError(configDiagnosticList: _ts.Diagnostic[]) {\n    const error = createTSError(configDiagnosticList);\n    if (options.logError) {\n      // Print error in red color and continue execution.\n      console.error('\\x1b[31m%s\\x1b[0m', error);\n    } else {\n      // Throw error and exit the script.\n      throw error;\n    }\n  }\n\n  // Render the configuration errors.\n  if (configDiagnosticList.length) reportTSError(configDiagnosticList);\n\n  const jsxEmitPreserve = config.options.jsx === ts.JsxEmit.Preserve;\n  /**\n   * Get the extension for a transpiled file.\n   * [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n   */\n  function getEmitExtension(path: string) {\n    const lastDotIndex = path.lastIndexOf('.');\n    if (lastDotIndex >= 0) {\n      const ext = path.slice(lastDotIndex);\n      switch (ext) {\n        case '.js':\n        case '.ts':\n          return '.js';\n        case '.jsx':\n        case '.tsx':\n          return jsxEmitPreserve ? '.jsx' : '.js';\n        case '.mjs':\n        case '.mts':\n          return '.mjs';\n        case '.cjs':\n        case '.cts':\n          return '.cjs';\n      }\n    }\n    return '.js';\n  }\n\n  type GetOutputFunction = (code: string, fileName: string) => SourceOutput;\n  /**\n   * Get output from TS compiler w/typechecking.  `undefined` in `transpileOnly`\n   * mode.\n   */\n  let getOutput: GetOutputFunction | undefined;\n  let getTypeInfo: (\n    _code: string,\n    _fileName: string,\n    _position: number\n  ) => TypeInfo;\n\n  const getCanonicalFileName = (\n    ts as unknown as TSInternal\n  ).createGetCanonicalFileName(ts.sys.useCaseSensitiveFileNames);\n\n  const moduleTypeClassifier = createModuleTypeClassifier({\n    basePath: options.optionBasePaths?.moduleTypes,\n    patterns: options.moduleTypes,\n  });\n\n  const extensions = getExtensions(config, options, ts.version);\n\n  // Use full language services when the fast option is disabled.\n  if (!transpileOnly) {\n    const fileContents = new Map<string, string>();\n    const rootFileNames = new Set(config.fileNames);\n    const cachedReadFile = cachedLookup(debugFn('readFile', readFile));\n\n    // Use language services by default\n    if (!options.compilerHost) {\n      let projectVersion = 1;\n      const fileVersions = new Map(\n        Array.from(rootFileNames).map((fileName) => [fileName, 0])\n      );\n\n      const getCustomTransformers = () => {\n        if (typeof transformers === 'function') {\n          const program = service.getProgram();\n          return program ? transformers(program) : undefined;\n        }\n\n        return transformers;\n      };\n\n      // Create the compiler host for type checking.\n      const serviceHost: _ts.LanguageServiceHost &\n        Required<Pick<_ts.LanguageServiceHost, 'fileExists' | 'readFile'>> = {\n        getProjectVersion: () => String(projectVersion),\n        getScriptFileNames: () => Array.from(rootFileNames),\n        getScriptVersion: (fileName: string) => {\n          const version = fileVersions.get(fileName);\n          return version ? version.toString() : '';\n        },\n        getScriptSnapshot(fileName: string) {\n          // TODO ordering of this with getScriptVersion?  Should they sync up?\n          let contents = fileContents.get(fileName);\n\n          // Read contents into TypeScript memory cache.\n          if (contents === undefined) {\n            contents = cachedReadFile(fileName);\n            if (contents === undefined) return;\n\n            fileVersions.set(fileName, 1);\n            fileContents.set(fileName, contents);\n            projectVersion++;\n          }\n\n          return ts.ScriptSnapshot.fromString(contents);\n        },\n        readFile: cachedReadFile,\n        readDirectory: ts.sys.readDirectory,\n        getDirectories: cachedLookup(\n          debugFn('getDirectories', ts.sys.getDirectories)\n        ),\n        fileExists: cachedLookup(debugFn('fileExists', fileExists)),\n        directoryExists: cachedLookup(\n          debugFn('directoryExists', ts.sys.directoryExists)\n        ),\n        realpath: ts.sys.realpath\n          ? cachedLookup(debugFn('realpath', ts.sys.realpath))\n          : undefined,\n        getNewLine: () => ts.sys.newLine,\n        useCaseSensitiveFileNames: () => ts.sys.useCaseSensitiveFileNames,\n        getCurrentDirectory: () => cwd,\n        getCompilationSettings: () => config.options,\n        getDefaultLibFileName: () => ts.getDefaultLibFilePath(config.options),\n        getCustomTransformers: getCustomTransformers,\n        trace: options.tsTrace,\n      };\n      const {\n        resolveModuleNames,\n        getResolvedModuleWithFailedLookupLocationsFromCache,\n        resolveTypeReferenceDirectives,\n        isFileKnownToBeInternal,\n        markBucketOfFilenameInternal,\n      } = createResolverFunctions({\n        host: serviceHost,\n        getCanonicalFileName,\n        ts,\n        cwd,\n        config,\n        projectLocalResolveHelper,\n        options,\n        extensions,\n      });\n      serviceHost.resolveModuleNames = resolveModuleNames;\n      serviceHost.getResolvedModuleWithFailedLookupLocationsFromCache =\n        getResolvedModuleWithFailedLookupLocationsFromCache;\n      serviceHost.resolveTypeReferenceDirectives =\n        resolveTypeReferenceDirectives;\n\n      const registry = ts.createDocumentRegistry(\n        ts.sys.useCaseSensitiveFileNames,\n        cwd\n      );\n      const service = ts.createLanguageService(serviceHost, registry);\n\n      const updateMemoryCache = (contents: string, fileName: string) => {\n        // Add to `rootFiles` as necessary, either to make TS include a file it has not seen,\n        // or to trigger a re-classification of files from external to internal.\n        if (\n          !rootFileNames.has(fileName) &&\n          !isFileKnownToBeInternal(fileName)\n        ) {\n          markBucketOfFilenameInternal(fileName);\n          rootFileNames.add(fileName);\n          // Increment project version for every change to rootFileNames.\n          projectVersion++;\n        }\n\n        const previousVersion = fileVersions.get(fileName) || 0;\n        const previousContents = fileContents.get(fileName);\n        // Avoid incrementing cache when nothing has changed.\n        if (contents !== previousContents) {\n          fileVersions.set(fileName, previousVersion + 1);\n          fileContents.set(fileName, contents);\n          // Increment project version for every file change.\n          projectVersion++;\n        }\n      };\n\n      let previousProgram: _ts.Program | undefined = undefined;\n\n      getOutput = (code: string, fileName: string) => {\n        updateMemoryCache(code, fileName);\n\n        const programBefore = service.getProgram();\n        if (programBefore !== previousProgram) {\n          debug(\n            `compiler rebuilt Program instance when getting output for ${fileName}`\n          );\n        }\n\n        const output = service.getEmitOutput(fileName);\n\n        // Get the relevant diagnostics - this is 3x faster than `getPreEmitDiagnostics`.\n        const diagnostics = service\n          .getSemanticDiagnostics(fileName)\n          .concat(service.getSyntacticDiagnostics(fileName));\n\n        const programAfter = service.getProgram();\n\n        debug(\n          'invariant: Is service.getProject() identical before and after getting emit output and diagnostics? (should always be true) ',\n          programBefore === programAfter\n        );\n\n        previousProgram = programAfter;\n\n        const diagnosticList = filterDiagnostics(\n          diagnostics,\n          diagnosticFilters\n        );\n        if (diagnosticList.length) reportTSError(diagnosticList);\n\n        if (output.emitSkipped) {\n          return [undefined, undefined, true];\n        }\n\n        // Throw an error when requiring `.d.ts` files.\n        if (output.outputFiles.length === 0) {\n          throw new TypeError(\n            `Unable to require file: ${relative(cwd, fileName)}\\n` +\n              'This is usually the result of a faulty configuration or import. ' +\n              'Make sure there is a `.js`, `.json` or other executable extension with ' +\n              'loader attached before `ts-node` available.'\n          );\n        }\n\n        return [output.outputFiles[1].text, output.outputFiles[0].text, false];\n      };\n\n      getTypeInfo = (code: string, fileName: string, position: number) => {\n        const normalizedFileName = normalizeSlashes(fileName);\n        updateMemoryCache(code, normalizedFileName);\n\n        const info = service.getQuickInfoAtPosition(\n          normalizedFileName,\n          position\n        );\n        const name = ts.displayPartsToString(info ? info.displayParts : []);\n        const comment = ts.displayPartsToString(info ? info.documentation : []);\n\n        return { name, comment };\n      };\n    } else {\n      const sys: _ts.System & _ts.FormatDiagnosticsHost = {\n        ...ts.sys,\n        ...diagnosticHost,\n        readFile: (fileName: string) => {\n          const cacheContents = fileContents.get(fileName);\n          if (cacheContents !== undefined) return cacheContents;\n          const contents = cachedReadFile(fileName);\n          if (contents) fileContents.set(fileName, contents);\n          return contents;\n        },\n        readDirectory: ts.sys.readDirectory,\n        getDirectories: cachedLookup(\n          debugFn('getDirectories', ts.sys.getDirectories)\n        ),\n        fileExists: cachedLookup(debugFn('fileExists', fileExists)),\n        directoryExists: cachedLookup(\n          debugFn('directoryExists', ts.sys.directoryExists)\n        ),\n        resolvePath: cachedLookup(debugFn('resolvePath', ts.sys.resolvePath)),\n        realpath: ts.sys.realpath\n          ? cachedLookup(debugFn('realpath', ts.sys.realpath))\n          : undefined,\n      };\n\n      const host: _ts.CompilerHost = ts.createIncrementalCompilerHost\n        ? ts.createIncrementalCompilerHost(config.options, sys)\n        : {\n            ...sys,\n            getSourceFile: (fileName, languageVersion) => {\n              const contents = sys.readFile(fileName);\n              if (contents === undefined) return;\n              return ts.createSourceFile(fileName, contents, languageVersion);\n            },\n            getDefaultLibLocation: () => normalizeSlashes(dirname(compiler)),\n            getDefaultLibFileName: () =>\n              normalizeSlashes(\n                join(\n                  dirname(compiler),\n                  ts.getDefaultLibFileName(config.options)\n                )\n              ),\n            useCaseSensitiveFileNames: () => sys.useCaseSensitiveFileNames,\n          };\n      host.trace = options.tsTrace;\n      const {\n        resolveModuleNames,\n        resolveTypeReferenceDirectives,\n        isFileKnownToBeInternal,\n        markBucketOfFilenameInternal,\n      } = createResolverFunctions({\n        host,\n        cwd,\n        config,\n        ts,\n        getCanonicalFileName,\n        projectLocalResolveHelper,\n        options,\n        extensions,\n      });\n      host.resolveModuleNames = resolveModuleNames;\n      host.resolveTypeReferenceDirectives = resolveTypeReferenceDirectives;\n\n      // Fallback for older TypeScript releases without incremental API.\n      let builderProgram = ts.createIncrementalProgram\n        ? ts.createIncrementalProgram({\n            rootNames: Array.from(rootFileNames),\n            options: config.options,\n            host,\n            configFileParsingDiagnostics: config.errors,\n            projectReferences: config.projectReferences,\n          })\n        : ts.createEmitAndSemanticDiagnosticsBuilderProgram(\n            Array.from(rootFileNames),\n            config.options,\n            host,\n            undefined,\n            config.errors,\n            config.projectReferences\n          );\n\n      // Read and cache custom transformers.\n      const customTransformers =\n        typeof transformers === 'function'\n          ? transformers(builderProgram.getProgram())\n          : transformers;\n\n      // Set the file contents into cache manually.\n      const updateMemoryCache = (contents: string, fileName: string) => {\n        const previousContents = fileContents.get(fileName);\n        const contentsChanged = previousContents !== contents;\n        if (contentsChanged) {\n          fileContents.set(fileName, contents);\n        }\n\n        // Add to `rootFiles` when discovered by compiler for the first time.\n        let addedToRootFileNames = false;\n        if (\n          !rootFileNames.has(fileName) &&\n          !isFileKnownToBeInternal(fileName)\n        ) {\n          markBucketOfFilenameInternal(fileName);\n          rootFileNames.add(fileName);\n          addedToRootFileNames = true;\n        }\n\n        // Update program when file changes.\n        if (addedToRootFileNames || contentsChanged) {\n          builderProgram = ts.createEmitAndSemanticDiagnosticsBuilderProgram(\n            Array.from(rootFileNames),\n            config.options,\n            host,\n            builderProgram,\n            config.errors,\n            config.projectReferences\n          );\n        }\n      };\n\n      getOutput = (code: string, fileName: string) => {\n        let outText = '';\n        let outMap = '';\n\n        updateMemoryCache(code, fileName);\n\n        const sourceFile = builderProgram.getSourceFile(fileName);\n        if (!sourceFile)\n          throw new TypeError(`Unable to read file: ${fileName}`);\n\n        const program = builderProgram.getProgram();\n        const diagnostics = ts.getPreEmitDiagnostics(program, sourceFile);\n        const diagnosticList = filterDiagnostics(\n          diagnostics,\n          diagnosticFilters\n        );\n        if (diagnosticList.length) reportTSError(diagnosticList);\n\n        const result = builderProgram.emit(\n          sourceFile,\n          (path, file, writeByteOrderMark) => {\n            if (path.endsWith('.map')) {\n              outMap = file;\n            } else {\n              outText = file;\n            }\n\n            if (options.emit) sys.writeFile(path, file, writeByteOrderMark);\n          },\n          undefined,\n          undefined,\n          customTransformers\n        );\n\n        if (result.emitSkipped) {\n          return [undefined, undefined, true];\n        }\n\n        // Throw an error when requiring files that cannot be compiled.\n        if (outText === '') {\n          if (program.isSourceFileFromExternalLibrary(sourceFile)) {\n            throw new TypeError(\n              `Unable to compile file from external library: ${relative(\n                cwd,\n                fileName\n              )}`\n            );\n          }\n\n          throw new TypeError(\n            `Unable to require file: ${relative(cwd, fileName)}\\n` +\n              'This is usually the result of a faulty configuration or import. ' +\n              'Make sure there is a `.js`, `.json` or other executable extension with ' +\n              'loader attached before `ts-node` available.'\n          );\n        }\n\n        return [outText, outMap, false];\n      };\n\n      getTypeInfo = (code: string, fileName: string, position: number) => {\n        const normalizedFileName = normalizeSlashes(fileName);\n        updateMemoryCache(code, normalizedFileName);\n\n        const sourceFile = builderProgram.getSourceFile(normalizedFileName);\n        if (!sourceFile)\n          throw new TypeError(`Unable to read file: ${fileName}`);\n\n        const node = getTokenAtPosition(ts, sourceFile, position);\n        const checker = builderProgram.getProgram().getTypeChecker();\n        const symbol = checker.getSymbolAtLocation(node);\n\n        if (!symbol) return { name: '', comment: '' };\n\n        const type = checker.getTypeOfSymbolAtLocation(symbol, node);\n        const signatures = [\n          ...type.getConstructSignatures(),\n          ...type.getCallSignatures(),\n        ];\n\n        return {\n          name: signatures.length\n            ? signatures.map((x) => checker.signatureToString(x)).join('\\n')\n            : checker.typeToString(type),\n          comment: ts.displayPartsToString(\n            symbol ? symbol.getDocumentationComment(checker) : []\n          ),\n        };\n      };\n\n      // Write `.tsbuildinfo` when `--build` is enabled.\n      if (options.emit && config.options.incremental) {\n        process.on('exit', () => {\n          // Emits `.tsbuildinfo` to filesystem.\n          (builderProgram.getProgram() as any).emitBuildInfo();\n        });\n      }\n    }\n  } else {\n    getTypeInfo = () => {\n      throw new TypeError(\n        'Type information is unavailable in \"--transpile-only\"'\n      );\n    };\n  }\n\n  function createTranspileOnlyGetOutputFunction(\n    overrideModuleType?: _ts.ModuleKind,\n    nodeModuleEmitKind?: NodeModuleEmitKind\n  ): GetOutputFunction {\n    const compilerOptions = { ...config.options };\n    if (overrideModuleType !== undefined)\n      compilerOptions.module = overrideModuleType;\n    let customTranspiler = createTranspiler?.(\n      compilerOptions,\n      nodeModuleEmitKind\n    );\n    let tsTranspileModule = versionGteLt(ts.version, '4.7.0')\n      ? createTsTranspileModule(ts, {\n          compilerOptions,\n          reportDiagnostics: true,\n          transformers: transformers as _ts.CustomTransformers | undefined,\n        })\n      : undefined;\n    return (code: string, fileName: string): SourceOutput => {\n      let result: _ts.TranspileOutput;\n      if (customTranspiler) {\n        result = customTranspiler.transpile(code, {\n          fileName,\n        });\n      } else if (tsTranspileModule) {\n        result = tsTranspileModule(\n          code,\n          {\n            fileName,\n          },\n          nodeModuleEmitKind === 'nodeesm' ? 'module' : 'commonjs'\n        );\n      } else {\n        result = ts.transpileModule(code, {\n          fileName,\n          compilerOptions,\n          reportDiagnostics: true,\n          transformers: transformers as _ts.CustomTransformers | undefined,\n        });\n      }\n\n      const diagnosticList = filterDiagnostics(\n        result.diagnostics || [],\n        diagnosticFilters\n      );\n      if (diagnosticList.length) reportTSError(diagnosticList);\n\n      return [result.outputText, result.sourceMapText as string, false];\n    };\n  }\n\n  // When true, these mean that a `moduleType` override will cause a different emit\n  // than the TypeScript compiler, so we *must* overwrite the emit.\n  const shouldOverwriteEmitWhenForcingCommonJS =\n    config.options.module !== ts.ModuleKind.CommonJS;\n  // [MUST_UPDATE_FOR_NEW_MODULEKIND]\n  const shouldOverwriteEmitWhenForcingEsm = !(\n    config.options.module === ts.ModuleKind.ES2015 ||\n    (ts.ModuleKind.ES2020 && config.options.module === ts.ModuleKind.ES2020) ||\n    (ts.ModuleKind.ES2022 && config.options.module === ts.ModuleKind.ES2022) ||\n    config.options.module === ts.ModuleKind.ESNext\n  );\n  /**\n   * node16 or nodenext\n   * [MUST_UPDATE_FOR_NEW_MODULEKIND]\n   */\n  const isNodeModuleType =\n    (ts.ModuleKind.Node16 && config.options.module === ts.ModuleKind.Node16) ||\n    (ts.ModuleKind.NodeNext &&\n      config.options.module === ts.ModuleKind.NodeNext);\n  const getOutputForceCommonJS = createTranspileOnlyGetOutputFunction(\n    ts.ModuleKind.CommonJS\n  );\n  const getOutputForceNodeCommonJS = createTranspileOnlyGetOutputFunction(\n    ts.ModuleKind.NodeNext,\n    'nodecjs'\n  );\n  const getOutputForceNodeESM = createTranspileOnlyGetOutputFunction(\n    ts.ModuleKind.NodeNext,\n    'nodeesm'\n  );\n  // [MUST_UPDATE_FOR_NEW_MODULEKIND]\n  const getOutputForceESM = createTranspileOnlyGetOutputFunction(\n    ts.ModuleKind.ES2022 || ts.ModuleKind.ES2020 || ts.ModuleKind.ES2015\n  );\n  const getOutputTranspileOnly = createTranspileOnlyGetOutputFunction();\n\n  // Create a simple TypeScript compiler proxy.\n  function compile(code: string, fileName: string, lineOffset = 0) {\n    const normalizedFileName = normalizeSlashes(fileName);\n    const classification =\n      moduleTypeClassifier.classifyModuleByModuleTypeOverrides(\n        normalizedFileName\n      );\n    let value: string | undefined = '';\n    let sourceMap: string | undefined = '';\n    let emitSkipped = true;\n    if (getOutput) {\n      // Must always call normal getOutput to throw typechecking errors\n      [value, sourceMap, emitSkipped] = getOutput(code, normalizedFileName);\n    }\n    // If module classification contradicts the above, call the relevant transpiler\n    if (\n      classification.moduleType === 'cjs' &&\n      (shouldOverwriteEmitWhenForcingCommonJS || emitSkipped)\n    ) {\n      [value, sourceMap] = getOutputForceCommonJS(code, normalizedFileName);\n    } else if (\n      classification.moduleType === 'esm' &&\n      (shouldOverwriteEmitWhenForcingEsm || emitSkipped)\n    ) {\n      [value, sourceMap] = getOutputForceESM(code, normalizedFileName);\n    } else if (emitSkipped) {\n      // Happens when ts compiler skips emit or in transpileOnly mode\n      const classification = classifyModule(fileName, isNodeModuleType);\n      [value, sourceMap] =\n        classification === 'nodecjs'\n          ? getOutputForceNodeCommonJS(code, normalizedFileName)\n          : classification === 'nodeesm'\n          ? getOutputForceNodeESM(code, normalizedFileName)\n          : classification === 'cjs'\n          ? getOutputForceCommonJS(code, normalizedFileName)\n          : classification === 'esm'\n          ? getOutputForceESM(code, normalizedFileName)\n          : getOutputTranspileOnly(code, normalizedFileName);\n    }\n    const output = updateOutput(\n      value!,\n      normalizedFileName,\n      sourceMap!,\n      getEmitExtension\n    );\n    outputCache.set(normalizedFileName, { content: output });\n    return output;\n  }\n\n  let active = true;\n  const enabled = (enabled?: boolean) =>\n    enabled === undefined ? active : (active = !!enabled);\n  const ignored = (fileName: string) => {\n    if (!active) return true;\n    const ext = extname(fileName);\n    if (extensions.compiled.includes(ext)) {\n      return !isScoped(fileName) || shouldIgnore(fileName);\n    }\n    return true;\n  };\n\n  function addDiagnosticFilter(filter: DiagnosticFilter) {\n    diagnosticFilters.push({\n      ...filter,\n      filenamesAbsolute: filter.filenamesAbsolute.map((f) =>\n        normalizeSlashes(f)\n      ),\n    });\n  }\n\n  const getNodeEsmResolver = once(() =>\n    (\n      require('../dist-raw/node-internal-modules-esm-resolve') as typeof _nodeInternalModulesEsmResolve\n    ).createResolve({\n      extensions,\n      preferTsExts: options.preferTsExts,\n      tsNodeExperimentalSpecifierResolution:\n        options.experimentalSpecifierResolution,\n    })\n  );\n  const getNodeEsmGetFormat = once(() =>\n    (\n      require('../dist-raw/node-internal-modules-esm-get_format') as typeof _nodeInternalModulesEsmGetFormat\n    ).createGetFormat(\n      options.experimentalSpecifierResolution,\n      getNodeEsmResolver()\n    )\n  );\n  const getNodeCjsLoader = once(() =>\n    (\n      require('../dist-raw/node-internal-modules-cjs-loader') as typeof _nodeInternalModulesCjsLoader\n    ).createCjsLoader({\n      extensions,\n      preferTsExts: options.preferTsExts,\n      nodeEsmResolver: getNodeEsmResolver(),\n    })\n  );\n\n  return {\n    [TS_NODE_SERVICE_BRAND]: true,\n    ts,\n    compilerPath: compiler,\n    config,\n    compile,\n    getTypeInfo,\n    ignored,\n    enabled,\n    options,\n    configFilePath,\n    moduleTypeClassifier,\n    shouldReplAwait,\n    addDiagnosticFilter,\n    installSourceMapSupport,\n    enableExperimentalEsmLoaderInterop,\n    transpileOnly,\n    projectLocalResolveHelper,\n    getNodeEsmResolver,\n    getNodeEsmGetFormat,\n    getNodeCjsLoader,\n    extensions,\n  };\n}\n\n/**\n * Check if the filename should be ignored.\n */\nfunction createIgnore(ignoreBaseDir: string, ignore: RegExp[]) {\n  return (fileName: string) => {\n    const relname = relative(ignoreBaseDir, fileName);\n    const path = normalizeSlashes(relname);\n\n    return ignore.some((x) => x.test(path));\n  };\n}\n\n/**\n * Register the extensions to support when importing files.\n */\nfunction registerExtensions(\n  preferTsExts: boolean | null | undefined,\n  extensions: string[],\n  service: Service,\n  originalJsHandler: (m: NodeModule, filename: string) => any\n) {\n  const exts = new Set(extensions);\n  // Can't add these extensions cuz would allow omitting file extension; node requires ext for .cjs and .mjs\n  // Unless they're already registered by something else (nyc does this):\n  // then we *must* hook them or else our transformer will not be called.\n  for (const cannotAdd of ['.mts', '.cts', '.mjs', '.cjs']) {\n    if (exts.has(cannotAdd) && !hasOwnProperty(require.extensions, cannotAdd)) {\n      // Unrecognized file exts can be transformed via the `.js` handler.\n      exts.add('.js');\n      exts.delete(cannotAdd);\n    }\n  }\n\n  // Register new extensions.\n  for (const ext of exts) {\n    registerExtension(ext, service, originalJsHandler);\n  }\n\n  if (preferTsExts) {\n    const preferredExtensions = new Set([\n      ...exts,\n      ...Object.keys(require.extensions),\n    ]);\n\n    // Re-sort iteration order of Object.keys()\n    for (const ext of preferredExtensions) {\n      const old = Object.getOwnPropertyDescriptor(require.extensions, ext);\n      delete require.extensions[ext];\n      Object.defineProperty(require.extensions, ext, old!);\n    }\n  }\n}\n\n/**\n * Register the extension for node.\n */\nfunction registerExtension(\n  ext: string,\n  service: Service,\n  originalHandler: (m: NodeModule, filename: string) => any\n) {\n  const old = require.extensions[ext] || originalHandler;\n\n  require.extensions[ext] = function (m: any, filename) {\n    if (service.ignored(filename)) return old(m, filename);\n\n    assertScriptCanLoadAsCJS(service, m, filename);\n\n    const _compile = m._compile;\n\n    m._compile = function (code: string, fileName: string) {\n      debug('module._compile', fileName);\n\n      const result = service.compile(code, fileName);\n      return _compile.call(this, result, fileName);\n    };\n\n    return old(m, filename);\n  };\n}\n\n/**\n * Internal source output.\n */\ntype SourceOutput = [string, string, false] | [undefined, undefined, true];\n\n/**\n * Update the output remapping the source map.\n */\nfunction updateOutput(\n  outputText: string,\n  fileName: string,\n  sourceMap: string,\n  getEmitExtension: (fileName: string) => string\n) {\n  const base64Map = Buffer.from(\n    updateSourceMap(sourceMap, fileName),\n    'utf8'\n  ).toString('base64');\n  const sourceMapContent = `//# sourceMappingURL=data:application/json;charset=utf-8;base64,${base64Map}`;\n  // Expected form: `//# sourceMappingURL=foo bar.js.map` or `//# sourceMappingURL=foo%20bar.js.map` for input file \"foo bar.tsx\"\n  // Percent-encoding behavior added in TS 4.1.1: https://github.com/microsoft/TypeScript/issues/40951\n  const prefix = '//# sourceMappingURL=';\n  const prefixLength = prefix.length;\n  const baseName = /*foo.tsx*/ basename(fileName);\n  const extName = /*.tsx*/ extname(fileName);\n  const extension = /*.js*/ getEmitExtension(fileName);\n  const sourcemapFilename =\n    baseName.slice(0, -extName.length) + extension + '.map';\n  const sourceMapLengthWithoutPercentEncoding =\n    prefixLength + sourcemapFilename.length;\n  /*\n   * Only rewrite if existing directive exists at the location we expect, to support:\n   *   a) compilers that do not append a sourcemap directive\n   *   b) situations where we did the math wrong\n   *     Not ideal, but appending our sourcemap *after* a pre-existing sourcemap still overrides, so the end-user is happy.\n   */\n  if (\n    outputText.substr(-sourceMapLengthWithoutPercentEncoding, prefixLength) ===\n    prefix\n  ) {\n    return (\n      outputText.slice(0, -sourceMapLengthWithoutPercentEncoding) +\n      sourceMapContent\n    );\n  }\n  // If anyone asks why we're not using URL, the URL equivalent is: `u = new URL('http://d'); u.pathname = \"/\" + sourcemapFilename; return u.pathname.slice(1);\n  const sourceMapLengthWithPercentEncoding =\n    prefixLength + encodeURI(sourcemapFilename).length;\n  if (\n    outputText.substr(-sourceMapLengthWithPercentEncoding, prefixLength) ===\n    prefix\n  ) {\n    return (\n      outputText.slice(0, -sourceMapLengthWithPercentEncoding) +\n      sourceMapContent\n    );\n  }\n\n  return `${outputText}\\n${sourceMapContent}`;\n}\n\n/**\n * Update the source map contents for improved output.\n */\nfunction updateSourceMap(sourceMapText: string, fileName: string) {\n  const sourceMap = JSON.parse(sourceMapText);\n  sourceMap.file = fileName;\n  sourceMap.sources = [fileName];\n  delete sourceMap.sourceRoot;\n  return JSON.stringify(sourceMap);\n}\n\n/**\n * Filter diagnostics.\n */\nfunction filterDiagnostics(\n  diagnostics: readonly _ts.Diagnostic[],\n  filters: DiagnosticFilter[]\n) {\n  return diagnostics.filter((d) =>\n    filters.every(\n      (f) =>\n        (!f.appliesToAllFiles &&\n          f.filenamesAbsolute.indexOf(d.file?.fileName!) === -1) ||\n        f.diagnosticsIgnored.indexOf(d.code) === -1\n    )\n  );\n}\n\n/**\n * Get token at file position.\n *\n * Reference: https://github.com/microsoft/TypeScript/blob/fcd9334f57d85b73dd66ad2d21c02e84822f4841/src/services/utilities.ts#L705-L731\n */\nfunction getTokenAtPosition(\n  ts: TSCommon,\n  sourceFile: _ts.SourceFile,\n  position: number\n): _ts.Node {\n  let current: _ts.Node = sourceFile;\n\n  outer: while (true) {\n    for (const child of current.getChildren(sourceFile)) {\n      const start = child.getFullStart();\n      if (start > position) break;\n\n      const end = child.getEnd();\n      if (position <= end) {\n        current = child;\n        continue outer;\n      }\n    }\n\n    return current;\n  }\n}\n\n/**\n * Create an implementation of node's ESM loader hooks.\n *\n * This may be useful if you\n * want to wrap or compose the loader hooks to add additional functionality or\n * combine with another loader.\n *\n * Node changed the hooks API, so there are two possible APIs.  This function\n * detects your node version and returns the appropriate API.\n *\n * @category ESM Loader\n */\nexport const createEsmHooks: typeof createEsmHooksFn = (\n  tsNodeService: Service\n) => (require('./esm') as typeof import('./esm')).createEsmHooks(tsNodeService);\n\n/**\n * When using `module: nodenext` or `module: node12`, there are two possible styles of emit depending in file extension or package.json \"type\":\n *\n * - CommonJS with dynamic imports preserved (not transformed into `require()` calls)\n * - ECMAScript modules with `import foo = require()` transformed into `require = createRequire(); const foo = require()`\n */\nexport type NodeModuleEmitKind = 'nodeesm' | 'nodecjs';\n"]},"metadata":{},"sourceType":"script"}