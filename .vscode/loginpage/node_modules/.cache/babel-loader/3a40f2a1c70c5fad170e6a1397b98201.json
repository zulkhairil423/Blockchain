{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createTsTranspileModule = void 0;\n/** @internal */\n\nfunction createTsTranspileModule(ts, transpileOptions) {\n  const {\n    createProgram,\n    createSourceFile,\n    getDefaultCompilerOptions,\n    getImpliedNodeFormatForFile,\n    fixupCompilerOptions,\n    transpileOptionValueCompilerOptions,\n    getNewLineCharacter,\n    fileExtensionIs,\n    normalizePath,\n    Debug,\n    toPath,\n    getSetExternalModuleIndicator,\n    getEntries,\n    addRange,\n    hasProperty,\n    getEmitScriptTarget,\n    getDirectoryPath\n  } = ts;\n  const compilerOptionsDiagnostics = [];\n  const options = transpileOptions.compilerOptions ? fixupCompilerOptions(transpileOptions.compilerOptions, compilerOptionsDiagnostics) : {}; // mix in default options\n\n  const defaultOptions = getDefaultCompilerOptions();\n\n  for (const key in defaultOptions) {\n    if (hasProperty(defaultOptions, key) && options[key] === undefined) {\n      options[key] = defaultOptions[key];\n    }\n  }\n\n  for (const option of transpileOptionValueCompilerOptions) {\n    options[option.name] = option.transpileOptionValue;\n  } // transpileModule does not write anything to disk so there is no need to verify that there are no conflicts between input and output paths.\n\n\n  options.suppressOutputPathCheck = true; // Filename can be non-ts file.\n\n  options.allowNonTsExtensions = true;\n  const newLine = getNewLineCharacter(options); // Create a compilerHost object to allow the compiler to read and write files\n\n  const compilerHost = {\n    getSourceFile: fileName => fileName === normalizePath(inputFileName) ? sourceFile : undefined,\n    writeFile: (name, text) => {\n      if (fileExtensionIs(name, '.map')) {\n        Debug.assertEqual(sourceMapText, undefined, 'Unexpected multiple source map outputs, file:', name);\n        sourceMapText = text;\n      } else {\n        Debug.assertEqual(outputText, undefined, 'Unexpected multiple outputs, file:', name);\n        outputText = text;\n      }\n    },\n    getDefaultLibFileName: () => 'lib.d.ts',\n    useCaseSensitiveFileNames: () => true,\n    getCanonicalFileName: fileName => fileName,\n    getCurrentDirectory: () => '',\n    getNewLine: () => newLine,\n    fileExists: fileName => fileName === inputFileName || fileName === packageJsonFileName,\n    readFile: fileName => fileName === packageJsonFileName ? `{\"type\": \"${_packageJsonType}\"}` : '',\n    directoryExists: () => true,\n    getDirectories: () => []\n  };\n  let inputFileName;\n  let packageJsonFileName;\n\n  let _packageJsonType;\n\n  let sourceFile;\n  let outputText;\n  let sourceMapText;\n  return transpileModule;\n\n  function transpileModule(input, transpileOptions2) {\n    let packageJsonType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'commonjs';\n    // if jsx is specified then treat file as .tsx\n    inputFileName = transpileOptions2.fileName || (transpileOptions.compilerOptions && transpileOptions.compilerOptions.jsx ? 'module.tsx' : 'module.ts');\n    packageJsonFileName = getDirectoryPath(inputFileName) + '/package.json';\n    _packageJsonType = packageJsonType;\n    sourceFile = createSourceFile(inputFileName, input, {\n      languageVersion: getEmitScriptTarget(options),\n      impliedNodeFormat: getImpliedNodeFormatForFile(toPath(inputFileName, '', compilerHost.getCanonicalFileName),\n      /*cache*/\n      undefined, compilerHost, options),\n      setExternalModuleIndicator: getSetExternalModuleIndicator(options)\n    });\n\n    if (transpileOptions2.moduleName) {\n      sourceFile.moduleName = transpileOptions2.moduleName;\n    }\n\n    if (transpileOptions2.renamedDependencies) {\n      sourceFile.renamedDependencies = new Map(getEntries(transpileOptions2.renamedDependencies));\n    } // Output\n\n\n    outputText = undefined;\n    sourceMapText = undefined;\n    const program = createProgram([inputFileName], options, compilerHost);\n    const diagnostics = compilerOptionsDiagnostics.slice();\n\n    if (transpileOptions.reportDiagnostics) {\n      addRange(\n      /*to*/\n      diagnostics,\n      /*from*/\n      program.getSyntacticDiagnostics(sourceFile));\n      addRange(\n      /*to*/\n      diagnostics,\n      /*from*/\n      program.getOptionsDiagnostics());\n    } // Emit\n\n\n    program.emit(\n    /*targetSourceFile*/\n    undefined,\n    /*writeFile*/\n    undefined,\n    /*cancellationToken*/\n    undefined,\n    /*emitOnlyDtsFiles*/\n    undefined, transpileOptions.transformers);\n    if (outputText === undefined) return Debug.fail('Output generation failed');\n    return {\n      outputText,\n      diagnostics,\n      sourceMapText\n    };\n  }\n}\n\nexports.createTsTranspileModule = createTsTranspileModule;","map":{"version":3,"mappings":"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","names":["createTsTranspileModule","ts","transpileOptions","createProgram","createSourceFile","getDefaultCompilerOptions","getImpliedNodeFormatForFile","fixupCompilerOptions","transpileOptionValueCompilerOptions","getNewLineCharacter","fileExtensionIs","normalizePath","Debug","toPath","getSetExternalModuleIndicator","getEntries","addRange","hasProperty","getEmitScriptTarget","getDirectoryPath","compilerOptionsDiagnostics","options","compilerOptions","defaultOptions","key","undefined","option","name","transpileOptionValue","suppressOutputPathCheck","allowNonTsExtensions","newLine","compilerHost","getSourceFile","fileName","inputFileName","sourceFile","writeFile","text","assertEqual","sourceMapText","outputText","getDefaultLibFileName","useCaseSensitiveFileNames","getCanonicalFileName","getCurrentDirectory","getNewLine","fileExists","packageJsonFileName","readFile","_packageJsonType","directoryExists","getDirectories","transpileModule","input","transpileOptions2","packageJsonType","jsx","languageVersion","impliedNodeFormat","setExternalModuleIndicator","moduleName","renamedDependencies","Map","program","diagnostics","slice","reportDiagnostics","getSyntacticDiagnostics","getOptionsDiagnostics","emit","transformers","fail","exports"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\ts-node\\src\\ts-transpile-module.ts"],"sourcesContent":["import type {\n  CompilerHost,\n  CompilerOptions,\n  Diagnostic,\n  SourceFile,\n  TranspileOptions,\n  TranspileOutput,\n} from 'typescript';\nimport type { TSCommon } from './ts-compiler-types';\n\n/** @internal */\nexport function createTsTranspileModule(\n  ts: TSCommon,\n  transpileOptions: Pick<\n    TranspileOptions,\n    'compilerOptions' | 'reportDiagnostics' | 'transformers'\n  >\n) {\n  const {\n    createProgram,\n    createSourceFile,\n    getDefaultCompilerOptions,\n    getImpliedNodeFormatForFile,\n    fixupCompilerOptions,\n    transpileOptionValueCompilerOptions,\n    getNewLineCharacter,\n    fileExtensionIs,\n    normalizePath,\n    Debug,\n    toPath,\n    getSetExternalModuleIndicator,\n    getEntries,\n    addRange,\n    hasProperty,\n    getEmitScriptTarget,\n    getDirectoryPath,\n  } = ts as any;\n\n  const compilerOptionsDiagnostics: Diagnostic[] = [];\n\n  const options: CompilerOptions = transpileOptions.compilerOptions\n    ? fixupCompilerOptions(\n        transpileOptions.compilerOptions,\n        compilerOptionsDiagnostics\n      )\n    : {};\n\n  // mix in default options\n  const defaultOptions = getDefaultCompilerOptions();\n  for (const key in defaultOptions) {\n    if (hasProperty(defaultOptions, key) && options[key] === undefined) {\n      options[key] = defaultOptions[key];\n    }\n  }\n\n  for (const option of transpileOptionValueCompilerOptions) {\n    options[option.name] = option.transpileOptionValue;\n  }\n\n  // transpileModule does not write anything to disk so there is no need to verify that there are no conflicts between input and output paths.\n  options.suppressOutputPathCheck = true;\n\n  // Filename can be non-ts file.\n  options.allowNonTsExtensions = true;\n\n  const newLine = getNewLineCharacter(options);\n  // Create a compilerHost object to allow the compiler to read and write files\n  const compilerHost: CompilerHost = {\n    getSourceFile: (fileName) =>\n      fileName === normalizePath(inputFileName) ? sourceFile : undefined,\n    writeFile: (name, text) => {\n      if (fileExtensionIs(name, '.map')) {\n        Debug.assertEqual(\n          sourceMapText,\n          undefined,\n          'Unexpected multiple source map outputs, file:',\n          name\n        );\n        sourceMapText = text;\n      } else {\n        Debug.assertEqual(\n          outputText,\n          undefined,\n          'Unexpected multiple outputs, file:',\n          name\n        );\n        outputText = text;\n      }\n    },\n    getDefaultLibFileName: () => 'lib.d.ts',\n    useCaseSensitiveFileNames: () => true,\n    getCanonicalFileName: (fileName) => fileName,\n    getCurrentDirectory: () => '',\n    getNewLine: () => newLine,\n    fileExists: (fileName): boolean =>\n      fileName === inputFileName || fileName === packageJsonFileName,\n    readFile: (fileName) =>\n      fileName === packageJsonFileName ? `{\"type\": \"${_packageJsonType}\"}` : '',\n    directoryExists: () => true,\n    getDirectories: () => [],\n  };\n\n  let inputFileName: string;\n  let packageJsonFileName: string;\n  let _packageJsonType: 'module' | 'commonjs';\n  let sourceFile: SourceFile;\n  let outputText: string | undefined;\n  let sourceMapText: string | undefined;\n\n  return transpileModule;\n\n  function transpileModule(\n    input: string,\n    transpileOptions2: Pick<\n      TranspileOptions,\n      'fileName' | 'moduleName' | 'renamedDependencies'\n    >,\n    packageJsonType: 'module' | 'commonjs' = 'commonjs'\n  ): TranspileOutput {\n    // if jsx is specified then treat file as .tsx\n    inputFileName =\n      transpileOptions2.fileName ||\n      (transpileOptions.compilerOptions && transpileOptions.compilerOptions.jsx\n        ? 'module.tsx'\n        : 'module.ts');\n    packageJsonFileName = getDirectoryPath(inputFileName) + '/package.json';\n    _packageJsonType = packageJsonType;\n\n    sourceFile = createSourceFile(inputFileName, input, {\n      languageVersion: getEmitScriptTarget(options),\n      impliedNodeFormat: getImpliedNodeFormatForFile(\n        toPath(inputFileName, '', compilerHost.getCanonicalFileName),\n        /*cache*/ undefined,\n        compilerHost,\n        options\n      ),\n      setExternalModuleIndicator: getSetExternalModuleIndicator(options),\n    });\n    if (transpileOptions2.moduleName) {\n      sourceFile.moduleName = transpileOptions2.moduleName;\n    }\n\n    if (transpileOptions2.renamedDependencies) {\n      (sourceFile as any).renamedDependencies = new Map(\n        getEntries(transpileOptions2.renamedDependencies)\n      );\n    }\n\n    // Output\n    outputText = undefined;\n    sourceMapText = undefined;\n\n    const program = createProgram([inputFileName], options, compilerHost);\n\n    const diagnostics = compilerOptionsDiagnostics.slice();\n\n    if (transpileOptions.reportDiagnostics) {\n      addRange(\n        /*to*/ diagnostics,\n        /*from*/ program.getSyntacticDiagnostics(sourceFile)\n      );\n      addRange(/*to*/ diagnostics, /*from*/ program.getOptionsDiagnostics());\n    }\n    // Emit\n    program.emit(\n      /*targetSourceFile*/ undefined,\n      /*writeFile*/ undefined,\n      /*cancellationToken*/ undefined,\n      /*emitOnlyDtsFiles*/ undefined,\n      transpileOptions.transformers\n    );\n\n    if (outputText === undefined) return Debug.fail('Output generation failed');\n\n    return { outputText, diagnostics, sourceMapText };\n  }\n}\n"]},"metadata":{},"sourceType":"script"}