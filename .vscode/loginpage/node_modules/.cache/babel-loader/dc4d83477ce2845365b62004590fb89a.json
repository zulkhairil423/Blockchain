{"ast":null,"code":"'use strict';\n\nconst {\n  finished\n} = require('stream');\n\nconst {\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError\n} = require('../core/errors');\n\nconst util = require('../core/util');\n\nconst {\n  AsyncResource\n} = require('async_hooks');\n\nconst {\n  addSignal,\n  removeSignal\n} = require('./abort-signal');\n\nclass StreamHandler extends AsyncResource {\n  constructor(opts, factory, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts');\n    }\n\n    const {\n      signal,\n      method,\n      opaque,\n      body,\n      onInfo,\n      responseHeaders\n    } = opts;\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback');\n      }\n\n      if (typeof factory !== 'function') {\n        throw new InvalidArgumentError('invalid factory');\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method');\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback');\n      }\n\n      super('UNDICI_STREAM');\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err);\n      }\n\n      throw err;\n    }\n\n    this.responseHeaders = responseHeaders || null;\n    this.opaque = opaque || null;\n    this.factory = factory;\n    this.callback = callback;\n    this.res = null;\n    this.abort = null;\n    this.context = null;\n    this.trailers = null;\n    this.body = body;\n    this.onInfo = onInfo || null;\n\n    if (util.isStream(body)) {\n      body.on('error', err => {\n        this.onError(err);\n      });\n    }\n\n    addSignal(this, signal);\n  }\n\n  onConnect(abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError();\n    }\n\n    this.abort = abort;\n    this.context = context;\n  }\n\n  onHeaders(statusCode, rawHeaders, resume) {\n    const {\n      factory,\n      opaque,\n      context\n    } = this;\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n        this.onInfo({\n          statusCode,\n          headers\n        });\n      }\n\n      return;\n    }\n\n    this.factory = null;\n    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n    const res = this.runInAsyncScope(factory, null, {\n      statusCode,\n      headers,\n      opaque,\n      context\n    });\n\n    if (!res || typeof res.write !== 'function' || typeof res.end !== 'function' || typeof res.on !== 'function') {\n      throw new InvalidReturnValueError('expected Writable');\n    }\n\n    res.on('drain', resume); // TODO: Avoid finished. It registers an unecessary amount of listeners.\n\n    finished(res, {\n      readable: false\n    }, err => {\n      const {\n        callback,\n        res,\n        opaque,\n        trailers,\n        abort\n      } = this;\n      this.res = null;\n\n      if (err || !res.readable) {\n        util.destroy(res, err);\n      }\n\n      this.callback = null;\n      this.runInAsyncScope(callback, null, err || null, {\n        opaque,\n        trailers\n      });\n\n      if (err) {\n        abort();\n      }\n    });\n    this.res = res;\n    const needDrain = res.writableNeedDrain !== undefined ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;\n    return needDrain !== true;\n  }\n\n  onData(chunk) {\n    const {\n      res\n    } = this;\n    return res.write(chunk);\n  }\n\n  onComplete(trailers) {\n    const {\n      res\n    } = this;\n    removeSignal(this);\n    this.trailers = util.parseHeaders(trailers);\n    res.end();\n  }\n\n  onError(err) {\n    const {\n      res,\n      callback,\n      opaque,\n      body\n    } = this;\n    removeSignal(this);\n    this.factory = null;\n\n    if (res) {\n      this.res = null;\n      util.destroy(res, err);\n    } else if (callback) {\n      this.callback = null;\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, {\n          opaque\n        });\n      });\n    }\n\n    if (body) {\n      this.body = null;\n      util.destroy(body, err);\n    }\n  }\n\n}\n\nfunction stream(opts, factory, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      stream.call(this, opts, factory, (err, data) => {\n        return err ? reject(err) : resolve(data);\n      });\n    });\n  }\n\n  try {\n    this.dispatch(opts, new StreamHandler(opts, factory, callback));\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err;\n    }\n\n    const opaque = opts && opts.opaque;\n    queueMicrotask(() => callback(err, {\n      opaque\n    }));\n  }\n}\n\nmodule.exports = stream;","map":{"version":3,"names":["finished","require","InvalidArgumentError","InvalidReturnValueError","RequestAbortedError","util","AsyncResource","addSignal","removeSignal","StreamHandler","constructor","opts","factory","callback","signal","method","opaque","body","onInfo","responseHeaders","on","addEventListener","err","isStream","destroy","nop","res","abort","context","trailers","onError","onConnect","onHeaders","statusCode","rawHeaders","resume","headers","parseRawHeaders","parseHeaders","runInAsyncScope","write","end","readable","needDrain","writableNeedDrain","undefined","_writableState","onData","chunk","onComplete","queueMicrotask","stream","Promise","resolve","reject","call","data","dispatch","module","exports"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/undici/lib/api/api-stream.js"],"sourcesContent":["'use strict'\n\nconst { finished } = require('stream')\nconst {\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError\n} = require('../core/errors')\nconst util = require('../core/util')\nconst { AsyncResource } = require('async_hooks')\nconst { addSignal, removeSignal } = require('./abort-signal')\n\nclass StreamHandler extends AsyncResource {\n  constructor (opts, factory, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo, responseHeaders } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (typeof factory !== 'function') {\n        throw new InvalidArgumentError('invalid factory')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_STREAM')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err)\n      }\n      throw err\n    }\n\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.factory = factory\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.context = null\n    this.trailers = null\n    this.body = body\n    this.onInfo = onInfo || null\n\n    if (util.isStream(body)) {\n      body.on('error', (err) => {\n        this.onError(err)\n      })\n    }\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError()\n    }\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume) {\n    const { factory, opaque, context } = this\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    this.factory = null\n    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n    const res = this.runInAsyncScope(factory, null, {\n      statusCode,\n      headers,\n      opaque,\n      context\n    })\n\n    if (\n      !res ||\n      typeof res.write !== 'function' ||\n      typeof res.end !== 'function' ||\n      typeof res.on !== 'function'\n    ) {\n      throw new InvalidReturnValueError('expected Writable')\n    }\n\n    res.on('drain', resume)\n    // TODO: Avoid finished. It registers an unecessary amount of listeners.\n    finished(res, { readable: false }, (err) => {\n      const { callback, res, opaque, trailers, abort } = this\n\n      this.res = null\n      if (err || !res.readable) {\n        util.destroy(res, err)\n      }\n\n      this.callback = null\n      this.runInAsyncScope(callback, null, err || null, { opaque, trailers })\n\n      if (err) {\n        abort()\n      }\n    })\n\n    this.res = res\n\n    const needDrain = res.writableNeedDrain !== undefined\n      ? res.writableNeedDrain\n      : res._writableState && res._writableState.needDrain\n\n    return needDrain !== true\n  }\n\n  onData (chunk) {\n    const { res } = this\n\n    return res.write(chunk)\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n\n    removeSignal(this)\n\n    this.trailers = util.parseHeaders(trailers)\n\n    res.end()\n  }\n\n  onError (err) {\n    const { res, callback, opaque, body } = this\n\n    removeSignal(this)\n\n    this.factory = null\n\n    if (res) {\n      this.res = null\n      util.destroy(res, err)\n    } else if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (body) {\n      this.body = null\n      util.destroy(body, err)\n    }\n  }\n}\n\nfunction stream (opts, factory, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      stream.call(this, opts, factory, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    this.dispatch(opts, new StreamHandler(opts, factory, callback))\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts && opts.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = stream\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}