{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.runScriptWithHardhat = exports.runScript = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst execution_mode_1 = require(\"../core/execution-mode\");\n\nconst env_variables_1 = require(\"../core/params/env-variables\");\n\nconst log = (0, debug_1.default)(\"hardhat:core:scripts-runner\");\n\nasync function runScript(scriptPath) {\n  let scriptArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let extraNodeArgs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let extraEnvVars = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const {\n    fork\n  } = await Promise.resolve().then(() => __importStar(require(\"child_process\")));\n  return new Promise((resolve, reject) => {\n    const processExecArgv = withFixedInspectArg(process.execArgv);\n    const nodeArgs = [...processExecArgv, ...getTsNodeArgsIfNeeded(scriptPath, extraEnvVars.HARDHAT_TYPECHECK === \"true\"), ...extraNodeArgs];\n    const envVars = { ...process.env,\n      ...extraEnvVars\n    };\n    const childProcess = fork(scriptPath, scriptArgs, {\n      stdio: \"inherit\",\n      execArgv: nodeArgs,\n      env: envVars\n    });\n    childProcess.once(\"close\", status => {\n      log(`Script ${scriptPath} exited with status code ${status ?? \"null\"}`);\n      resolve(status);\n    });\n    childProcess.once(\"error\", reject);\n  });\n}\n\nexports.runScript = runScript;\n\nasync function runScriptWithHardhat(hardhatArguments, scriptPath) {\n  let scriptArgs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let extraNodeArgs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  let extraEnvVars = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  log(`Creating Hardhat subprocess to run ${scriptPath}`);\n  return runScript(scriptPath, scriptArgs, [...extraNodeArgs, \"--require\", path_1.default.join(__dirname, \"..\", \"..\", \"register\")], { ...(0, env_variables_1.getEnvVariablesMap)(hardhatArguments),\n    ...extraEnvVars\n  });\n}\n\nexports.runScriptWithHardhat = runScriptWithHardhat;\n/**\n * Fix debugger \"inspect\" arg from process.argv, if present.\n *\n * When running this process with a debugger, a debugger port\n * is specified via the \"--inspect-brk=\" arg param in some IDEs/setups.\n *\n * This normally works, but if we do a fork afterwards, we'll get an error stating\n * that the port is already in use (since the fork would also use the same args,\n * therefore the same port number). To prevent this issue, we could replace the port number with\n * a different free one, or simply use the port-agnostic --inspect\" flag, and leave the debugger\n * port selection to the Node process itself, which will pick an empty AND valid one.\n *\n * This way, we can properly use the debugger for this process AND for the executed\n * script itself - even if it's compiled using ts-node.\n */\n\nfunction withFixedInspectArg(argv) {\n  const fixIfInspectArg = arg => {\n    if (arg.toLowerCase().includes(\"--inspect-brk=\")) {\n      return \"--inspect\";\n    }\n\n    return arg;\n  };\n\n  return argv.map(fixIfInspectArg);\n}\n\nfunction getTsNodeArgsIfNeeded(scriptPath, shouldTypecheck) {\n  if (process.execArgv.includes(\"ts-node/register\")) {\n    return [];\n  } // if we are running the tests we only want to transpile, or these tests\n  // take forever\n\n\n  if ((0, execution_mode_1.isRunningHardhatCoreTests)()) {\n    return [\"--require\", \"ts-node/register/transpile-only\"];\n  } // If the script we are going to run is .ts we need ts-node\n\n\n  if (/\\.tsx?$/i.test(scriptPath)) {\n    return [\"--require\", `ts-node/register${shouldTypecheck ? \"\" : \"/transpile-only\"}`];\n  }\n\n  return [];\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AAGA;;AACA;;AAEA,MAAMA,GAAG,GAAG,qBAAM,6BAAN,CAAZ;;AAEO,eAAeC,SAAf,CACLC,UADK,EAIwC;EAAA,IAF7CC,UAE6C,uEAFtB,EAEsB;EAAA,IAD7CC,aAC6C,uEADnB,EACmB;EAAA,IAA7CC,YAA6C,uEAAF,EAAE;EAE7C,MAAM;IAAEC;EAAF,IAAW,wDAAa,eAAb,GAAjB;EAEA,OAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAoB;IACrC,MAAMC,eAAe,GAAGC,mBAAmB,CAACC,OAAO,CAACC,QAAT,CAA3C;IAEA,MAAMC,QAAQ,GAAG,CACf,GAAGJ,eADY,EAEf,GAAGK,qBAAqB,CACtBb,UADsB,EAEtBG,YAAY,CAACW,iBAAb,KAAmC,MAFb,CAFT,EAMf,GAAGZ,aANY,CAAjB;IASA,MAAMa,OAAO,GAAG,EAAE,GAAGL,OAAO,CAACM,GAAb;MAAkB,GAAGb;IAArB,CAAhB;IAEA,MAAMc,YAAY,GAAGb,IAAI,CAACJ,UAAD,EAAaC,UAAb,EAAyB;MAChDiB,KAAK,EAAE,SADyC;MAEhDP,QAAQ,EAAEC,QAFsC;MAGhDI,GAAG,EAAED;IAH2C,CAAzB,CAAzB;IAMAE,YAAY,CAACE,IAAb,CAAkB,OAAlB,EAA4BC,MAAD,IAAW;MACpCtB,GAAG,CAAC,UAAUE,UAAU,4BAA4BoB,MAAM,IAAI,MAAM,EAAjE,CAAH;MAEAd,OAAO,CAACc,MAAD,CAAP;IACD,CAJD;IAKAH,YAAY,CAACE,IAAb,CAAkB,OAAlB,EAA2BZ,MAA3B;EACD,CA1BM,CAAP;AA2BD;;AAnCDc;;AAqCO,eAAeC,oBAAf,CACLC,gBADK,EAELvB,UAFK,EAKwC;EAAA,IAF7CC,UAE6C,uEAFtB,EAEsB;EAAA,IAD7CC,aAC6C,uEADnB,EACmB;EAAA,IAA7CC,YAA6C,uEAAF,EAAE;EAE7CL,GAAG,CAAC,sCAAsCE,UAAU,EAAjD,CAAH;EAEA,OAAOD,SAAS,CACdC,UADc,EAEdC,UAFc,EAGd,CACE,GAAGC,aADL,EAEE,WAFF,EAGEsB,eAAKC,IAAL,CAAUC,SAAV,EAAqB,IAArB,EAA2B,IAA3B,EAAiC,UAAjC,CAHF,CAHc,EAQd,EACE,GAAG,wCAAmBH,gBAAnB,CADL;IAEE,GAAGpB;EAFL,CARc,CAAhB;AAaD;;AAtBDkB;AAwBA;;;;;;;;;;;;;;;;AAeA,SAASZ,mBAAT,CAA6BkB,IAA7B,EAA2C;EACzC,MAAMC,eAAe,GAAIC,GAAD,IAAgB;IACtC,IAAIA,GAAG,CAACC,WAAJ,GAAkBC,QAAlB,CAA2B,gBAA3B,CAAJ,EAAkD;MAChD,OAAO,WAAP;IACD;;IACD,OAAOF,GAAP;EACD,CALD;;EAMA,OAAOF,IAAI,CAACK,GAAL,CAASJ,eAAT,CAAP;AACD;;AAED,SAASf,qBAAT,CACEb,UADF,EAEEiC,eAFF,EAE0B;EAExB,IAAIvB,OAAO,CAACC,QAAR,CAAiBoB,QAAjB,CAA0B,kBAA1B,CAAJ,EAAmD;IACjD,OAAO,EAAP;EACD,CAJuB,CAMxB;EACA;;;EACA,IAAI,iDAAJ,EAAiC;IAC/B,OAAO,CAAC,WAAD,EAAc,iCAAd,CAAP;EACD,CAVuB,CAYxB;;;EACA,IAAI,WAAWG,IAAX,CAAgBlC,UAAhB,CAAJ,EAAiC;IAC/B,OAAO,CACL,WADK,EAEL,mBAAmBiC,eAAe,GAAG,EAAH,GAAQ,iBAAiB,EAFtD,CAAP;EAID;;EAED,OAAO,EAAP;AACD","names":["log","runScript","scriptPath","scriptArgs","extraNodeArgs","extraEnvVars","fork","Promise","resolve","reject","processExecArgv","withFixedInspectArg","process","execArgv","nodeArgs","getTsNodeArgsIfNeeded","HARDHAT_TYPECHECK","envVars","env","childProcess","stdio","once","status","exports","runScriptWithHardhat","hardhatArguments","path_1","join","__dirname","argv","fixIfInspectArg","arg","toLowerCase","includes","map","shouldTypecheck","test"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\hardhat\\src\\internal\\util\\scripts-runner.ts"],"sourcesContent":["import debug from \"debug\";\nimport path from \"path\";\n\nimport { HardhatArguments } from \"../../types\";\nimport { isRunningHardhatCoreTests } from \"../core/execution-mode\";\nimport { getEnvVariablesMap } from \"../core/params/env-variables\";\n\nconst log = debug(\"hardhat:core:scripts-runner\");\n\nexport async function runScript(\n  scriptPath: string,\n  scriptArgs: string[] = [],\n  extraNodeArgs: string[] = [],\n  extraEnvVars: { [name: string]: string } = {}\n): Promise<number> {\n  const { fork } = await import(\"child_process\");\n\n  return new Promise((resolve, reject) => {\n    const processExecArgv = withFixedInspectArg(process.execArgv);\n\n    const nodeArgs = [\n      ...processExecArgv,\n      ...getTsNodeArgsIfNeeded(\n        scriptPath,\n        extraEnvVars.HARDHAT_TYPECHECK === \"true\"\n      ),\n      ...extraNodeArgs,\n    ];\n\n    const envVars = { ...process.env, ...extraEnvVars };\n\n    const childProcess = fork(scriptPath, scriptArgs, {\n      stdio: \"inherit\",\n      execArgv: nodeArgs,\n      env: envVars,\n    });\n\n    childProcess.once(\"close\", (status) => {\n      log(`Script ${scriptPath} exited with status code ${status ?? \"null\"}`);\n\n      resolve(status as number);\n    });\n    childProcess.once(\"error\", reject);\n  });\n}\n\nexport async function runScriptWithHardhat(\n  hardhatArguments: HardhatArguments,\n  scriptPath: string,\n  scriptArgs: string[] = [],\n  extraNodeArgs: string[] = [],\n  extraEnvVars: { [name: string]: string } = {}\n): Promise<number> {\n  log(`Creating Hardhat subprocess to run ${scriptPath}`);\n\n  return runScript(\n    scriptPath,\n    scriptArgs,\n    [\n      ...extraNodeArgs,\n      \"--require\",\n      path.join(__dirname, \"..\", \"..\", \"register\"),\n    ],\n    {\n      ...getEnvVariablesMap(hardhatArguments),\n      ...extraEnvVars,\n    }\n  );\n}\n\n/**\n * Fix debugger \"inspect\" arg from process.argv, if present.\n *\n * When running this process with a debugger, a debugger port\n * is specified via the \"--inspect-brk=\" arg param in some IDEs/setups.\n *\n * This normally works, but if we do a fork afterwards, we'll get an error stating\n * that the port is already in use (since the fork would also use the same args,\n * therefore the same port number). To prevent this issue, we could replace the port number with\n * a different free one, or simply use the port-agnostic --inspect\" flag, and leave the debugger\n * port selection to the Node process itself, which will pick an empty AND valid one.\n *\n * This way, we can properly use the debugger for this process AND for the executed\n * script itself - even if it's compiled using ts-node.\n */\nfunction withFixedInspectArg(argv: string[]) {\n  const fixIfInspectArg = (arg: string) => {\n    if (arg.toLowerCase().includes(\"--inspect-brk=\")) {\n      return \"--inspect\";\n    }\n    return arg;\n  };\n  return argv.map(fixIfInspectArg);\n}\n\nfunction getTsNodeArgsIfNeeded(\n  scriptPath: string,\n  shouldTypecheck: boolean\n): string[] {\n  if (process.execArgv.includes(\"ts-node/register\")) {\n    return [];\n  }\n\n  // if we are running the tests we only want to transpile, or these tests\n  // take forever\n  if (isRunningHardhatCoreTests()) {\n    return [\"--require\", \"ts-node/register/transpile-only\"];\n  }\n\n  // If the script we are going to run is .ts we need ts-node\n  if (/\\.tsx?$/i.test(scriptPath)) {\n    return [\n      \"--require\",\n      `ts-node/register${shouldTypecheck ? \"\" : \"/transpile-only\"}`,\n    ];\n  }\n\n  return [];\n}\n"]},"metadata":{},"sourceType":"script"}