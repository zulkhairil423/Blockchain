{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createEsmHooks = exports.registerAndCreateEsmHooks = exports.filterHooksByAPIVersion = void 0;\n\nconst index_1 = require(\"./index\");\n\nconst url_1 = require(\"url\");\n\nconst path_1 = require(\"path\");\n\nconst assert = require(\"assert\");\n\nconst util_1 = require(\"./util\");\n\nconst module_1 = require(\"module\"); // The hooks API changed in node version X so we need to check for backwards compatibility.\n\n\nconst newHooksAPI = (0, util_1.versionGteLt)(process.versions.node, '16.12.0');\n/** @internal */\n\nfunction filterHooksByAPIVersion(hooks) {\n  const {\n    getFormat,\n    load,\n    resolve,\n    transformSource\n  } = hooks; // Explicit return type to avoid TS's non-ideal inferred type\n\n  const hooksAPI = newHooksAPI ? {\n    resolve,\n    load,\n    getFormat: undefined,\n    transformSource: undefined\n  } : {\n    resolve,\n    getFormat,\n    transformSource,\n    load: undefined\n  };\n  return hooksAPI;\n}\n\nexports.filterHooksByAPIVersion = filterHooksByAPIVersion;\n/** @internal */\n\nfunction registerAndCreateEsmHooks(opts) {\n  // Automatically performs registration just like `-r ts-node/register`\n  const tsNodeInstance = (0, index_1.register)(opts);\n  return createEsmHooks(tsNodeInstance);\n}\n\nexports.registerAndCreateEsmHooks = registerAndCreateEsmHooks;\n\nfunction createEsmHooks(tsNodeService) {\n  tsNodeService.enableExperimentalEsmLoaderInterop(); // Custom implementation that considers additional file extensions and automatically adds file extensions\n\n  const nodeResolveImplementation = tsNodeService.getNodeEsmResolver();\n  const nodeGetFormatImplementation = tsNodeService.getNodeEsmGetFormat();\n  const extensions = tsNodeService.extensions;\n  const hooksAPI = filterHooksByAPIVersion({\n    resolve,\n    load,\n    getFormat,\n    transformSource\n  });\n\n  function isFileUrlOrNodeStyleSpecifier(parsed) {\n    // We only understand file:// URLs, but in node, the specifier can be a node-style `./foo` or `foo`\n    const {\n      protocol\n    } = parsed;\n    return protocol === null || protocol === 'file:';\n  }\n  /**\n   * Named \"probably\" as a reminder that this is a guess.\n   * node does not explicitly tell us if we're resolving the entrypoint or not.\n   */\n\n\n  function isProbablyEntrypoint(specifier, parentURL) {\n    return parentURL === undefined && specifier.startsWith('file://');\n  } // Side-channel between `resolve()` and `load()` hooks\n\n\n  const rememberIsProbablyEntrypoint = new Set();\n  const rememberResolvedViaCommonjsFallback = new Set();\n\n  async function resolve(specifier, context, defaultResolve) {\n    const defer = async () => {\n      const r = await defaultResolve(specifier, context, defaultResolve);\n      return r;\n    }; // See: https://github.com/nodejs/node/discussions/41711\n    // nodejs will likely implement a similar fallback.  Till then, we can do our users a favor and fallback today.\n\n\n    async function entrypointFallback(cb) {\n      try {\n        const resolution = await cb();\n        if ((resolution === null || resolution === void 0 ? void 0 : resolution.url) && isProbablyEntrypoint(specifier, context.parentURL)) rememberIsProbablyEntrypoint.add(resolution.url);\n        return resolution;\n      } catch (esmResolverError) {\n        if (!isProbablyEntrypoint(specifier, context.parentURL)) throw esmResolverError;\n\n        try {\n          let cjsSpecifier = specifier; // Attempt to convert from ESM file:// to CommonJS path\n\n          try {\n            if (specifier.startsWith('file://')) cjsSpecifier = (0, url_1.fileURLToPath)(specifier);\n          } catch {}\n\n          const resolution = (0, url_1.pathToFileURL)((0, module_1.createRequire)(process.cwd()).resolve(cjsSpecifier)).toString();\n          rememberIsProbablyEntrypoint.add(resolution);\n          rememberResolvedViaCommonjsFallback.add(resolution);\n          return {\n            url: resolution,\n            format: 'commonjs'\n          };\n        } catch (commonjsResolverError) {\n          throw esmResolverError;\n        }\n      }\n    }\n\n    return addShortCircuitFlag(async () => {\n      const parsed = (0, url_1.parse)(specifier);\n      const {\n        pathname,\n        protocol,\n        hostname\n      } = parsed;\n\n      if (!isFileUrlOrNodeStyleSpecifier(parsed)) {\n        return entrypointFallback(defer);\n      }\n\n      if (protocol !== null && protocol !== 'file:') {\n        return entrypointFallback(defer);\n      } // Malformed file:// URL?  We should always see `null` or `''`\n\n\n      if (hostname) {\n        // TODO file://./foo sets `hostname` to `'.'`.  Perhaps we should special-case this.\n        return entrypointFallback(defer);\n      } // pathname is the path to be resolved\n\n\n      return entrypointFallback(() => nodeResolveImplementation.defaultResolve(specifier, context, defaultResolve));\n    });\n  } // `load` from new loader hook API (See description at the top of this file)\n\n\n  async function load(url, context, defaultLoad) {\n    return addShortCircuitFlag(async () => {\n      var _a; // If we get a format hint from resolve() on the context then use it\n      // otherwise call the old getFormat() hook using node's old built-in defaultGetFormat() that ships with ts-node\n\n\n      const format = (_a = context.format) !== null && _a !== void 0 ? _a : (await getFormat(url, context, nodeGetFormatImplementation.defaultGetFormat)).format;\n      let source = undefined;\n\n      if (format !== 'builtin' && format !== 'commonjs') {\n        // Call the new defaultLoad() to get the source\n        const {\n          source: rawSource\n        } = await defaultLoad(url, { ...context,\n          format\n        }, defaultLoad);\n\n        if (rawSource === undefined || rawSource === null) {\n          throw new Error(`Failed to load raw source: Format was '${format}' and url was '${url}''.`);\n        } // Emulate node's built-in old defaultTransformSource() so we can re-use the old transformSource() hook\n\n\n        const defaultTransformSource = async (source, _context, _defaultTransformSource) => ({\n          source\n        }); // Call the old hook\n\n\n        const {\n          source: transformedSource\n        } = await transformSource(rawSource, {\n          url,\n          format\n        }, defaultTransformSource);\n        source = transformedSource;\n      }\n\n      return {\n        format,\n        source\n      };\n    });\n  }\n\n  async function getFormat(url, context, defaultGetFormat) {\n    const defer = function () {\n      let overrideUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : url;\n      return defaultGetFormat(overrideUrl, context, defaultGetFormat);\n    }; // See: https://github.com/nodejs/node/discussions/41711\n    // nodejs will likely implement a similar fallback.  Till then, we can do our users a favor and fallback today.\n\n\n    async function entrypointFallback(cb) {\n      try {\n        return await cb();\n      } catch (getFormatError) {\n        if (!rememberIsProbablyEntrypoint.has(url)) throw getFormatError;\n        return {\n          format: 'commonjs'\n        };\n      }\n    }\n\n    const parsed = (0, url_1.parse)(url);\n\n    if (!isFileUrlOrNodeStyleSpecifier(parsed)) {\n      return entrypointFallback(defer);\n    }\n\n    const {\n      pathname\n    } = parsed;\n    assert(pathname !== null, 'ESM getFormat() hook: URL should never have null pathname');\n    const nativePath = (0, url_1.fileURLToPath)(url);\n    let nodeSays; // If file has extension not understood by node, then ask node how it would treat the emitted extension.\n    // E.g. .mts compiles to .mjs, so ask node how to classify an .mjs file.\n\n    const ext = (0, path_1.extname)(nativePath);\n    const tsNodeIgnored = tsNodeService.ignored(nativePath);\n    const nodeEquivalentExt = extensions.nodeEquivalents.get(ext);\n\n    if (nodeEquivalentExt && !tsNodeIgnored) {\n      nodeSays = await entrypointFallback(() => defer((0, url_1.format)((0, url_1.pathToFileURL)(nativePath + nodeEquivalentExt))));\n    } else {\n      try {\n        nodeSays = await entrypointFallback(defer);\n      } catch (e) {\n        if (e instanceof Error && tsNodeIgnored && extensions.nodeDoesNotUnderstand.includes(ext)) {\n          e.message += `\\n\\n` + `Hint:\\n` + `ts-node is configured to ignore this file.\\n` + `If you want ts-node to handle this file, consider enabling the \"skipIgnore\" option or adjusting your \"ignore\" patterns.\\n` + `https://typestrong.org/ts-node/docs/scope\\n`;\n        }\n\n        throw e;\n      }\n    } // For files compiled by ts-node that node believes are either CJS or ESM, check if we should override that classification\n\n\n    if (!tsNodeService.ignored(nativePath) && (nodeSays.format === 'commonjs' || nodeSays.format === 'module')) {\n      const {\n        moduleType\n      } = tsNodeService.moduleTypeClassifier.classifyModuleByModuleTypeOverrides((0, util_1.normalizeSlashes)(nativePath));\n\n      if (moduleType === 'cjs') {\n        return {\n          format: 'commonjs'\n        };\n      } else if (moduleType === 'esm') {\n        return {\n          format: 'module'\n        };\n      }\n    }\n\n    return nodeSays;\n  }\n\n  async function transformSource(source, context, defaultTransformSource) {\n    if (source === null || source === undefined) {\n      throw new Error('No source');\n    }\n\n    const defer = () => defaultTransformSource(source, context, defaultTransformSource);\n\n    const sourceAsString = typeof source === 'string' ? source : source.toString('utf8');\n    const {\n      url\n    } = context;\n    const parsed = (0, url_1.parse)(url);\n\n    if (!isFileUrlOrNodeStyleSpecifier(parsed)) {\n      return defer();\n    }\n\n    const nativePath = (0, url_1.fileURLToPath)(url);\n\n    if (tsNodeService.ignored(nativePath)) {\n      return defer();\n    }\n\n    const emittedJs = tsNodeService.compile(sourceAsString, nativePath);\n    return {\n      source: emittedJs\n    };\n  }\n\n  return hooksAPI;\n}\n\nexports.createEsmHooks = createEsmHooks;\n\nasync function addShortCircuitFlag(fn) {\n  const ret = await fn(); // Not sure if this is necessary; being lazy.  Can revisit in the future.\n\n  if (ret == null) return ret;\n  return { ...ret,\n    shortCircuit: true\n  };\n}","map":{"version":3,"mappings":"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","names":["newHooksAPI","process","versions","node","filterHooksByAPIVersion","hooks","getFormat","load","resolve","transformSource","hooksAPI","undefined","exports","registerAndCreateEsmHooks","opts","tsNodeInstance","createEsmHooks","tsNodeService","enableExperimentalEsmLoaderInterop","nodeResolveImplementation","getNodeEsmResolver","nodeGetFormatImplementation","getNodeEsmGetFormat","extensions","isFileUrlOrNodeStyleSpecifier","parsed","protocol","isProbablyEntrypoint","specifier","parentURL","startsWith","rememberIsProbablyEntrypoint","Set","rememberResolvedViaCommonjsFallback","context","defaultResolve","defer","r","entrypointFallback","cb","resolution","url","add","esmResolverError","cjsSpecifier","cwd","toString","format","commonjsResolverError","addShortCircuitFlag","pathname","hostname","defaultLoad","_a","defaultGetFormat","source","rawSource","Error","defaultTransformSource","_context","_defaultTransformSource","transformedSource","overrideUrl","getFormatError","has","assert","nativePath","nodeSays","ext","tsNodeIgnored","ignored","nodeEquivalentExt","nodeEquivalents","get","e","nodeDoesNotUnderstand","includes","message","moduleType","moduleTypeClassifier","classifyModuleByModuleTypeOverrides","sourceAsString","emittedJs","compile","fn","ret","shortCircuit"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\ts-node\\src\\esm.ts"],"sourcesContent":["import { register, RegisterOptions, Service } from './index';\nimport {\n  parse as parseUrl,\n  format as formatUrl,\n  UrlWithStringQuery,\n  fileURLToPath,\n  pathToFileURL,\n} from 'url';\nimport { extname } from 'path';\nimport * as assert from 'assert';\nimport { normalizeSlashes, versionGteLt } from './util';\nimport { createRequire } from 'module';\n\n// Note: On Windows, URLs look like this: file:///D:/dev/@TypeStrong/ts-node-examples/foo.ts\n\n// NOTE ABOUT MULTIPLE EXPERIMENTAL LOADER APIS\n//\n// At the time of writing, this file implements 2x different loader APIs.\n// Node made a breaking change to the loader API in https://github.com/nodejs/node/pull/37468\n//\n// We check the node version number and export either the *old* or the *new* API.\n//\n// Today, we are implementing the *new* API on top of our implementation of the *old* API,\n// which relies on copy-pasted code from the *old* hooks implementation in node.\n//\n// In the future, we will likely invert this: we will copy-paste the *new* API implementation\n// from node, build our implementation of the *new* API on top of it, and implement the *old*\n// hooks API as a shim to the *new* API.\n\nexport interface NodeLoaderHooksAPI1 {\n  resolve: NodeLoaderHooksAPI1.ResolveHook;\n  getFormat: NodeLoaderHooksAPI1.GetFormatHook;\n  transformSource: NodeLoaderHooksAPI1.TransformSourceHook;\n}\nexport namespace NodeLoaderHooksAPI1 {\n  export type ResolveHook = NodeLoaderHooksAPI2.ResolveHook;\n  export type GetFormatHook = (\n    url: string,\n    context: {},\n    defaultGetFormat: GetFormatHook\n  ) => Promise<{ format: NodeLoaderHooksFormat }>;\n  export type TransformSourceHook = (\n    source: string | Buffer,\n    context: { url: string; format: NodeLoaderHooksFormat },\n    defaultTransformSource: NodeLoaderHooksAPI1.TransformSourceHook\n  ) => Promise<{ source: string | Buffer }>;\n}\n\nexport interface NodeLoaderHooksAPI2 {\n  resolve: NodeLoaderHooksAPI2.ResolveHook;\n  load: NodeLoaderHooksAPI2.LoadHook;\n}\nexport namespace NodeLoaderHooksAPI2 {\n  export type ResolveHook = (\n    specifier: string,\n    context: {\n      conditions?: NodeImportConditions;\n      importAssertions?: NodeImportAssertions;\n      parentURL: string;\n    },\n    defaultResolve: ResolveHook\n  ) => Promise<{\n    url: string;\n    format?: NodeLoaderHooksFormat;\n    shortCircuit?: boolean;\n  }>;\n  export type LoadHook = (\n    url: string,\n    context: {\n      format: NodeLoaderHooksFormat | null | undefined;\n      importAssertions?: NodeImportAssertions;\n    },\n    defaultLoad: NodeLoaderHooksAPI2['load']\n  ) => Promise<{\n    format: NodeLoaderHooksFormat;\n    source: string | Buffer | undefined;\n    shortCircuit?: boolean;\n  }>;\n  export type NodeImportConditions = unknown;\n  export interface NodeImportAssertions {\n    type?: 'json';\n  }\n}\n\nexport type NodeLoaderHooksFormat =\n  | 'builtin'\n  | 'commonjs'\n  | 'dynamic'\n  | 'json'\n  | 'module'\n  | 'wasm';\n\nexport type NodeImportConditions = unknown;\nexport interface NodeImportAssertions {\n  type?: 'json';\n}\n\n// The hooks API changed in node version X so we need to check for backwards compatibility.\nconst newHooksAPI = versionGteLt(process.versions.node, '16.12.0');\n\n/** @internal */\nexport function filterHooksByAPIVersion(\n  hooks: NodeLoaderHooksAPI1 & NodeLoaderHooksAPI2\n): NodeLoaderHooksAPI1 | NodeLoaderHooksAPI2 {\n  const { getFormat, load, resolve, transformSource } = hooks;\n  // Explicit return type to avoid TS's non-ideal inferred type\n  const hooksAPI: NodeLoaderHooksAPI1 | NodeLoaderHooksAPI2 = newHooksAPI\n    ? { resolve, load, getFormat: undefined, transformSource: undefined }\n    : { resolve, getFormat, transformSource, load: undefined };\n  return hooksAPI;\n}\n\n/** @internal */\nexport function registerAndCreateEsmHooks(opts?: RegisterOptions) {\n  // Automatically performs registration just like `-r ts-node/register`\n  const tsNodeInstance = register(opts);\n\n  return createEsmHooks(tsNodeInstance);\n}\n\nexport function createEsmHooks(tsNodeService: Service) {\n  tsNodeService.enableExperimentalEsmLoaderInterop();\n\n  // Custom implementation that considers additional file extensions and automatically adds file extensions\n  const nodeResolveImplementation = tsNodeService.getNodeEsmResolver();\n  const nodeGetFormatImplementation = tsNodeService.getNodeEsmGetFormat();\n  const extensions = tsNodeService.extensions;\n\n  const hooksAPI = filterHooksByAPIVersion({\n    resolve,\n    load,\n    getFormat,\n    transformSource,\n  });\n\n  function isFileUrlOrNodeStyleSpecifier(parsed: UrlWithStringQuery) {\n    // We only understand file:// URLs, but in node, the specifier can be a node-style `./foo` or `foo`\n    const { protocol } = parsed;\n    return protocol === null || protocol === 'file:';\n  }\n\n  /**\n   * Named \"probably\" as a reminder that this is a guess.\n   * node does not explicitly tell us if we're resolving the entrypoint or not.\n   */\n  function isProbablyEntrypoint(specifier: string, parentURL: string) {\n    return parentURL === undefined && specifier.startsWith('file://');\n  }\n  // Side-channel between `resolve()` and `load()` hooks\n  const rememberIsProbablyEntrypoint = new Set();\n  const rememberResolvedViaCommonjsFallback = new Set();\n\n  async function resolve(\n    specifier: string,\n    context: { parentURL: string },\n    defaultResolve: typeof resolve\n  ): Promise<{ url: string; format?: NodeLoaderHooksFormat }> {\n    const defer = async () => {\n      const r = await defaultResolve(specifier, context, defaultResolve);\n      return r;\n    };\n    // See: https://github.com/nodejs/node/discussions/41711\n    // nodejs will likely implement a similar fallback.  Till then, we can do our users a favor and fallback today.\n    async function entrypointFallback(\n      cb: () => ReturnType<typeof resolve> | Awaited<ReturnType<typeof resolve>>\n    ): ReturnType<typeof resolve> {\n      try {\n        const resolution = await cb();\n        if (\n          resolution?.url &&\n          isProbablyEntrypoint(specifier, context.parentURL)\n        )\n          rememberIsProbablyEntrypoint.add(resolution.url);\n        return resolution;\n      } catch (esmResolverError) {\n        if (!isProbablyEntrypoint(specifier, context.parentURL))\n          throw esmResolverError;\n        try {\n          let cjsSpecifier = specifier;\n          // Attempt to convert from ESM file:// to CommonJS path\n          try {\n            if (specifier.startsWith('file://'))\n              cjsSpecifier = fileURLToPath(specifier);\n          } catch {}\n          const resolution = pathToFileURL(\n            createRequire(process.cwd()).resolve(cjsSpecifier)\n          ).toString();\n          rememberIsProbablyEntrypoint.add(resolution);\n          rememberResolvedViaCommonjsFallback.add(resolution);\n          return { url: resolution, format: 'commonjs' };\n        } catch (commonjsResolverError) {\n          throw esmResolverError;\n        }\n      }\n    }\n\n    return addShortCircuitFlag(async () => {\n      const parsed = parseUrl(specifier);\n      const { pathname, protocol, hostname } = parsed;\n\n      if (!isFileUrlOrNodeStyleSpecifier(parsed)) {\n        return entrypointFallback(defer);\n      }\n\n      if (protocol !== null && protocol !== 'file:') {\n        return entrypointFallback(defer);\n      }\n\n      // Malformed file:// URL?  We should always see `null` or `''`\n      if (hostname) {\n        // TODO file://./foo sets `hostname` to `'.'`.  Perhaps we should special-case this.\n        return entrypointFallback(defer);\n      }\n\n      // pathname is the path to be resolved\n\n      return entrypointFallback(() =>\n        nodeResolveImplementation.defaultResolve(\n          specifier,\n          context,\n          defaultResolve\n        )\n      );\n    });\n  }\n\n  // `load` from new loader hook API (See description at the top of this file)\n  async function load(\n    url: string,\n    context: {\n      format: NodeLoaderHooksFormat | null | undefined;\n      importAssertions?: NodeLoaderHooksAPI2.NodeImportAssertions;\n    },\n    defaultLoad: typeof load\n  ): Promise<{\n    format: NodeLoaderHooksFormat;\n    source: string | Buffer | undefined;\n  }> {\n    return addShortCircuitFlag(async () => {\n      // If we get a format hint from resolve() on the context then use it\n      // otherwise call the old getFormat() hook using node's old built-in defaultGetFormat() that ships with ts-node\n      const format =\n        context.format ??\n        (\n          await getFormat(\n            url,\n            context,\n            nodeGetFormatImplementation.defaultGetFormat\n          )\n        ).format;\n\n      let source = undefined;\n      if (format !== 'builtin' && format !== 'commonjs') {\n        // Call the new defaultLoad() to get the source\n        const { source: rawSource } = await defaultLoad(\n          url,\n          {\n            ...context,\n            format,\n          },\n          defaultLoad\n        );\n\n        if (rawSource === undefined || rawSource === null) {\n          throw new Error(\n            `Failed to load raw source: Format was '${format}' and url was '${url}''.`\n          );\n        }\n\n        // Emulate node's built-in old defaultTransformSource() so we can re-use the old transformSource() hook\n        const defaultTransformSource: typeof transformSource = async (\n          source,\n          _context,\n          _defaultTransformSource\n        ) => ({ source });\n\n        // Call the old hook\n        const { source: transformedSource } = await transformSource(\n          rawSource,\n          { url, format },\n          defaultTransformSource\n        );\n        source = transformedSource;\n      }\n\n      return { format, source };\n    });\n  }\n\n  async function getFormat(\n    url: string,\n    context: {},\n    defaultGetFormat: typeof getFormat\n  ): Promise<{ format: NodeLoaderHooksFormat }> {\n    const defer = (overrideUrl: string = url) =>\n      defaultGetFormat(overrideUrl, context, defaultGetFormat);\n\n    // See: https://github.com/nodejs/node/discussions/41711\n    // nodejs will likely implement a similar fallback.  Till then, we can do our users a favor and fallback today.\n    async function entrypointFallback(\n      cb: () => ReturnType<typeof getFormat>\n    ): ReturnType<typeof getFormat> {\n      try {\n        return await cb();\n      } catch (getFormatError) {\n        if (!rememberIsProbablyEntrypoint.has(url)) throw getFormatError;\n        return { format: 'commonjs' };\n      }\n    }\n\n    const parsed = parseUrl(url);\n\n    if (!isFileUrlOrNodeStyleSpecifier(parsed)) {\n      return entrypointFallback(defer);\n    }\n\n    const { pathname } = parsed;\n    assert(\n      pathname !== null,\n      'ESM getFormat() hook: URL should never have null pathname'\n    );\n\n    const nativePath = fileURLToPath(url);\n\n    let nodeSays: { format: NodeLoaderHooksFormat };\n\n    // If file has extension not understood by node, then ask node how it would treat the emitted extension.\n    // E.g. .mts compiles to .mjs, so ask node how to classify an .mjs file.\n    const ext = extname(nativePath);\n    const tsNodeIgnored = tsNodeService.ignored(nativePath);\n    const nodeEquivalentExt = extensions.nodeEquivalents.get(ext);\n    if (nodeEquivalentExt && !tsNodeIgnored) {\n      nodeSays = await entrypointFallback(() =>\n        defer(formatUrl(pathToFileURL(nativePath + nodeEquivalentExt)))\n      );\n    } else {\n      try {\n        nodeSays = await entrypointFallback(defer);\n      } catch (e) {\n        if (\n          e instanceof Error &&\n          tsNodeIgnored &&\n          extensions.nodeDoesNotUnderstand.includes(ext)\n        ) {\n          e.message +=\n            `\\n\\n` +\n            `Hint:\\n` +\n            `ts-node is configured to ignore this file.\\n` +\n            `If you want ts-node to handle this file, consider enabling the \"skipIgnore\" option or adjusting your \"ignore\" patterns.\\n` +\n            `https://typestrong.org/ts-node/docs/scope\\n`;\n        }\n        throw e;\n      }\n    }\n    // For files compiled by ts-node that node believes are either CJS or ESM, check if we should override that classification\n    if (\n      !tsNodeService.ignored(nativePath) &&\n      (nodeSays.format === 'commonjs' || nodeSays.format === 'module')\n    ) {\n      const { moduleType } =\n        tsNodeService.moduleTypeClassifier.classifyModuleByModuleTypeOverrides(\n          normalizeSlashes(nativePath)\n        );\n      if (moduleType === 'cjs') {\n        return { format: 'commonjs' };\n      } else if (moduleType === 'esm') {\n        return { format: 'module' };\n      }\n    }\n    return nodeSays;\n  }\n\n  async function transformSource(\n    source: string | Buffer,\n    context: { url: string; format: NodeLoaderHooksFormat },\n    defaultTransformSource: typeof transformSource\n  ): Promise<{ source: string | Buffer }> {\n    if (source === null || source === undefined) {\n      throw new Error('No source');\n    }\n\n    const defer = () =>\n      defaultTransformSource(source, context, defaultTransformSource);\n\n    const sourceAsString =\n      typeof source === 'string' ? source : source.toString('utf8');\n\n    const { url } = context;\n    const parsed = parseUrl(url);\n\n    if (!isFileUrlOrNodeStyleSpecifier(parsed)) {\n      return defer();\n    }\n    const nativePath = fileURLToPath(url);\n\n    if (tsNodeService.ignored(nativePath)) {\n      return defer();\n    }\n\n    const emittedJs = tsNodeService.compile(sourceAsString, nativePath);\n\n    return { source: emittedJs };\n  }\n\n  return hooksAPI;\n}\n\nasync function addShortCircuitFlag<T>(fn: () => Promise<T>) {\n  const ret = await fn();\n  // Not sure if this is necessary; being lazy.  Can revisit in the future.\n  if (ret == null) return ret;\n  return {\n    ...ret,\n    shortCircuit: true,\n  };\n}\n"]},"metadata":{},"sourceType":"script"}