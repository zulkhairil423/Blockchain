{"ast":null,"code":"'use strict';\n\nconst Readable = require('./readable');\n\nconst {\n  InvalidArgumentError,\n  RequestAbortedError,\n  ResponseStatusCodeError\n} = require('../core/errors');\n\nconst util = require('../core/util');\n\nconst {\n  AsyncResource\n} = require('async_hooks');\n\nconst {\n  addSignal,\n  removeSignal\n} = require('./abort-signal');\n\nclass RequestHandler extends AsyncResource {\n  constructor(opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts');\n    }\n\n    const {\n      signal,\n      method,\n      opaque,\n      body,\n      onInfo,\n      responseHeaders,\n      throwOnError\n    } = opts;\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback');\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method');\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback');\n      }\n\n      super('UNDICI_REQUEST');\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err);\n      }\n\n      throw err;\n    }\n\n    this.responseHeaders = responseHeaders || null;\n    this.opaque = opaque || null;\n    this.callback = callback;\n    this.res = null;\n    this.abort = null;\n    this.body = body;\n    this.trailers = {};\n    this.context = null;\n    this.onInfo = onInfo || null;\n    this.throwOnError = throwOnError;\n\n    if (util.isStream(body)) {\n      body.on('error', err => {\n        this.onError(err);\n      });\n    }\n\n    addSignal(this, signal);\n  }\n\n  onConnect(abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError();\n    }\n\n    this.abort = abort;\n    this.context = context;\n  }\n\n  onHeaders(statusCode, rawHeaders, resume, statusMessage) {\n    const {\n      callback,\n      opaque,\n      abort,\n      context\n    } = this;\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n        this.onInfo({\n          statusCode,\n          headers\n        });\n      }\n\n      return;\n    }\n\n    const parsedHeaders = util.parseHeaders(rawHeaders);\n    const contentType = parsedHeaders['content-type'];\n    const body = new Readable(resume, abort, contentType);\n    this.callback = null;\n    this.res = body;\n    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n\n    if (callback !== null) {\n      if (this.throwOnError && statusCode >= 400) {\n        this.runInAsyncScope(getResolveErrorBodyCallback, null, {\n          callback,\n          body,\n          contentType,\n          statusCode,\n          statusMessage,\n          headers\n        });\n        return;\n      }\n\n      this.runInAsyncScope(callback, null, null, {\n        statusCode,\n        headers,\n        trailers: this.trailers,\n        opaque,\n        body,\n        context\n      });\n    }\n  }\n\n  onData(chunk) {\n    const {\n      res\n    } = this;\n    return res.push(chunk);\n  }\n\n  onComplete(trailers) {\n    const {\n      res\n    } = this;\n    removeSignal(this);\n    util.parseHeaders(trailers, this.trailers);\n    res.push(null);\n  }\n\n  onError(err) {\n    const {\n      res,\n      callback,\n      body,\n      opaque\n    } = this;\n    removeSignal(this);\n\n    if (callback) {\n      // TODO: Does this need queueMicrotask?\n      this.callback = null;\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, {\n          opaque\n        });\n      });\n    }\n\n    if (res) {\n      this.res = null; // Ensure all queued handlers are invoked before destroying res.\n\n      queueMicrotask(() => {\n        util.destroy(res, err);\n      });\n    }\n\n    if (body) {\n      this.body = null;\n      util.destroy(body, err);\n    }\n  }\n\n}\n\nasync function getResolveErrorBodyCallback(_ref) {\n  let {\n    callback,\n    body,\n    contentType,\n    statusCode,\n    statusMessage,\n    headers\n  } = _ref;\n\n  if (statusCode === 204 || !contentType) {\n    body.dump();\n    process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers));\n    return;\n  }\n\n  try {\n    if (contentType.startsWith('application/json')) {\n      const payload = await body.json();\n      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers, payload));\n      return;\n    }\n\n    if (contentType.startsWith('text/')) {\n      const payload = await body.text();\n      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers, payload));\n      return;\n    }\n  } catch (err) {// Process in a fallback if error\n  }\n\n  body.dump();\n  process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers));\n}\n\nfunction request(opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      request.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data);\n      });\n    });\n  }\n\n  try {\n    this.dispatch(opts, new RequestHandler(opts, callback));\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err;\n    }\n\n    const opaque = opts && opts.opaque;\n    queueMicrotask(() => callback(err, {\n      opaque\n    }));\n  }\n}\n\nmodule.exports = request;","map":{"version":3,"names":["Readable","require","InvalidArgumentError","RequestAbortedError","ResponseStatusCodeError","util","AsyncResource","addSignal","removeSignal","RequestHandler","constructor","opts","callback","signal","method","opaque","body","onInfo","responseHeaders","throwOnError","on","addEventListener","err","isStream","destroy","nop","res","abort","trailers","context","onError","onConnect","onHeaders","statusCode","rawHeaders","resume","statusMessage","headers","parseRawHeaders","parseHeaders","parsedHeaders","contentType","runInAsyncScope","getResolveErrorBodyCallback","onData","chunk","push","onComplete","queueMicrotask","dump","process","nextTick","startsWith","payload","json","text","request","undefined","Promise","resolve","reject","call","data","dispatch","module","exports"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/undici/lib/api/api-request.js"],"sourcesContent":["'use strict'\n\nconst Readable = require('./readable')\nconst {\n  InvalidArgumentError,\n  RequestAbortedError,\n  ResponseStatusCodeError\n} = require('../core/errors')\nconst util = require('../core/util')\nconst { AsyncResource } = require('async_hooks')\nconst { addSignal, removeSignal } = require('./abort-signal')\n\nclass RequestHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_REQUEST')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err)\n      }\n      throw err\n    }\n\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.body = body\n    this.trailers = {}\n    this.context = null\n    this.onInfo = onInfo || null\n    this.throwOnError = throwOnError\n\n    if (util.isStream(body)) {\n      body.on('error', (err) => {\n        this.onError(err)\n      })\n    }\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError()\n    }\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    const { callback, opaque, abort, context } = this\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    const parsedHeaders = util.parseHeaders(rawHeaders)\n    const contentType = parsedHeaders['content-type']\n    const body = new Readable(resume, abort, contentType)\n\n    this.callback = null\n    this.res = body\n    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n\n    if (callback !== null) {\n      if (this.throwOnError && statusCode >= 400) {\n        this.runInAsyncScope(getResolveErrorBodyCallback, null,\n          { callback, body, contentType, statusCode, statusMessage, headers }\n        )\n        return\n      }\n\n      this.runInAsyncScope(callback, null, null, {\n        statusCode,\n        headers,\n        trailers: this.trailers,\n        opaque,\n        body,\n        context\n      })\n    }\n  }\n\n  onData (chunk) {\n    const { res } = this\n    return res.push(chunk)\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n\n    removeSignal(this)\n\n    util.parseHeaders(trailers, this.trailers)\n\n    res.push(null)\n  }\n\n  onError (err) {\n    const { res, callback, body, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      // TODO: Does this need queueMicrotask?\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (res) {\n      this.res = null\n      // Ensure all queued handlers are invoked before destroying res.\n      queueMicrotask(() => {\n        util.destroy(res, err)\n      })\n    }\n\n    if (body) {\n      this.body = null\n      util.destroy(body, err)\n    }\n  }\n}\n\nasync function getResolveErrorBodyCallback ({ callback, body, contentType, statusCode, statusMessage, headers }) {\n  if (statusCode === 204 || !contentType) {\n    body.dump()\n    process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers))\n    return\n  }\n\n  try {\n    if (contentType.startsWith('application/json')) {\n      const payload = await body.json()\n      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers, payload))\n      return\n    }\n\n    if (contentType.startsWith('text/')) {\n      const payload = await body.text()\n      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers, payload))\n      return\n    }\n  } catch (err) {\n    // Process in a fallback if error\n  }\n\n  body.dump()\n  process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers))\n}\n\nfunction request (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      request.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    this.dispatch(opts, new RequestHandler(opts, callback))\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts && opts.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = request\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}