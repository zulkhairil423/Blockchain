{"ast":null,"code":"'use strict';\n/**\n * Module dependencies.\n * @private\n */\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar Pending = require('./pending');\n\nvar utils = require('./utils');\n\nvar debug = require('debug')('mocha:runner');\n\nvar Runnable = require('./runnable');\n\nvar Suite = require('./suite');\n\nvar HOOK_TYPE_BEFORE_EACH = Suite.constants.HOOK_TYPE_BEFORE_EACH;\nvar HOOK_TYPE_AFTER_EACH = Suite.constants.HOOK_TYPE_AFTER_EACH;\nvar HOOK_TYPE_AFTER_ALL = Suite.constants.HOOK_TYPE_AFTER_ALL;\nvar HOOK_TYPE_BEFORE_ALL = Suite.constants.HOOK_TYPE_BEFORE_ALL;\nvar EVENT_ROOT_SUITE_RUN = Suite.constants.EVENT_ROOT_SUITE_RUN;\nvar STATE_FAILED = Runnable.constants.STATE_FAILED;\nvar STATE_PASSED = Runnable.constants.STATE_PASSED;\nvar STATE_PENDING = Runnable.constants.STATE_PENDING;\nvar stackFilter = utils.stackTraceFilter();\nvar stringify = utils.stringify;\n\nconst {\n  createInvalidExceptionError,\n  createUnsupportedError,\n  createFatalError,\n  isMochaError,\n  constants: errorConstants\n} = require('./errors');\n/**\n * Non-enumerable globals.\n * @private\n * @readonly\n */\n\n\nvar globals = ['setTimeout', 'clearTimeout', 'setInterval', 'clearInterval', 'XMLHttpRequest', 'Date', 'setImmediate', 'clearImmediate'];\nvar constants = utils.defineConstants(\n/**\n * {@link Runner}-related constants.\n * @public\n * @memberof Runner\n * @readonly\n * @alias constants\n * @static\n * @enum {string}\n */\n{\n  /**\n   * Emitted when {@link Hook} execution begins\n   */\n  EVENT_HOOK_BEGIN: 'hook',\n\n  /**\n   * Emitted when {@link Hook} execution ends\n   */\n  EVENT_HOOK_END: 'hook end',\n\n  /**\n   * Emitted when Root {@link Suite} execution begins (all files have been parsed and hooks/tests are ready for execution)\n   */\n  EVENT_RUN_BEGIN: 'start',\n\n  /**\n   * Emitted when Root {@link Suite} execution has been delayed via `delay` option\n   */\n  EVENT_DELAY_BEGIN: 'waiting',\n\n  /**\n   * Emitted when delayed Root {@link Suite} execution is triggered by user via `global.run()`\n   */\n  EVENT_DELAY_END: 'ready',\n\n  /**\n   * Emitted when Root {@link Suite} execution ends\n   */\n  EVENT_RUN_END: 'end',\n\n  /**\n   * Emitted when {@link Suite} execution begins\n   */\n  EVENT_SUITE_BEGIN: 'suite',\n\n  /**\n   * Emitted when {@link Suite} execution ends\n   */\n  EVENT_SUITE_END: 'suite end',\n\n  /**\n   * Emitted when {@link Test} execution begins\n   */\n  EVENT_TEST_BEGIN: 'test',\n\n  /**\n   * Emitted when {@link Test} execution ends\n   */\n  EVENT_TEST_END: 'test end',\n\n  /**\n   * Emitted when {@link Test} execution fails\n   */\n  EVENT_TEST_FAIL: 'fail',\n\n  /**\n   * Emitted when {@link Test} execution succeeds\n   */\n  EVENT_TEST_PASS: 'pass',\n\n  /**\n   * Emitted when {@link Test} becomes pending\n   */\n  EVENT_TEST_PENDING: 'pending',\n\n  /**\n   * Emitted when {@link Test} execution has failed, but will retry\n   */\n  EVENT_TEST_RETRY: 'retry',\n\n  /**\n   * Initial state of Runner\n   */\n  STATE_IDLE: 'idle',\n\n  /**\n   * State set to this value when the Runner has started running\n   */\n  STATE_RUNNING: 'running',\n\n  /**\n   * State set to this value when the Runner has stopped\n   */\n  STATE_STOPPED: 'stopped'\n});\n\nclass Runner extends EventEmitter {\n  /**\n   * Initialize a `Runner` at the Root {@link Suite}, which represents a hierarchy of {@link Suite|Suites} and {@link Test|Tests}.\n   *\n   * @extends external:EventEmitter\n   * @public\n   * @class\n   * @param {Suite} suite - Root suite\n   * @param {Object} [opts] - Settings object\n   * @param {boolean} [opts.cleanReferencesAfterRun] - Whether to clean references to test fns and hooks when a suite is done.\n   * @param {boolean} [opts.delay] - Whether to delay execution of root suite until ready.\n   * @param {boolean} [opts.dryRun] - Whether to report tests without running them.\n   * @param {boolean} [opts.failZero] - Whether to fail test run if zero tests encountered.\n   */\n  constructor(suite) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    var self = this;\n    this._globals = [];\n    this._abort = false;\n    this.suite = suite;\n    this._opts = opts;\n    this.state = constants.STATE_IDLE;\n    this.total = suite.total();\n    this.failures = 0;\n    /**\n     * @type {Map<EventEmitter,Map<string,Set<EventListener>>>}\n     */\n\n    this._eventListeners = new Map();\n    this.on(constants.EVENT_TEST_END, function (test) {\n      if (test.type === 'test' && test.retriedTest() && test.parent) {\n        var idx = test.parent.tests && test.parent.tests.indexOf(test.retriedTest());\n        if (idx > -1) test.parent.tests[idx] = test;\n      }\n\n      self.checkGlobals(test);\n    });\n    this.on(constants.EVENT_HOOK_END, function (hook) {\n      self.checkGlobals(hook);\n    });\n    this._defaultGrep = /.*/;\n    this.grep(this._defaultGrep);\n    this.globals(this.globalProps());\n    this.uncaught = this._uncaught.bind(this);\n\n    this.unhandled = (reason, promise) => {\n      if (isMochaError(reason)) {\n        debug('trapped unhandled rejection coming out of Mocha; forwarding to uncaught handler:', reason);\n        this.uncaught(reason);\n      } else {\n        debug('trapped unhandled rejection from (probably) user code; re-emitting on process');\n\n        this._removeEventListener(process, 'unhandledRejection', this.unhandled);\n\n        try {\n          process.emit('unhandledRejection', reason, promise);\n        } finally {\n          this._addEventListener(process, 'unhandledRejection', this.unhandled);\n        }\n      }\n    };\n  }\n\n}\n/**\n * Wrapper for setImmediate, process.nextTick, or browser polyfill.\n *\n * @param {Function} fn\n * @private\n */\n\n\nRunner.immediately = global.setImmediate || process.nextTick;\n/**\n * Replacement for `target.on(eventName, listener)` that does bookkeeping to remove them when this runner instance is disposed.\n * @param {EventEmitter} target - The `EventEmitter`\n * @param {string} eventName - The event name\n * @param {string} fn - Listener function\n * @private\n */\n\nRunner.prototype._addEventListener = function (target, eventName, listener) {\n  debug('_addEventListener(): adding for event %s; %d current listeners', eventName, target.listenerCount(eventName));\n  /* istanbul ignore next */\n\n  if (this._eventListeners.has(target) && this._eventListeners.get(target).has(eventName) && this._eventListeners.get(target).get(eventName).has(listener)) {\n    debug('warning: tried to attach duplicate event listener for %s', eventName);\n    return;\n  }\n\n  target.on(eventName, listener);\n  const targetListeners = this._eventListeners.has(target) ? this._eventListeners.get(target) : new Map();\n  const targetEventListeners = targetListeners.has(eventName) ? targetListeners.get(eventName) : new Set();\n  targetEventListeners.add(listener);\n  targetListeners.set(eventName, targetEventListeners);\n\n  this._eventListeners.set(target, targetListeners);\n};\n/**\n * Replacement for `target.removeListener(eventName, listener)` that also updates the bookkeeping.\n * @param {EventEmitter} target - The `EventEmitter`\n * @param {string} eventName - The event name\n * @param {function} listener - Listener function\n * @private\n */\n\n\nRunner.prototype._removeEventListener = function (target, eventName, listener) {\n  target.removeListener(eventName, listener);\n\n  if (this._eventListeners.has(target)) {\n    const targetListeners = this._eventListeners.get(target);\n\n    if (targetListeners.has(eventName)) {\n      const targetEventListeners = targetListeners.get(eventName);\n      targetEventListeners.delete(listener);\n\n      if (!targetEventListeners.size) {\n        targetListeners.delete(eventName);\n      }\n    }\n\n    if (!targetListeners.size) {\n      this._eventListeners.delete(target);\n    }\n  } else {\n    debug('trying to remove listener for untracked object %s', target);\n  }\n};\n/**\n * Removes all event handlers set during a run on this instance.\n * Remark: this does _not_ clean/dispose the tests or suites themselves.\n */\n\n\nRunner.prototype.dispose = function () {\n  this.removeAllListeners();\n\n  this._eventListeners.forEach((targetListeners, target) => {\n    targetListeners.forEach((targetEventListeners, eventName) => {\n      targetEventListeners.forEach(listener => {\n        target.removeListener(eventName, listener);\n      });\n    });\n  });\n\n  this._eventListeners.clear();\n};\n/**\n * Run tests with full titles matching `re`. Updates runner.total\n * with number of tests matched.\n *\n * @public\n * @memberof Runner\n * @param {RegExp} re\n * @param {boolean} invert\n * @return {Runner} Runner instance.\n */\n\n\nRunner.prototype.grep = function (re, invert) {\n  debug('grep(): setting to %s', re);\n  this._grep = re;\n  this._invert = invert;\n  this.total = this.grepTotal(this.suite);\n  return this;\n};\n/**\n * Returns the number of tests matching the grep search for the\n * given suite.\n *\n * @memberof Runner\n * @public\n * @param {Suite} suite\n * @return {number}\n */\n\n\nRunner.prototype.grepTotal = function (suite) {\n  var self = this;\n  var total = 0;\n  suite.eachTest(function (test) {\n    var match = self._grep.test(test.fullTitle());\n\n    if (self._invert) {\n      match = !match;\n    }\n\n    if (match) {\n      total++;\n    }\n  });\n  return total;\n};\n/**\n * Return a list of global properties.\n *\n * @return {Array}\n * @private\n */\n\n\nRunner.prototype.globalProps = function () {\n  var props = Object.keys(global); // non-enumerables\n\n  for (var i = 0; i < globals.length; ++i) {\n    if (~props.indexOf(globals[i])) {\n      continue;\n    }\n\n    props.push(globals[i]);\n  }\n\n  return props;\n};\n/**\n * Allow the given `arr` of globals.\n *\n * @public\n * @memberof Runner\n * @param {Array} arr\n * @return {Runner} Runner instance.\n */\n\n\nRunner.prototype.globals = function (arr) {\n  if (!arguments.length) {\n    return this._globals;\n  }\n\n  debug('globals(): setting to %O', arr);\n  this._globals = this._globals.concat(arr);\n  return this;\n};\n/**\n * Check for global variable leaks.\n *\n * @private\n */\n\n\nRunner.prototype.checkGlobals = function (test) {\n  if (!this.checkLeaks) {\n    return;\n  }\n\n  var ok = this._globals;\n  var globals = this.globalProps();\n  var leaks;\n\n  if (test) {\n    ok = ok.concat(test._allowedGlobals || []);\n  }\n\n  if (this.prevGlobalsLength === globals.length) {\n    return;\n  }\n\n  this.prevGlobalsLength = globals.length;\n  leaks = filterLeaks(ok, globals);\n  this._globals = this._globals.concat(leaks);\n\n  if (leaks.length) {\n    var msg = `global leak(s) detected: ${leaks.map(e => `'${e}'`).join(', ')}`;\n    this.fail(test, new Error(msg));\n  }\n};\n/**\n * Fail the given `test`.\n *\n * If `test` is a hook, failures work in the following pattern:\n * - If bail, run corresponding `after each` and `after` hooks,\n *   then exit\n * - Failed `before` hook skips all tests in a suite and subsuites,\n *   but jumps to corresponding `after` hook\n * - Failed `before each` hook skips remaining tests in a\n *   suite and jumps to corresponding `after each` hook,\n *   which is run only once\n * - Failed `after` hook does not alter execution order\n * - Failed `after each` hook skips remaining tests in a\n *   suite and subsuites, but executes other `after each`\n *   hooks\n *\n * @private\n * @param {Runnable} test\n * @param {Error} err\n * @param {boolean} [force=false] - Whether to fail a pending test.\n */\n\n\nRunner.prototype.fail = function (test, err, force) {\n  force = force === true;\n\n  if (test.isPending() && !force) {\n    return;\n  }\n\n  if (this.state === constants.STATE_STOPPED) {\n    if (err.code === errorConstants.MULTIPLE_DONE) {\n      throw err;\n    }\n\n    throw createFatalError('Test failed after root suite execution completed!', err);\n  }\n\n  ++this.failures;\n  debug('total number of failures: %d', this.failures);\n  test.state = STATE_FAILED;\n\n  if (!isError(err)) {\n    err = thrown2Error(err);\n  }\n\n  try {\n    err.stack = this.fullStackTrace || !err.stack ? err.stack : stackFilter(err.stack);\n  } catch (ignore) {// some environments do not take kindly to monkeying with the stack\n  }\n\n  this.emit(constants.EVENT_TEST_FAIL, test, err);\n};\n/**\n * Run hook `name` callbacks and then invoke `fn()`.\n *\n * @private\n * @param {string} name\n * @param {Function} fn\n */\n\n\nRunner.prototype.hook = function (name, fn) {\n  if (this._opts.dryRun) return fn();\n  var suite = this.suite;\n  var hooks = suite.getHooks(name);\n  var self = this;\n\n  function next(i) {\n    var hook = hooks[i];\n\n    if (!hook) {\n      return fn();\n    }\n\n    self.currentRunnable = hook;\n\n    if (name === HOOK_TYPE_BEFORE_ALL) {\n      hook.ctx.currentTest = hook.parent.tests[0];\n    } else if (name === HOOK_TYPE_AFTER_ALL) {\n      hook.ctx.currentTest = hook.parent.tests[hook.parent.tests.length - 1];\n    } else {\n      hook.ctx.currentTest = self.test;\n    }\n\n    setHookTitle(hook);\n    hook.allowUncaught = self.allowUncaught;\n    self.emit(constants.EVENT_HOOK_BEGIN, hook);\n\n    if (!hook.listeners('error').length) {\n      self._addEventListener(hook, 'error', function (err) {\n        self.fail(hook, err);\n      });\n    }\n\n    hook.run(function cbHookRun(err) {\n      var testError = hook.error();\n\n      if (testError) {\n        self.fail(self.test, testError);\n      } // conditional skip\n\n\n      if (hook.pending) {\n        if (name === HOOK_TYPE_AFTER_EACH) {\n          // TODO define and implement use case\n          if (self.test) {\n            self.test.pending = true;\n          }\n        } else if (name === HOOK_TYPE_BEFORE_EACH) {\n          if (self.test) {\n            self.test.pending = true;\n          }\n\n          self.emit(constants.EVENT_HOOK_END, hook);\n          hook.pending = false; // activates hook for next test\n\n          return fn(new Error('abort hookDown'));\n        } else if (name === HOOK_TYPE_BEFORE_ALL) {\n          suite.tests.forEach(function (test) {\n            test.pending = true;\n          });\n          suite.suites.forEach(function (suite) {\n            suite.pending = true;\n          });\n          hooks = [];\n        } else {\n          hook.pending = false;\n          var errForbid = createUnsupportedError('`this.skip` forbidden');\n          self.fail(hook, errForbid);\n          return fn(errForbid);\n        }\n      } else if (err) {\n        self.fail(hook, err); // stop executing hooks, notify callee of hook err\n\n        return fn(err);\n      }\n\n      self.emit(constants.EVENT_HOOK_END, hook);\n      delete hook.ctx.currentTest;\n      setHookTitle(hook);\n      next(++i);\n    });\n\n    function setHookTitle(hook) {\n      hook.originalTitle = hook.originalTitle || hook.title;\n\n      if (hook.ctx && hook.ctx.currentTest) {\n        hook.title = `${hook.originalTitle} for \"${hook.ctx.currentTest.title}\"`;\n      } else {\n        var parentTitle;\n\n        if (hook.parent.title) {\n          parentTitle = hook.parent.title;\n        } else {\n          parentTitle = hook.parent.root ? '{root}' : '';\n        }\n\n        hook.title = `${hook.originalTitle} in \"${parentTitle}\"`;\n      }\n    }\n  }\n\n  Runner.immediately(function () {\n    next(0);\n  });\n};\n/**\n * Run hook `name` for the given array of `suites`\n * in order, and callback `fn(err, errSuite)`.\n *\n * @private\n * @param {string} name\n * @param {Array} suites\n * @param {Function} fn\n */\n\n\nRunner.prototype.hooks = function (name, suites, fn) {\n  var self = this;\n  var orig = this.suite;\n\n  function next(suite) {\n    self.suite = suite;\n\n    if (!suite) {\n      self.suite = orig;\n      return fn();\n    }\n\n    self.hook(name, function (err) {\n      if (err) {\n        var errSuite = self.suite;\n        self.suite = orig;\n        return fn(err, errSuite);\n      }\n\n      next(suites.pop());\n    });\n  }\n\n  next(suites.pop());\n};\n/**\n * Run 'afterEach' hooks from bottom up.\n *\n * @param {String} name\n * @param {Function} fn\n * @private\n */\n\n\nRunner.prototype.hookUp = function (name, fn) {\n  var suites = [this.suite].concat(this.parents()).reverse();\n  this.hooks(name, suites, fn);\n};\n/**\n * Run 'beforeEach' hooks from top level down.\n *\n * @param {String} name\n * @param {Function} fn\n * @private\n */\n\n\nRunner.prototype.hookDown = function (name, fn) {\n  var suites = [this.suite].concat(this.parents());\n  this.hooks(name, suites, fn);\n};\n/**\n * Return an array of parent Suites from\n * closest to furthest.\n *\n * @return {Array}\n * @private\n */\n\n\nRunner.prototype.parents = function () {\n  var suite = this.suite;\n  var suites = [];\n\n  while (suite.parent) {\n    suite = suite.parent;\n    suites.push(suite);\n  }\n\n  return suites;\n};\n/**\n * Run the current test and callback `fn(err)`.\n *\n * @param {Function} fn\n * @private\n */\n\n\nRunner.prototype.runTest = function (fn) {\n  if (this._opts.dryRun) return Runner.immediately(fn);\n  var self = this;\n  var test = this.test;\n\n  if (!test) {\n    return;\n  }\n\n  if (this.asyncOnly) {\n    test.asyncOnly = true;\n  }\n\n  this._addEventListener(test, 'error', function (err) {\n    self.fail(test, err);\n  });\n\n  if (this.allowUncaught) {\n    test.allowUncaught = true;\n    return test.run(fn);\n  }\n\n  try {\n    test.run(fn);\n  } catch (err) {\n    fn(err);\n  }\n};\n/**\n * Run tests in the given `suite` and invoke the callback `fn()` when complete.\n *\n * @private\n * @param {Suite} suite\n * @param {Function} fn\n */\n\n\nRunner.prototype.runTests = function (suite, fn) {\n  var self = this;\n  var tests = suite.tests.slice();\n  var test;\n\n  function hookErr(_, errSuite, after) {\n    // before/after Each hook for errSuite failed:\n    var orig = self.suite; // for failed 'after each' hook start from errSuite parent,\n    // otherwise start from errSuite itself\n\n    self.suite = after ? errSuite.parent : errSuite;\n\n    if (self.suite) {\n      self.hookUp(HOOK_TYPE_AFTER_EACH, function (err2, errSuite2) {\n        self.suite = orig; // some hooks may fail even now\n\n        if (err2) {\n          return hookErr(err2, errSuite2, true);\n        } // report error suite\n\n\n        fn(errSuite);\n      });\n    } else {\n      // there is no need calling other 'after each' hooks\n      self.suite = orig;\n      fn(errSuite);\n    }\n  }\n\n  function next(err, errSuite) {\n    // if we bail after first err\n    if (self.failures && suite._bail) {\n      tests = [];\n    }\n\n    if (self._abort) {\n      return fn();\n    }\n\n    if (err) {\n      return hookErr(err, errSuite, true);\n    } // next test\n\n\n    test = tests.shift(); // all done\n\n    if (!test) {\n      return fn();\n    } // grep\n\n\n    var match = self._grep.test(test.fullTitle());\n\n    if (self._invert) {\n      match = !match;\n    }\n\n    if (!match) {\n      // Run immediately only if we have defined a grep. When we\n      // define a grep — It can cause maximum callstack error if\n      // the grep is doing a large recursive loop by neglecting\n      // all tests. The run immediately function also comes with\n      // a performance cost. So we don't want to run immediately\n      // if we run the whole test suite, because running the whole\n      // test suite don't do any immediate recursive loops. Thus,\n      // allowing a JS runtime to breathe.\n      if (self._grep !== self._defaultGrep) {\n        Runner.immediately(next);\n      } else {\n        next();\n      }\n\n      return;\n    } // static skip, no hooks are executed\n\n\n    if (test.isPending()) {\n      if (self.forbidPending) {\n        self.fail(test, new Error('Pending test forbidden'), true);\n      } else {\n        test.state = STATE_PENDING;\n        self.emit(constants.EVENT_TEST_PENDING, test);\n      }\n\n      self.emit(constants.EVENT_TEST_END, test);\n      return next();\n    } // execute test and hook(s)\n\n\n    self.emit(constants.EVENT_TEST_BEGIN, self.test = test);\n    self.hookDown(HOOK_TYPE_BEFORE_EACH, function (err, errSuite) {\n      // conditional skip within beforeEach\n      if (test.isPending()) {\n        if (self.forbidPending) {\n          self.fail(test, new Error('Pending test forbidden'), true);\n        } else {\n          test.state = STATE_PENDING;\n          self.emit(constants.EVENT_TEST_PENDING, test);\n        }\n\n        self.emit(constants.EVENT_TEST_END, test); // skip inner afterEach hooks below errSuite level\n\n        var origSuite = self.suite;\n        self.suite = errSuite || self.suite;\n        return self.hookUp(HOOK_TYPE_AFTER_EACH, function (e, eSuite) {\n          self.suite = origSuite;\n          next(e, eSuite);\n        });\n      }\n\n      if (err) {\n        return hookErr(err, errSuite, false);\n      }\n\n      self.currentRunnable = self.test;\n      self.runTest(function (err) {\n        test = self.test; // conditional skip within it\n\n        if (test.pending) {\n          if (self.forbidPending) {\n            self.fail(test, new Error('Pending test forbidden'), true);\n          } else {\n            test.state = STATE_PENDING;\n            self.emit(constants.EVENT_TEST_PENDING, test);\n          }\n\n          self.emit(constants.EVENT_TEST_END, test);\n          return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n        } else if (err) {\n          var retry = test.currentRetry();\n\n          if (retry < test.retries()) {\n            var clonedTest = test.clone();\n            clonedTest.currentRetry(retry + 1);\n            tests.unshift(clonedTest);\n            self.emit(constants.EVENT_TEST_RETRY, test, err); // Early return + hook trigger so that it doesn't\n            // increment the count wrong\n\n            return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n          } else {\n            self.fail(test, err);\n          }\n\n          self.emit(constants.EVENT_TEST_END, test);\n          return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n        }\n\n        test.state = STATE_PASSED;\n        self.emit(constants.EVENT_TEST_PASS, test);\n        self.emit(constants.EVENT_TEST_END, test);\n        self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n      });\n    });\n  }\n\n  this.next = next;\n  this.hookErr = hookErr;\n  next();\n};\n/**\n * Run the given `suite` and invoke the callback `fn()` when complete.\n *\n * @private\n * @param {Suite} suite\n * @param {Function} fn\n */\n\n\nRunner.prototype.runSuite = function (suite, fn) {\n  var i = 0;\n  var self = this;\n  var total = this.grepTotal(suite);\n  debug('runSuite(): running %s', suite.fullTitle());\n\n  if (!total || self.failures && suite._bail) {\n    debug('runSuite(): bailing');\n    return fn();\n  }\n\n  this.emit(constants.EVENT_SUITE_BEGIN, this.suite = suite);\n\n  function next(errSuite) {\n    if (errSuite) {\n      // current suite failed on a hook from errSuite\n      if (errSuite === suite) {\n        // if errSuite is current suite\n        // continue to the next sibling suite\n        return done();\n      } // errSuite is among the parents of current suite\n      // stop execution of errSuite and all sub-suites\n\n\n      return done(errSuite);\n    }\n\n    if (self._abort) {\n      return done();\n    }\n\n    var curr = suite.suites[i++];\n\n    if (!curr) {\n      return done();\n    } // Avoid grep neglecting large number of tests causing a\n    // huge recursive loop and thus a maximum call stack error.\n    // See comment in `this.runTests()` for more information.\n\n\n    if (self._grep !== self._defaultGrep) {\n      Runner.immediately(function () {\n        self.runSuite(curr, next);\n      });\n    } else {\n      self.runSuite(curr, next);\n    }\n  }\n\n  function done(errSuite) {\n    self.suite = suite;\n    self.nextSuite = next; // remove reference to test\n\n    delete self.test;\n    self.hook(HOOK_TYPE_AFTER_ALL, function () {\n      self.emit(constants.EVENT_SUITE_END, suite);\n      fn(errSuite);\n    });\n  }\n\n  this.nextSuite = next;\n  this.hook(HOOK_TYPE_BEFORE_ALL, function (err) {\n    if (err) {\n      return done();\n    }\n\n    self.runTests(suite, next);\n  });\n};\n/**\n * Handle uncaught exceptions within runner.\n *\n * This function is bound to the instance as `Runner#uncaught` at instantiation\n * time. It's intended to be listening on the `Process.uncaughtException` event.\n * In order to not leak EE listeners, we need to ensure no more than a single\n * `uncaughtException` listener exists per `Runner`.  The only way to do\n * this--because this function needs the context (and we don't have lambdas)--is\n * to use `Function.prototype.bind`. We need strict equality to unregister and\n * _only_ unregister the _one_ listener we set from the\n * `Process.uncaughtException` event; would be poor form to just remove\n * everything. See {@link Runner#run} for where the event listener is registered\n * and unregistered.\n * @param {Error} err - Some uncaught error\n * @private\n */\n\n\nRunner.prototype._uncaught = function (err) {\n  // this is defensive to prevent future developers from mis-calling this function.\n  // it's more likely that it'd be called with the incorrect context--say, the global\n  // `process` object--than it would to be called with a context that is not a \"subclass\"\n  // of `Runner`.\n  if (!(this instanceof Runner)) {\n    throw createFatalError('Runner#uncaught() called with invalid context', this);\n  }\n\n  if (err instanceof Pending) {\n    debug('uncaught(): caught a Pending');\n    return;\n  } // browser does not exit script when throwing in global.onerror()\n\n\n  if (this.allowUncaught && !utils.isBrowser()) {\n    debug('uncaught(): bubbling exception due to --allow-uncaught');\n    throw err;\n  }\n\n  if (this.state === constants.STATE_STOPPED) {\n    debug('uncaught(): throwing after run has completed!');\n    throw err;\n  }\n\n  if (err) {\n    debug('uncaught(): got truthy exception %O', err);\n  } else {\n    debug('uncaught(): undefined/falsy exception');\n    err = createInvalidExceptionError('Caught falsy/undefined exception which would otherwise be uncaught. No stack trace found; try a debugger', err);\n  }\n\n  if (!isError(err)) {\n    err = thrown2Error(err);\n    debug('uncaught(): converted \"error\" %o to Error', err);\n  }\n\n  err.uncaught = true;\n  var runnable = this.currentRunnable;\n\n  if (!runnable) {\n    runnable = new Runnable('Uncaught error outside test suite');\n    debug('uncaught(): no current Runnable; created a phony one');\n    runnable.parent = this.suite;\n\n    if (this.state === constants.STATE_RUNNING) {\n      debug('uncaught(): failing gracefully');\n      this.fail(runnable, err);\n    } else {\n      // Can't recover from this failure\n      debug('uncaught(): test run has not yet started; unrecoverable');\n      this.emit(constants.EVENT_RUN_BEGIN);\n      this.fail(runnable, err);\n      this.emit(constants.EVENT_RUN_END);\n    }\n\n    return;\n  }\n\n  runnable.clearTimeout();\n\n  if (runnable.isFailed()) {\n    debug('uncaught(): Runnable has already failed'); // Ignore error if already failed\n\n    return;\n  } else if (runnable.isPending()) {\n    debug('uncaught(): pending Runnable wound up failing!'); // report 'pending test' retrospectively as failed\n\n    this.fail(runnable, err, true);\n    return;\n  } // we cannot recover gracefully if a Runnable has already passed\n  // then fails asynchronously\n\n\n  if (runnable.isPassed()) {\n    debug('uncaught(): Runnable has already passed; bailing gracefully');\n    this.fail(runnable, err);\n    this.abort();\n  } else {\n    debug('uncaught(): forcing Runnable to complete with Error');\n    return runnable.callback(err);\n  }\n};\n/**\n * Run the root suite and invoke `fn(failures)`\n * on completion.\n *\n * @public\n * @memberof Runner\n * @param {Function} fn - Callback when finished\n * @param {Object} [opts] - For subclasses\n * @param {string[]} opts.files - Files to run\n * @param {Options} opts.options - command-line options\n * @returns {Runner} Runner instance.\n */\n\n\nRunner.prototype.run = function (fn) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var rootSuite = this.suite;\n  var options = opts.options || {};\n  debug('run(): got options: %O', options);\n\n  fn = fn || function () {};\n\n  const end = () => {\n    if (!this.total && this._opts.failZero) this.failures = 1;\n    debug('run(): root suite completed; emitting %s', constants.EVENT_RUN_END);\n    this.emit(constants.EVENT_RUN_END);\n  };\n\n  const begin = () => {\n    debug('run(): emitting %s', constants.EVENT_RUN_BEGIN);\n    this.emit(constants.EVENT_RUN_BEGIN);\n    debug('run(): emitted %s', constants.EVENT_RUN_BEGIN);\n    this.runSuite(rootSuite, end);\n  };\n\n  const prepare = () => {\n    debug('run(): starting'); // If there is an `only` filter\n\n    if (rootSuite.hasOnly()) {\n      rootSuite.filterOnly();\n      debug('run(): filtered exclusive Runnables');\n    }\n\n    this.state = constants.STATE_RUNNING;\n\n    if (this._opts.delay) {\n      this.emit(constants.EVENT_DELAY_END);\n      debug('run(): \"delay\" ended');\n    }\n\n    return begin();\n  }; // references cleanup to avoid memory leaks\n\n\n  if (this._opts.cleanReferencesAfterRun) {\n    this.on(constants.EVENT_SUITE_END, suite => {\n      suite.cleanReferences();\n    });\n  } // callback\n\n\n  this.on(constants.EVENT_RUN_END, function () {\n    this.state = constants.STATE_STOPPED;\n    debug('run(): emitted %s', constants.EVENT_RUN_END);\n    fn(this.failures);\n  });\n\n  this._removeEventListener(process, 'uncaughtException', this.uncaught);\n\n  this._removeEventListener(process, 'unhandledRejection', this.unhandled);\n\n  this._addEventListener(process, 'uncaughtException', this.uncaught);\n\n  this._addEventListener(process, 'unhandledRejection', this.unhandled);\n\n  if (this._opts.delay) {\n    // for reporters, I guess.\n    // might be nice to debounce some dots while we wait.\n    this.emit(constants.EVENT_DELAY_BEGIN, rootSuite);\n    rootSuite.once(EVENT_ROOT_SUITE_RUN, prepare);\n    debug('run(): waiting for green light due to --delay');\n  } else {\n    Runner.immediately(prepare);\n  }\n\n  return this;\n};\n/**\n * Toggle partial object linking behavior; used for building object references from\n * unique ID's. Does nothing in serial mode, because the object references already exist.\n * Subclasses can implement this (e.g., `ParallelBufferedRunner`)\n * @abstract\n * @param {boolean} [value] - If `true`, enable partial object linking, otherwise disable\n * @returns {Runner}\n * @chainable\n * @public\n * @example\n * // this reporter needs proper object references when run in parallel mode\n * class MyReporter() {\n *   constructor(runner) {\n *     this.runner.linkPartialObjects(true)\n *       .on(EVENT_SUITE_BEGIN, suite => {\n           // this Suite may be the same object...\n *       })\n *       .on(EVENT_TEST_BEGIN, test => {\n *         // ...as the `test.parent` property\n *       });\n *   }\n * }\n */\n\n\nRunner.prototype.linkPartialObjects = function (value) {\n  return this;\n};\n/*\n * Like {@link Runner#run}, but does not accept a callback and returns a `Promise` instead of a `Runner`.\n * This function cannot reject; an `unhandledRejection` event will bubble up to the `process` object instead.\n * @public\n * @memberof Runner\n * @param {Object} [opts] - Options for {@link Runner#run}\n * @returns {Promise<number>} Failure count\n */\n\n\nRunner.prototype.runAsync = async function runAsync() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return new Promise(resolve => {\n    this.run(resolve, opts);\n  });\n};\n/**\n * Cleanly abort execution.\n *\n * @memberof Runner\n * @public\n * @return {Runner} Runner instance.\n */\n\n\nRunner.prototype.abort = function () {\n  debug('abort(): aborting');\n  this._abort = true;\n  return this;\n};\n/**\n * Returns `true` if Mocha is running in parallel mode.  For reporters.\n *\n * Subclasses should return an appropriate value.\n * @public\n * @returns {false}\n */\n\n\nRunner.prototype.isParallelMode = function isParallelMode() {\n  return false;\n};\n/**\n * Configures an alternate reporter for worker processes to use. Subclasses\n * using worker processes should implement this.\n * @public\n * @param {string} path - Absolute path to alternate reporter for worker processes to use\n * @returns {Runner}\n * @throws When in serial mode\n * @chainable\n * @abstract\n */\n\n\nRunner.prototype.workerReporter = function () {\n  throw createUnsupportedError('workerReporter() not supported in serial mode');\n};\n/**\n * Filter leaks with the given globals flagged as `ok`.\n *\n * @private\n * @param {Array} ok\n * @param {Array} globals\n * @return {Array}\n */\n\n\nfunction filterLeaks(ok, globals) {\n  return globals.filter(function (key) {\n    // Firefox and Chrome exposes iframes as index inside the window object\n    if (/^\\d+/.test(key)) {\n      return false;\n    } // in firefox\n    // if runner runs in an iframe, this iframe's window.getInterface method\n    // not init at first it is assigned in some seconds\n\n\n    if (global.navigator && /^getInterface/.test(key)) {\n      return false;\n    } // an iframe could be approached by window[iframeIndex]\n    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak\n\n\n    if (global.navigator && /^\\d+/.test(key)) {\n      return false;\n    } // Opera and IE expose global variables for HTML element IDs (issue #243)\n\n\n    if (/^mocha-/.test(key)) {\n      return false;\n    }\n\n    var matched = ok.filter(function (ok) {\n      if (~ok.indexOf('*')) {\n        return key.indexOf(ok.split('*')[0]) === 0;\n      }\n\n      return key === ok;\n    });\n    return !matched.length && (!global.navigator || key !== 'onerror');\n  });\n}\n/**\n * Check if argument is an instance of Error object or a duck-typed equivalent.\n *\n * @private\n * @param {Object} err - object to check\n * @param {string} err.message - error message\n * @returns {boolean}\n */\n\n\nfunction isError(err) {\n  return err instanceof Error || err && typeof err.message === 'string';\n}\n/**\n *\n * Converts thrown non-extensible type into proper Error.\n *\n * @private\n * @param {*} thrown - Non-extensible type thrown by code\n * @return {Error}\n */\n\n\nfunction thrown2Error(err) {\n  return new Error(`the ${utils.canonicalType(err)} ${stringify(err)} was thrown, throw an Error :)`);\n}\n\nRunner.constants = constants;\n/**\n * Node.js' `EventEmitter`\n * @external EventEmitter\n * @see {@link https://nodejs.org/api/events.html#events_class_eventemitter}\n */\n\nmodule.exports = Runner;","map":{"version":3,"names":["EventEmitter","require","Pending","utils","debug","Runnable","Suite","HOOK_TYPE_BEFORE_EACH","constants","HOOK_TYPE_AFTER_EACH","HOOK_TYPE_AFTER_ALL","HOOK_TYPE_BEFORE_ALL","EVENT_ROOT_SUITE_RUN","STATE_FAILED","STATE_PASSED","STATE_PENDING","stackFilter","stackTraceFilter","stringify","createInvalidExceptionError","createUnsupportedError","createFatalError","isMochaError","errorConstants","globals","defineConstants","EVENT_HOOK_BEGIN","EVENT_HOOK_END","EVENT_RUN_BEGIN","EVENT_DELAY_BEGIN","EVENT_DELAY_END","EVENT_RUN_END","EVENT_SUITE_BEGIN","EVENT_SUITE_END","EVENT_TEST_BEGIN","EVENT_TEST_END","EVENT_TEST_FAIL","EVENT_TEST_PASS","EVENT_TEST_PENDING","EVENT_TEST_RETRY","STATE_IDLE","STATE_RUNNING","STATE_STOPPED","Runner","constructor","suite","opts","self","_globals","_abort","_opts","state","total","failures","_eventListeners","Map","on","test","type","retriedTest","parent","idx","tests","indexOf","checkGlobals","hook","_defaultGrep","grep","globalProps","uncaught","_uncaught","bind","unhandled","reason","promise","_removeEventListener","process","emit","_addEventListener","immediately","global","setImmediate","nextTick","prototype","target","eventName","listener","listenerCount","has","get","targetListeners","targetEventListeners","Set","add","set","removeListener","delete","size","dispose","removeAllListeners","forEach","clear","re","invert","_grep","_invert","grepTotal","eachTest","match","fullTitle","props","Object","keys","i","length","push","arr","arguments","concat","checkLeaks","ok","leaks","_allowedGlobals","prevGlobalsLength","filterLeaks","msg","map","e","join","fail","Error","err","force","isPending","code","MULTIPLE_DONE","isError","thrown2Error","stack","fullStackTrace","ignore","name","fn","dryRun","hooks","getHooks","next","currentRunnable","ctx","currentTest","setHookTitle","allowUncaught","listeners","run","cbHookRun","testError","error","pending","suites","errForbid","originalTitle","title","parentTitle","root","orig","errSuite","pop","hookUp","parents","reverse","hookDown","runTest","asyncOnly","runTests","slice","hookErr","_","after","err2","errSuite2","_bail","shift","forbidPending","origSuite","eSuite","retry","currentRetry","retries","clonedTest","clone","unshift","runSuite","done","curr","nextSuite","isBrowser","runnable","clearTimeout","isFailed","isPassed","abort","callback","rootSuite","options","end","failZero","begin","prepare","hasOnly","filterOnly","delay","cleanReferencesAfterRun","cleanReferences","once","linkPartialObjects","value","runAsync","Promise","resolve","isParallelMode","workerReporter","filter","key","navigator","matched","split","message","canonicalType","module","exports"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/mocha/lib/runner.js"],"sourcesContent":["'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\nvar EventEmitter = require('events').EventEmitter;\nvar Pending = require('./pending');\nvar utils = require('./utils');\nvar debug = require('debug')('mocha:runner');\nvar Runnable = require('./runnable');\nvar Suite = require('./suite');\nvar HOOK_TYPE_BEFORE_EACH = Suite.constants.HOOK_TYPE_BEFORE_EACH;\nvar HOOK_TYPE_AFTER_EACH = Suite.constants.HOOK_TYPE_AFTER_EACH;\nvar HOOK_TYPE_AFTER_ALL = Suite.constants.HOOK_TYPE_AFTER_ALL;\nvar HOOK_TYPE_BEFORE_ALL = Suite.constants.HOOK_TYPE_BEFORE_ALL;\nvar EVENT_ROOT_SUITE_RUN = Suite.constants.EVENT_ROOT_SUITE_RUN;\nvar STATE_FAILED = Runnable.constants.STATE_FAILED;\nvar STATE_PASSED = Runnable.constants.STATE_PASSED;\nvar STATE_PENDING = Runnable.constants.STATE_PENDING;\nvar stackFilter = utils.stackTraceFilter();\nvar stringify = utils.stringify;\n\nconst {\n  createInvalidExceptionError,\n  createUnsupportedError,\n  createFatalError,\n  isMochaError,\n  constants: errorConstants\n} = require('./errors');\n\n/**\n * Non-enumerable globals.\n * @private\n * @readonly\n */\nvar globals = [\n  'setTimeout',\n  'clearTimeout',\n  'setInterval',\n  'clearInterval',\n  'XMLHttpRequest',\n  'Date',\n  'setImmediate',\n  'clearImmediate'\n];\n\nvar constants = utils.defineConstants(\n  /**\n   * {@link Runner}-related constants.\n   * @public\n   * @memberof Runner\n   * @readonly\n   * @alias constants\n   * @static\n   * @enum {string}\n   */\n  {\n    /**\n     * Emitted when {@link Hook} execution begins\n     */\n    EVENT_HOOK_BEGIN: 'hook',\n    /**\n     * Emitted when {@link Hook} execution ends\n     */\n    EVENT_HOOK_END: 'hook end',\n    /**\n     * Emitted when Root {@link Suite} execution begins (all files have been parsed and hooks/tests are ready for execution)\n     */\n    EVENT_RUN_BEGIN: 'start',\n    /**\n     * Emitted when Root {@link Suite} execution has been delayed via `delay` option\n     */\n    EVENT_DELAY_BEGIN: 'waiting',\n    /**\n     * Emitted when delayed Root {@link Suite} execution is triggered by user via `global.run()`\n     */\n    EVENT_DELAY_END: 'ready',\n    /**\n     * Emitted when Root {@link Suite} execution ends\n     */\n    EVENT_RUN_END: 'end',\n    /**\n     * Emitted when {@link Suite} execution begins\n     */\n    EVENT_SUITE_BEGIN: 'suite',\n    /**\n     * Emitted when {@link Suite} execution ends\n     */\n    EVENT_SUITE_END: 'suite end',\n    /**\n     * Emitted when {@link Test} execution begins\n     */\n    EVENT_TEST_BEGIN: 'test',\n    /**\n     * Emitted when {@link Test} execution ends\n     */\n    EVENT_TEST_END: 'test end',\n    /**\n     * Emitted when {@link Test} execution fails\n     */\n    EVENT_TEST_FAIL: 'fail',\n    /**\n     * Emitted when {@link Test} execution succeeds\n     */\n    EVENT_TEST_PASS: 'pass',\n    /**\n     * Emitted when {@link Test} becomes pending\n     */\n    EVENT_TEST_PENDING: 'pending',\n    /**\n     * Emitted when {@link Test} execution has failed, but will retry\n     */\n    EVENT_TEST_RETRY: 'retry',\n    /**\n     * Initial state of Runner\n     */\n    STATE_IDLE: 'idle',\n    /**\n     * State set to this value when the Runner has started running\n     */\n    STATE_RUNNING: 'running',\n    /**\n     * State set to this value when the Runner has stopped\n     */\n    STATE_STOPPED: 'stopped'\n  }\n);\n\nclass Runner extends EventEmitter {\n  /**\n   * Initialize a `Runner` at the Root {@link Suite}, which represents a hierarchy of {@link Suite|Suites} and {@link Test|Tests}.\n   *\n   * @extends external:EventEmitter\n   * @public\n   * @class\n   * @param {Suite} suite - Root suite\n   * @param {Object} [opts] - Settings object\n   * @param {boolean} [opts.cleanReferencesAfterRun] - Whether to clean references to test fns and hooks when a suite is done.\n   * @param {boolean} [opts.delay] - Whether to delay execution of root suite until ready.\n   * @param {boolean} [opts.dryRun] - Whether to report tests without running them.\n   * @param {boolean} [opts.failZero] - Whether to fail test run if zero tests encountered.\n   */\n  constructor(suite, opts = {}) {\n    super();\n\n    var self = this;\n    this._globals = [];\n    this._abort = false;\n    this.suite = suite;\n    this._opts = opts;\n    this.state = constants.STATE_IDLE;\n    this.total = suite.total();\n    this.failures = 0;\n    /**\n     * @type {Map<EventEmitter,Map<string,Set<EventListener>>>}\n     */\n    this._eventListeners = new Map();\n    this.on(constants.EVENT_TEST_END, function (test) {\n      if (test.type === 'test' && test.retriedTest() && test.parent) {\n        var idx =\n          test.parent.tests && test.parent.tests.indexOf(test.retriedTest());\n        if (idx > -1) test.parent.tests[idx] = test;\n      }\n      self.checkGlobals(test);\n    });\n    this.on(constants.EVENT_HOOK_END, function (hook) {\n      self.checkGlobals(hook);\n    });\n    this._defaultGrep = /.*/;\n    this.grep(this._defaultGrep);\n    this.globals(this.globalProps());\n\n    this.uncaught = this._uncaught.bind(this);\n    this.unhandled = (reason, promise) => {\n      if (isMochaError(reason)) {\n        debug(\n          'trapped unhandled rejection coming out of Mocha; forwarding to uncaught handler:',\n          reason\n        );\n        this.uncaught(reason);\n      } else {\n        debug(\n          'trapped unhandled rejection from (probably) user code; re-emitting on process'\n        );\n        this._removeEventListener(\n          process,\n          'unhandledRejection',\n          this.unhandled\n        );\n        try {\n          process.emit('unhandledRejection', reason, promise);\n        } finally {\n          this._addEventListener(process, 'unhandledRejection', this.unhandled);\n        }\n      }\n    };\n  }\n}\n\n/**\n * Wrapper for setImmediate, process.nextTick, or browser polyfill.\n *\n * @param {Function} fn\n * @private\n */\nRunner.immediately = global.setImmediate || process.nextTick;\n\n/**\n * Replacement for `target.on(eventName, listener)` that does bookkeeping to remove them when this runner instance is disposed.\n * @param {EventEmitter} target - The `EventEmitter`\n * @param {string} eventName - The event name\n * @param {string} fn - Listener function\n * @private\n */\nRunner.prototype._addEventListener = function (target, eventName, listener) {\n  debug(\n    '_addEventListener(): adding for event %s; %d current listeners',\n    eventName,\n    target.listenerCount(eventName)\n  );\n  /* istanbul ignore next */\n  if (\n    this._eventListeners.has(target) &&\n    this._eventListeners.get(target).has(eventName) &&\n    this._eventListeners.get(target).get(eventName).has(listener)\n  ) {\n    debug(\n      'warning: tried to attach duplicate event listener for %s',\n      eventName\n    );\n    return;\n  }\n  target.on(eventName, listener);\n  const targetListeners = this._eventListeners.has(target)\n    ? this._eventListeners.get(target)\n    : new Map();\n  const targetEventListeners = targetListeners.has(eventName)\n    ? targetListeners.get(eventName)\n    : new Set();\n  targetEventListeners.add(listener);\n  targetListeners.set(eventName, targetEventListeners);\n  this._eventListeners.set(target, targetListeners);\n};\n\n/**\n * Replacement for `target.removeListener(eventName, listener)` that also updates the bookkeeping.\n * @param {EventEmitter} target - The `EventEmitter`\n * @param {string} eventName - The event name\n * @param {function} listener - Listener function\n * @private\n */\nRunner.prototype._removeEventListener = function (target, eventName, listener) {\n  target.removeListener(eventName, listener);\n\n  if (this._eventListeners.has(target)) {\n    const targetListeners = this._eventListeners.get(target);\n    if (targetListeners.has(eventName)) {\n      const targetEventListeners = targetListeners.get(eventName);\n      targetEventListeners.delete(listener);\n      if (!targetEventListeners.size) {\n        targetListeners.delete(eventName);\n      }\n    }\n    if (!targetListeners.size) {\n      this._eventListeners.delete(target);\n    }\n  } else {\n    debug('trying to remove listener for untracked object %s', target);\n  }\n};\n\n/**\n * Removes all event handlers set during a run on this instance.\n * Remark: this does _not_ clean/dispose the tests or suites themselves.\n */\nRunner.prototype.dispose = function () {\n  this.removeAllListeners();\n  this._eventListeners.forEach((targetListeners, target) => {\n    targetListeners.forEach((targetEventListeners, eventName) => {\n      targetEventListeners.forEach(listener => {\n        target.removeListener(eventName, listener);\n      });\n    });\n  });\n  this._eventListeners.clear();\n};\n\n/**\n * Run tests with full titles matching `re`. Updates runner.total\n * with number of tests matched.\n *\n * @public\n * @memberof Runner\n * @param {RegExp} re\n * @param {boolean} invert\n * @return {Runner} Runner instance.\n */\nRunner.prototype.grep = function (re, invert) {\n  debug('grep(): setting to %s', re);\n  this._grep = re;\n  this._invert = invert;\n  this.total = this.grepTotal(this.suite);\n  return this;\n};\n\n/**\n * Returns the number of tests matching the grep search for the\n * given suite.\n *\n * @memberof Runner\n * @public\n * @param {Suite} suite\n * @return {number}\n */\nRunner.prototype.grepTotal = function (suite) {\n  var self = this;\n  var total = 0;\n\n  suite.eachTest(function (test) {\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (match) {\n      total++;\n    }\n  });\n\n  return total;\n};\n\n/**\n * Return a list of global properties.\n *\n * @return {Array}\n * @private\n */\nRunner.prototype.globalProps = function () {\n  var props = Object.keys(global);\n\n  // non-enumerables\n  for (var i = 0; i < globals.length; ++i) {\n    if (~props.indexOf(globals[i])) {\n      continue;\n    }\n    props.push(globals[i]);\n  }\n\n  return props;\n};\n\n/**\n * Allow the given `arr` of globals.\n *\n * @public\n * @memberof Runner\n * @param {Array} arr\n * @return {Runner} Runner instance.\n */\nRunner.prototype.globals = function (arr) {\n  if (!arguments.length) {\n    return this._globals;\n  }\n  debug('globals(): setting to %O', arr);\n  this._globals = this._globals.concat(arr);\n  return this;\n};\n\n/**\n * Check for global variable leaks.\n *\n * @private\n */\nRunner.prototype.checkGlobals = function (test) {\n  if (!this.checkLeaks) {\n    return;\n  }\n  var ok = this._globals;\n\n  var globals = this.globalProps();\n  var leaks;\n\n  if (test) {\n    ok = ok.concat(test._allowedGlobals || []);\n  }\n\n  if (this.prevGlobalsLength === globals.length) {\n    return;\n  }\n  this.prevGlobalsLength = globals.length;\n\n  leaks = filterLeaks(ok, globals);\n  this._globals = this._globals.concat(leaks);\n\n  if (leaks.length) {\n    var msg = `global leak(s) detected: ${leaks.map(e => `'${e}'`).join(', ')}`;\n    this.fail(test, new Error(msg));\n  }\n};\n\n/**\n * Fail the given `test`.\n *\n * If `test` is a hook, failures work in the following pattern:\n * - If bail, run corresponding `after each` and `after` hooks,\n *   then exit\n * - Failed `before` hook skips all tests in a suite and subsuites,\n *   but jumps to corresponding `after` hook\n * - Failed `before each` hook skips remaining tests in a\n *   suite and jumps to corresponding `after each` hook,\n *   which is run only once\n * - Failed `after` hook does not alter execution order\n * - Failed `after each` hook skips remaining tests in a\n *   suite and subsuites, but executes other `after each`\n *   hooks\n *\n * @private\n * @param {Runnable} test\n * @param {Error} err\n * @param {boolean} [force=false] - Whether to fail a pending test.\n */\nRunner.prototype.fail = function (test, err, force) {\n  force = force === true;\n  if (test.isPending() && !force) {\n    return;\n  }\n  if (this.state === constants.STATE_STOPPED) {\n    if (err.code === errorConstants.MULTIPLE_DONE) {\n      throw err;\n    }\n    throw createFatalError(\n      'Test failed after root suite execution completed!',\n      err\n    );\n  }\n\n  ++this.failures;\n  debug('total number of failures: %d', this.failures);\n  test.state = STATE_FAILED;\n\n  if (!isError(err)) {\n    err = thrown2Error(err);\n  }\n\n  try {\n    err.stack =\n      this.fullStackTrace || !err.stack ? err.stack : stackFilter(err.stack);\n  } catch (ignore) {\n    // some environments do not take kindly to monkeying with the stack\n  }\n\n  this.emit(constants.EVENT_TEST_FAIL, test, err);\n};\n\n/**\n * Run hook `name` callbacks and then invoke `fn()`.\n *\n * @private\n * @param {string} name\n * @param {Function} fn\n */\n\nRunner.prototype.hook = function (name, fn) {\n  if (this._opts.dryRun) return fn();\n\n  var suite = this.suite;\n  var hooks = suite.getHooks(name);\n  var self = this;\n\n  function next(i) {\n    var hook = hooks[i];\n    if (!hook) {\n      return fn();\n    }\n    self.currentRunnable = hook;\n\n    if (name === HOOK_TYPE_BEFORE_ALL) {\n      hook.ctx.currentTest = hook.parent.tests[0];\n    } else if (name === HOOK_TYPE_AFTER_ALL) {\n      hook.ctx.currentTest = hook.parent.tests[hook.parent.tests.length - 1];\n    } else {\n      hook.ctx.currentTest = self.test;\n    }\n\n    setHookTitle(hook);\n\n    hook.allowUncaught = self.allowUncaught;\n\n    self.emit(constants.EVENT_HOOK_BEGIN, hook);\n\n    if (!hook.listeners('error').length) {\n      self._addEventListener(hook, 'error', function (err) {\n        self.fail(hook, err);\n      });\n    }\n\n    hook.run(function cbHookRun(err) {\n      var testError = hook.error();\n      if (testError) {\n        self.fail(self.test, testError);\n      }\n      // conditional skip\n      if (hook.pending) {\n        if (name === HOOK_TYPE_AFTER_EACH) {\n          // TODO define and implement use case\n          if (self.test) {\n            self.test.pending = true;\n          }\n        } else if (name === HOOK_TYPE_BEFORE_EACH) {\n          if (self.test) {\n            self.test.pending = true;\n          }\n          self.emit(constants.EVENT_HOOK_END, hook);\n          hook.pending = false; // activates hook for next test\n          return fn(new Error('abort hookDown'));\n        } else if (name === HOOK_TYPE_BEFORE_ALL) {\n          suite.tests.forEach(function (test) {\n            test.pending = true;\n          });\n          suite.suites.forEach(function (suite) {\n            suite.pending = true;\n          });\n          hooks = [];\n        } else {\n          hook.pending = false;\n          var errForbid = createUnsupportedError('`this.skip` forbidden');\n          self.fail(hook, errForbid);\n          return fn(errForbid);\n        }\n      } else if (err) {\n        self.fail(hook, err);\n        // stop executing hooks, notify callee of hook err\n        return fn(err);\n      }\n      self.emit(constants.EVENT_HOOK_END, hook);\n      delete hook.ctx.currentTest;\n      setHookTitle(hook);\n      next(++i);\n    });\n\n    function setHookTitle(hook) {\n      hook.originalTitle = hook.originalTitle || hook.title;\n      if (hook.ctx && hook.ctx.currentTest) {\n        hook.title = `${hook.originalTitle} for \"${hook.ctx.currentTest.title}\"`;\n      } else {\n        var parentTitle;\n        if (hook.parent.title) {\n          parentTitle = hook.parent.title;\n        } else {\n          parentTitle = hook.parent.root ? '{root}' : '';\n        }\n        hook.title = `${hook.originalTitle} in \"${parentTitle}\"`;\n      }\n    }\n  }\n\n  Runner.immediately(function () {\n    next(0);\n  });\n};\n\n/**\n * Run hook `name` for the given array of `suites`\n * in order, and callback `fn(err, errSuite)`.\n *\n * @private\n * @param {string} name\n * @param {Array} suites\n * @param {Function} fn\n */\nRunner.prototype.hooks = function (name, suites, fn) {\n  var self = this;\n  var orig = this.suite;\n\n  function next(suite) {\n    self.suite = suite;\n\n    if (!suite) {\n      self.suite = orig;\n      return fn();\n    }\n\n    self.hook(name, function (err) {\n      if (err) {\n        var errSuite = self.suite;\n        self.suite = orig;\n        return fn(err, errSuite);\n      }\n\n      next(suites.pop());\n    });\n  }\n\n  next(suites.pop());\n};\n\n/**\n * Run 'afterEach' hooks from bottom up.\n *\n * @param {String} name\n * @param {Function} fn\n * @private\n */\nRunner.prototype.hookUp = function (name, fn) {\n  var suites = [this.suite].concat(this.parents()).reverse();\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Run 'beforeEach' hooks from top level down.\n *\n * @param {String} name\n * @param {Function} fn\n * @private\n */\nRunner.prototype.hookDown = function (name, fn) {\n  var suites = [this.suite].concat(this.parents());\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Return an array of parent Suites from\n * closest to furthest.\n *\n * @return {Array}\n * @private\n */\nRunner.prototype.parents = function () {\n  var suite = this.suite;\n  var suites = [];\n  while (suite.parent) {\n    suite = suite.parent;\n    suites.push(suite);\n  }\n  return suites;\n};\n\n/**\n * Run the current test and callback `fn(err)`.\n *\n * @param {Function} fn\n * @private\n */\nRunner.prototype.runTest = function (fn) {\n  if (this._opts.dryRun) return Runner.immediately(fn);\n\n  var self = this;\n  var test = this.test;\n\n  if (!test) {\n    return;\n  }\n\n  if (this.asyncOnly) {\n    test.asyncOnly = true;\n  }\n  this._addEventListener(test, 'error', function (err) {\n    self.fail(test, err);\n  });\n  if (this.allowUncaught) {\n    test.allowUncaught = true;\n    return test.run(fn);\n  }\n  try {\n    test.run(fn);\n  } catch (err) {\n    fn(err);\n  }\n};\n\n/**\n * Run tests in the given `suite` and invoke the callback `fn()` when complete.\n *\n * @private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runTests = function (suite, fn) {\n  var self = this;\n  var tests = suite.tests.slice();\n  var test;\n\n  function hookErr(_, errSuite, after) {\n    // before/after Each hook for errSuite failed:\n    var orig = self.suite;\n\n    // for failed 'after each' hook start from errSuite parent,\n    // otherwise start from errSuite itself\n    self.suite = after ? errSuite.parent : errSuite;\n\n    if (self.suite) {\n      self.hookUp(HOOK_TYPE_AFTER_EACH, function (err2, errSuite2) {\n        self.suite = orig;\n        // some hooks may fail even now\n        if (err2) {\n          return hookErr(err2, errSuite2, true);\n        }\n        // report error suite\n        fn(errSuite);\n      });\n    } else {\n      // there is no need calling other 'after each' hooks\n      self.suite = orig;\n      fn(errSuite);\n    }\n  }\n\n  function next(err, errSuite) {\n    // if we bail after first err\n    if (self.failures && suite._bail) {\n      tests = [];\n    }\n\n    if (self._abort) {\n      return fn();\n    }\n\n    if (err) {\n      return hookErr(err, errSuite, true);\n    }\n\n    // next test\n    test = tests.shift();\n\n    // all done\n    if (!test) {\n      return fn();\n    }\n\n    // grep\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (!match) {\n      // Run immediately only if we have defined a grep. When we\n      // define a grep — It can cause maximum callstack error if\n      // the grep is doing a large recursive loop by neglecting\n      // all tests. The run immediately function also comes with\n      // a performance cost. So we don't want to run immediately\n      // if we run the whole test suite, because running the whole\n      // test suite don't do any immediate recursive loops. Thus,\n      // allowing a JS runtime to breathe.\n      if (self._grep !== self._defaultGrep) {\n        Runner.immediately(next);\n      } else {\n        next();\n      }\n      return;\n    }\n\n    // static skip, no hooks are executed\n    if (test.isPending()) {\n      if (self.forbidPending) {\n        self.fail(test, new Error('Pending test forbidden'), true);\n      } else {\n        test.state = STATE_PENDING;\n        self.emit(constants.EVENT_TEST_PENDING, test);\n      }\n      self.emit(constants.EVENT_TEST_END, test);\n      return next();\n    }\n\n    // execute test and hook(s)\n    self.emit(constants.EVENT_TEST_BEGIN, (self.test = test));\n    self.hookDown(HOOK_TYPE_BEFORE_EACH, function (err, errSuite) {\n      // conditional skip within beforeEach\n      if (test.isPending()) {\n        if (self.forbidPending) {\n          self.fail(test, new Error('Pending test forbidden'), true);\n        } else {\n          test.state = STATE_PENDING;\n          self.emit(constants.EVENT_TEST_PENDING, test);\n        }\n        self.emit(constants.EVENT_TEST_END, test);\n        // skip inner afterEach hooks below errSuite level\n        var origSuite = self.suite;\n        self.suite = errSuite || self.suite;\n        return self.hookUp(HOOK_TYPE_AFTER_EACH, function (e, eSuite) {\n          self.suite = origSuite;\n          next(e, eSuite);\n        });\n      }\n      if (err) {\n        return hookErr(err, errSuite, false);\n      }\n      self.currentRunnable = self.test;\n      self.runTest(function (err) {\n        test = self.test;\n        // conditional skip within it\n        if (test.pending) {\n          if (self.forbidPending) {\n            self.fail(test, new Error('Pending test forbidden'), true);\n          } else {\n            test.state = STATE_PENDING;\n            self.emit(constants.EVENT_TEST_PENDING, test);\n          }\n          self.emit(constants.EVENT_TEST_END, test);\n          return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n        } else if (err) {\n          var retry = test.currentRetry();\n          if (retry < test.retries()) {\n            var clonedTest = test.clone();\n            clonedTest.currentRetry(retry + 1);\n            tests.unshift(clonedTest);\n\n            self.emit(constants.EVENT_TEST_RETRY, test, err);\n\n            // Early return + hook trigger so that it doesn't\n            // increment the count wrong\n            return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n          } else {\n            self.fail(test, err);\n          }\n          self.emit(constants.EVENT_TEST_END, test);\n          return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n        }\n\n        test.state = STATE_PASSED;\n        self.emit(constants.EVENT_TEST_PASS, test);\n        self.emit(constants.EVENT_TEST_END, test);\n        self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n      });\n    });\n  }\n\n  this.next = next;\n  this.hookErr = hookErr;\n  next();\n};\n\n/**\n * Run the given `suite` and invoke the callback `fn()` when complete.\n *\n * @private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runSuite = function (suite, fn) {\n  var i = 0;\n  var self = this;\n  var total = this.grepTotal(suite);\n\n  debug('runSuite(): running %s', suite.fullTitle());\n\n  if (!total || (self.failures && suite._bail)) {\n    debug('runSuite(): bailing');\n    return fn();\n  }\n\n  this.emit(constants.EVENT_SUITE_BEGIN, (this.suite = suite));\n\n  function next(errSuite) {\n    if (errSuite) {\n      // current suite failed on a hook from errSuite\n      if (errSuite === suite) {\n        // if errSuite is current suite\n        // continue to the next sibling suite\n        return done();\n      }\n      // errSuite is among the parents of current suite\n      // stop execution of errSuite and all sub-suites\n      return done(errSuite);\n    }\n\n    if (self._abort) {\n      return done();\n    }\n\n    var curr = suite.suites[i++];\n    if (!curr) {\n      return done();\n    }\n\n    // Avoid grep neglecting large number of tests causing a\n    // huge recursive loop and thus a maximum call stack error.\n    // See comment in `this.runTests()` for more information.\n    if (self._grep !== self._defaultGrep) {\n      Runner.immediately(function () {\n        self.runSuite(curr, next);\n      });\n    } else {\n      self.runSuite(curr, next);\n    }\n  }\n\n  function done(errSuite) {\n    self.suite = suite;\n    self.nextSuite = next;\n\n    // remove reference to test\n    delete self.test;\n\n    self.hook(HOOK_TYPE_AFTER_ALL, function () {\n      self.emit(constants.EVENT_SUITE_END, suite);\n      fn(errSuite);\n    });\n  }\n\n  this.nextSuite = next;\n\n  this.hook(HOOK_TYPE_BEFORE_ALL, function (err) {\n    if (err) {\n      return done();\n    }\n    self.runTests(suite, next);\n  });\n};\n\n/**\n * Handle uncaught exceptions within runner.\n *\n * This function is bound to the instance as `Runner#uncaught` at instantiation\n * time. It's intended to be listening on the `Process.uncaughtException` event.\n * In order to not leak EE listeners, we need to ensure no more than a single\n * `uncaughtException` listener exists per `Runner`.  The only way to do\n * this--because this function needs the context (and we don't have lambdas)--is\n * to use `Function.prototype.bind`. We need strict equality to unregister and\n * _only_ unregister the _one_ listener we set from the\n * `Process.uncaughtException` event; would be poor form to just remove\n * everything. See {@link Runner#run} for where the event listener is registered\n * and unregistered.\n * @param {Error} err - Some uncaught error\n * @private\n */\nRunner.prototype._uncaught = function (err) {\n  // this is defensive to prevent future developers from mis-calling this function.\n  // it's more likely that it'd be called with the incorrect context--say, the global\n  // `process` object--than it would to be called with a context that is not a \"subclass\"\n  // of `Runner`.\n  if (!(this instanceof Runner)) {\n    throw createFatalError(\n      'Runner#uncaught() called with invalid context',\n      this\n    );\n  }\n  if (err instanceof Pending) {\n    debug('uncaught(): caught a Pending');\n    return;\n  }\n  // browser does not exit script when throwing in global.onerror()\n  if (this.allowUncaught && !utils.isBrowser()) {\n    debug('uncaught(): bubbling exception due to --allow-uncaught');\n    throw err;\n  }\n\n  if (this.state === constants.STATE_STOPPED) {\n    debug('uncaught(): throwing after run has completed!');\n    throw err;\n  }\n\n  if (err) {\n    debug('uncaught(): got truthy exception %O', err);\n  } else {\n    debug('uncaught(): undefined/falsy exception');\n    err = createInvalidExceptionError(\n      'Caught falsy/undefined exception which would otherwise be uncaught. No stack trace found; try a debugger',\n      err\n    );\n  }\n\n  if (!isError(err)) {\n    err = thrown2Error(err);\n    debug('uncaught(): converted \"error\" %o to Error', err);\n  }\n  err.uncaught = true;\n\n  var runnable = this.currentRunnable;\n\n  if (!runnable) {\n    runnable = new Runnable('Uncaught error outside test suite');\n    debug('uncaught(): no current Runnable; created a phony one');\n    runnable.parent = this.suite;\n\n    if (this.state === constants.STATE_RUNNING) {\n      debug('uncaught(): failing gracefully');\n      this.fail(runnable, err);\n    } else {\n      // Can't recover from this failure\n      debug('uncaught(): test run has not yet started; unrecoverable');\n      this.emit(constants.EVENT_RUN_BEGIN);\n      this.fail(runnable, err);\n      this.emit(constants.EVENT_RUN_END);\n    }\n\n    return;\n  }\n\n  runnable.clearTimeout();\n\n  if (runnable.isFailed()) {\n    debug('uncaught(): Runnable has already failed');\n    // Ignore error if already failed\n    return;\n  } else if (runnable.isPending()) {\n    debug('uncaught(): pending Runnable wound up failing!');\n    // report 'pending test' retrospectively as failed\n    this.fail(runnable, err, true);\n    return;\n  }\n\n  // we cannot recover gracefully if a Runnable has already passed\n  // then fails asynchronously\n  if (runnable.isPassed()) {\n    debug('uncaught(): Runnable has already passed; bailing gracefully');\n    this.fail(runnable, err);\n    this.abort();\n  } else {\n    debug('uncaught(): forcing Runnable to complete with Error');\n    return runnable.callback(err);\n  }\n};\n\n/**\n * Run the root suite and invoke `fn(failures)`\n * on completion.\n *\n * @public\n * @memberof Runner\n * @param {Function} fn - Callback when finished\n * @param {Object} [opts] - For subclasses\n * @param {string[]} opts.files - Files to run\n * @param {Options} opts.options - command-line options\n * @returns {Runner} Runner instance.\n */\nRunner.prototype.run = function (fn, opts = {}) {\n  var rootSuite = this.suite;\n  var options = opts.options || {};\n\n  debug('run(): got options: %O', options);\n  fn = fn || function () {};\n\n  const end = () => {\n    if (!this.total && this._opts.failZero) this.failures = 1;\n\n    debug('run(): root suite completed; emitting %s', constants.EVENT_RUN_END);\n    this.emit(constants.EVENT_RUN_END);\n  };\n\n  const begin = () => {\n    debug('run(): emitting %s', constants.EVENT_RUN_BEGIN);\n    this.emit(constants.EVENT_RUN_BEGIN);\n    debug('run(): emitted %s', constants.EVENT_RUN_BEGIN);\n\n    this.runSuite(rootSuite, end);\n  };\n\n  const prepare = () => {\n    debug('run(): starting');\n    // If there is an `only` filter\n    if (rootSuite.hasOnly()) {\n      rootSuite.filterOnly();\n      debug('run(): filtered exclusive Runnables');\n    }\n    this.state = constants.STATE_RUNNING;\n    if (this._opts.delay) {\n      this.emit(constants.EVENT_DELAY_END);\n      debug('run(): \"delay\" ended');\n    }\n\n    return begin();\n  };\n\n  // references cleanup to avoid memory leaks\n  if (this._opts.cleanReferencesAfterRun) {\n    this.on(constants.EVENT_SUITE_END, suite => {\n      suite.cleanReferences();\n    });\n  }\n\n  // callback\n  this.on(constants.EVENT_RUN_END, function () {\n    this.state = constants.STATE_STOPPED;\n    debug('run(): emitted %s', constants.EVENT_RUN_END);\n    fn(this.failures);\n  });\n\n  this._removeEventListener(process, 'uncaughtException', this.uncaught);\n  this._removeEventListener(process, 'unhandledRejection', this.unhandled);\n  this._addEventListener(process, 'uncaughtException', this.uncaught);\n  this._addEventListener(process, 'unhandledRejection', this.unhandled);\n\n  if (this._opts.delay) {\n    // for reporters, I guess.\n    // might be nice to debounce some dots while we wait.\n    this.emit(constants.EVENT_DELAY_BEGIN, rootSuite);\n    rootSuite.once(EVENT_ROOT_SUITE_RUN, prepare);\n    debug('run(): waiting for green light due to --delay');\n  } else {\n    Runner.immediately(prepare);\n  }\n\n  return this;\n};\n\n/**\n * Toggle partial object linking behavior; used for building object references from\n * unique ID's. Does nothing in serial mode, because the object references already exist.\n * Subclasses can implement this (e.g., `ParallelBufferedRunner`)\n * @abstract\n * @param {boolean} [value] - If `true`, enable partial object linking, otherwise disable\n * @returns {Runner}\n * @chainable\n * @public\n * @example\n * // this reporter needs proper object references when run in parallel mode\n * class MyReporter() {\n *   constructor(runner) {\n *     this.runner.linkPartialObjects(true)\n *       .on(EVENT_SUITE_BEGIN, suite => {\n           // this Suite may be the same object...\n *       })\n *       .on(EVENT_TEST_BEGIN, test => {\n *         // ...as the `test.parent` property\n *       });\n *   }\n * }\n */\nRunner.prototype.linkPartialObjects = function (value) {\n  return this;\n};\n\n/*\n * Like {@link Runner#run}, but does not accept a callback and returns a `Promise` instead of a `Runner`.\n * This function cannot reject; an `unhandledRejection` event will bubble up to the `process` object instead.\n * @public\n * @memberof Runner\n * @param {Object} [opts] - Options for {@link Runner#run}\n * @returns {Promise<number>} Failure count\n */\nRunner.prototype.runAsync = async function runAsync(opts = {}) {\n  return new Promise(resolve => {\n    this.run(resolve, opts);\n  });\n};\n\n/**\n * Cleanly abort execution.\n *\n * @memberof Runner\n * @public\n * @return {Runner} Runner instance.\n */\nRunner.prototype.abort = function () {\n  debug('abort(): aborting');\n  this._abort = true;\n\n  return this;\n};\n\n/**\n * Returns `true` if Mocha is running in parallel mode.  For reporters.\n *\n * Subclasses should return an appropriate value.\n * @public\n * @returns {false}\n */\nRunner.prototype.isParallelMode = function isParallelMode() {\n  return false;\n};\n\n/**\n * Configures an alternate reporter for worker processes to use. Subclasses\n * using worker processes should implement this.\n * @public\n * @param {string} path - Absolute path to alternate reporter for worker processes to use\n * @returns {Runner}\n * @throws When in serial mode\n * @chainable\n * @abstract\n */\nRunner.prototype.workerReporter = function () {\n  throw createUnsupportedError('workerReporter() not supported in serial mode');\n};\n\n/**\n * Filter leaks with the given globals flagged as `ok`.\n *\n * @private\n * @param {Array} ok\n * @param {Array} globals\n * @return {Array}\n */\nfunction filterLeaks(ok, globals) {\n  return globals.filter(function (key) {\n    // Firefox and Chrome exposes iframes as index inside the window object\n    if (/^\\d+/.test(key)) {\n      return false;\n    }\n\n    // in firefox\n    // if runner runs in an iframe, this iframe's window.getInterface method\n    // not init at first it is assigned in some seconds\n    if (global.navigator && /^getInterface/.test(key)) {\n      return false;\n    }\n\n    // an iframe could be approached by window[iframeIndex]\n    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak\n    if (global.navigator && /^\\d+/.test(key)) {\n      return false;\n    }\n\n    // Opera and IE expose global variables for HTML element IDs (issue #243)\n    if (/^mocha-/.test(key)) {\n      return false;\n    }\n\n    var matched = ok.filter(function (ok) {\n      if (~ok.indexOf('*')) {\n        return key.indexOf(ok.split('*')[0]) === 0;\n      }\n      return key === ok;\n    });\n    return !matched.length && (!global.navigator || key !== 'onerror');\n  });\n}\n\n/**\n * Check if argument is an instance of Error object or a duck-typed equivalent.\n *\n * @private\n * @param {Object} err - object to check\n * @param {string} err.message - error message\n * @returns {boolean}\n */\nfunction isError(err) {\n  return err instanceof Error || (err && typeof err.message === 'string');\n}\n\n/**\n *\n * Converts thrown non-extensible type into proper Error.\n *\n * @private\n * @param {*} thrown - Non-extensible type thrown by code\n * @return {Error}\n */\nfunction thrown2Error(err) {\n  return new Error(\n    `the ${utils.canonicalType(err)} ${stringify(\n      err\n    )} was thrown, throw an Error :)`\n  );\n}\n\nRunner.constants = constants;\n\n/**\n * Node.js' `EventEmitter`\n * @external EventEmitter\n * @see {@link https://nodejs.org/api/events.html#events_class_eventemitter}\n */\n\nmodule.exports = Runner;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}