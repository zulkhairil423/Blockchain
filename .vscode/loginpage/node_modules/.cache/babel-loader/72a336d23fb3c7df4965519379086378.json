{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JsonRpcServer = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst http_1 = __importDefault(require(\"http\"));\n\nconst http_2 = require(\"../../core/providers/http\");\n\nconst handler_1 = require(\"./handler\");\n\nconst log = (0, debug_1.default)(\"hardhat:core:hardhat-network:jsonrpc\");\n\nclass JsonRpcServer {\n  constructor(config) {\n    var _this = this;\n\n    this.getProvider = function () {\n      let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"json-rpc\";\n\n      const {\n        Client\n      } = require(\"undici\");\n\n      const {\n        address,\n        port\n      } = _this._httpServer.address();\n\n      const dispatcher = new Client(`http://${address}:${port}/`, {\n        keepAliveTimeout: 10,\n        keepAliveMaxTimeout: 10\n      });\n      return new http_2.HttpProvider(`http://${address}:${port}/`, name, {}, 20000, dispatcher);\n    };\n\n    this.listen = () => {\n      return new Promise(resolve => {\n        log(`Starting JSON-RPC server on port ${this._config.port}`);\n\n        this._httpServer.listen(this._config.port, this._config.hostname, () => {\n          // We get the address and port directly from the server in order to handle random port allocation with `0`.\n          const address = this._httpServer.address(); // TCP sockets return AddressInfo\n\n\n          resolve(address);\n        });\n      });\n    };\n\n    this.waitUntilClosed = async () => {\n      const httpServerClosed = new Promise(resolve => {\n        this._httpServer.once(\"close\", resolve);\n      });\n      const wsServerClosed = new Promise(resolve => {\n        this._wsServer.once(\"close\", resolve);\n      });\n      await Promise.all([httpServerClosed, wsServerClosed]);\n    };\n\n    this.close = async () => {\n      await Promise.all([new Promise((resolve, reject) => {\n        log(\"Closing JSON-RPC server\");\n\n        this._httpServer.close(err => {\n          if (err !== null && err !== undefined) {\n            log(\"Failed to close JSON-RPC server\");\n            reject(err);\n            return;\n          }\n\n          log(\"JSON-RPC server closed\");\n          resolve();\n        });\n      }), new Promise((resolve, reject) => {\n        log(\"Closing websocket server\");\n\n        this._wsServer.close(err => {\n          if (err !== null && err !== undefined) {\n            log(\"Failed to close websocket server\");\n            reject(err);\n            return;\n          }\n\n          log(\"Websocket server closed\");\n          resolve();\n        });\n      })]);\n    };\n\n    const {\n      Server: WSServer\n    } = require(\"ws\");\n\n    this._config = config;\n    const handler = new handler_1.JsonRpcHandler(config.provider);\n    this._httpServer = http_1.default.createServer();\n    this._wsServer = new WSServer({\n      server: this._httpServer\n    });\n\n    this._httpServer.on(\"request\", handler.handleHttp);\n\n    this._wsServer.on(\"connection\", handler.handleWs);\n  }\n\n}\n\nexports.JsonRpcServer = JsonRpcServer;","map":{"version":3,"mappings":"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","names":["log","JsonRpcServer","constructor","config","name","Client","require","address","port","_httpServer","dispatcher","keepAliveTimeout","keepAliveMaxTimeout","http_2","Promise","resolve","_config","listen","hostname","httpServerClosed","once","wsServerClosed","_wsServer","all","reject","close","err","undefined","Server","WSServer","handler","handler_1","provider","http_1","createServer","server","on","handleHttp","handleWs","exports"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\hardhat\\src\\internal\\hardhat-network\\jsonrpc\\server.ts"],"sourcesContent":["import type { Client as ClientT } from \"undici\";\nimport type WsT from \"ws\";\n\nimport debug from \"debug\";\nimport http, { Server } from \"http\";\nimport { AddressInfo } from \"net\";\n\nimport {\n  EIP1193Provider,\n  JsonRpcServer as IJsonRpcServer,\n} from \"../../../types\";\nimport { HttpProvider } from \"../../core/providers/http\";\n\nimport { JsonRpcHandler } from \"./handler\";\n\nconst log = debug(\"hardhat:core:hardhat-network:jsonrpc\");\n\nexport interface JsonRpcServerConfig {\n  hostname: string;\n  port: number;\n\n  provider: EIP1193Provider;\n}\n\nexport class JsonRpcServer implements IJsonRpcServer {\n  private _config: JsonRpcServerConfig;\n  private _httpServer: Server;\n  private _wsServer: WsT.Server;\n\n  constructor(config: JsonRpcServerConfig) {\n    const { Server: WSServer } = require(\"ws\") as typeof WsT;\n\n    this._config = config;\n\n    const handler = new JsonRpcHandler(config.provider);\n\n    this._httpServer = http.createServer();\n    this._wsServer = new WSServer({\n      server: this._httpServer,\n    });\n\n    this._httpServer.on(\"request\", handler.handleHttp);\n    this._wsServer.on(\"connection\", handler.handleWs);\n  }\n\n  public getProvider = (name = \"json-rpc\"): EIP1193Provider => {\n    const { Client } = require(\"undici\") as { Client: typeof ClientT };\n    const { address, port } = this._httpServer.address() as AddressInfo;\n\n    const dispatcher = new Client(`http://${address}:${port}/`, {\n      keepAliveTimeout: 10,\n      keepAliveMaxTimeout: 10,\n    });\n\n    return new HttpProvider(\n      `http://${address}:${port}/`,\n      name,\n      {},\n      20000,\n      dispatcher\n    );\n  };\n\n  public listen = (): Promise<{ address: string; port: number }> => {\n    return new Promise((resolve) => {\n      log(`Starting JSON-RPC server on port ${this._config.port}`);\n      this._httpServer.listen(this._config.port, this._config.hostname, () => {\n        // We get the address and port directly from the server in order to handle random port allocation with `0`.\n        const address = this._httpServer.address() as AddressInfo; // TCP sockets return AddressInfo\n        resolve(address);\n      });\n    });\n  };\n\n  public waitUntilClosed = async () => {\n    const httpServerClosed = new Promise((resolve) => {\n      this._httpServer.once(\"close\", resolve);\n    });\n\n    const wsServerClosed = new Promise((resolve) => {\n      this._wsServer.once(\"close\", resolve);\n    });\n\n    await Promise.all([httpServerClosed, wsServerClosed]);\n  };\n\n  public close = async () => {\n    await Promise.all([\n      new Promise<void>((resolve, reject) => {\n        log(\"Closing JSON-RPC server\");\n        this._httpServer.close((err) => {\n          if (err !== null && err !== undefined) {\n            log(\"Failed to close JSON-RPC server\");\n            reject(err);\n            return;\n          }\n\n          log(\"JSON-RPC server closed\");\n          resolve();\n        });\n      }),\n      new Promise<void>((resolve, reject) => {\n        log(\"Closing websocket server\");\n        this._wsServer.close((err) => {\n          if (err !== null && err !== undefined) {\n            log(\"Failed to close websocket server\");\n            reject(err);\n            return;\n          }\n\n          log(\"Websocket server closed\");\n          resolve();\n        });\n      }),\n    ]);\n  };\n}\n"]},"metadata":{},"sourceType":"script"}