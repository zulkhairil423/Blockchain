{"ast":null,"code":"var Utils = require(\"./util\");\n\nvar fs = Utils.FileSystem.require(),\n    pth = require(\"path\");\n\nfs.existsSync = fs.existsSync || pth.existsSync;\n\nvar ZipEntry = require(\"./zipEntry\"),\n    ZipFile = require(\"./zipFile\");\n\nvar isWin = /^win/.test(process.platform);\n\nmodule.exports = function (\n/**String*/\ninput) {\n  var _zip = undefined,\n      _filename = \"\";\n\n  if (input && typeof input === \"string\") {\n    // load zip file\n    if (fs.existsSync(input)) {\n      _filename = input;\n      _zip = new ZipFile(input, Utils.Constants.FILE);\n    } else {\n      throw new Error(Utils.Errors.INVALID_FILENAME);\n    }\n  } else if (input && Buffer.isBuffer(input)) {\n    // load buffer\n    _zip = new ZipFile(input, Utils.Constants.BUFFER);\n  } else {\n    // create new zip file\n    _zip = new ZipFile(null, Utils.Constants.NONE);\n  }\n\n  function sanitize(prefix, name) {\n    prefix = pth.resolve(pth.normalize(prefix));\n    var parts = name.split('/');\n\n    for (var i = 0, l = parts.length; i < l; i++) {\n      var path = pth.normalize(pth.join(prefix, parts.slice(i, l).join(pth.sep)));\n\n      if (path.indexOf(prefix) === 0) {\n        return path;\n      }\n    }\n\n    return pth.normalize(pth.join(prefix, pth.basename(name)));\n  }\n\n  function getEntry(\n  /**Object*/\n  entry) {\n    if (entry && _zip) {\n      var item; // If entry was given as a file name\n\n      if (typeof entry === \"string\") item = _zip.getEntry(entry); // if entry was given as a ZipEntry object\n\n      if (typeof entry === \"object\" && typeof entry.entryName !== \"undefined\" && typeof entry.header !== \"undefined\") item = _zip.getEntry(entry.entryName);\n\n      if (item) {\n        return item;\n      }\n    }\n\n    return null;\n  }\n\n  return {\n    /**\r\n     * Extracts the given entry from the archive and returns the content as a Buffer object\r\n     * @param entry ZipEntry object or String with the full path of the entry\r\n     *\r\n     * @return Buffer or Null in case of error\r\n     */\n    readFile: function (\n    /**Object*/\n    entry) {\n      var item = getEntry(entry);\n      return item && item.getData() || null;\n    },\n\n    /**\r\n     * Asynchronous readFile\r\n     * @param entry ZipEntry object or String with the full path of the entry\r\n     * @param callback\r\n     *\r\n     * @return Buffer or Null in case of error\r\n     */\n    readFileAsync: function (\n    /**Object*/\n    entry,\n    /**Function*/\n    callback) {\n      var item = getEntry(entry);\n\n      if (item) {\n        item.getDataAsync(callback);\n      } else {\n        callback(null, \"getEntry failed for:\" + entry);\n      }\n    },\n\n    /**\r\n     * Extracts the given entry from the archive and returns the content as plain text in the given encoding\r\n     * @param entry ZipEntry object or String with the full path of the entry\r\n     * @param encoding Optional. If no encoding is specified utf8 is used\r\n     *\r\n     * @return String\r\n     */\n    readAsText: function (\n    /**Object*/\n    entry,\n    /**String=*/\n    encoding) {\n      var item = getEntry(entry);\n\n      if (item) {\n        var data = item.getData();\n\n        if (data && data.length) {\n          return data.toString(encoding || \"utf8\");\n        }\n      }\n\n      return \"\";\n    },\n\n    /**\r\n     * Asynchronous readAsText\r\n     * @param entry ZipEntry object or String with the full path of the entry\r\n     * @param callback\r\n     * @param encoding Optional. If no encoding is specified utf8 is used\r\n     *\r\n     * @return String\r\n     */\n    readAsTextAsync: function (\n    /**Object*/\n    entry,\n    /**Function*/\n    callback,\n    /**String=*/\n    encoding) {\n      var item = getEntry(entry);\n\n      if (item) {\n        item.getDataAsync(function (data, err) {\n          if (err) {\n            callback(data, err);\n            return;\n          }\n\n          if (data && data.length) {\n            callback(data.toString(encoding || \"utf8\"));\n          } else {\n            callback(\"\");\n          }\n        });\n      } else {\n        callback(\"\");\n      }\n    },\n\n    /**\r\n     * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory\r\n     *\r\n     * @param entry\r\n     */\n    deleteFile: function (\n    /**Object*/\n    entry) {\n      // @TODO: test deleteFile\n      var item = getEntry(entry);\n\n      if (item) {\n        _zip.deleteEntry(item.entryName);\n      }\n    },\n\n    /**\r\n     * Adds a comment to the zip. The zip must be rewritten after adding the comment.\r\n     *\r\n     * @param comment\r\n     */\n    addZipComment: function (\n    /**String*/\n    comment) {\n      // @TODO: test addZipComment\n      _zip.comment = comment;\n    },\n\n    /**\r\n     * Returns the zip comment\r\n     *\r\n     * @return String\r\n     */\n    getZipComment: function () {\n      return _zip.comment || '';\n    },\n\n    /**\r\n     * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment\r\n     * The comment cannot exceed 65535 characters in length\r\n     *\r\n     * @param entry\r\n     * @param comment\r\n     */\n    addZipEntryComment: function (\n    /**Object*/\n    entry,\n    /**String*/\n    comment) {\n      var item = getEntry(entry);\n\n      if (item) {\n        item.comment = comment;\n      }\n    },\n\n    /**\r\n     * Returns the comment of the specified entry\r\n     *\r\n     * @param entry\r\n     * @return String\r\n     */\n    getZipEntryComment: function (\n    /**Object*/\n    entry) {\n      var item = getEntry(entry);\n\n      if (item) {\n        return item.comment || '';\n      }\n\n      return '';\n    },\n\n    /**\r\n     * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content\r\n     *\r\n     * @param entry\r\n     * @param content\r\n     */\n    updateFile: function (\n    /**Object*/\n    entry,\n    /**Buffer*/\n    content) {\n      var item = getEntry(entry);\n\n      if (item) {\n        item.setData(content);\n      }\n    },\n\n    /**\r\n     * Adds a file from the disk to the archive\r\n     *\r\n     * @param localPath File to add to zip\r\n     * @param zipPath Optional path inside the zip\r\n     * @param zipName Optional name for the file\r\n     */\n    addLocalFile: function (\n    /**String*/\n    localPath,\n    /**String=*/\n    zipPath,\n    /**String=*/\n    zipName) {\n      if (fs.existsSync(localPath)) {\n        if (zipPath) {\n          zipPath = zipPath.split(\"\\\\\").join(\"/\");\n\n          if (zipPath.charAt(zipPath.length - 1) !== \"/\") {\n            zipPath += \"/\";\n          }\n        } else {\n          zipPath = \"\";\n        }\n\n        var p = localPath.split(\"\\\\\").join(\"/\").split(\"/\").pop();\n\n        if (zipName) {\n          this.addFile(zipPath + zipName, fs.readFileSync(localPath), \"\", 0);\n        } else {\n          this.addFile(zipPath + p, fs.readFileSync(localPath), \"\", 0);\n        }\n      } else {\n        throw new Error(Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\n      }\n    },\n\n    /**\r\n     * Adds a local directory and all its nested files and directories to the archive\r\n     *\r\n     * @param localPath\r\n     * @param zipPath optional path inside zip\r\n     * @param filter optional RegExp or Function if files match will\r\n     *               be included.\r\n     */\n    addLocalFolder: function (\n    /**String*/\n    localPath,\n    /**String=*/\n    zipPath,\n    /**=RegExp|Function*/\n    filter) {\n      if (filter === undefined) {\n        filter = function () {\n          return true;\n        };\n      } else if (filter instanceof RegExp) {\n        filter = function (filter) {\n          return function (filename) {\n            return filter.test(filename);\n          };\n        }(filter);\n      }\n\n      if (zipPath) {\n        zipPath = zipPath.split(\"\\\\\").join(\"/\");\n\n        if (zipPath.charAt(zipPath.length - 1) !== \"/\") {\n          zipPath += \"/\";\n        }\n      } else {\n        zipPath = \"\";\n      } // normalize the path first\n\n\n      localPath = pth.normalize(localPath);\n      localPath = localPath.split(\"\\\\\").join(\"/\"); //windows fix\n\n      if (localPath.charAt(localPath.length - 1) !== \"/\") localPath += \"/\";\n\n      if (fs.existsSync(localPath)) {\n        var items = Utils.findFiles(localPath),\n            self = this;\n\n        if (items.length) {\n          items.forEach(function (path) {\n            var p = path.split(\"\\\\\").join(\"/\").replace(new RegExp(localPath.replace(/(\\(|\\)|\\$)/g, '\\\\$1'), 'i'), \"\"); //windows fix\n\n            if (filter(p)) {\n              if (p.charAt(p.length - 1) !== \"/\") {\n                self.addFile(zipPath + p, fs.readFileSync(path), \"\", 0);\n              } else {\n                self.addFile(zipPath + p, Buffer.alloc(0), \"\", 0);\n              }\n            }\n          });\n        }\n      } else {\n        throw new Error(Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\n      }\n    },\n\n    /**\r\n     * Asynchronous addLocalFile\r\n     * @param localPath\r\n     * @param callback\r\n     * @param zipPath optional path inside zip\r\n     * @param filter optional RegExp or Function if files match will\r\n     *               be included.\r\n     */\n    addLocalFolderAsync: function (\n    /*String*/\n    localPath,\n    /*Function*/\n    callback,\n    /*String*/\n    zipPath,\n    /*RegExp|Function*/\n    filter) {\n      if (filter === undefined) {\n        filter = function () {\n          return true;\n        };\n      } else if (filter instanceof RegExp) {\n        filter = function (filter) {\n          return function (filename) {\n            return filter.test(filename);\n          };\n        }(filter);\n      }\n\n      if (zipPath) {\n        zipPath = zipPath.split(\"\\\\\").join(\"/\");\n\n        if (zipPath.charAt(zipPath.length - 1) !== \"/\") {\n          zipPath += \"/\";\n        }\n      } else {\n        zipPath = \"\";\n      } // normalize the path first\n\n\n      localPath = pth.normalize(localPath);\n      localPath = localPath.split(\"\\\\\").join(\"/\"); //windows fix\n\n      if (localPath.charAt(localPath.length - 1) !== \"/\") localPath += \"/\";\n      var self = this;\n      fs.open(localPath, 'r', function (err, fd) {\n        if (err && err.code === 'ENOENT') {\n          callback(undefined, Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\n        } else if (err) {\n          callback(undefined, err);\n        } else {\n          var items = Utils.findFiles(localPath);\n          var i = -1;\n\n          var next = function () {\n            i += 1;\n\n            if (i < items.length) {\n              var p = items[i].split(\"\\\\\").join(\"/\").replace(new RegExp(localPath.replace(/(\\(|\\))/g, '\\\\$1'), 'i'), \"\"); //windows fix\n\n              p = p.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').replace(/[^\\x20-\\x7E]/g, ''); // accent fix\n\n              if (filter(p)) {\n                if (p.charAt(p.length - 1) !== \"/\") {\n                  fs.readFile(items[i], function (err, data) {\n                    if (err) {\n                      callback(undefined, err);\n                    } else {\n                      self.addFile(zipPath + p, data, '', 0);\n                      next();\n                    }\n                  });\n                } else {\n                  self.addFile(zipPath + p, Buffer.alloc(0), \"\", 0);\n                  next();\n                }\n              } else {\n                next();\n              }\n            } else {\n              callback(true, undefined);\n            }\n          };\n\n          next();\n        }\n      });\n    },\n\n    /**\r\n     * Allows you to create a entry (file or directory) in the zip file.\r\n     * If you want to create a directory the entryName must end in / and a null buffer should be provided.\r\n     * Comment and attributes are optional\r\n     *\r\n     * @param entryName\r\n     * @param content\r\n     * @param comment\r\n     * @param attr\r\n     */\n    addFile: function (\n    /**String*/\n    entryName,\n    /**Buffer*/\n    content,\n    /**String*/\n    comment,\n    /**Number*/\n    attr) {\n      var entry = new ZipEntry();\n      entry.entryName = entryName;\n      entry.comment = comment || \"\";\n\n      if (!attr) {\n        if (entry.isDirectory) {\n          attr = 0o40755 << 16 | 0x10; // (permissions drwxr-xr-x) + (MS-DOS directory flag)\n        } else {\n          attr = 0o644 << 16; // permissions -r-wr--r--\n        }\n      }\n\n      entry.attr = attr;\n      entry.setData(content);\n\n      _zip.setEntry(entry);\n    },\n\n    /**\r\n     * Returns an array of ZipEntry objects representing the files and folders inside the archive\r\n     *\r\n     * @return Array\r\n     */\n    getEntries: function () {\n      if (_zip) {\n        return _zip.entries;\n      } else {\n        return [];\n      }\n    },\n\n    /**\r\n     * Returns a ZipEntry object representing the file or folder specified by ``name``.\r\n     *\r\n     * @param name\r\n     * @return ZipEntry\r\n     */\n    getEntry: function (\n    /**String*/\n    name) {\n      return getEntry(name);\n    },\n    getEntryCount: function () {\n      return _zip.getEntryCount();\n    },\n    forEach: function (callback) {\n      return _zip.forEach(callback);\n    },\n\n    /**\r\n     * Extracts the given entry to the given targetPath\r\n     * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted\r\n     *\r\n     * @param entry ZipEntry object or String with the full path of the entry\r\n     * @param targetPath Target folder where to write the file\r\n     * @param maintainEntryPath If maintainEntryPath is true and the entry is inside a folder, the entry folder\r\n     *                          will be created in targetPath as well. Default is TRUE\r\n     * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\r\n     *                  Default is FALSE\r\n     *\r\n     * @return Boolean\r\n     */\n    extractEntryTo: function (\n    /**Object*/\n    entry,\n    /**String*/\n    targetPath,\n    /**Boolean*/\n    maintainEntryPath,\n    /**Boolean*/\n    overwrite) {\n      overwrite = overwrite || false;\n      maintainEntryPath = typeof maintainEntryPath === \"undefined\" ? true : maintainEntryPath;\n      var item = getEntry(entry);\n\n      if (!item) {\n        throw new Error(Utils.Errors.NO_ENTRY);\n      }\n\n      var entryName = item.entryName;\n      var target = sanitize(targetPath, maintainEntryPath ? entryName : pth.basename(entryName));\n\n      if (item.isDirectory) {\n        target = pth.resolve(target, \"..\");\n\n        var children = _zip.getEntryChildren(item);\n\n        children.forEach(function (child) {\n          if (child.isDirectory) return;\n          var content = child.getData();\n\n          if (!content) {\n            throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\n          }\n\n          var childName = sanitize(targetPath, maintainEntryPath ? child.entryName : pth.basename(child.entryName));\n          Utils.writeFileTo(childName, content, overwrite);\n        });\n        return true;\n      }\n\n      var content = item.getData();\n      if (!content) throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\n\n      if (fs.existsSync(target) && !overwrite) {\n        throw new Error(Utils.Errors.CANT_OVERRIDE);\n      }\n\n      Utils.writeFileTo(target, content, overwrite);\n      return true;\n    },\n\n    /**\r\n     * Test the archive\r\n     *\r\n     */\n    test: function () {\n      if (!_zip) {\n        return false;\n      }\n\n      for (var entry in _zip.entries) {\n        try {\n          if (entry.isDirectory) {\n            continue;\n          }\n\n          var content = _zip.entries[entry].getData();\n\n          if (!content) {\n            return false;\n          }\n        } catch (err) {\n          return false;\n        }\n      }\n\n      return true;\n    },\n\n    /**\r\n     * Extracts the entire archive to the given location\r\n     *\r\n     * @param targetPath Target location\r\n     * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\r\n     *                  Default is FALSE\r\n     */\n    extractAllTo: function (\n    /**String*/\n    targetPath,\n    /**Boolean*/\n    overwrite) {\n      overwrite = overwrite || false;\n\n      if (!_zip) {\n        throw new Error(Utils.Errors.NO_ZIP);\n      }\n\n      _zip.entries.forEach(function (entry) {\n        var entryName = sanitize(targetPath, entry.entryName.toString());\n\n        if (entry.isDirectory) {\n          Utils.makeDir(entryName);\n          return;\n        }\n\n        var content = entry.getData();\n\n        if (!content) {\n          throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\n        }\n\n        Utils.writeFileTo(entryName, content, overwrite);\n\n        try {\n          fs.utimesSync(entryName, entry.header.time, entry.header.time);\n        } catch (err) {\n          throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\n        }\n      });\n    },\n\n    /**\r\n     * Asynchronous extractAllTo\r\n     *\r\n     * @param targetPath Target location\r\n     * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\r\n     *                  Default is FALSE\r\n     * @param callback\r\n     */\n    extractAllToAsync: function (\n    /**String*/\n    targetPath,\n    /**Boolean*/\n    overwrite,\n    /**Function*/\n    callback) {\n      if (!callback) {\n        callback = function () {};\n      }\n\n      overwrite = overwrite || false;\n\n      if (!_zip) {\n        callback(new Error(Utils.Errors.NO_ZIP));\n        return;\n      }\n\n      var entries = _zip.entries;\n      var i = entries.length;\n      entries.forEach(function (entry) {\n        if (i <= 0) return; // Had an error already\n\n        var entryName = pth.normalize(entry.entryName.toString());\n\n        if (entry.isDirectory) {\n          Utils.makeDir(sanitize(targetPath, entryName));\n          if (--i === 0) callback(undefined);\n          return;\n        }\n\n        entry.getDataAsync(function (content, err) {\n          if (i <= 0) return;\n\n          if (err) {\n            callback(new Error(err));\n            return;\n          }\n\n          if (!content) {\n            i = 0;\n            callback(new Error(Utils.Errors.CANT_EXTRACT_FILE));\n            return;\n          }\n\n          Utils.writeFileToAsync(sanitize(targetPath, entryName), content, overwrite, function (succ) {\n            try {\n              fs.utimesSync(pth.resolve(targetPath, entryName), entry.header.time, entry.header.time);\n            } catch (err) {\n              callback(new Error('Unable to set utimes'));\n            }\n\n            if (i <= 0) return;\n\n            if (!succ) {\n              i = 0;\n              callback(new Error('Unable to write'));\n              return;\n            }\n\n            if (--i === 0) callback(undefined);\n          });\n        });\n      });\n    },\n\n    /**\r\n     * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip\r\n     *\r\n     * @param targetFileName\r\n     * @param callback\r\n     */\n    writeZip: function (\n    /**String*/\n    targetFileName,\n    /**Function*/\n    callback) {\n      if (arguments.length === 1) {\n        if (typeof targetFileName === \"function\") {\n          callback = targetFileName;\n          targetFileName = \"\";\n        }\n      }\n\n      if (!targetFileName && _filename) {\n        targetFileName = _filename;\n      }\n\n      if (!targetFileName) return;\n\n      var zipData = _zip.compressToBuffer();\n\n      if (zipData) {\n        var ok = Utils.writeFileTo(targetFileName, zipData, true);\n        if (typeof callback === 'function') callback(!ok ? new Error(\"failed\") : null, \"\");\n      }\n    },\n\n    /**\r\n     * Returns the content of the entire zip file as a Buffer object\r\n     *\r\n     * @return Buffer\r\n     */\n    toBuffer: function (\n    /**Function=*/\n    onSuccess,\n    /**Function=*/\n    onFail,\n    /**Function=*/\n    onItemStart,\n    /**Function=*/\n    onItemEnd) {\n      this.valueOf = 2;\n\n      if (typeof onSuccess === \"function\") {\n        _zip.toAsyncBuffer(onSuccess, onFail, onItemStart, onItemEnd);\n\n        return null;\n      }\n\n      return _zip.compressToBuffer();\n    }\n  };\n};","map":{"version":3,"names":["Utils","require","fs","FileSystem","pth","existsSync","ZipEntry","ZipFile","isWin","test","process","platform","module","exports","input","_zip","undefined","_filename","Constants","FILE","Error","Errors","INVALID_FILENAME","Buffer","isBuffer","BUFFER","NONE","sanitize","prefix","name","resolve","normalize","parts","split","i","l","length","path","join","slice","sep","indexOf","basename","getEntry","entry","item","entryName","header","readFile","getData","readFileAsync","callback","getDataAsync","readAsText","encoding","data","toString","readAsTextAsync","err","deleteFile","deleteEntry","addZipComment","comment","getZipComment","addZipEntryComment","getZipEntryComment","updateFile","content","setData","addLocalFile","localPath","zipPath","zipName","charAt","p","pop","addFile","readFileSync","FILE_NOT_FOUND","replace","addLocalFolder","filter","RegExp","filename","items","findFiles","self","forEach","alloc","addLocalFolderAsync","open","fd","code","next","attr","isDirectory","setEntry","getEntries","entries","getEntryCount","extractEntryTo","targetPath","maintainEntryPath","overwrite","NO_ENTRY","target","children","getEntryChildren","child","CANT_EXTRACT_FILE","childName","writeFileTo","CANT_OVERRIDE","extractAllTo","NO_ZIP","makeDir","utimesSync","time","extractAllToAsync","writeFileToAsync","succ","writeZip","targetFileName","arguments","zipData","compressToBuffer","ok","toBuffer","onSuccess","onFail","onItemStart","onItemEnd","valueOf","toAsyncBuffer"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/adm-zip/adm-zip.js"],"sourcesContent":["var Utils = require(\"./util\");\r\nvar fs = Utils.FileSystem.require(),\r\n\tpth = require(\"path\");\r\n\r\nfs.existsSync = fs.existsSync || pth.existsSync;\r\n\r\nvar ZipEntry = require(\"./zipEntry\"),\r\n\tZipFile = require(\"./zipFile\");\r\n\r\nvar isWin = /^win/.test(process.platform);\r\n\r\n\r\nmodule.exports = function (/**String*/input) {\r\n\tvar _zip = undefined,\r\n\t\t_filename = \"\";\r\n\r\n\tif (input && typeof input === \"string\") { // load zip file\r\n\t\tif (fs.existsSync(input)) {\r\n\t\t\t_filename = input;\r\n\t\t\t_zip = new ZipFile(input, Utils.Constants.FILE);\r\n\t\t} else {\r\n\t\t\tthrow new Error(Utils.Errors.INVALID_FILENAME);\r\n\t\t}\r\n\t} else if (input && Buffer.isBuffer(input)) { // load buffer\r\n\t\t_zip = new ZipFile(input, Utils.Constants.BUFFER);\r\n\t} else { // create new zip file\r\n\t\t_zip = new ZipFile(null, Utils.Constants.NONE);\r\n\t}\r\n\r\n\tfunction sanitize(prefix, name) {\r\n\t\tprefix = pth.resolve(pth.normalize(prefix));\r\n\t\tvar parts = name.split('/');\r\n\t\tfor (var i = 0, l = parts.length; i < l; i++) {\r\n\t\t\tvar path = pth.normalize(pth.join(prefix, parts.slice(i, l).join(pth.sep)));\r\n\t\t\tif (path.indexOf(prefix) === 0) {\r\n\t\t\t\treturn path;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn pth.normalize(pth.join(prefix, pth.basename(name)));\r\n\t}\r\n\r\n\tfunction getEntry(/**Object*/entry) {\r\n\t\tif (entry && _zip) {\r\n\t\t\tvar item;\r\n\t\t\t// If entry was given as a file name\r\n\t\t\tif (typeof entry === \"string\")\r\n\t\t\t\titem = _zip.getEntry(entry);\r\n\t\t\t// if entry was given as a ZipEntry object\r\n\t\t\tif (typeof entry === \"object\" && typeof entry.entryName !== \"undefined\" && typeof entry.header !== \"undefined\")\r\n\t\t\t\titem = _zip.getEntry(entry.entryName);\r\n\r\n\t\t\tif (item) {\r\n\t\t\t\treturn item;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * Extracts the given entry from the archive and returns the content as a Buffer object\r\n\t\t * @param entry ZipEntry object or String with the full path of the entry\r\n\t\t *\r\n\t\t * @return Buffer or Null in case of error\r\n\t\t */\r\n\t\treadFile: function (/**Object*/entry) {\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\treturn item && item.getData() || null;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Asynchronous readFile\r\n\t\t * @param entry ZipEntry object or String with the full path of the entry\r\n\t\t * @param callback\r\n\t\t *\r\n\t\t * @return Buffer or Null in case of error\r\n\t\t */\r\n\t\treadFileAsync: function (/**Object*/entry, /**Function*/callback) {\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (item) {\r\n\t\t\t\titem.getDataAsync(callback);\r\n\t\t\t} else {\r\n\t\t\t\tcallback(null, \"getEntry failed for:\" + entry)\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Extracts the given entry from the archive and returns the content as plain text in the given encoding\r\n\t\t * @param entry ZipEntry object or String with the full path of the entry\r\n\t\t * @param encoding Optional. If no encoding is specified utf8 is used\r\n\t\t *\r\n\t\t * @return String\r\n\t\t */\r\n\t\treadAsText: function (/**Object*/entry, /**String=*/encoding) {\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (item) {\r\n\t\t\t\tvar data = item.getData();\r\n\t\t\t\tif (data && data.length) {\r\n\t\t\t\t\treturn data.toString(encoding || \"utf8\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn \"\";\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Asynchronous readAsText\r\n\t\t * @param entry ZipEntry object or String with the full path of the entry\r\n\t\t * @param callback\r\n\t\t * @param encoding Optional. If no encoding is specified utf8 is used\r\n\t\t *\r\n\t\t * @return String\r\n\t\t */\r\n\t\treadAsTextAsync: function (/**Object*/entry, /**Function*/callback, /**String=*/encoding) {\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (item) {\r\n\t\t\t\titem.getDataAsync(function (data, err) {\r\n\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\tcallback(data, err);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (data && data.length) {\r\n\t\t\t\t\t\tcallback(data.toString(encoding || \"utf8\"));\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcallback(\"\");\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\tcallback(\"\");\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory\r\n\t\t *\r\n\t\t * @param entry\r\n\t\t */\r\n\t\tdeleteFile: function (/**Object*/entry) { // @TODO: test deleteFile\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (item) {\r\n\t\t\t\t_zip.deleteEntry(item.entryName);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds a comment to the zip. The zip must be rewritten after adding the comment.\r\n\t\t *\r\n\t\t * @param comment\r\n\t\t */\r\n\t\taddZipComment: function (/**String*/comment) { // @TODO: test addZipComment\r\n\t\t\t_zip.comment = comment;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the zip comment\r\n\t\t *\r\n\t\t * @return String\r\n\t\t */\r\n\t\tgetZipComment: function () {\r\n\t\t\treturn _zip.comment || '';\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment\r\n\t\t * The comment cannot exceed 65535 characters in length\r\n\t\t *\r\n\t\t * @param entry\r\n\t\t * @param comment\r\n\t\t */\r\n\t\taddZipEntryComment: function (/**Object*/entry, /**String*/comment) {\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (item) {\r\n\t\t\t\titem.comment = comment;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the comment of the specified entry\r\n\t\t *\r\n\t\t * @param entry\r\n\t\t * @return String\r\n\t\t */\r\n\t\tgetZipEntryComment: function (/**Object*/entry) {\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (item) {\r\n\t\t\t\treturn item.comment || '';\r\n\t\t\t}\r\n\t\t\treturn ''\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content\r\n\t\t *\r\n\t\t * @param entry\r\n\t\t * @param content\r\n\t\t */\r\n\t\tupdateFile: function (/**Object*/entry, /**Buffer*/content) {\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (item) {\r\n\t\t\t\titem.setData(content);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds a file from the disk to the archive\r\n\t\t *\r\n\t\t * @param localPath File to add to zip\r\n\t\t * @param zipPath Optional path inside the zip\r\n\t\t * @param zipName Optional name for the file\r\n\t\t */\r\n\t\taddLocalFile: function (/**String*/localPath, /**String=*/zipPath, /**String=*/zipName) {\r\n\t\t\tif (fs.existsSync(localPath)) {\r\n\t\t\t\tif (zipPath) {\r\n\t\t\t\t\tzipPath = zipPath.split(\"\\\\\").join(\"/\");\r\n\t\t\t\t\tif (zipPath.charAt(zipPath.length - 1) !== \"/\") {\r\n\t\t\t\t\t\tzipPath += \"/\";\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tzipPath = \"\";\r\n\t\t\t\t}\r\n\t\t\t\tvar p = localPath.split(\"\\\\\").join(\"/\").split(\"/\").pop();\r\n\r\n\t\t\t\tif (zipName) {\r\n\t\t\t\t\tthis.addFile(zipPath + zipName, fs.readFileSync(localPath), \"\", 0)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.addFile(zipPath + p, fs.readFileSync(localPath), \"\", 0)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error(Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds a local directory and all its nested files and directories to the archive\r\n\t\t *\r\n\t\t * @param localPath\r\n\t\t * @param zipPath optional path inside zip\r\n\t\t * @param filter optional RegExp or Function if files match will\r\n\t\t *               be included.\r\n\t\t */\r\n\t\taddLocalFolder: function (/**String*/localPath, /**String=*/zipPath, /**=RegExp|Function*/filter) {\r\n\t\t\tif (filter === undefined) {\r\n\t\t\t\tfilter = function () {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t};\r\n\t\t\t} else if (filter instanceof RegExp) {\r\n\t\t\t\tfilter = function (filter) {\r\n\t\t\t\t\treturn function (filename) {\r\n\t\t\t\t\t\treturn filter.test(filename);\r\n\t\t\t\t\t}\r\n\t\t\t\t}(filter);\r\n\t\t\t}\r\n\r\n\t\t\tif (zipPath) {\r\n\t\t\t\tzipPath = zipPath.split(\"\\\\\").join(\"/\");\r\n\t\t\t\tif (zipPath.charAt(zipPath.length - 1) !== \"/\") {\r\n\t\t\t\t\tzipPath += \"/\";\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tzipPath = \"\";\r\n\t\t\t}\r\n\t\t\t// normalize the path first\r\n\t\t\tlocalPath = pth.normalize(localPath);\r\n\t\t\tlocalPath = localPath.split(\"\\\\\").join(\"/\"); //windows fix\r\n\t\t\tif (localPath.charAt(localPath.length - 1) !== \"/\")\r\n\t\t\t\tlocalPath += \"/\";\r\n\r\n\t\t\tif (fs.existsSync(localPath)) {\r\n\r\n\t\t\t\tvar items = Utils.findFiles(localPath),\r\n\t\t\t\t\tself = this;\r\n\r\n\t\t\t\tif (items.length) {\r\n\t\t\t\t\titems.forEach(function (path) {\r\n\t\t\t\t\t\tvar p = path.split(\"\\\\\").join(\"/\").replace(new RegExp(localPath.replace(/(\\(|\\)|\\$)/g, '\\\\$1'), 'i'), \"\"); //windows fix\r\n\t\t\t\t\t\tif (filter(p)) {\r\n\t\t\t\t\t\t\tif (p.charAt(p.length - 1) !== \"/\") {\r\n\t\t\t\t\t\t\t\tself.addFile(zipPath + p, fs.readFileSync(path), \"\", 0)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tself.addFile(zipPath + p, Buffer.alloc(0), \"\", 0)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error(Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Asynchronous addLocalFile\r\n\t\t * @param localPath\r\n\t\t * @param callback\r\n\t\t * @param zipPath optional path inside zip\r\n\t\t * @param filter optional RegExp or Function if files match will\r\n\t\t *               be included.\r\n\t\t */\r\n\t\taddLocalFolderAsync: function (/*String*/localPath, /*Function*/callback, /*String*/zipPath, /*RegExp|Function*/filter) {\r\n\t\t\tif (filter === undefined) {\r\n\t\t\t\tfilter = function () {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t};\r\n\t\t\t} else if (filter instanceof RegExp) {\r\n\t\t\t\tfilter = function (filter) {\r\n\t\t\t\t\treturn function (filename) {\r\n\t\t\t\t\t\treturn filter.test(filename);\r\n\t\t\t\t\t}\r\n\t\t\t\t}(filter);\r\n\t\t\t}\r\n\r\n\t\t\tif (zipPath) {\r\n\t\t\t\tzipPath = zipPath.split(\"\\\\\").join(\"/\");\r\n\t\t\t\tif (zipPath.charAt(zipPath.length - 1) !== \"/\") {\r\n\t\t\t\t\tzipPath += \"/\";\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tzipPath = \"\";\r\n\t\t\t}\r\n\t\t\t// normalize the path first\r\n\t\t\tlocalPath = pth.normalize(localPath);\r\n\t\t\tlocalPath = localPath.split(\"\\\\\").join(\"/\"); //windows fix\r\n\t\t\tif (localPath.charAt(localPath.length - 1) !== \"/\")\r\n\t\t\t\tlocalPath += \"/\";\r\n\r\n\t\t\tvar self = this;\r\n\t\t\tfs.open(localPath, 'r', function (err, fd) {\r\n\t\t\t\tif (err && err.code === 'ENOENT') {\r\n\t\t\t\t\tcallback(undefined, Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\r\n\t\t\t\t} else if (err) {\r\n\t\t\t\t\tcallback(undefined, err);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar items = Utils.findFiles(localPath);\r\n\t\t\t\t\tvar i = -1;\r\n\r\n\t\t\t\t\tvar next = function () {\r\n\t\t\t\t\t\ti += 1;\r\n\t\t\t\t\t\tif (i < items.length) {\r\n\t\t\t\t\t\t\tvar p = items[i].split(\"\\\\\").join(\"/\").replace(new RegExp(localPath.replace(/(\\(|\\))/g, '\\\\$1'), 'i'), \"\"); //windows fix\r\n\t\t\t\t\t\t\tp = p.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').replace(/[^\\x20-\\x7E]/g, '') // accent fix\r\n\t\t\t\t\t\t\tif (filter(p)) {\r\n\t\t\t\t\t\t\t\tif (p.charAt(p.length - 1) !== \"/\") {\r\n\t\t\t\t\t\t\t\t\tfs.readFile(items[i], function (err, data) {\r\n\t\t\t\t\t\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\t\t\t\t\t\tcallback(undefined, err);\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\tself.addFile(zipPath + p, data, '', 0);\r\n\t\t\t\t\t\t\t\t\t\t\tnext();\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tself.addFile(zipPath + p, Buffer.alloc(0), \"\", 0);\r\n\t\t\t\t\t\t\t\t\tnext();\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tnext();\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tcallback(true, undefined);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tnext();\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Allows you to create a entry (file or directory) in the zip file.\r\n\t\t * If you want to create a directory the entryName must end in / and a null buffer should be provided.\r\n\t\t * Comment and attributes are optional\r\n\t\t *\r\n\t\t * @param entryName\r\n\t\t * @param content\r\n\t\t * @param comment\r\n\t\t * @param attr\r\n\t\t */\r\n\t\taddFile: function (/**String*/entryName, /**Buffer*/content, /**String*/comment, /**Number*/attr) {\r\n\t\t\tvar entry = new ZipEntry();\r\n\t\t\tentry.entryName = entryName;\r\n\t\t\tentry.comment = comment || \"\";\r\n\r\n\t\t\tif (!attr) {\r\n\t\t\t\tif (entry.isDirectory) {\r\n\t\t\t\t\tattr = (0o40755 << 16) | 0x10; // (permissions drwxr-xr-x) + (MS-DOS directory flag)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tattr = 0o644 << 16; // permissions -r-wr--r--\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tentry.attr = attr;\r\n\r\n\t\t\tentry.setData(content);\r\n\t\t\t_zip.setEntry(entry);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns an array of ZipEntry objects representing the files and folders inside the archive\r\n\t\t *\r\n\t\t * @return Array\r\n\t\t */\r\n\t\tgetEntries: function () {\r\n\t\t\tif (_zip) {\r\n\t\t\t\treturn _zip.entries;\r\n\t\t\t} else {\r\n\t\t\t\treturn [];\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns a ZipEntry object representing the file or folder specified by ``name``.\r\n\t\t *\r\n\t\t * @param name\r\n\t\t * @return ZipEntry\r\n\t\t */\r\n\t\tgetEntry: function (/**String*/name) {\r\n\t\t\treturn getEntry(name);\r\n\t\t},\r\n\r\n\t\tgetEntryCount: function() {\r\n\t\t\treturn _zip.getEntryCount();\r\n\t\t},\r\n\r\n\t\tforEach: function(callback) {\r\n\t\t\treturn _zip.forEach(callback);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Extracts the given entry to the given targetPath\r\n\t\t * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted\r\n\t\t *\r\n\t\t * @param entry ZipEntry object or String with the full path of the entry\r\n\t\t * @param targetPath Target folder where to write the file\r\n\t\t * @param maintainEntryPath If maintainEntryPath is true and the entry is inside a folder, the entry folder\r\n\t\t *                          will be created in targetPath as well. Default is TRUE\r\n\t\t * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\r\n\t\t *                  Default is FALSE\r\n\t\t *\r\n\t\t * @return Boolean\r\n\t\t */\r\n\t\textractEntryTo: function (/**Object*/entry, /**String*/targetPath, /**Boolean*/maintainEntryPath, /**Boolean*/overwrite) {\r\n\t\t\toverwrite = overwrite || false;\r\n\t\t\tmaintainEntryPath = typeof maintainEntryPath === \"undefined\" ? true : maintainEntryPath;\r\n\r\n\t\t\tvar item = getEntry(entry);\r\n\t\t\tif (!item) {\r\n\t\t\t\tthrow new Error(Utils.Errors.NO_ENTRY);\r\n\t\t\t}\r\n\r\n\t\t\tvar entryName = item.entryName;\r\n\r\n\t\t\tvar target = sanitize(targetPath, maintainEntryPath ? entryName : pth.basename(entryName));\r\n\r\n\t\t\tif (item.isDirectory) {\r\n\t\t\t\ttarget = pth.resolve(target, \"..\");\r\n\t\t\t\tvar children = _zip.getEntryChildren(item);\r\n\t\t\t\tchildren.forEach(function (child) {\r\n\t\t\t\t\tif (child.isDirectory) return;\r\n\t\t\t\t\tvar content = child.getData();\r\n\t\t\t\t\tif (!content) {\r\n\t\t\t\t\t\tthrow new Error(Utils.Errors.CANT_EXTRACT_FILE);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar childName = sanitize(targetPath, maintainEntryPath ? child.entryName : pth.basename(child.entryName));\r\n\r\n\t\t\t\t\tUtils.writeFileTo(childName, content, overwrite);\r\n\t\t\t\t});\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\tvar content = item.getData();\r\n\t\t\tif (!content) throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\r\n\r\n\t\t\tif (fs.existsSync(target) && !overwrite) {\r\n\t\t\t\tthrow new Error(Utils.Errors.CANT_OVERRIDE);\r\n\t\t\t}\r\n\t\t\tUtils.writeFileTo(target, content, overwrite);\r\n\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Test the archive\r\n\t\t *\r\n\t\t */\r\n\t\ttest: function () {\r\n\t\t\tif (!_zip) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tfor (var entry in _zip.entries) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (entry.isDirectory) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar content = _zip.entries[entry].getData();\r\n\t\t\t\t\tif (!content) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (err) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Extracts the entire archive to the given location\r\n\t\t *\r\n\t\t * @param targetPath Target location\r\n\t\t * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\r\n\t\t *                  Default is FALSE\r\n\t\t */\r\n\t\textractAllTo: function (/**String*/targetPath, /**Boolean*/overwrite) {\r\n\t\t\toverwrite = overwrite || false;\r\n\t\t\tif (!_zip) {\r\n\t\t\t\tthrow new Error(Utils.Errors.NO_ZIP);\r\n\t\t\t}\r\n\t\t\t_zip.entries.forEach(function (entry) {\r\n\t\t\t\tvar entryName = sanitize(targetPath, entry.entryName.toString());\r\n\t\t\t\tif (entry.isDirectory) {\r\n\t\t\t\t\tUtils.makeDir(entryName);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tvar content = entry.getData();\r\n\t\t\t\tif (!content) {\r\n\t\t\t\t\tthrow new Error(Utils.Errors.CANT_EXTRACT_FILE);\r\n\t\t\t\t}\r\n\t\t\t\tUtils.writeFileTo(entryName, content, overwrite);\r\n\t\t\t\ttry {\r\n\t\t\t\t\tfs.utimesSync(entryName, entry.header.time, entry.header.time)\r\n\t\t\t\t} catch (err) {\r\n\t\t\t\t\tthrow new Error(Utils.Errors.CANT_EXTRACT_FILE);\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Asynchronous extractAllTo\r\n\t\t *\r\n\t\t * @param targetPath Target location\r\n\t\t * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\r\n\t\t *                  Default is FALSE\r\n\t\t * @param callback\r\n\t\t */\r\n\t\textractAllToAsync: function (/**String*/targetPath, /**Boolean*/overwrite, /**Function*/callback) {\r\n\t\t\tif (!callback) {\r\n\t\t\t\tcallback = function() {}\r\n\t\t\t}\r\n\t\t\toverwrite = overwrite || false;\r\n\t\t\tif (!_zip) {\r\n\t\t\t\tcallback(new Error(Utils.Errors.NO_ZIP));\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar entries = _zip.entries;\r\n\t\t\tvar i = entries.length;\r\n\t\t\tentries.forEach(function (entry) {\r\n\t\t\t\tif (i <= 0) return; // Had an error already\r\n\r\n\t\t\t\tvar entryName = pth.normalize(entry.entryName.toString());\r\n\r\n\t\t\t\tif (entry.isDirectory) {\r\n\t\t\t\t\tUtils.makeDir(sanitize(targetPath, entryName));\r\n\t\t\t\t\tif (--i === 0)\r\n\t\t\t\t\t\tcallback(undefined);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tentry.getDataAsync(function (content, err) {\r\n\t\t\t\t\tif (i <= 0) return;\r\n\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\tcallback(new Error(err));\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!content) {\r\n\t\t\t\t\t\ti = 0;\r\n\t\t\t\t\t\tcallback(new Error(Utils.Errors.CANT_EXTRACT_FILE));\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tUtils.writeFileToAsync(sanitize(targetPath, entryName), content, overwrite, function (succ) {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tfs.utimesSync(pth.resolve(targetPath, entryName), entry.header.time, entry.header.time);\r\n\t\t\t\t\t\t} catch (err) {\r\n\t\t\t\t\t\t\tcallback(new Error('Unable to set utimes'));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (i <= 0) return;\r\n\t\t\t\t\t\tif (!succ) {\r\n\t\t\t\t\t\t\ti = 0;\r\n\t\t\t\t\t\t\tcallback(new Error('Unable to write'));\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (--i === 0)\r\n\t\t\t\t\t\t\tcallback(undefined);\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip\r\n\t\t *\r\n\t\t * @param targetFileName\r\n\t\t * @param callback\r\n\t\t */\r\n\t\twriteZip: function (/**String*/targetFileName, /**Function*/callback) {\r\n\t\t\tif (arguments.length === 1) {\r\n\t\t\t\tif (typeof targetFileName === \"function\") {\r\n\t\t\t\t\tcallback = targetFileName;\r\n\t\t\t\t\ttargetFileName = \"\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (!targetFileName && _filename) {\r\n\t\t\t\ttargetFileName = _filename;\r\n\t\t\t}\r\n\t\t\tif (!targetFileName) return;\r\n\r\n\t\t\tvar zipData = _zip.compressToBuffer();\r\n\t\t\tif (zipData) {\r\n\t\t\t\tvar ok = Utils.writeFileTo(targetFileName, zipData, true);\r\n\t\t\t\tif (typeof callback === 'function') callback(!ok ? new Error(\"failed\") : null, \"\");\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the content of the entire zip file as a Buffer object\r\n\t\t *\r\n\t\t * @return Buffer\r\n\t\t */\r\n\t\ttoBuffer: function (/**Function=*/onSuccess, /**Function=*/onFail, /**Function=*/onItemStart, /**Function=*/onItemEnd) {\r\n\t\t\tthis.valueOf = 2;\r\n\t\t\tif (typeof onSuccess === \"function\") {\r\n\t\t\t\t_zip.toAsyncBuffer(onSuccess, onFail, onItemStart, onItemEnd);\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\treturn _zip.compressToBuffer()\r\n\t\t}\r\n\t}\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}