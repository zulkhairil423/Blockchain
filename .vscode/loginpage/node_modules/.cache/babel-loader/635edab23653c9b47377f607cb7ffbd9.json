{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getExtensions = void 0;\n\nconst util_1 = require(\"./util\");\n\nconst nodeEquivalents = new Map([['.ts', '.js'], ['.tsx', '.js'], ['.jsx', '.js'], ['.mts', '.mjs'], ['.cts', '.cjs']]);\nconst tsResolverEquivalents = new Map([['.ts', ['.js']], ['.tsx', ['.js', '.jsx']], ['.mts', ['.mjs']], ['.cts', ['.cjs']]]); // All extensions understood by vanilla node\n\nconst vanillaNodeExtensions = ['.js', '.json', '.node', '.mjs', '.cjs']; // Extensions added by vanilla node's require() if you omit them:\n// js, json, node\n// Extensions added by vanilla node if you omit them with --experimental-specifier-resolution=node\n// js, json, node, mjs\n// Extensions added by ESM codepath's legacy package.json \"main\" resolver\n// js, json, node (not mjs!)\n\nconst nodeDoesNotUnderstand = ['.ts', '.tsx', '.jsx', '.cts', '.mts'];\n/**\n * [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n * @internal\n */\n\nfunction getExtensions(config, options, tsVersion) {\n  // TS 4.5 is first version to understand .cts, .mts, .cjs, and .mjs extensions\n  const tsSupportsMtsCtsExts = (0, util_1.versionGteLt)(tsVersion, '4.5.0');\n  const requiresHigherTypescriptVersion = [];\n  if (!tsSupportsMtsCtsExts) requiresHigherTypescriptVersion.push('.cts', '.cjs', '.mts', '.mjs');\n  const allPossibleExtensionsSortedByPreference = Array.from(new Set([...(options.preferTsExts ? nodeDoesNotUnderstand : []), ...vanillaNodeExtensions, ...nodeDoesNotUnderstand]));\n  const compiledJsUnsorted = ['.ts'];\n  const compiledJsxUnsorted = [];\n  if (config.options.jsx) compiledJsxUnsorted.push('.tsx');\n  if (tsSupportsMtsCtsExts) compiledJsUnsorted.push('.mts', '.cts');\n\n  if (config.options.allowJs) {\n    compiledJsUnsorted.push('.js');\n    if (config.options.jsx) compiledJsxUnsorted.push('.jsx');\n    if (tsSupportsMtsCtsExts) compiledJsUnsorted.push('.mjs', '.cjs');\n  }\n\n  const compiledUnsorted = [...compiledJsUnsorted, ...compiledJsxUnsorted];\n  const compiled = allPossibleExtensionsSortedByPreference.filter(ext => compiledUnsorted.includes(ext));\n  const compiledNodeDoesNotUnderstand = nodeDoesNotUnderstand.filter(ext => compiled.includes(ext));\n  /**\n   * TS's resolver can resolve foo.js to foo.ts, by replacing .js extension with several source extensions.\n   * IMPORTANT: Must preserve ordering according to preferTsExts!\n   *            Must include the .js/.mjs/.cjs extension in the array!\n   *            This affects resolution behavior!\n   * [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n   */\n\n  const r = allPossibleExtensionsSortedByPreference.filter(ext => [...compiledUnsorted, '.js', '.mjs', '.cjs', '.mts', '.cts'].includes(ext));\n  const replacementsForJs = r.filter(ext => ['.js', '.jsx', '.ts', '.tsx'].includes(ext));\n  const replacementsForJsx = r.filter(ext => ['.jsx', '.tsx'].includes(ext));\n  const replacementsForMjs = r.filter(ext => ['.mjs', '.mts'].includes(ext));\n  const replacementsForCjs = r.filter(ext => ['.cjs', '.cts'].includes(ext));\n  const replacementsForJsOrMjs = r.filter(ext => ['.js', '.jsx', '.ts', '.tsx', '.mjs', '.mts'].includes(ext)); // Node allows omitting .js or .mjs extension in certain situations (CJS, ESM w/experimental flag)\n  // So anything that compiles to .js or .mjs can also be omitted.\n\n  const experimentalSpecifierResolutionAddsIfOmitted = Array.from(new Set([...replacementsForJsOrMjs, '.json', '.node'])); // Same as above, except node curiuosly doesn't do .mjs here\n\n  const legacyMainResolveAddsIfOmitted = Array.from(new Set([...replacementsForJs, '.json', '.node']));\n  return {\n    /** All file extensions we transform, ordered by resolution preference according to preferTsExts */\n    compiled,\n\n    /** Resolved extensions that vanilla node will not understand; we should handle them */\n    nodeDoesNotUnderstand,\n\n    /** Like the above, but only the ones we're compiling */\n    compiledNodeDoesNotUnderstand,\n\n    /**\n     * Mapping from extensions understood by tsc to the equivalent for node,\n     * as far as getFormat is concerned.\n     */\n    nodeEquivalents,\n\n    /**\n     * Mapping from extensions rejected by TSC in import specifiers, to the\n     * possible alternatives that TS's resolver will accept.\n     *\n     * When we allow users to opt-in to .ts extensions in import specifiers, TS's\n     * resolver requires us to replace the .ts extensions with .js alternatives.\n     * Otherwise, resolution fails.\n     *\n     * Note TS's resolver is only used by, and only required for, typechecking.\n     * This is separate from node's resolver, which we hook separately and which\n     * does not require this mapping.\n     */\n    tsResolverEquivalents,\n\n    /**\n     * Extensions that we can support if the user upgrades their typescript version.\n     * Used when raising hints.\n     */\n    requiresHigherTypescriptVersion,\n\n    /**\n     * --experimental-specifier-resolution=node will add these extensions.\n     */\n    experimentalSpecifierResolutionAddsIfOmitted,\n\n    /**\n     * ESM loader will add these extensions to package.json \"main\" field\n     */\n    legacyMainResolveAddsIfOmitted,\n    replacementsForMjs,\n    replacementsForCjs,\n    replacementsForJsx,\n    replacementsForJs\n  };\n}\n\nexports.getExtensions = getExtensions;","map":{"version":3,"mappings":"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","names":["nodeEquivalents","Map","tsResolverEquivalents","vanillaNodeExtensions","nodeDoesNotUnderstand","getExtensions","config","options","tsVersion","tsSupportsMtsCtsExts","requiresHigherTypescriptVersion","push","allPossibleExtensionsSortedByPreference","Array","from","Set","preferTsExts","compiledJsUnsorted","compiledJsxUnsorted","jsx","allowJs","compiledUnsorted","compiled","filter","ext","includes","compiledNodeDoesNotUnderstand","r","replacementsForJs","replacementsForJsx","replacementsForMjs","replacementsForCjs","replacementsForJsOrMjs","experimentalSpecifierResolutionAddsIfOmitted","legacyMainResolveAddsIfOmitted","exports"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\ts-node\\src\\file-extensions.ts"],"sourcesContent":["import type * as _ts from 'typescript';\nimport type { RegisterOptions } from '.';\nimport { versionGteLt } from './util';\n\n/**\n * Centralized specification of how we deal with file extensions based on\n * project options:\n * which ones we do/don't support, in what situations, etc.  These rules drive\n * logic elsewhere.\n * @internal\n * */\nexport type Extensions = ReturnType<typeof getExtensions>;\n\nconst nodeEquivalents = new Map<string, string>([\n  ['.ts', '.js'],\n  ['.tsx', '.js'],\n  ['.jsx', '.js'],\n  ['.mts', '.mjs'],\n  ['.cts', '.cjs'],\n]);\n\nconst tsResolverEquivalents = new Map<string, readonly string[]>([\n  ['.ts', ['.js']],\n  ['.tsx', ['.js', '.jsx']],\n  ['.mts', ['.mjs']],\n  ['.cts', ['.cjs']],\n]);\n\n// All extensions understood by vanilla node\nconst vanillaNodeExtensions: readonly string[] = [\n  '.js',\n  '.json',\n  '.node',\n  '.mjs',\n  '.cjs',\n];\n\n// Extensions added by vanilla node's require() if you omit them:\n// js, json, node\n// Extensions added by vanilla node if you omit them with --experimental-specifier-resolution=node\n// js, json, node, mjs\n// Extensions added by ESM codepath's legacy package.json \"main\" resolver\n// js, json, node (not mjs!)\n\nconst nodeDoesNotUnderstand: readonly string[] = [\n  '.ts',\n  '.tsx',\n  '.jsx',\n  '.cts',\n  '.mts',\n];\n\n/**\n * [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n * @internal\n */\nexport function getExtensions(\n  config: _ts.ParsedCommandLine,\n  options: RegisterOptions,\n  tsVersion: string\n) {\n  // TS 4.5 is first version to understand .cts, .mts, .cjs, and .mjs extensions\n  const tsSupportsMtsCtsExts = versionGteLt(tsVersion, '4.5.0');\n\n  const requiresHigherTypescriptVersion: string[] = [];\n  if (!tsSupportsMtsCtsExts)\n    requiresHigherTypescriptVersion.push('.cts', '.cjs', '.mts', '.mjs');\n\n  const allPossibleExtensionsSortedByPreference = Array.from(\n    new Set([\n      ...(options.preferTsExts ? nodeDoesNotUnderstand : []),\n      ...vanillaNodeExtensions,\n      ...nodeDoesNotUnderstand,\n    ])\n  );\n\n  const compiledJsUnsorted: string[] = ['.ts'];\n  const compiledJsxUnsorted: string[] = [];\n\n  if (config.options.jsx) compiledJsxUnsorted.push('.tsx');\n  if (tsSupportsMtsCtsExts) compiledJsUnsorted.push('.mts', '.cts');\n  if (config.options.allowJs) {\n    compiledJsUnsorted.push('.js');\n    if (config.options.jsx) compiledJsxUnsorted.push('.jsx');\n    if (tsSupportsMtsCtsExts) compiledJsUnsorted.push('.mjs', '.cjs');\n  }\n\n  const compiledUnsorted = [...compiledJsUnsorted, ...compiledJsxUnsorted];\n  const compiled = allPossibleExtensionsSortedByPreference.filter((ext) =>\n    compiledUnsorted.includes(ext)\n  );\n\n  const compiledNodeDoesNotUnderstand = nodeDoesNotUnderstand.filter((ext) =>\n    compiled.includes(ext)\n  );\n\n  /**\n   * TS's resolver can resolve foo.js to foo.ts, by replacing .js extension with several source extensions.\n   * IMPORTANT: Must preserve ordering according to preferTsExts!\n   *            Must include the .js/.mjs/.cjs extension in the array!\n   *            This affects resolution behavior!\n   * [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n   */\n  const r = allPossibleExtensionsSortedByPreference.filter((ext) =>\n    [...compiledUnsorted, '.js', '.mjs', '.cjs', '.mts', '.cts'].includes(ext)\n  );\n  const replacementsForJs = r.filter((ext) =>\n    ['.js', '.jsx', '.ts', '.tsx'].includes(ext)\n  );\n  const replacementsForJsx = r.filter((ext) => ['.jsx', '.tsx'].includes(ext));\n  const replacementsForMjs = r.filter((ext) => ['.mjs', '.mts'].includes(ext));\n  const replacementsForCjs = r.filter((ext) => ['.cjs', '.cts'].includes(ext));\n  const replacementsForJsOrMjs = r.filter((ext) =>\n    ['.js', '.jsx', '.ts', '.tsx', '.mjs', '.mts'].includes(ext)\n  );\n\n  // Node allows omitting .js or .mjs extension in certain situations (CJS, ESM w/experimental flag)\n  // So anything that compiles to .js or .mjs can also be omitted.\n  const experimentalSpecifierResolutionAddsIfOmitted = Array.from(\n    new Set([...replacementsForJsOrMjs, '.json', '.node'])\n  );\n  // Same as above, except node curiuosly doesn't do .mjs here\n  const legacyMainResolveAddsIfOmitted = Array.from(\n    new Set([...replacementsForJs, '.json', '.node'])\n  );\n\n  return {\n    /** All file extensions we transform, ordered by resolution preference according to preferTsExts */\n    compiled,\n    /** Resolved extensions that vanilla node will not understand; we should handle them */\n    nodeDoesNotUnderstand,\n    /** Like the above, but only the ones we're compiling */\n    compiledNodeDoesNotUnderstand,\n    /**\n     * Mapping from extensions understood by tsc to the equivalent for node,\n     * as far as getFormat is concerned.\n     */\n    nodeEquivalents,\n    /**\n     * Mapping from extensions rejected by TSC in import specifiers, to the\n     * possible alternatives that TS's resolver will accept.\n     *\n     * When we allow users to opt-in to .ts extensions in import specifiers, TS's\n     * resolver requires us to replace the .ts extensions with .js alternatives.\n     * Otherwise, resolution fails.\n     *\n     * Note TS's resolver is only used by, and only required for, typechecking.\n     * This is separate from node's resolver, which we hook separately and which\n     * does not require this mapping.\n     */\n    tsResolverEquivalents,\n    /**\n     * Extensions that we can support if the user upgrades their typescript version.\n     * Used when raising hints.\n     */\n    requiresHigherTypescriptVersion,\n    /**\n     * --experimental-specifier-resolution=node will add these extensions.\n     */\n    experimentalSpecifierResolutionAddsIfOmitted,\n    /**\n     * ESM loader will add these extensions to package.json \"main\" field\n     */\n    legacyMainResolveAddsIfOmitted,\n    replacementsForMjs,\n    replacementsForCjs,\n    replacementsForJsx,\n    replacementsForJs,\n  };\n}\n"]},"metadata":{},"sourceType":"script"}