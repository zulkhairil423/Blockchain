{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Parser = void 0;\n\nconst solidity_files_cache_1 = require(\"../../builtin-tasks/utils/solidity-files-cache\");\n\nconst errors_1 = require(\"../core/errors\");\n\nconst errors_list_1 = require(\"../core/errors-list\");\n\nclass Parser {\n  constructor(_solidityFilesCache) {\n    this._cache = new Map();\n    this._solidityFilesCache = _solidityFilesCache ?? solidity_files_cache_1.SolidityFilesCache.createEmpty();\n  }\n\n  parse(fileContent, absolutePath, contentHash) {\n    const cacheResult = this._getFromCache(absolutePath, contentHash);\n\n    if (cacheResult !== null) {\n      return cacheResult;\n    }\n\n    try {\n      const {\n        analyze\n      } = require(\"@nomicfoundation/solidity-analyzer\");\n\n      const result = analyze(fileContent);\n\n      this._cache.set(contentHash, result);\n\n      return result;\n    } catch (e) {\n      if (e.code === \"MODULE_NOT_FOUND\") {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.CORRUPTED_LOCKFILE);\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw e;\n    }\n  }\n  /**\n   * Get parsed data from the internal cache, or from the solidity files cache.\n   *\n   * Returns null if cannot find it in either one.\n   */\n\n\n  _getFromCache(absolutePath, contentHash) {\n    const internalCacheEntry = this._cache.get(contentHash);\n\n    if (internalCacheEntry !== undefined) {\n      return internalCacheEntry;\n    }\n\n    const solidityFilesCacheEntry = this._solidityFilesCache.getEntry(absolutePath);\n\n    if (solidityFilesCacheEntry === undefined) {\n      return null;\n    }\n\n    const {\n      imports,\n      versionPragmas\n    } = solidityFilesCacheEntry;\n\n    if (solidityFilesCacheEntry.contentHash !== contentHash) {\n      return null;\n    }\n\n    return {\n      imports,\n      versionPragmas\n    };\n  }\n\n}\n\nexports.Parser = Parser;","map":{"version":3,"mappings":";;;;;;;AAEA;;AACA;;AACA;;AAOA,MAAaA,MAAb,CAAmB;EAIjBC,YAAYC,mBAAZ,EAAoD;IAH5C,cAAS,IAAIC,GAAJ,EAAT;IAIN,KAAKD,mBAAL,GACEA,mBAAmB,IAAIE,0CAAmBC,WAAnB,EADzB;EAED;;EAEMC,KAAK,CACVC,WADU,EAEVC,YAFU,EAGVC,WAHU,EAGS;IAEnB,MAAMC,WAAW,GAAG,KAAKC,aAAL,CAAmBH,YAAnB,EAAiCC,WAAjC,CAApB;;IAEA,IAAIC,WAAW,KAAK,IAApB,EAA0B;MACxB,OAAOA,WAAP;IACD;;IAED,IAAI;MACF,MAAM;QAAEE;MAAF,IACJC,OAAO,CAAC,oCAAD,CADT;;MAEA,MAAMC,MAAM,GAAGF,OAAO,CAACL,WAAD,CAAtB;;MAEA,KAAKQ,MAAL,CAAYC,GAAZ,CAAgBP,WAAhB,EAA6BK,MAA7B;;MAEA,OAAOA,MAAP;IACD,CARD,CAQE,OAAOG,CAAP,EAAe;MACf,IAAIA,CAAC,CAACC,IAAF,KAAW,kBAAf,EAAmC;QACjC,MAAM,IAAIC,qBAAJ,CAAiBC,qBAAOC,OAAP,CAAeC,kBAAhC,CAAN;MACD,CAHc,CAKf;;;MACA,MAAML,CAAN;IACD;EACF;EAED;;;;;;;EAKQN,aAAa,CACnBH,YADmB,EAEnBC,WAFmB,EAEA;IAEnB,MAAMc,kBAAkB,GAAG,KAAKR,MAAL,CAAYS,GAAZ,CAAgBf,WAAhB,CAA3B;;IAEA,IAAIc,kBAAkB,KAAKE,SAA3B,EAAsC;MACpC,OAAOF,kBAAP;IACD;;IAED,MAAMG,uBAAuB,GAC3B,KAAKxB,mBAAL,CAAyByB,QAAzB,CAAkCnB,YAAlC,CADF;;IAGA,IAAIkB,uBAAuB,KAAKD,SAAhC,EAA2C;MACzC,OAAO,IAAP;IACD;;IAED,MAAM;MAAEG,OAAF;MAAWC;IAAX,IAA8BH,uBAApC;;IAEA,IAAIA,uBAAuB,CAACjB,WAAxB,KAAwCA,WAA5C,EAAyD;MACvD,OAAO,IAAP;IACD;;IAED,OAAO;MAAEmB,OAAF;MAAWC;IAAX,CAAP;EACD;;AAnEgB;;AAAnBC","names":["Parser","constructor","_solidityFilesCache","Map","solidity_files_cache_1","createEmpty","parse","fileContent","absolutePath","contentHash","cacheResult","_getFromCache","analyze","require","result","_cache","set","e","code","errors_1","errors_list_1","GENERAL","CORRUPTED_LOCKFILE","internalCacheEntry","get","undefined","solidityFilesCacheEntry","getEntry","imports","versionPragmas","exports"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\hardhat\\src\\internal\\solidity\\parse.ts"],"sourcesContent":["import type SolidityAnalyzerT from \"@nomicfoundation/solidity-analyzer\";\n\nimport { SolidityFilesCache } from \"../../builtin-tasks/utils/solidity-files-cache\";\nimport { HardhatError } from \"../core/errors\";\nimport { ERRORS } from \"../core/errors-list\";\n\ninterface ParsedData {\n  imports: string[];\n  versionPragmas: string[];\n}\n\nexport class Parser {\n  private _cache = new Map<string, ParsedData>();\n  private _solidityFilesCache: SolidityFilesCache;\n\n  constructor(_solidityFilesCache?: SolidityFilesCache) {\n    this._solidityFilesCache =\n      _solidityFilesCache ?? SolidityFilesCache.createEmpty();\n  }\n\n  public parse(\n    fileContent: string,\n    absolutePath: string,\n    contentHash: string\n  ): ParsedData {\n    const cacheResult = this._getFromCache(absolutePath, contentHash);\n\n    if (cacheResult !== null) {\n      return cacheResult;\n    }\n\n    try {\n      const { analyze } =\n        require(\"@nomicfoundation/solidity-analyzer\") as typeof SolidityAnalyzerT;\n      const result = analyze(fileContent);\n\n      this._cache.set(contentHash, result);\n\n      return result;\n    } catch (e: any) {\n      if (e.code === \"MODULE_NOT_FOUND\") {\n        throw new HardhatError(ERRORS.GENERAL.CORRUPTED_LOCKFILE);\n      }\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    }\n  }\n\n  /**\n   * Get parsed data from the internal cache, or from the solidity files cache.\n   *\n   * Returns null if cannot find it in either one.\n   */\n  private _getFromCache(\n    absolutePath: string,\n    contentHash: string\n  ): ParsedData | null {\n    const internalCacheEntry = this._cache.get(contentHash);\n\n    if (internalCacheEntry !== undefined) {\n      return internalCacheEntry;\n    }\n\n    const solidityFilesCacheEntry =\n      this._solidityFilesCache.getEntry(absolutePath);\n\n    if (solidityFilesCacheEntry === undefined) {\n      return null;\n    }\n\n    const { imports, versionPragmas } = solidityFilesCacheEntry;\n\n    if (solidityFilesCacheEntry.contentHash !== contentHash) {\n      return null;\n    }\n\n    return { imports, versionPragmas };\n  }\n}\n"]},"metadata":{},"sourceType":"script"}