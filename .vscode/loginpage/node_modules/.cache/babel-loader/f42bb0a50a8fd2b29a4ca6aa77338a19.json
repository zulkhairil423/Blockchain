{"ast":null,"code":"// copied from https://github.com/nodejs/node/blob/88799930794045795e8abac874730f9eba7e2300/lib/internal/repl/await.js\n'use strict';\n\nconst {\n  ArrayFrom,\n  ArrayPrototypeForEach,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeJoin,\n  ArrayPrototypePop,\n  ArrayPrototypePush,\n  FunctionPrototype,\n  ObjectKeys,\n  RegExpPrototypeSymbolReplace,\n  StringPrototypeEndsWith,\n  StringPrototypeIncludes,\n  StringPrototypeIndexOf,\n  StringPrototypeRepeat,\n  StringPrototypeSplit,\n  StringPrototypeStartsWith,\n  SyntaxError\n} = require('./node-primordials');\n\nconst parser = require('acorn').Parser;\n\nconst walk = require('acorn-walk');\n\nconst {\n  Recoverable\n} = require('repl');\n\nfunction isTopLevelDeclaration(state) {\n  return state.ancestors[state.ancestors.length - 2] === state.body;\n}\n\nconst noop = FunctionPrototype;\nconst visitorsWithoutAncestors = {\n  ClassDeclaration(node, state, c) {\n    if (isTopLevelDeclaration(state)) {\n      state.prepend(node, `${node.id.name}=`);\n      ArrayPrototypePush(state.hoistedDeclarationStatements, `let ${node.id.name}; `);\n    }\n\n    walk.base.ClassDeclaration(node, state, c);\n  },\n\n  ForOfStatement(node, state, c) {\n    if (node.await === true) {\n      state.containsAwait = true;\n    }\n\n    walk.base.ForOfStatement(node, state, c);\n  },\n\n  FunctionDeclaration(node, state, c) {\n    state.prepend(node, `${node.id.name}=`);\n    ArrayPrototypePush(state.hoistedDeclarationStatements, `var ${node.id.name}; `);\n  },\n\n  FunctionExpression: noop,\n  ArrowFunctionExpression: noop,\n  MethodDefinition: noop,\n\n  AwaitExpression(node, state, c) {\n    state.containsAwait = true;\n    walk.base.AwaitExpression(node, state, c);\n  },\n\n  ReturnStatement(node, state, c) {\n    state.containsReturn = true;\n    walk.base.ReturnStatement(node, state, c);\n  },\n\n  VariableDeclaration(node, state, c) {\n    const variableKind = node.kind;\n    const isIterableForDeclaration = ArrayPrototypeIncludes(['ForOfStatement', 'ForInStatement'], state.ancestors[state.ancestors.length - 2].type);\n\n    if (variableKind === 'var' || isTopLevelDeclaration(state)) {\n      state.replace(node.start, node.start + variableKind.length + (isIterableForDeclaration ? 1 : 0), variableKind === 'var' && isIterableForDeclaration ? '' : 'void' + (node.declarations.length === 1 ? '' : ' ('));\n\n      if (!isIterableForDeclaration) {\n        ArrayPrototypeForEach(node.declarations, decl => {\n          state.prepend(decl, '(');\n          state.append(decl, decl.init ? ')' : '=undefined)');\n        });\n\n        if (node.declarations.length !== 1) {\n          state.append(node.declarations[node.declarations.length - 1], ')');\n        }\n      }\n\n      const variableIdentifiersToHoist = [['var', []], ['let', []]];\n\n      function registerVariableDeclarationIdentifiers(node) {\n        switch (node.type) {\n          case 'Identifier':\n            ArrayPrototypePush(variableIdentifiersToHoist[variableKind === 'var' ? 0 : 1][1], node.name);\n            break;\n\n          case 'ObjectPattern':\n            ArrayPrototypeForEach(node.properties, property => {\n              registerVariableDeclarationIdentifiers(property.value);\n            });\n            break;\n\n          case 'ArrayPattern':\n            ArrayPrototypeForEach(node.elements, element => {\n              registerVariableDeclarationIdentifiers(element);\n            });\n            break;\n        }\n      }\n\n      ArrayPrototypeForEach(node.declarations, decl => {\n        registerVariableDeclarationIdentifiers(decl.id);\n      });\n      ArrayPrototypeForEach(variableIdentifiersToHoist, _ref => {\n        let {\n          0: kind,\n          1: identifiers\n        } = _ref;\n\n        if (identifiers.length > 0) {\n          ArrayPrototypePush(state.hoistedDeclarationStatements, `${kind} ${ArrayPrototypeJoin(identifiers, ', ')}; `);\n        }\n      });\n    }\n\n    walk.base.VariableDeclaration(node, state, c);\n  }\n\n};\nconst visitors = {};\n\nfor (const nodeType of ObjectKeys(walk.base)) {\n  const callback = visitorsWithoutAncestors[nodeType] || walk.base[nodeType];\n\n  visitors[nodeType] = (node, state, c) => {\n    const isNew = node !== state.ancestors[state.ancestors.length - 1];\n\n    if (isNew) {\n      ArrayPrototypePush(state.ancestors, node);\n    }\n\n    callback(node, state, c);\n\n    if (isNew) {\n      ArrayPrototypePop(state.ancestors);\n    }\n  };\n}\n\nfunction processTopLevelAwait(src) {\n  const wrapPrefix = '(async () => { ';\n  const wrapped = `${wrapPrefix}${src} })()`;\n  const wrappedArray = ArrayFrom(wrapped);\n  let root;\n\n  try {\n    root = parser.parse(wrapped, {\n      ecmaVersion: 'latest'\n    });\n  } catch (e) {\n    if (StringPrototypeStartsWith(e.message, 'Unterminated ')) throw new Recoverable(e); // If the parse error is before the first \"await\", then use the execution\n    // error. Otherwise we must emit this parse error, making it look like a\n    // proper syntax error.\n\n    const awaitPos = StringPrototypeIndexOf(src, 'await');\n    const errPos = e.pos - wrapPrefix.length;\n    if (awaitPos > errPos) return null; // Convert keyword parse errors on await into their original errors when\n    // possible.\n\n    if (errPos === awaitPos + 6 && StringPrototypeIncludes(e.message, 'Expecting Unicode escape sequence')) return null;\n    if (errPos === awaitPos + 7 && StringPrototypeIncludes(e.message, 'Unexpected token')) return null;\n    const line = e.loc.line;\n    const column = line === 1 ? e.loc.column - wrapPrefix.length : e.loc.column;\n    let message = '\\n' + StringPrototypeSplit(src, '\\n')[line - 1] + '\\n' + StringPrototypeRepeat(' ', column) + '^\\n\\n' + RegExpPrototypeSymbolReplace(/ \\([^)]+\\)/, e.message, ''); // V8 unexpected token errors include the token string.\n\n    if (StringPrototypeEndsWith(message, 'Unexpected token')) message += \" '\" + ( // Wrapper end may cause acorn to report error position after the source\n    src.length - 1 >= e.pos - wrapPrefix.length ? src[e.pos - wrapPrefix.length] : src[src.length - 1]) + \"'\"; // eslint-disable-next-line no-restricted-syntax\n\n    throw new SyntaxError(message);\n  }\n\n  const body = root.body[0].expression.callee.body;\n  const state = {\n    body,\n    ancestors: [],\n    hoistedDeclarationStatements: [],\n\n    replace(from, to, str) {\n      for (let i = from; i < to; i++) {\n        wrappedArray[i] = '';\n      }\n\n      if (from === to) str += wrappedArray[from];\n      wrappedArray[from] = str;\n    },\n\n    prepend(node, str) {\n      wrappedArray[node.start] = str + wrappedArray[node.start];\n    },\n\n    append(node, str) {\n      wrappedArray[node.end - 1] += str;\n    },\n\n    containsAwait: false,\n    containsReturn: false\n  };\n  walk.recursive(body, state, visitors); // Do not transform if\n  // 1. False alarm: there isn't actually an await expression.\n  // 2. There is a top-level return, which is not allowed.\n\n  if (!state.containsAwait || state.containsReturn) {\n    return null;\n  }\n\n  const last = body.body[body.body.length - 1];\n\n  if (last.type === 'ExpressionStatement') {\n    // For an expression statement of the form\n    // ( expr ) ;\n    // ^^^^^^^^^^   // last\n    //   ^^^^       // last.expression\n    //\n    // We do not want the left parenthesis before the `return` keyword;\n    // therefore we prepend the `return (` to `last`.\n    //\n    // On the other hand, we do not want the right parenthesis after the\n    // semicolon. Since there can only be more right parentheses between\n    // last.expression.end and the semicolon, appending one more to\n    // last.expression should be fine.\n    state.prepend(last, 'return (');\n    state.append(last.expression, ')');\n  }\n\n  return ArrayPrototypeJoin(state.hoistedDeclarationStatements, '') + ArrayPrototypeJoin(wrappedArray, '');\n}\n\nmodule.exports = {\n  processTopLevelAwait\n};","map":{"version":3,"names":["ArrayFrom","ArrayPrototypeForEach","ArrayPrototypeIncludes","ArrayPrototypeJoin","ArrayPrototypePop","ArrayPrototypePush","FunctionPrototype","ObjectKeys","RegExpPrototypeSymbolReplace","StringPrototypeEndsWith","StringPrototypeIncludes","StringPrototypeIndexOf","StringPrototypeRepeat","StringPrototypeSplit","StringPrototypeStartsWith","SyntaxError","require","parser","Parser","walk","Recoverable","isTopLevelDeclaration","state","ancestors","length","body","noop","visitorsWithoutAncestors","ClassDeclaration","node","c","prepend","id","name","hoistedDeclarationStatements","base","ForOfStatement","await","containsAwait","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","MethodDefinition","AwaitExpression","ReturnStatement","containsReturn","VariableDeclaration","variableKind","kind","isIterableForDeclaration","type","replace","start","declarations","decl","append","init","variableIdentifiersToHoist","registerVariableDeclarationIdentifiers","properties","property","value","elements","element","identifiers","visitors","nodeType","callback","isNew","processTopLevelAwait","src","wrapPrefix","wrapped","wrappedArray","root","parse","ecmaVersion","e","message","awaitPos","errPos","pos","line","loc","column","expression","callee","from","to","str","i","end","recursive","last","module","exports"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/ts-node/dist-raw/node-internal-repl-await.js"],"sourcesContent":["// copied from https://github.com/nodejs/node/blob/88799930794045795e8abac874730f9eba7e2300/lib/internal/repl/await.js\n'use strict';\n\nconst {\n  ArrayFrom,\n  ArrayPrototypeForEach,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeJoin,\n  ArrayPrototypePop,\n  ArrayPrototypePush,\n  FunctionPrototype,\n  ObjectKeys,\n  RegExpPrototypeSymbolReplace,\n  StringPrototypeEndsWith,\n  StringPrototypeIncludes,\n  StringPrototypeIndexOf,\n  StringPrototypeRepeat,\n  StringPrototypeSplit,\n  StringPrototypeStartsWith,\n  SyntaxError,\n} = require('./node-primordials');\n\nconst parser = require('acorn').Parser;\nconst walk = require('acorn-walk');\nconst { Recoverable } = require('repl');\n\nfunction isTopLevelDeclaration(state) {\n  return state.ancestors[state.ancestors.length - 2] === state.body;\n}\n\nconst noop = FunctionPrototype;\nconst visitorsWithoutAncestors = {\n  ClassDeclaration(node, state, c) {\n    if (isTopLevelDeclaration(state)) {\n      state.prepend(node, `${node.id.name}=`);\n      ArrayPrototypePush(\n        state.hoistedDeclarationStatements,\n        `let ${node.id.name}; `\n      );\n    }\n\n    walk.base.ClassDeclaration(node, state, c);\n  },\n  ForOfStatement(node, state, c) {\n    if (node.await === true) {\n      state.containsAwait = true;\n    }\n    walk.base.ForOfStatement(node, state, c);\n  },\n  FunctionDeclaration(node, state, c) {\n    state.prepend(node, `${node.id.name}=`);\n    ArrayPrototypePush(\n      state.hoistedDeclarationStatements,\n      `var ${node.id.name}; `\n    );\n  },\n  FunctionExpression: noop,\n  ArrowFunctionExpression: noop,\n  MethodDefinition: noop,\n  AwaitExpression(node, state, c) {\n    state.containsAwait = true;\n    walk.base.AwaitExpression(node, state, c);\n  },\n  ReturnStatement(node, state, c) {\n    state.containsReturn = true;\n    walk.base.ReturnStatement(node, state, c);\n  },\n  VariableDeclaration(node, state, c) {\n    const variableKind = node.kind;\n    const isIterableForDeclaration = ArrayPrototypeIncludes(\n      ['ForOfStatement', 'ForInStatement'],\n      state.ancestors[state.ancestors.length - 2].type\n    );\n\n    if (variableKind === 'var' || isTopLevelDeclaration(state)) {\n      state.replace(\n        node.start,\n        node.start + variableKind.length + (isIterableForDeclaration ? 1 : 0),\n        variableKind === 'var' && isIterableForDeclaration ?\n          '' :\n          'void' + (node.declarations.length === 1 ? '' : ' (')\n      );\n\n      if (!isIterableForDeclaration) {\n        ArrayPrototypeForEach(node.declarations, (decl) => {\n          state.prepend(decl, '(');\n          state.append(decl, decl.init ? ')' : '=undefined)');\n        });\n\n        if (node.declarations.length !== 1) {\n          state.append(node.declarations[node.declarations.length - 1], ')');\n        }\n      }\n\n      const variableIdentifiersToHoist = [\n        ['var', []],\n        ['let', []],\n      ];\n      function registerVariableDeclarationIdentifiers(node) {\n        switch (node.type) {\n          case 'Identifier':\n            ArrayPrototypePush(\n              variableIdentifiersToHoist[variableKind === 'var' ? 0 : 1][1],\n              node.name\n            );\n            break;\n          case 'ObjectPattern':\n            ArrayPrototypeForEach(node.properties, (property) => {\n              registerVariableDeclarationIdentifiers(property.value);\n            });\n            break;\n          case 'ArrayPattern':\n            ArrayPrototypeForEach(node.elements, (element) => {\n              registerVariableDeclarationIdentifiers(element);\n            });\n            break;\n        }\n      }\n\n      ArrayPrototypeForEach(node.declarations, (decl) => {\n        registerVariableDeclarationIdentifiers(decl.id);\n      });\n\n      ArrayPrototypeForEach(\n        variableIdentifiersToHoist,\n        ({ 0: kind, 1: identifiers }) => {\n          if (identifiers.length > 0) {\n            ArrayPrototypePush(\n              state.hoistedDeclarationStatements,\n              `${kind} ${ArrayPrototypeJoin(identifiers, ', ')}; `\n            );\n          }\n        }\n      );\n    }\n\n    walk.base.VariableDeclaration(node, state, c);\n  }\n};\n\nconst visitors = {};\nfor (const nodeType of ObjectKeys(walk.base)) {\n  const callback = visitorsWithoutAncestors[nodeType] || walk.base[nodeType];\n  visitors[nodeType] = (node, state, c) => {\n    const isNew = node !== state.ancestors[state.ancestors.length - 1];\n    if (isNew) {\n      ArrayPrototypePush(state.ancestors, node);\n    }\n    callback(node, state, c);\n    if (isNew) {\n      ArrayPrototypePop(state.ancestors);\n    }\n  };\n}\n\nfunction processTopLevelAwait(src) {\n  const wrapPrefix = '(async () => { ';\n  const wrapped = `${wrapPrefix}${src} })()`;\n  const wrappedArray = ArrayFrom(wrapped);\n  let root;\n  try {\n    root = parser.parse(wrapped, { ecmaVersion: 'latest' });\n  } catch (e) {\n    if (StringPrototypeStartsWith(e.message, 'Unterminated '))\n      throw new Recoverable(e);\n    // If the parse error is before the first \"await\", then use the execution\n    // error. Otherwise we must emit this parse error, making it look like a\n    // proper syntax error.\n    const awaitPos = StringPrototypeIndexOf(src, 'await');\n    const errPos = e.pos - wrapPrefix.length;\n    if (awaitPos > errPos)\n      return null;\n    // Convert keyword parse errors on await into their original errors when\n    // possible.\n    if (errPos === awaitPos + 6 &&\n        StringPrototypeIncludes(e.message, 'Expecting Unicode escape sequence'))\n      return null;\n    if (errPos === awaitPos + 7 &&\n        StringPrototypeIncludes(e.message, 'Unexpected token'))\n      return null;\n    const line = e.loc.line;\n    const column = line === 1 ? e.loc.column - wrapPrefix.length : e.loc.column;\n    let message = '\\n' + StringPrototypeSplit(src, '\\n')[line - 1] + '\\n' +\n        StringPrototypeRepeat(' ', column) +\n        '^\\n\\n' + RegExpPrototypeSymbolReplace(/ \\([^)]+\\)/, e.message, '');\n    // V8 unexpected token errors include the token string.\n    if (StringPrototypeEndsWith(message, 'Unexpected token'))\n      message += \" '\" +\n        // Wrapper end may cause acorn to report error position after the source\n        ((src.length - 1) >= (e.pos - wrapPrefix.length)\n          ? src[e.pos - wrapPrefix.length]\n          : src[src.length - 1]) +\n        \"'\";\n    // eslint-disable-next-line no-restricted-syntax\n    throw new SyntaxError(message);\n  }\n  const body = root.body[0].expression.callee.body;\n  const state = {\n    body,\n    ancestors: [],\n    hoistedDeclarationStatements: [],\n    replace(from, to, str) {\n      for (let i = from; i < to; i++) {\n        wrappedArray[i] = '';\n      }\n      if (from === to) str += wrappedArray[from];\n      wrappedArray[from] = str;\n    },\n    prepend(node, str) {\n      wrappedArray[node.start] = str + wrappedArray[node.start];\n    },\n    append(node, str) {\n      wrappedArray[node.end - 1] += str;\n    },\n    containsAwait: false,\n    containsReturn: false\n  };\n\n  walk.recursive(body, state, visitors);\n\n  // Do not transform if\n  // 1. False alarm: there isn't actually an await expression.\n  // 2. There is a top-level return, which is not allowed.\n  if (!state.containsAwait || state.containsReturn) {\n    return null;\n  }\n\n  const last = body.body[body.body.length - 1];\n  if (last.type === 'ExpressionStatement') {\n    // For an expression statement of the form\n    // ( expr ) ;\n    // ^^^^^^^^^^   // last\n    //   ^^^^       // last.expression\n    //\n    // We do not want the left parenthesis before the `return` keyword;\n    // therefore we prepend the `return (` to `last`.\n    //\n    // On the other hand, we do not want the right parenthesis after the\n    // semicolon. Since there can only be more right parentheses between\n    // last.expression.end and the semicolon, appending one more to\n    // last.expression should be fine.\n    state.prepend(last, 'return (');\n    state.append(last.expression, ')');\n  }\n\n  return (\n    ArrayPrototypeJoin(state.hoistedDeclarationStatements, '') +\n    ArrayPrototypeJoin(wrappedArray, '')\n  );\n}\n\nmodule.exports = {\n  processTopLevelAwait\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}