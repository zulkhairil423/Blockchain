{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createResolverFunctions = void 0;\n\nconst path_1 = require(\"path\");\n/**\n * @internal\n * In a factory because these are shared across both CompilerHost and LanguageService codepaths\n */\n\n\nfunction createResolverFunctions(kwargs) {\n  const {\n    host,\n    ts,\n    config,\n    cwd,\n    getCanonicalFileName,\n    projectLocalResolveHelper,\n    options,\n    extensions\n  } = kwargs;\n  const moduleResolutionCache = ts.createModuleResolutionCache(cwd, getCanonicalFileName, config.options);\n  const knownInternalFilenames = new Set();\n  /** \"Buckets\" (module directories) whose contents should be marked \"internal\" */\n\n  const internalBuckets = new Set(); // Get bucket for a source filename.  Bucket is the containing `./node_modules/*/` directory\n  // For '/project/node_modules/foo/node_modules/bar/lib/index.js' bucket is '/project/node_modules/foo/node_modules/bar/'\n  // For '/project/node_modules/foo/node_modules/@scope/bar/lib/index.js' bucket is '/project/node_modules/foo/node_modules/@scope/bar/'\n\n  const moduleBucketRe = /.*\\/node_modules\\/(?:@[^\\/]+\\/)?[^\\/]+\\//;\n\n  function getModuleBucket(filename) {\n    const find = moduleBucketRe.exec(filename);\n    if (find) return find[0];\n    return '';\n  } // Mark that this file and all siblings in its bucket should be \"internal\"\n\n\n  function markBucketOfFilenameInternal(filename) {\n    internalBuckets.add(getModuleBucket(filename));\n  }\n\n  function isFileInInternalBucket(filename) {\n    return internalBuckets.has(getModuleBucket(filename));\n  }\n\n  function isFileKnownToBeInternal(filename) {\n    return knownInternalFilenames.has(filename);\n  }\n  /**\n   * If we need to emit JS for a file, force TS to consider it non-external\n   */\n\n\n  const fixupResolvedModule = resolvedModule => {\n    const {\n      resolvedFileName\n    } = resolvedModule;\n    if (resolvedFileName === undefined) return; // [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n    // .ts,.mts,.cts is always switched to internal\n    // .js is switched on-demand\n\n    if (resolvedModule.isExternalLibraryImport && (resolvedFileName.endsWith('.ts') && !resolvedFileName.endsWith('.d.ts') || resolvedFileName.endsWith('.cts') && !resolvedFileName.endsWith('.d.cts') || resolvedFileName.endsWith('.mts') && !resolvedFileName.endsWith('.d.mts') || isFileKnownToBeInternal(resolvedFileName) || isFileInInternalBucket(resolvedFileName))) {\n      resolvedModule.isExternalLibraryImport = false;\n    }\n\n    if (!resolvedModule.isExternalLibraryImport) {\n      knownInternalFilenames.add(resolvedFileName);\n    }\n  };\n  /*\n   * NOTE:\n   * Older ts versions do not pass `redirectedReference` nor `options`.\n   * We must pass `redirectedReference` to newer ts versions, but cannot rely on `options`, hence the weird argument name\n   */\n\n\n  const resolveModuleNames = (moduleNames, containingFile, reusedNames, redirectedReference, optionsOnlyWithNewerTsVersions, containingSourceFile) => {\n    return moduleNames.map((moduleName, i) => {\n      var _a, _b;\n\n      const mode = containingSourceFile ? (_b = (_a = ts).getModeForResolutionAtIndex) === null || _b === void 0 ? void 0 : _b.call(_a, containingSourceFile, i) : undefined;\n      let {\n        resolvedModule\n      } = ts.resolveModuleName(moduleName, containingFile, config.options, host, moduleResolutionCache, redirectedReference, mode);\n\n      if (!resolvedModule && options.experimentalTsImportSpecifiers) {\n        const lastDotIndex = moduleName.lastIndexOf('.');\n        const ext = lastDotIndex >= 0 ? moduleName.slice(lastDotIndex) : '';\n\n        if (ext) {\n          const replacements = extensions.tsResolverEquivalents.get(ext);\n\n          for (const replacementExt of replacements !== null && replacements !== void 0 ? replacements : []) {\n            ({\n              resolvedModule\n            } = ts.resolveModuleName(moduleName.slice(0, -ext.length) + replacementExt, containingFile, config.options, host, moduleResolutionCache, redirectedReference, mode));\n            if (resolvedModule) break;\n          }\n        }\n      }\n\n      if (resolvedModule) {\n        fixupResolvedModule(resolvedModule);\n      }\n\n      return resolvedModule;\n    });\n  }; // language service never calls this, but TS docs recommend that we implement it\n\n\n  const getResolvedModuleWithFailedLookupLocationsFromCache = (moduleName, containingFile, resolutionMode) => {\n    const ret = ts.resolveModuleNameFromCache(moduleName, containingFile, moduleResolutionCache, resolutionMode);\n\n    if (ret && ret.resolvedModule) {\n      fixupResolvedModule(ret.resolvedModule);\n    }\n\n    return ret;\n  };\n\n  const resolveTypeReferenceDirectives = (typeDirectiveNames, containingFile, redirectedReference, options, containingFileMode // new impliedNodeFormat is accepted by compilerHost\n  ) => {\n    // Note: seems to be called with empty typeDirectiveNames array for all files.\n    // TODO consider using `ts.loadWithTypeDirectiveCache`\n    return typeDirectiveNames.map(typeDirectiveName => {\n      // Copy-pasted from TS source:\n      const nameIsString = typeof typeDirectiveName === 'string';\n      const mode = nameIsString ? undefined : ts.getModeForFileReference(typeDirectiveName, containingFileMode);\n      const strName = nameIsString ? typeDirectiveName : typeDirectiveName.fileName.toLowerCase();\n      let {\n        resolvedTypeReferenceDirective\n      } = ts.resolveTypeReferenceDirective(strName, containingFile, config.options, host, redirectedReference, undefined, mode);\n\n      if (typeDirectiveName === 'node' && !resolvedTypeReferenceDirective) {\n        // Resolve @types/node relative to project first, then __dirname (copy logic from elsewhere / refactor into reusable function)\n        let typesNodePackageJsonPath;\n\n        try {\n          typesNodePackageJsonPath = projectLocalResolveHelper('@types/node/package.json', true);\n        } catch {} // gracefully do nothing when @types/node is not installed for any reason\n\n\n        if (typesNodePackageJsonPath) {\n          const typeRoots = [(0, path_1.resolve)(typesNodePackageJsonPath, '../..')];\n          ({\n            resolvedTypeReferenceDirective\n          } = ts.resolveTypeReferenceDirective(typeDirectiveName, containingFile, { ...config.options,\n            typeRoots\n          }, host, redirectedReference));\n        }\n      }\n\n      if (resolvedTypeReferenceDirective) {\n        fixupResolvedModule(resolvedTypeReferenceDirective);\n      }\n\n      return resolvedTypeReferenceDirective;\n    });\n  };\n\n  return {\n    resolveModuleNames,\n    getResolvedModuleWithFailedLookupLocationsFromCache,\n    resolveTypeReferenceDirectives,\n    isFileKnownToBeInternal,\n    markBucketOfFilenameInternal\n  };\n}\n\nexports.createResolverFunctions = createResolverFunctions;","map":{"version":3,"mappings":"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","names":["createResolverFunctions","kwargs","host","ts","config","cwd","getCanonicalFileName","projectLocalResolveHelper","options","extensions","moduleResolutionCache","createModuleResolutionCache","knownInternalFilenames","Set","internalBuckets","moduleBucketRe","getModuleBucket","filename","find","exec","markBucketOfFilenameInternal","add","isFileInInternalBucket","has","isFileKnownToBeInternal","fixupResolvedModule","resolvedModule","resolvedFileName","undefined","isExternalLibraryImport","endsWith","resolveModuleNames","moduleNames","containingFile","reusedNames","redirectedReference","optionsOnlyWithNewerTsVersions","containingSourceFile","map","moduleName","i","mode","getModeForResolutionAtIndex","_b","resolveModuleName","experimentalTsImportSpecifiers","lastDotIndex","lastIndexOf","ext","slice","replacements","tsResolverEquivalents","get","replacementExt","length","getResolvedModuleWithFailedLookupLocationsFromCache","resolutionMode","ret","resolveModuleNameFromCache","resolveTypeReferenceDirectives","typeDirectiveNames","containingFileMode","typeDirectiveName","nameIsString","getModeForFileReference","strName","fileName","toLowerCase","resolvedTypeReferenceDirective","resolveTypeReferenceDirective","typesNodePackageJsonPath","typeRoots","exports"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\ts-node\\src\\resolver-functions.ts"],"sourcesContent":["import { resolve } from 'path';\nimport type { CreateOptions } from '.';\nimport type { Extensions } from './file-extensions';\nimport type { TSCommon, TSInternal } from './ts-compiler-types';\nimport type { ProjectLocalResolveHelper } from './util';\n\n/**\n * @internal\n * In a factory because these are shared across both CompilerHost and LanguageService codepaths\n */\nexport function createResolverFunctions(kwargs: {\n  ts: TSCommon;\n  host: TSCommon.ModuleResolutionHost;\n  cwd: string;\n  getCanonicalFileName: (filename: string) => string;\n  config: TSCommon.ParsedCommandLine;\n  projectLocalResolveHelper: ProjectLocalResolveHelper;\n  options: CreateOptions;\n  extensions: Extensions;\n}) {\n  const {\n    host,\n    ts,\n    config,\n    cwd,\n    getCanonicalFileName,\n    projectLocalResolveHelper,\n    options,\n    extensions,\n  } = kwargs;\n  const moduleResolutionCache = ts.createModuleResolutionCache(\n    cwd,\n    getCanonicalFileName,\n    config.options\n  );\n  const knownInternalFilenames = new Set<string>();\n  /** \"Buckets\" (module directories) whose contents should be marked \"internal\" */\n  const internalBuckets = new Set<string>();\n\n  // Get bucket for a source filename.  Bucket is the containing `./node_modules/*/` directory\n  // For '/project/node_modules/foo/node_modules/bar/lib/index.js' bucket is '/project/node_modules/foo/node_modules/bar/'\n  // For '/project/node_modules/foo/node_modules/@scope/bar/lib/index.js' bucket is '/project/node_modules/foo/node_modules/@scope/bar/'\n  const moduleBucketRe = /.*\\/node_modules\\/(?:@[^\\/]+\\/)?[^\\/]+\\//;\n  function getModuleBucket(filename: string) {\n    const find = moduleBucketRe.exec(filename);\n    if (find) return find[0];\n    return '';\n  }\n\n  // Mark that this file and all siblings in its bucket should be \"internal\"\n  function markBucketOfFilenameInternal(filename: string) {\n    internalBuckets.add(getModuleBucket(filename));\n  }\n\n  function isFileInInternalBucket(filename: string) {\n    return internalBuckets.has(getModuleBucket(filename));\n  }\n\n  function isFileKnownToBeInternal(filename: string) {\n    return knownInternalFilenames.has(filename);\n  }\n\n  /**\n   * If we need to emit JS for a file, force TS to consider it non-external\n   */\n  const fixupResolvedModule = (\n    resolvedModule:\n      | TSCommon.ResolvedModule\n      | TSCommon.ResolvedTypeReferenceDirective\n  ) => {\n    const { resolvedFileName } = resolvedModule;\n    if (resolvedFileName === undefined) return;\n    // [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n    // .ts,.mts,.cts is always switched to internal\n    // .js is switched on-demand\n    if (\n      resolvedModule.isExternalLibraryImport &&\n      ((resolvedFileName.endsWith('.ts') &&\n        !resolvedFileName.endsWith('.d.ts')) ||\n        (resolvedFileName.endsWith('.cts') &&\n          !resolvedFileName.endsWith('.d.cts')) ||\n        (resolvedFileName.endsWith('.mts') &&\n          !resolvedFileName.endsWith('.d.mts')) ||\n        isFileKnownToBeInternal(resolvedFileName) ||\n        isFileInInternalBucket(resolvedFileName))\n    ) {\n      resolvedModule.isExternalLibraryImport = false;\n    }\n    if (!resolvedModule.isExternalLibraryImport) {\n      knownInternalFilenames.add(resolvedFileName);\n    }\n  };\n  /*\n   * NOTE:\n   * Older ts versions do not pass `redirectedReference` nor `options`.\n   * We must pass `redirectedReference` to newer ts versions, but cannot rely on `options`, hence the weird argument name\n   */\n  const resolveModuleNames: TSCommon.LanguageServiceHost['resolveModuleNames'] =\n    (\n      moduleNames: string[],\n      containingFile: string,\n      reusedNames: string[] | undefined,\n      redirectedReference: TSCommon.ResolvedProjectReference | undefined,\n      optionsOnlyWithNewerTsVersions: TSCommon.CompilerOptions,\n      containingSourceFile?: TSCommon.SourceFile\n    ): (TSCommon.ResolvedModule | undefined)[] => {\n      return moduleNames.map((moduleName, i) => {\n        const mode = containingSourceFile\n          ? (ts as any as TSInternal).getModeForResolutionAtIndex?.(\n              containingSourceFile,\n              i\n            )\n          : undefined;\n        let { resolvedModule } = ts.resolveModuleName(\n          moduleName,\n          containingFile,\n          config.options,\n          host,\n          moduleResolutionCache,\n          redirectedReference,\n          mode\n        );\n        if (!resolvedModule && options.experimentalTsImportSpecifiers) {\n          const lastDotIndex = moduleName.lastIndexOf('.');\n          const ext = lastDotIndex >= 0 ? moduleName.slice(lastDotIndex) : '';\n          if (ext) {\n            const replacements = extensions.tsResolverEquivalents.get(ext);\n            for (const replacementExt of replacements ?? []) {\n              ({ resolvedModule } = ts.resolveModuleName(\n                moduleName.slice(0, -ext.length) + replacementExt,\n                containingFile,\n                config.options,\n                host,\n                moduleResolutionCache,\n                redirectedReference,\n                mode\n              ));\n              if (resolvedModule) break;\n            }\n          }\n        }\n        if (resolvedModule) {\n          fixupResolvedModule(resolvedModule);\n        }\n        return resolvedModule;\n      });\n    };\n\n  // language service never calls this, but TS docs recommend that we implement it\n  const getResolvedModuleWithFailedLookupLocationsFromCache: TSCommon.LanguageServiceHost['getResolvedModuleWithFailedLookupLocationsFromCache'] =\n    (\n      moduleName,\n      containingFile,\n      resolutionMode?: TSCommon.ModuleKind.CommonJS | TSCommon.ModuleKind.ESNext\n    ): TSCommon.ResolvedModuleWithFailedLookupLocations | undefined => {\n      const ret = ts.resolveModuleNameFromCache(\n        moduleName,\n        containingFile,\n        moduleResolutionCache,\n        resolutionMode\n      );\n      if (ret && ret.resolvedModule) {\n        fixupResolvedModule(ret.resolvedModule);\n      }\n      return ret;\n    };\n\n  const resolveTypeReferenceDirectives: TSCommon.LanguageServiceHost['resolveTypeReferenceDirectives'] =\n    (\n      typeDirectiveNames: string[] | readonly TSCommon.FileReference[],\n      containingFile: string,\n      redirectedReference: TSCommon.ResolvedProjectReference | undefined,\n      options: TSCommon.CompilerOptions,\n      containingFileMode?: TSCommon.SourceFile['impliedNodeFormat'] | undefined // new impliedNodeFormat is accepted by compilerHost\n    ): (TSCommon.ResolvedTypeReferenceDirective | undefined)[] => {\n      // Note: seems to be called with empty typeDirectiveNames array for all files.\n      // TODO consider using `ts.loadWithTypeDirectiveCache`\n      return typeDirectiveNames.map((typeDirectiveName) => {\n        // Copy-pasted from TS source:\n        const nameIsString = typeof typeDirectiveName === 'string';\n        const mode = nameIsString\n          ? undefined\n          : (ts as any as TSInternal).getModeForFileReference!(\n              typeDirectiveName,\n              containingFileMode\n            );\n        const strName = nameIsString\n          ? typeDirectiveName\n          : typeDirectiveName.fileName.toLowerCase();\n        let { resolvedTypeReferenceDirective } =\n          ts.resolveTypeReferenceDirective(\n            strName,\n            containingFile,\n            config.options,\n            host,\n            redirectedReference,\n            undefined,\n            mode\n          );\n        if (typeDirectiveName === 'node' && !resolvedTypeReferenceDirective) {\n          // Resolve @types/node relative to project first, then __dirname (copy logic from elsewhere / refactor into reusable function)\n          let typesNodePackageJsonPath: string | undefined;\n          try {\n            typesNodePackageJsonPath = projectLocalResolveHelper(\n              '@types/node/package.json',\n              true\n            );\n          } catch {} // gracefully do nothing when @types/node is not installed for any reason\n          if (typesNodePackageJsonPath) {\n            const typeRoots = [resolve(typesNodePackageJsonPath, '../..')];\n            ({ resolvedTypeReferenceDirective } =\n              ts.resolveTypeReferenceDirective(\n                typeDirectiveName,\n                containingFile,\n                {\n                  ...config.options,\n                  typeRoots,\n                },\n                host,\n                redirectedReference\n              ));\n          }\n        }\n        if (resolvedTypeReferenceDirective) {\n          fixupResolvedModule(resolvedTypeReferenceDirective);\n        }\n        return resolvedTypeReferenceDirective;\n      });\n    };\n\n  return {\n    resolveModuleNames,\n    getResolvedModuleWithFailedLookupLocationsFromCache,\n    resolveTypeReferenceDirectives,\n    isFileKnownToBeInternal,\n    markBucketOfFilenameInternal,\n  };\n}\n"]},"metadata":{},"sourceType":"script"}