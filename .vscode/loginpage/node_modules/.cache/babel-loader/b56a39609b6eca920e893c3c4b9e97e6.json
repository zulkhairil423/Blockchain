{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = global || self, factory((global.acorn = global.acorn || {}, global.acorn.walk = {})));\n})(this, function (exports) {\n  'use strict'; // AST walker module for Mozilla Parser API compatible trees\n  // A simple walk is one where you simply specify callbacks to be\n  // called on specific nodes. The last two arguments are optional. A\n  // simple use would be\n  //\n  //     walk.simple(myTree, {\n  //         Expression: function(node) { ... }\n  //     });\n  //\n  // to do something with all expressions. All Parser API node types\n  // can be used to identify node types, as well as Expression and\n  // Statement, which denote categories of nodes.\n  //\n  // The base argument can be used to pass a custom (recursive)\n  // walker, and state can be used to give this walked an initial\n  // state.\n\n  function simple(node, visitors, baseVisitor, state, override) {\n    if (!baseVisitor) {\n      baseVisitor = base;\n    }\n\n    (function c(node, st, override) {\n      var type = override || node.type,\n          found = visitors[type];\n      baseVisitor[type](node, st, c);\n\n      if (found) {\n        found(node, st);\n      }\n    })(node, state, override);\n  } // An ancestor walk keeps an array of ancestor nodes (including the\n  // current node) and passes them to the callback as third parameter\n  // (and also as state parameter when no other state is present).\n\n\n  function ancestor(node, visitors, baseVisitor, state, override) {\n    var ancestors = [];\n\n    if (!baseVisitor) {\n      baseVisitor = base;\n    }\n\n    (function c(node, st, override) {\n      var type = override || node.type,\n          found = visitors[type];\n      var isNew = node !== ancestors[ancestors.length - 1];\n\n      if (isNew) {\n        ancestors.push(node);\n      }\n\n      baseVisitor[type](node, st, c);\n\n      if (found) {\n        found(node, st || ancestors, ancestors);\n      }\n\n      if (isNew) {\n        ancestors.pop();\n      }\n    })(node, state, override);\n  } // A recursive walk is one where your functions override the default\n  // walkers. They can modify and replace the state parameter that's\n  // threaded through the walk, and can opt how and whether to walk\n  // their child nodes (by calling their third argument on these\n  // nodes).\n\n\n  function recursive(node, state, funcs, baseVisitor, override) {\n    var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor;\n\n    (function c(node, st, override) {\n      visitor[override || node.type](node, st, c);\n    })(node, state, override);\n  }\n\n  function makeTest(test) {\n    if (typeof test === \"string\") {\n      return function (type) {\n        return type === test;\n      };\n    } else if (!test) {\n      return function () {\n        return true;\n      };\n    } else {\n      return test;\n    }\n  }\n\n  var Found = function Found(node, state) {\n    this.node = node;\n    this.state = state;\n  }; // A full walk triggers the callback on each node\n\n\n  function full(node, callback, baseVisitor, state, override) {\n    if (!baseVisitor) {\n      baseVisitor = base;\n    }\n\n    var last;\n\n    (function c(node, st, override) {\n      var type = override || node.type;\n      baseVisitor[type](node, st, c);\n\n      if (last !== node) {\n        callback(node, st, type);\n        last = node;\n      }\n    })(node, state, override);\n  } // An fullAncestor walk is like an ancestor walk, but triggers\n  // the callback on each node\n\n\n  function fullAncestor(node, callback, baseVisitor, state) {\n    if (!baseVisitor) {\n      baseVisitor = base;\n    }\n\n    var ancestors = [],\n        last;\n\n    (function c(node, st, override) {\n      var type = override || node.type;\n      var isNew = node !== ancestors[ancestors.length - 1];\n\n      if (isNew) {\n        ancestors.push(node);\n      }\n\n      baseVisitor[type](node, st, c);\n\n      if (last !== node) {\n        callback(node, st || ancestors, ancestors, type);\n        last = node;\n      }\n\n      if (isNew) {\n        ancestors.pop();\n      }\n    })(node, state);\n  } // Find a node with a given start, end, and type (all are optional,\n  // null can be used as wildcard). Returns a {node, state} object, or\n  // undefined when it doesn't find a matching node.\n\n\n  function findNodeAt(node, start, end, test, baseVisitor, state) {\n    if (!baseVisitor) {\n      baseVisitor = base;\n    }\n\n    test = makeTest(test);\n\n    try {\n      (function c(node, st, override) {\n        var type = override || node.type;\n\n        if ((start == null || node.start <= start) && (end == null || node.end >= end)) {\n          baseVisitor[type](node, st, c);\n        }\n\n        if ((start == null || node.start === start) && (end == null || node.end === end) && test(type, node)) {\n          throw new Found(node, st);\n        }\n      })(node, state);\n    } catch (e) {\n      if (e instanceof Found) {\n        return e;\n      }\n\n      throw e;\n    }\n  } // Find the innermost node of a given type that contains the given\n  // position. Interface similar to findNodeAt.\n\n\n  function findNodeAround(node, pos, test, baseVisitor, state) {\n    test = makeTest(test);\n\n    if (!baseVisitor) {\n      baseVisitor = base;\n    }\n\n    try {\n      (function c(node, st, override) {\n        var type = override || node.type;\n\n        if (node.start > pos || node.end < pos) {\n          return;\n        }\n\n        baseVisitor[type](node, st, c);\n\n        if (test(type, node)) {\n          throw new Found(node, st);\n        }\n      })(node, state);\n    } catch (e) {\n      if (e instanceof Found) {\n        return e;\n      }\n\n      throw e;\n    }\n  } // Find the outermost matching node after a given position.\n\n\n  function findNodeAfter(node, pos, test, baseVisitor, state) {\n    test = makeTest(test);\n\n    if (!baseVisitor) {\n      baseVisitor = base;\n    }\n\n    try {\n      (function c(node, st, override) {\n        if (node.end < pos) {\n          return;\n        }\n\n        var type = override || node.type;\n\n        if (node.start >= pos && test(type, node)) {\n          throw new Found(node, st);\n        }\n\n        baseVisitor[type](node, st, c);\n      })(node, state);\n    } catch (e) {\n      if (e instanceof Found) {\n        return e;\n      }\n\n      throw e;\n    }\n  } // Find the outermost matching node before a given position.\n\n\n  function findNodeBefore(node, pos, test, baseVisitor, state) {\n    test = makeTest(test);\n\n    if (!baseVisitor) {\n      baseVisitor = base;\n    }\n\n    var max;\n\n    (function c(node, st, override) {\n      if (node.start > pos) {\n        return;\n      }\n\n      var type = override || node.type;\n\n      if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node)) {\n        max = new Found(node, st);\n      }\n\n      baseVisitor[type](node, st, c);\n    })(node, state);\n\n    return max;\n  } // Used to create a custom walker. Will fill in all missing node\n  // type properties with the defaults.\n\n\n  function make(funcs, baseVisitor) {\n    var visitor = Object.create(baseVisitor || base);\n\n    for (var type in funcs) {\n      visitor[type] = funcs[type];\n    }\n\n    return visitor;\n  }\n\n  function skipThrough(node, st, c) {\n    c(node, st);\n  }\n\n  function ignore(_node, _st, _c) {} // Node walkers.\n\n\n  var base = {};\n\n  base.Program = base.BlockStatement = base.StaticBlock = function (node, st, c) {\n    for (var i = 0, list = node.body; i < list.length; i += 1) {\n      var stmt = list[i];\n      c(stmt, st, \"Statement\");\n    }\n  };\n\n  base.Statement = skipThrough;\n  base.EmptyStatement = ignore;\n\n  base.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression = function (node, st, c) {\n    return c(node.expression, st, \"Expression\");\n  };\n\n  base.IfStatement = function (node, st, c) {\n    c(node.test, st, \"Expression\");\n    c(node.consequent, st, \"Statement\");\n\n    if (node.alternate) {\n      c(node.alternate, st, \"Statement\");\n    }\n  };\n\n  base.LabeledStatement = function (node, st, c) {\n    return c(node.body, st, \"Statement\");\n  };\n\n  base.BreakStatement = base.ContinueStatement = ignore;\n\n  base.WithStatement = function (node, st, c) {\n    c(node.object, st, \"Expression\");\n    c(node.body, st, \"Statement\");\n  };\n\n  base.SwitchStatement = function (node, st, c) {\n    c(node.discriminant, st, \"Expression\");\n\n    for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {\n      var cs = list$1[i$1];\n\n      if (cs.test) {\n        c(cs.test, st, \"Expression\");\n      }\n\n      for (var i = 0, list = cs.consequent; i < list.length; i += 1) {\n        var cons = list[i];\n        c(cons, st, \"Statement\");\n      }\n    }\n  };\n\n  base.SwitchCase = function (node, st, c) {\n    if (node.test) {\n      c(node.test, st, \"Expression\");\n    }\n\n    for (var i = 0, list = node.consequent; i < list.length; i += 1) {\n      var cons = list[i];\n      c(cons, st, \"Statement\");\n    }\n  };\n\n  base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {\n    if (node.argument) {\n      c(node.argument, st, \"Expression\");\n    }\n  };\n\n  base.ThrowStatement = base.SpreadElement = function (node, st, c) {\n    return c(node.argument, st, \"Expression\");\n  };\n\n  base.TryStatement = function (node, st, c) {\n    c(node.block, st, \"Statement\");\n\n    if (node.handler) {\n      c(node.handler, st);\n    }\n\n    if (node.finalizer) {\n      c(node.finalizer, st, \"Statement\");\n    }\n  };\n\n  base.CatchClause = function (node, st, c) {\n    if (node.param) {\n      c(node.param, st, \"Pattern\");\n    }\n\n    c(node.body, st, \"Statement\");\n  };\n\n  base.WhileStatement = base.DoWhileStatement = function (node, st, c) {\n    c(node.test, st, \"Expression\");\n    c(node.body, st, \"Statement\");\n  };\n\n  base.ForStatement = function (node, st, c) {\n    if (node.init) {\n      c(node.init, st, \"ForInit\");\n    }\n\n    if (node.test) {\n      c(node.test, st, \"Expression\");\n    }\n\n    if (node.update) {\n      c(node.update, st, \"Expression\");\n    }\n\n    c(node.body, st, \"Statement\");\n  };\n\n  base.ForInStatement = base.ForOfStatement = function (node, st, c) {\n    c(node.left, st, \"ForInit\");\n    c(node.right, st, \"Expression\");\n    c(node.body, st, \"Statement\");\n  };\n\n  base.ForInit = function (node, st, c) {\n    if (node.type === \"VariableDeclaration\") {\n      c(node, st);\n    } else {\n      c(node, st, \"Expression\");\n    }\n  };\n\n  base.DebuggerStatement = ignore;\n\n  base.FunctionDeclaration = function (node, st, c) {\n    return c(node, st, \"Function\");\n  };\n\n  base.VariableDeclaration = function (node, st, c) {\n    for (var i = 0, list = node.declarations; i < list.length; i += 1) {\n      var decl = list[i];\n      c(decl, st);\n    }\n  };\n\n  base.VariableDeclarator = function (node, st, c) {\n    c(node.id, st, \"Pattern\");\n\n    if (node.init) {\n      c(node.init, st, \"Expression\");\n    }\n  };\n\n  base.Function = function (node, st, c) {\n    if (node.id) {\n      c(node.id, st, \"Pattern\");\n    }\n\n    for (var i = 0, list = node.params; i < list.length; i += 1) {\n      var param = list[i];\n      c(param, st, \"Pattern\");\n    }\n\n    c(node.body, st, node.expression ? \"Expression\" : \"Statement\");\n  };\n\n  base.Pattern = function (node, st, c) {\n    if (node.type === \"Identifier\") {\n      c(node, st, \"VariablePattern\");\n    } else if (node.type === \"MemberExpression\") {\n      c(node, st, \"MemberPattern\");\n    } else {\n      c(node, st);\n    }\n  };\n\n  base.VariablePattern = ignore;\n  base.MemberPattern = skipThrough;\n\n  base.RestElement = function (node, st, c) {\n    return c(node.argument, st, \"Pattern\");\n  };\n\n  base.ArrayPattern = function (node, st, c) {\n    for (var i = 0, list = node.elements; i < list.length; i += 1) {\n      var elt = list[i];\n\n      if (elt) {\n        c(elt, st, \"Pattern\");\n      }\n    }\n  };\n\n  base.ObjectPattern = function (node, st, c) {\n    for (var i = 0, list = node.properties; i < list.length; i += 1) {\n      var prop = list[i];\n\n      if (prop.type === \"Property\") {\n        if (prop.computed) {\n          c(prop.key, st, \"Expression\");\n        }\n\n        c(prop.value, st, \"Pattern\");\n      } else if (prop.type === \"RestElement\") {\n        c(prop.argument, st, \"Pattern\");\n      }\n    }\n  };\n\n  base.Expression = skipThrough;\n  base.ThisExpression = base.Super = base.MetaProperty = ignore;\n\n  base.ArrayExpression = function (node, st, c) {\n    for (var i = 0, list = node.elements; i < list.length; i += 1) {\n      var elt = list[i];\n\n      if (elt) {\n        c(elt, st, \"Expression\");\n      }\n    }\n  };\n\n  base.ObjectExpression = function (node, st, c) {\n    for (var i = 0, list = node.properties; i < list.length; i += 1) {\n      var prop = list[i];\n      c(prop, st);\n    }\n  };\n\n  base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;\n\n  base.SequenceExpression = function (node, st, c) {\n    for (var i = 0, list = node.expressions; i < list.length; i += 1) {\n      var expr = list[i];\n      c(expr, st, \"Expression\");\n    }\n  };\n\n  base.TemplateLiteral = function (node, st, c) {\n    for (var i = 0, list = node.quasis; i < list.length; i += 1) {\n      var quasi = list[i];\n      c(quasi, st);\n    }\n\n    for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1) {\n      var expr = list$1[i$1];\n      c(expr, st, \"Expression\");\n    }\n  };\n\n  base.TemplateElement = ignore;\n\n  base.UnaryExpression = base.UpdateExpression = function (node, st, c) {\n    c(node.argument, st, \"Expression\");\n  };\n\n  base.BinaryExpression = base.LogicalExpression = function (node, st, c) {\n    c(node.left, st, \"Expression\");\n    c(node.right, st, \"Expression\");\n  };\n\n  base.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {\n    c(node.left, st, \"Pattern\");\n    c(node.right, st, \"Expression\");\n  };\n\n  base.ConditionalExpression = function (node, st, c) {\n    c(node.test, st, \"Expression\");\n    c(node.consequent, st, \"Expression\");\n    c(node.alternate, st, \"Expression\");\n  };\n\n  base.NewExpression = base.CallExpression = function (node, st, c) {\n    c(node.callee, st, \"Expression\");\n\n    if (node.arguments) {\n      for (var i = 0, list = node.arguments; i < list.length; i += 1) {\n        var arg = list[i];\n        c(arg, st, \"Expression\");\n      }\n    }\n  };\n\n  base.MemberExpression = function (node, st, c) {\n    c(node.object, st, \"Expression\");\n\n    if (node.computed) {\n      c(node.property, st, \"Expression\");\n    }\n  };\n\n  base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {\n    if (node.declaration) {\n      c(node.declaration, st, node.type === \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\");\n    }\n\n    if (node.source) {\n      c(node.source, st, \"Expression\");\n    }\n  };\n\n  base.ExportAllDeclaration = function (node, st, c) {\n    if (node.exported) {\n      c(node.exported, st);\n    }\n\n    c(node.source, st, \"Expression\");\n  };\n\n  base.ImportDeclaration = function (node, st, c) {\n    for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n      var spec = list[i];\n      c(spec, st);\n    }\n\n    c(node.source, st, \"Expression\");\n  };\n\n  base.ImportExpression = function (node, st, c) {\n    c(node.source, st, \"Expression\");\n  };\n\n  base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.PrivateIdentifier = base.Literal = ignore;\n\n  base.TaggedTemplateExpression = function (node, st, c) {\n    c(node.tag, st, \"Expression\");\n    c(node.quasi, st, \"Expression\");\n  };\n\n  base.ClassDeclaration = base.ClassExpression = function (node, st, c) {\n    return c(node, st, \"Class\");\n  };\n\n  base.Class = function (node, st, c) {\n    if (node.id) {\n      c(node.id, st, \"Pattern\");\n    }\n\n    if (node.superClass) {\n      c(node.superClass, st, \"Expression\");\n    }\n\n    c(node.body, st);\n  };\n\n  base.ClassBody = function (node, st, c) {\n    for (var i = 0, list = node.body; i < list.length; i += 1) {\n      var elt = list[i];\n      c(elt, st);\n    }\n  };\n\n  base.MethodDefinition = base.PropertyDefinition = base.Property = function (node, st, c) {\n    if (node.computed) {\n      c(node.key, st, \"Expression\");\n    }\n\n    if (node.value) {\n      c(node.value, st, \"Expression\");\n    }\n  };\n\n  exports.ancestor = ancestor;\n  exports.base = base;\n  exports.findNodeAfter = findNodeAfter;\n  exports.findNodeAround = findNodeAround;\n  exports.findNodeAt = findNodeAt;\n  exports.findNodeBefore = findNodeBefore;\n  exports.full = full;\n  exports.fullAncestor = fullAncestor;\n  exports.make = make;\n  exports.recursive = recursive;\n  exports.simple = simple;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","self","acorn","walk","simple","node","visitors","baseVisitor","state","override","base","c","st","type","found","ancestor","ancestors","isNew","length","push","pop","recursive","funcs","visitor","make","undefined","makeTest","test","Found","full","callback","last","fullAncestor","findNodeAt","start","end","e","findNodeAround","pos","findNodeAfter","findNodeBefore","max","Object","create","skipThrough","ignore","_node","_st","_c","Program","BlockStatement","StaticBlock","i","list","body","stmt","Statement","EmptyStatement","ExpressionStatement","ParenthesizedExpression","ChainExpression","expression","IfStatement","consequent","alternate","LabeledStatement","BreakStatement","ContinueStatement","WithStatement","object","SwitchStatement","discriminant","i$1","list$1","cases","cs","cons","SwitchCase","ReturnStatement","YieldExpression","AwaitExpression","argument","ThrowStatement","SpreadElement","TryStatement","block","handler","finalizer","CatchClause","param","WhileStatement","DoWhileStatement","ForStatement","init","update","ForInStatement","ForOfStatement","left","right","ForInit","DebuggerStatement","FunctionDeclaration","VariableDeclaration","declarations","decl","VariableDeclarator","id","Function","params","Pattern","VariablePattern","MemberPattern","RestElement","ArrayPattern","elements","elt","ObjectPattern","properties","prop","computed","key","value","Expression","ThisExpression","Super","MetaProperty","ArrayExpression","ObjectExpression","FunctionExpression","ArrowFunctionExpression","SequenceExpression","expressions","expr","TemplateLiteral","quasis","quasi","TemplateElement","UnaryExpression","UpdateExpression","BinaryExpression","LogicalExpression","AssignmentExpression","AssignmentPattern","ConditionalExpression","NewExpression","CallExpression","callee","arguments","arg","MemberExpression","property","ExportNamedDeclaration","ExportDefaultDeclaration","declaration","source","ExportAllDeclaration","exported","ImportDeclaration","specifiers","spec","ImportExpression","ImportSpecifier","ImportDefaultSpecifier","ImportNamespaceSpecifier","Identifier","PrivateIdentifier","Literal","TaggedTemplateExpression","tag","ClassDeclaration","ClassExpression","Class","superClass","ClassBody","MethodDefinition","PropertyDefinition","Property","defineProperty"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/ts-node/node_modules/acorn-walk/dist/walk.js"],"sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = global || self, factory((global.acorn = global.acorn || {}, global.acorn.walk = {})));\n}(this, (function (exports) { 'use strict';\n\n  // AST walker module for Mozilla Parser API compatible trees\n\n  // A simple walk is one where you simply specify callbacks to be\n  // called on specific nodes. The last two arguments are optional. A\n  // simple use would be\n  //\n  //     walk.simple(myTree, {\n  //         Expression: function(node) { ... }\n  //     });\n  //\n  // to do something with all expressions. All Parser API node types\n  // can be used to identify node types, as well as Expression and\n  // Statement, which denote categories of nodes.\n  //\n  // The base argument can be used to pass a custom (recursive)\n  // walker, and state can be used to give this walked an initial\n  // state.\n\n  function simple(node, visitors, baseVisitor, state, override) {\n    if (!baseVisitor) { baseVisitor = base\n    ; }(function c(node, st, override) {\n      var type = override || node.type, found = visitors[type];\n      baseVisitor[type](node, st, c);\n      if (found) { found(node, st); }\n    })(node, state, override);\n  }\n\n  // An ancestor walk keeps an array of ancestor nodes (including the\n  // current node) and passes them to the callback as third parameter\n  // (and also as state parameter when no other state is present).\n  function ancestor(node, visitors, baseVisitor, state, override) {\n    var ancestors = [];\n    if (!baseVisitor) { baseVisitor = base\n    ; }(function c(node, st, override) {\n      var type = override || node.type, found = visitors[type];\n      var isNew = node !== ancestors[ancestors.length - 1];\n      if (isNew) { ancestors.push(node); }\n      baseVisitor[type](node, st, c);\n      if (found) { found(node, st || ancestors, ancestors); }\n      if (isNew) { ancestors.pop(); }\n    })(node, state, override);\n  }\n\n  // A recursive walk is one where your functions override the default\n  // walkers. They can modify and replace the state parameter that's\n  // threaded through the walk, and can opt how and whether to walk\n  // their child nodes (by calling their third argument on these\n  // nodes).\n  function recursive(node, state, funcs, baseVisitor, override) {\n    var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor\n    ;(function c(node, st, override) {\n      visitor[override || node.type](node, st, c);\n    })(node, state, override);\n  }\n\n  function makeTest(test) {\n    if (typeof test === \"string\")\n      { return function (type) { return type === test; } }\n    else if (!test)\n      { return function () { return true; } }\n    else\n      { return test }\n  }\n\n  var Found = function Found(node, state) { this.node = node; this.state = state; };\n\n  // A full walk triggers the callback on each node\n  function full(node, callback, baseVisitor, state, override) {\n    if (!baseVisitor) { baseVisitor = base; }\n    var last\n    ;(function c(node, st, override) {\n      var type = override || node.type;\n      baseVisitor[type](node, st, c);\n      if (last !== node) {\n        callback(node, st, type);\n        last = node;\n      }\n    })(node, state, override);\n  }\n\n  // An fullAncestor walk is like an ancestor walk, but triggers\n  // the callback on each node\n  function fullAncestor(node, callback, baseVisitor, state) {\n    if (!baseVisitor) { baseVisitor = base; }\n    var ancestors = [], last\n    ;(function c(node, st, override) {\n      var type = override || node.type;\n      var isNew = node !== ancestors[ancestors.length - 1];\n      if (isNew) { ancestors.push(node); }\n      baseVisitor[type](node, st, c);\n      if (last !== node) {\n        callback(node, st || ancestors, ancestors, type);\n        last = node;\n      }\n      if (isNew) { ancestors.pop(); }\n    })(node, state);\n  }\n\n  // Find a node with a given start, end, and type (all are optional,\n  // null can be used as wildcard). Returns a {node, state} object, or\n  // undefined when it doesn't find a matching node.\n  function findNodeAt(node, start, end, test, baseVisitor, state) {\n    if (!baseVisitor) { baseVisitor = base; }\n    test = makeTest(test);\n    try {\n      (function c(node, st, override) {\n        var type = override || node.type;\n        if ((start == null || node.start <= start) &&\n            (end == null || node.end >= end))\n          { baseVisitor[type](node, st, c); }\n        if ((start == null || node.start === start) &&\n            (end == null || node.end === end) &&\n            test(type, node))\n          { throw new Found(node, st) }\n      })(node, state);\n    } catch (e) {\n      if (e instanceof Found) { return e }\n      throw e\n    }\n  }\n\n  // Find the innermost node of a given type that contains the given\n  // position. Interface similar to findNodeAt.\n  function findNodeAround(node, pos, test, baseVisitor, state) {\n    test = makeTest(test);\n    if (!baseVisitor) { baseVisitor = base; }\n    try {\n      (function c(node, st, override) {\n        var type = override || node.type;\n        if (node.start > pos || node.end < pos) { return }\n        baseVisitor[type](node, st, c);\n        if (test(type, node)) { throw new Found(node, st) }\n      })(node, state);\n    } catch (e) {\n      if (e instanceof Found) { return e }\n      throw e\n    }\n  }\n\n  // Find the outermost matching node after a given position.\n  function findNodeAfter(node, pos, test, baseVisitor, state) {\n    test = makeTest(test);\n    if (!baseVisitor) { baseVisitor = base; }\n    try {\n      (function c(node, st, override) {\n        if (node.end < pos) { return }\n        var type = override || node.type;\n        if (node.start >= pos && test(type, node)) { throw new Found(node, st) }\n        baseVisitor[type](node, st, c);\n      })(node, state);\n    } catch (e) {\n      if (e instanceof Found) { return e }\n      throw e\n    }\n  }\n\n  // Find the outermost matching node before a given position.\n  function findNodeBefore(node, pos, test, baseVisitor, state) {\n    test = makeTest(test);\n    if (!baseVisitor) { baseVisitor = base; }\n    var max\n    ;(function c(node, st, override) {\n      if (node.start > pos) { return }\n      var type = override || node.type;\n      if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node))\n        { max = new Found(node, st); }\n      baseVisitor[type](node, st, c);\n    })(node, state);\n    return max\n  }\n\n  // Used to create a custom walker. Will fill in all missing node\n  // type properties with the defaults.\n  function make(funcs, baseVisitor) {\n    var visitor = Object.create(baseVisitor || base);\n    for (var type in funcs) { visitor[type] = funcs[type]; }\n    return visitor\n  }\n\n  function skipThrough(node, st, c) { c(node, st); }\n  function ignore(_node, _st, _c) {}\n\n  // Node walkers.\n\n  var base = {};\n\n  base.Program = base.BlockStatement = base.StaticBlock = function (node, st, c) {\n    for (var i = 0, list = node.body; i < list.length; i += 1)\n      {\n      var stmt = list[i];\n\n      c(stmt, st, \"Statement\");\n    }\n  };\n  base.Statement = skipThrough;\n  base.EmptyStatement = ignore;\n  base.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression =\n    function (node, st, c) { return c(node.expression, st, \"Expression\"); };\n  base.IfStatement = function (node, st, c) {\n    c(node.test, st, \"Expression\");\n    c(node.consequent, st, \"Statement\");\n    if (node.alternate) { c(node.alternate, st, \"Statement\"); }\n  };\n  base.LabeledStatement = function (node, st, c) { return c(node.body, st, \"Statement\"); };\n  base.BreakStatement = base.ContinueStatement = ignore;\n  base.WithStatement = function (node, st, c) {\n    c(node.object, st, \"Expression\");\n    c(node.body, st, \"Statement\");\n  };\n  base.SwitchStatement = function (node, st, c) {\n    c(node.discriminant, st, \"Expression\");\n    for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {\n      var cs = list$1[i$1];\n\n      if (cs.test) { c(cs.test, st, \"Expression\"); }\n      for (var i = 0, list = cs.consequent; i < list.length; i += 1)\n        {\n        var cons = list[i];\n\n        c(cons, st, \"Statement\");\n      }\n    }\n  };\n  base.SwitchCase = function (node, st, c) {\n    if (node.test) { c(node.test, st, \"Expression\"); }\n    for (var i = 0, list = node.consequent; i < list.length; i += 1)\n      {\n      var cons = list[i];\n\n      c(cons, st, \"Statement\");\n    }\n  };\n  base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {\n    if (node.argument) { c(node.argument, st, \"Expression\"); }\n  };\n  base.ThrowStatement = base.SpreadElement =\n    function (node, st, c) { return c(node.argument, st, \"Expression\"); };\n  base.TryStatement = function (node, st, c) {\n    c(node.block, st, \"Statement\");\n    if (node.handler) { c(node.handler, st); }\n    if (node.finalizer) { c(node.finalizer, st, \"Statement\"); }\n  };\n  base.CatchClause = function (node, st, c) {\n    if (node.param) { c(node.param, st, \"Pattern\"); }\n    c(node.body, st, \"Statement\");\n  };\n  base.WhileStatement = base.DoWhileStatement = function (node, st, c) {\n    c(node.test, st, \"Expression\");\n    c(node.body, st, \"Statement\");\n  };\n  base.ForStatement = function (node, st, c) {\n    if (node.init) { c(node.init, st, \"ForInit\"); }\n    if (node.test) { c(node.test, st, \"Expression\"); }\n    if (node.update) { c(node.update, st, \"Expression\"); }\n    c(node.body, st, \"Statement\");\n  };\n  base.ForInStatement = base.ForOfStatement = function (node, st, c) {\n    c(node.left, st, \"ForInit\");\n    c(node.right, st, \"Expression\");\n    c(node.body, st, \"Statement\");\n  };\n  base.ForInit = function (node, st, c) {\n    if (node.type === \"VariableDeclaration\") { c(node, st); }\n    else { c(node, st, \"Expression\"); }\n  };\n  base.DebuggerStatement = ignore;\n\n  base.FunctionDeclaration = function (node, st, c) { return c(node, st, \"Function\"); };\n  base.VariableDeclaration = function (node, st, c) {\n    for (var i = 0, list = node.declarations; i < list.length; i += 1)\n      {\n      var decl = list[i];\n\n      c(decl, st);\n    }\n  };\n  base.VariableDeclarator = function (node, st, c) {\n    c(node.id, st, \"Pattern\");\n    if (node.init) { c(node.init, st, \"Expression\"); }\n  };\n\n  base.Function = function (node, st, c) {\n    if (node.id) { c(node.id, st, \"Pattern\"); }\n    for (var i = 0, list = node.params; i < list.length; i += 1)\n      {\n      var param = list[i];\n\n      c(param, st, \"Pattern\");\n    }\n    c(node.body, st, node.expression ? \"Expression\" : \"Statement\");\n  };\n\n  base.Pattern = function (node, st, c) {\n    if (node.type === \"Identifier\")\n      { c(node, st, \"VariablePattern\"); }\n    else if (node.type === \"MemberExpression\")\n      { c(node, st, \"MemberPattern\"); }\n    else\n      { c(node, st); }\n  };\n  base.VariablePattern = ignore;\n  base.MemberPattern = skipThrough;\n  base.RestElement = function (node, st, c) { return c(node.argument, st, \"Pattern\"); };\n  base.ArrayPattern = function (node, st, c) {\n    for (var i = 0, list = node.elements; i < list.length; i += 1) {\n      var elt = list[i];\n\n      if (elt) { c(elt, st, \"Pattern\"); }\n    }\n  };\n  base.ObjectPattern = function (node, st, c) {\n    for (var i = 0, list = node.properties; i < list.length; i += 1) {\n      var prop = list[i];\n\n      if (prop.type === \"Property\") {\n        if (prop.computed) { c(prop.key, st, \"Expression\"); }\n        c(prop.value, st, \"Pattern\");\n      } else if (prop.type === \"RestElement\") {\n        c(prop.argument, st, \"Pattern\");\n      }\n    }\n  };\n\n  base.Expression = skipThrough;\n  base.ThisExpression = base.Super = base.MetaProperty = ignore;\n  base.ArrayExpression = function (node, st, c) {\n    for (var i = 0, list = node.elements; i < list.length; i += 1) {\n      var elt = list[i];\n\n      if (elt) { c(elt, st, \"Expression\"); }\n    }\n  };\n  base.ObjectExpression = function (node, st, c) {\n    for (var i = 0, list = node.properties; i < list.length; i += 1)\n      {\n      var prop = list[i];\n\n      c(prop, st);\n    }\n  };\n  base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;\n  base.SequenceExpression = function (node, st, c) {\n    for (var i = 0, list = node.expressions; i < list.length; i += 1)\n      {\n      var expr = list[i];\n\n      c(expr, st, \"Expression\");\n    }\n  };\n  base.TemplateLiteral = function (node, st, c) {\n    for (var i = 0, list = node.quasis; i < list.length; i += 1)\n      {\n      var quasi = list[i];\n\n      c(quasi, st);\n    }\n\n    for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1)\n      {\n      var expr = list$1[i$1];\n\n      c(expr, st, \"Expression\");\n    }\n  };\n  base.TemplateElement = ignore;\n  base.UnaryExpression = base.UpdateExpression = function (node, st, c) {\n    c(node.argument, st, \"Expression\");\n  };\n  base.BinaryExpression = base.LogicalExpression = function (node, st, c) {\n    c(node.left, st, \"Expression\");\n    c(node.right, st, \"Expression\");\n  };\n  base.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {\n    c(node.left, st, \"Pattern\");\n    c(node.right, st, \"Expression\");\n  };\n  base.ConditionalExpression = function (node, st, c) {\n    c(node.test, st, \"Expression\");\n    c(node.consequent, st, \"Expression\");\n    c(node.alternate, st, \"Expression\");\n  };\n  base.NewExpression = base.CallExpression = function (node, st, c) {\n    c(node.callee, st, \"Expression\");\n    if (node.arguments)\n      { for (var i = 0, list = node.arguments; i < list.length; i += 1)\n        {\n          var arg = list[i];\n\n          c(arg, st, \"Expression\");\n        } }\n  };\n  base.MemberExpression = function (node, st, c) {\n    c(node.object, st, \"Expression\");\n    if (node.computed) { c(node.property, st, \"Expression\"); }\n  };\n  base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {\n    if (node.declaration)\n      { c(node.declaration, st, node.type === \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\"); }\n    if (node.source) { c(node.source, st, \"Expression\"); }\n  };\n  base.ExportAllDeclaration = function (node, st, c) {\n    if (node.exported)\n      { c(node.exported, st); }\n    c(node.source, st, \"Expression\");\n  };\n  base.ImportDeclaration = function (node, st, c) {\n    for (var i = 0, list = node.specifiers; i < list.length; i += 1)\n      {\n      var spec = list[i];\n\n      c(spec, st);\n    }\n    c(node.source, st, \"Expression\");\n  };\n  base.ImportExpression = function (node, st, c) {\n    c(node.source, st, \"Expression\");\n  };\n  base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.PrivateIdentifier = base.Literal = ignore;\n\n  base.TaggedTemplateExpression = function (node, st, c) {\n    c(node.tag, st, \"Expression\");\n    c(node.quasi, st, \"Expression\");\n  };\n  base.ClassDeclaration = base.ClassExpression = function (node, st, c) { return c(node, st, \"Class\"); };\n  base.Class = function (node, st, c) {\n    if (node.id) { c(node.id, st, \"Pattern\"); }\n    if (node.superClass) { c(node.superClass, st, \"Expression\"); }\n    c(node.body, st);\n  };\n  base.ClassBody = function (node, st, c) {\n    for (var i = 0, list = node.body; i < list.length; i += 1)\n      {\n      var elt = list[i];\n\n      c(elt, st);\n    }\n  };\n  base.MethodDefinition = base.PropertyDefinition = base.Property = function (node, st, c) {\n    if (node.computed) { c(node.key, st, \"Expression\"); }\n    if (node.value) { c(node.value, st, \"Expression\"); }\n  };\n\n  exports.ancestor = ancestor;\n  exports.base = base;\n  exports.findNodeAfter = findNodeAfter;\n  exports.findNodeAround = findNodeAround;\n  exports.findNodeAt = findNodeAt;\n  exports.findNodeBefore = findNodeBefore;\n  exports.full = full;\n  exports.fullAncestor = fullAncestor;\n  exports.make = make;\n  exports.recursive = recursive;\n  exports.simple = simple;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}