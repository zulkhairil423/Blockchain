{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveProjectPaths = exports.resolveConfig = void 0;\n\nconst cloneDeep_1 = __importDefault(require(\"lodash/cloneDeep\"));\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst constants_1 = require(\"../../constants\");\n\nconst lang_1 = require(\"../../util/lang\");\n\nconst errors_1 = require(\"../errors\");\n\nconst fs_utils_1 = require(\"../../util/fs-utils\");\n\nconst default_config_1 = require(\"./default-config\");\n/**\n * This functions resolves the hardhat config, setting its defaults and\n * normalizing its types if necessary.\n *\n * @param userConfigPath the user config filepath\n * @param userConfig     the user config object\n *\n * @returns the resolved config\n */\n\n\nfunction resolveConfig(userConfigPath, userConfig) {\n  userConfig = (0, cloneDeep_1.default)(userConfig);\n  return { ...userConfig,\n    defaultNetwork: userConfig.defaultNetwork ?? default_config_1.defaultDefaultNetwork,\n    paths: resolveProjectPaths(userConfigPath, userConfig.paths),\n    networks: resolveNetworksConfig(userConfig.networks),\n    solidity: resolveSolidityConfig(userConfig),\n    mocha: resolveMochaConfig(userConfig)\n  };\n}\n\nexports.resolveConfig = resolveConfig;\n\nfunction resolveNetworksConfig() {\n  let networksConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const hardhatNetworkConfig = networksConfig[constants_1.HARDHAT_NETWORK_NAME];\n  const localhostNetworkConfig = networksConfig.localhost ?? undefined;\n  const hardhat = resolveHardhatNetworkConfig(hardhatNetworkConfig);\n  const localhost = resolveHttpNetworkConfig({ ...(0, cloneDeep_1.default)(default_config_1.defaultLocalhostNetworkParams),\n    ...localhostNetworkConfig\n  });\n  const otherNetworks = (0, lang_1.fromEntries)(Object.entries(networksConfig).filter(_ref => {\n    let [name, config] = _ref;\n    return name !== \"localhost\" && name !== \"hardhat\" && config !== undefined && isHttpNetworkConfig(config);\n  }).map(_ref2 => {\n    let [name, config] = _ref2;\n    return [name, resolveHttpNetworkConfig(config)];\n  }));\n  return {\n    hardhat,\n    localhost,\n    ...otherNetworks\n  };\n}\n\nfunction isHttpNetworkConfig(config) {\n  return \"url\" in config;\n}\n\nfunction normalizeHexString(str) {\n  const normalized = str.trim().toLowerCase();\n\n  if (normalized.startsWith(\"0x\")) {\n    return normalized;\n  }\n\n  return `0x${normalized}`;\n}\n\nfunction resolveHardhatNetworkConfig() {\n  let hardhatNetworkConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const clonedDefaultHardhatNetworkParams = (0, cloneDeep_1.default)(default_config_1.defaultHardhatNetworkParams);\n  const accounts = hardhatNetworkConfig.accounts === undefined ? default_config_1.defaultHardhatNetworkHdAccountsConfigParams : Array.isArray(hardhatNetworkConfig.accounts) ? hardhatNetworkConfig.accounts.map(_ref3 => {\n    let {\n      privateKey,\n      balance\n    } = _ref3;\n    return {\n      privateKey: normalizeHexString(privateKey),\n      balance\n    };\n  }) : { ...default_config_1.defaultHardhatNetworkHdAccountsConfigParams,\n    ...hardhatNetworkConfig.accounts\n  };\n  const forking = hardhatNetworkConfig.forking !== undefined ? {\n    url: hardhatNetworkConfig.forking.url,\n    enabled: hardhatNetworkConfig.forking.enabled ?? true,\n    httpHeaders: {}\n  } : undefined;\n\n  if (forking !== undefined) {\n    const blockNumber = hardhatNetworkConfig?.forking?.blockNumber;\n\n    if (blockNumber !== undefined) {\n      forking.blockNumber = hardhatNetworkConfig?.forking?.blockNumber;\n    }\n\n    const httpHeaders = hardhatNetworkConfig.forking?.httpHeaders;\n\n    if (httpHeaders !== undefined) {\n      forking.httpHeaders = httpHeaders;\n    }\n  }\n\n  const mining = resolveMiningConfig(hardhatNetworkConfig.mining);\n  const minGasPrice = BigInt(hardhatNetworkConfig.minGasPrice ?? clonedDefaultHardhatNetworkParams.minGasPrice);\n  const blockGasLimit = hardhatNetworkConfig.blockGasLimit ?? clonedDefaultHardhatNetworkParams.blockGasLimit;\n  const gas = hardhatNetworkConfig.gas ?? blockGasLimit;\n  const gasPrice = hardhatNetworkConfig.gasPrice ?? clonedDefaultHardhatNetworkParams.gasPrice;\n  const initialBaseFeePerGas = hardhatNetworkConfig.initialBaseFeePerGas ?? clonedDefaultHardhatNetworkParams.initialBaseFeePerGas;\n  const initialDate = hardhatNetworkConfig.initialDate ?? new Date().toISOString();\n  const chains = new Map(default_config_1.defaultHardhatNetworkParams.chains);\n\n  if (hardhatNetworkConfig.chains !== undefined) {\n    for (const [chainId, userChainConfig] of Object.entries(hardhatNetworkConfig.chains)) {\n      const chainConfig = {\n        hardforkHistory: new Map()\n      };\n\n      if (userChainConfig.hardforkHistory !== undefined) {\n        for (const [name, block] of Object.entries(userChainConfig.hardforkHistory)) {\n          chainConfig.hardforkHistory.set(name, block);\n        }\n      }\n\n      chains.set(parseInt(chainId, 10), chainConfig);\n    }\n  }\n\n  const config = { ...clonedDefaultHardhatNetworkParams,\n    ...hardhatNetworkConfig,\n    accounts,\n    forking,\n    mining,\n    blockGasLimit,\n    gas,\n    gasPrice,\n    initialBaseFeePerGas,\n    initialDate,\n    minGasPrice,\n    chains\n  }; // We do it this way because ts gets lost otherwise\n\n  if (config.forking === undefined) {\n    delete config.forking;\n  }\n\n  if (config.initialBaseFeePerGas === undefined) {\n    delete config.initialBaseFeePerGas;\n  }\n\n  return config;\n}\n\nfunction isHdAccountsConfig(accounts) {\n  return typeof accounts === \"object\" && !Array.isArray(accounts);\n}\n\nfunction resolveHttpNetworkConfig(networkConfig) {\n  const accounts = networkConfig.accounts === undefined ? default_config_1.defaultHttpNetworkParams.accounts : isHdAccountsConfig(networkConfig.accounts) ? { ...default_config_1.defaultHdAccountsConfigParams,\n    ...networkConfig.accounts\n  } : Array.isArray(networkConfig.accounts) ? networkConfig.accounts.map(normalizeHexString) : \"remote\";\n  const url = networkConfig.url;\n  (0, errors_1.assertHardhatInvariant)(url !== undefined, \"Invalid http network config provided. URL missing.\");\n  return { ...(0, cloneDeep_1.default)(default_config_1.defaultHttpNetworkParams),\n    ...networkConfig,\n    accounts,\n    url,\n    gas: networkConfig.gas ?? default_config_1.defaultHttpNetworkParams.gas,\n    gasPrice: networkConfig.gasPrice ?? default_config_1.defaultHttpNetworkParams.gasPrice\n  };\n}\n\nfunction resolveMiningConfig(userConfig) {\n  const mempool = resolveMempoolConfig(userConfig?.mempool);\n\n  if (userConfig === undefined) {\n    return {\n      auto: true,\n      interval: 0,\n      mempool\n    };\n  }\n\n  const {\n    auto,\n    interval\n  } = userConfig;\n\n  if (auto === undefined && interval === undefined) {\n    return {\n      auto: true,\n      interval: 0,\n      mempool\n    };\n  }\n\n  if (auto === undefined && interval !== undefined) {\n    return {\n      auto: false,\n      interval,\n      mempool\n    };\n  }\n\n  if (auto !== undefined && interval === undefined) {\n    return {\n      auto,\n      interval: 0,\n      mempool\n    };\n  } // ts can't infer it, but both values are defined here\n\n\n  return {\n    auto: auto,\n    interval: interval,\n    mempool\n  };\n}\n\nfunction resolveMempoolConfig(userConfig) {\n  if (userConfig === undefined) {\n    return {\n      order: \"priority\"\n    };\n  }\n\n  if (userConfig.order === undefined) {\n    return {\n      order: \"priority\"\n    };\n  }\n\n  return {\n    order: userConfig.order\n  };\n}\n\nfunction resolveSolidityConfig(userConfig) {\n  const userSolidityConfig = userConfig.solidity ?? default_config_1.DEFAULT_SOLC_VERSION;\n  const multiSolcConfig = normalizeSolidityConfig(userSolidityConfig);\n  const overrides = multiSolcConfig.overrides ?? {};\n  return {\n    compilers: multiSolcConfig.compilers.map(resolveCompiler),\n    overrides: (0, lang_1.fromEntries)(Object.entries(overrides).map(_ref4 => {\n      let [name, config] = _ref4;\n      return [name, resolveCompiler(config)];\n    }))\n  };\n}\n\nfunction normalizeSolidityConfig(solidityConfig) {\n  if (typeof solidityConfig === \"string\") {\n    return {\n      compilers: [{\n        version: solidityConfig\n      }]\n    };\n  }\n\n  if (\"version\" in solidityConfig) {\n    return {\n      compilers: [solidityConfig]\n    };\n  }\n\n  return solidityConfig;\n}\n\nfunction resolveCompiler(compiler) {\n  const resolved = {\n    version: compiler.version,\n    settings: compiler.settings ?? {}\n  };\n  resolved.settings.optimizer = {\n    enabled: false,\n    runs: 200,\n    ...resolved.settings.optimizer\n  };\n\n  if (resolved.settings.outputSelection === undefined) {\n    resolved.settings.outputSelection = {};\n  }\n\n  for (const [file, contractSelection] of Object.entries(default_config_1.defaultSolcOutputSelection)) {\n    if (resolved.settings.outputSelection[file] === undefined) {\n      resolved.settings.outputSelection[file] = {};\n    }\n\n    for (const [contract, outputs] of Object.entries(contractSelection)) {\n      if (resolved.settings.outputSelection[file][contract] === undefined) {\n        resolved.settings.outputSelection[file][contract] = [];\n      }\n\n      for (const output of outputs) {\n        if (!resolved.settings.outputSelection[file][contract].includes(output)) {\n          resolved.settings.outputSelection[file][contract].push(output);\n        }\n      }\n    }\n  }\n\n  return resolved;\n}\n\nfunction resolveMochaConfig(userConfig) {\n  return { ...(0, cloneDeep_1.default)(default_config_1.defaultMochaOptions),\n    ...userConfig.mocha\n  };\n}\n/**\n * This function resolves the ProjectPathsConfig object from the user-provided config\n * and its path. The logic of this is not obvious and should well be document.\n * The good thing is that most users will never use this.\n *\n * Explanation:\n *    - paths.configFile is not overridable\n *    - If a path is absolute it is used \"as is\".\n *    - If the root path is relative, it's resolved from paths.configFile's dir.\n *    - If any other path is relative, it's resolved from paths.root.\n *    - Plugin-defined paths are not resolved, but encouraged to follow the same pattern.\n */\n\n\nfunction resolveProjectPaths(userConfigPath) {\n  let userPaths = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const configFile = (0, fs_utils_1.getRealPathSync)(userConfigPath);\n  const configDir = path_1.default.dirname(configFile);\n  const root = resolvePathFrom(configDir, \"\", userPaths.root);\n  return { ...userPaths,\n    root,\n    configFile,\n    sources: resolvePathFrom(root, \"contracts\", userPaths.sources),\n    cache: resolvePathFrom(root, \"cache\", userPaths.cache),\n    artifacts: resolvePathFrom(root, \"artifacts\", userPaths.artifacts),\n    tests: resolvePathFrom(root, \"test\", userPaths.tests)\n  };\n}\n\nexports.resolveProjectPaths = resolveProjectPaths;\n\nfunction resolvePathFrom(from, defaultPath) {\n  let relativeOrAbsolutePath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultPath;\n\n  if (path_1.default.isAbsolute(relativeOrAbsolutePath)) {\n    return relativeOrAbsolutePath;\n  }\n\n  return path_1.default.join(from, relativeOrAbsolutePath);\n}","map":{"version":3,"mappings":"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","names":["resolveConfig","userConfigPath","userConfig","defaultNetwork","default_config_1","paths","resolveProjectPaths","networks","resolveNetworksConfig","solidity","resolveSolidityConfig","mocha","resolveMochaConfig","exports","networksConfig","hardhatNetworkConfig","constants_1","localhostNetworkConfig","localhost","undefined","hardhat","resolveHardhatNetworkConfig","resolveHttpNetworkConfig","otherNetworks","Object","entries","filter","name","config","isHttpNetworkConfig","map","normalizeHexString","str","normalized","trim","toLowerCase","startsWith","clonedDefaultHardhatNetworkParams","accounts","Array","isArray","privateKey","balance","forking","url","enabled","httpHeaders","blockNumber","mining","resolveMiningConfig","minGasPrice","BigInt","blockGasLimit","gas","gasPrice","initialBaseFeePerGas","initialDate","Date","toISOString","chains","Map","chainId","userChainConfig","chainConfig","hardforkHistory","block","set","parseInt","isHdAccountsConfig","networkConfig","mempool","resolveMempoolConfig","auto","interval","order","userSolidityConfig","multiSolcConfig","normalizeSolidityConfig","overrides","compilers","resolveCompiler","solidityConfig","version","compiler","resolved","settings","optimizer","runs","outputSelection","file","contractSelection","contract","outputs","output","includes","push","userPaths","configFile","configDir","path_1","dirname","root","resolvePathFrom","sources","cache","artifacts","tests","from","defaultPath","relativeOrAbsolutePath","isAbsolute","join"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\hardhat\\src\\internal\\core\\config\\config-resolution.ts"],"sourcesContent":["import cloneDeep from \"lodash/cloneDeep\";\nimport path from \"path\";\n\nimport {\n  HardhatConfig,\n  HardhatNetworkAccountsConfig,\n  HardhatNetworkChainConfig,\n  HardhatNetworkChainsConfig,\n  HardhatNetworkConfig,\n  HardhatNetworkForkingConfig,\n  HardhatNetworkMiningConfig,\n  HardhatNetworkMiningUserConfig,\n  HardhatNetworkMempoolConfig,\n  HardhatNetworkMempoolUserConfig,\n  HardhatNetworkUserConfig,\n  HardhatUserConfig,\n  HDAccountsUserConfig,\n  HttpNetworkAccountsConfig,\n  HttpNetworkAccountsUserConfig,\n  HttpNetworkConfig,\n  HttpNetworkUserConfig,\n  MultiSolcUserConfig,\n  NetworksConfig,\n  NetworksUserConfig,\n  NetworkUserConfig,\n  ProjectPathsConfig,\n  ProjectPathsUserConfig,\n  SolcConfig,\n  SolcUserConfig,\n  SolidityConfig,\n  SolidityUserConfig,\n} from \"../../../types\";\nimport { HARDHAT_NETWORK_NAME } from \"../../constants\";\nimport { HardforkName } from \"../../util/hardforks\";\nimport { fromEntries } from \"../../util/lang\";\nimport { assertHardhatInvariant } from \"../errors\";\n\nimport { getRealPathSync } from \"../../util/fs-utils\";\nimport {\n  DEFAULT_SOLC_VERSION,\n  defaultDefaultNetwork,\n  defaultHardhatNetworkHdAccountsConfigParams,\n  defaultHardhatNetworkParams,\n  defaultHdAccountsConfigParams,\n  defaultHttpNetworkParams,\n  defaultLocalhostNetworkParams,\n  defaultMochaOptions,\n  defaultSolcOutputSelection,\n} from \"./default-config\";\n\n/**\n * This functions resolves the hardhat config, setting its defaults and\n * normalizing its types if necessary.\n *\n * @param userConfigPath the user config filepath\n * @param userConfig     the user config object\n *\n * @returns the resolved config\n */\nexport function resolveConfig(\n  userConfigPath: string,\n  userConfig: HardhatUserConfig\n): HardhatConfig {\n  userConfig = cloneDeep(userConfig);\n\n  return {\n    ...userConfig,\n    defaultNetwork: userConfig.defaultNetwork ?? defaultDefaultNetwork,\n    paths: resolveProjectPaths(userConfigPath, userConfig.paths),\n    networks: resolveNetworksConfig(userConfig.networks),\n    solidity: resolveSolidityConfig(userConfig),\n    mocha: resolveMochaConfig(userConfig),\n  };\n}\n\nfunction resolveNetworksConfig(\n  networksConfig: NetworksUserConfig = {}\n): NetworksConfig {\n  const hardhatNetworkConfig = networksConfig[HARDHAT_NETWORK_NAME];\n\n  const localhostNetworkConfig =\n    (networksConfig.localhost as HttpNetworkUserConfig) ?? undefined;\n\n  const hardhat = resolveHardhatNetworkConfig(hardhatNetworkConfig);\n  const localhost = resolveHttpNetworkConfig({\n    ...cloneDeep(defaultLocalhostNetworkParams),\n    ...localhostNetworkConfig,\n  });\n\n  const otherNetworks: { [name: string]: HttpNetworkConfig } = fromEntries(\n    Object.entries(networksConfig)\n      .filter(\n        ([name, config]) =>\n          name !== \"localhost\" &&\n          name !== \"hardhat\" &&\n          config !== undefined &&\n          isHttpNetworkConfig(config)\n      )\n      .map(([name, config]) => [\n        name,\n        resolveHttpNetworkConfig(config as HttpNetworkUserConfig),\n      ])\n  );\n\n  return {\n    hardhat,\n    localhost,\n    ...otherNetworks,\n  };\n}\n\nfunction isHttpNetworkConfig(\n  config: NetworkUserConfig\n): config is HttpNetworkUserConfig {\n  return \"url\" in config;\n}\n\nfunction normalizeHexString(str: string): string {\n  const normalized = str.trim().toLowerCase();\n  if (normalized.startsWith(\"0x\")) {\n    return normalized;\n  }\n\n  return `0x${normalized}`;\n}\n\nfunction resolveHardhatNetworkConfig(\n  hardhatNetworkConfig: HardhatNetworkUserConfig = {}\n): HardhatNetworkConfig {\n  const clonedDefaultHardhatNetworkParams = cloneDeep(\n    defaultHardhatNetworkParams\n  );\n\n  const accounts: HardhatNetworkAccountsConfig =\n    hardhatNetworkConfig.accounts === undefined\n      ? defaultHardhatNetworkHdAccountsConfigParams\n      : Array.isArray(hardhatNetworkConfig.accounts)\n      ? hardhatNetworkConfig.accounts.map(({ privateKey, balance }) => ({\n          privateKey: normalizeHexString(privateKey),\n          balance,\n        }))\n      : {\n          ...defaultHardhatNetworkHdAccountsConfigParams,\n          ...hardhatNetworkConfig.accounts,\n        };\n\n  const forking: HardhatNetworkForkingConfig | undefined =\n    hardhatNetworkConfig.forking !== undefined\n      ? {\n          url: hardhatNetworkConfig.forking.url,\n          enabled: hardhatNetworkConfig.forking.enabled ?? true,\n          httpHeaders: {},\n        }\n      : undefined;\n\n  if (forking !== undefined) {\n    const blockNumber = hardhatNetworkConfig?.forking?.blockNumber;\n    if (blockNumber !== undefined) {\n      forking.blockNumber = hardhatNetworkConfig?.forking?.blockNumber;\n    }\n\n    const httpHeaders = hardhatNetworkConfig.forking?.httpHeaders;\n    if (httpHeaders !== undefined) {\n      forking.httpHeaders = httpHeaders;\n    }\n  }\n\n  const mining = resolveMiningConfig(hardhatNetworkConfig.mining);\n\n  const minGasPrice = BigInt(\n    hardhatNetworkConfig.minGasPrice ??\n      clonedDefaultHardhatNetworkParams.minGasPrice\n  );\n\n  const blockGasLimit =\n    hardhatNetworkConfig.blockGasLimit ??\n    clonedDefaultHardhatNetworkParams.blockGasLimit;\n\n  const gas = hardhatNetworkConfig.gas ?? blockGasLimit;\n  const gasPrice =\n    hardhatNetworkConfig.gasPrice ?? clonedDefaultHardhatNetworkParams.gasPrice;\n  const initialBaseFeePerGas =\n    hardhatNetworkConfig.initialBaseFeePerGas ??\n    clonedDefaultHardhatNetworkParams.initialBaseFeePerGas;\n\n  const initialDate =\n    hardhatNetworkConfig.initialDate ?? new Date().toISOString();\n\n  const chains: HardhatNetworkChainsConfig = new Map(\n    defaultHardhatNetworkParams.chains\n  );\n  if (hardhatNetworkConfig.chains !== undefined) {\n    for (const [chainId, userChainConfig] of Object.entries(\n      hardhatNetworkConfig.chains\n    )) {\n      const chainConfig: HardhatNetworkChainConfig = {\n        hardforkHistory: new Map(),\n      };\n      if (userChainConfig.hardforkHistory !== undefined) {\n        for (const [name, block] of Object.entries(\n          userChainConfig.hardforkHistory\n        )) {\n          chainConfig.hardforkHistory.set(\n            name as HardforkName,\n            block as number\n          );\n        }\n      }\n      chains.set(parseInt(chainId, 10), chainConfig);\n    }\n  }\n\n  const config: HardhatNetworkConfig = {\n    ...clonedDefaultHardhatNetworkParams,\n    ...hardhatNetworkConfig,\n    accounts,\n    forking,\n    mining,\n    blockGasLimit,\n    gas,\n    gasPrice,\n    initialBaseFeePerGas,\n    initialDate,\n    minGasPrice,\n    chains,\n  };\n\n  // We do it this way because ts gets lost otherwise\n  if (config.forking === undefined) {\n    delete config.forking;\n  }\n  if (config.initialBaseFeePerGas === undefined) {\n    delete config.initialBaseFeePerGas;\n  }\n\n  return config;\n}\n\nfunction isHdAccountsConfig(\n  accounts: HttpNetworkAccountsUserConfig\n): accounts is HDAccountsUserConfig {\n  return typeof accounts === \"object\" && !Array.isArray(accounts);\n}\n\nfunction resolveHttpNetworkConfig(\n  networkConfig: HttpNetworkUserConfig\n): HttpNetworkConfig {\n  const accounts: HttpNetworkAccountsConfig =\n    networkConfig.accounts === undefined\n      ? defaultHttpNetworkParams.accounts\n      : isHdAccountsConfig(networkConfig.accounts)\n      ? {\n          ...defaultHdAccountsConfigParams,\n          ...networkConfig.accounts,\n        }\n      : Array.isArray(networkConfig.accounts)\n      ? networkConfig.accounts.map(normalizeHexString)\n      : \"remote\";\n\n  const url = networkConfig.url;\n\n  assertHardhatInvariant(\n    url !== undefined,\n    \"Invalid http network config provided. URL missing.\"\n  );\n\n  return {\n    ...cloneDeep(defaultHttpNetworkParams),\n    ...networkConfig,\n    accounts,\n    url,\n    gas: networkConfig.gas ?? defaultHttpNetworkParams.gas,\n    gasPrice: networkConfig.gasPrice ?? defaultHttpNetworkParams.gasPrice,\n  };\n}\n\nfunction resolveMiningConfig(\n  userConfig: HardhatNetworkMiningUserConfig | undefined\n): HardhatNetworkMiningConfig {\n  const mempool = resolveMempoolConfig(userConfig?.mempool);\n  if (userConfig === undefined) {\n    return {\n      auto: true,\n      interval: 0,\n      mempool,\n    };\n  }\n\n  const { auto, interval } = userConfig;\n\n  if (auto === undefined && interval === undefined) {\n    return {\n      auto: true,\n      interval: 0,\n      mempool,\n    };\n  }\n\n  if (auto === undefined && interval !== undefined) {\n    return {\n      auto: false,\n      interval,\n      mempool,\n    };\n  }\n\n  if (auto !== undefined && interval === undefined) {\n    return {\n      auto,\n      interval: 0,\n      mempool,\n    };\n  }\n\n  // ts can't infer it, but both values are defined here\n  return {\n    auto: auto!,\n    interval: interval!,\n    mempool,\n  };\n}\n\nfunction resolveMempoolConfig(\n  userConfig: HardhatNetworkMempoolUserConfig | undefined\n): HardhatNetworkMempoolConfig {\n  if (userConfig === undefined) {\n    return {\n      order: \"priority\",\n    };\n  }\n\n  if (userConfig.order === undefined) {\n    return {\n      order: \"priority\",\n    };\n  }\n\n  return {\n    order: userConfig.order,\n  } as HardhatNetworkMempoolConfig;\n}\n\nfunction resolveSolidityConfig(userConfig: HardhatUserConfig): SolidityConfig {\n  const userSolidityConfig = userConfig.solidity ?? DEFAULT_SOLC_VERSION;\n\n  const multiSolcConfig: MultiSolcUserConfig =\n    normalizeSolidityConfig(userSolidityConfig);\n\n  const overrides = multiSolcConfig.overrides ?? {};\n\n  return {\n    compilers: multiSolcConfig.compilers.map(resolveCompiler),\n    overrides: fromEntries(\n      Object.entries(overrides).map(([name, config]) => [\n        name,\n        resolveCompiler(config),\n      ])\n    ),\n  };\n}\n\nfunction normalizeSolidityConfig(\n  solidityConfig: SolidityUserConfig\n): MultiSolcUserConfig {\n  if (typeof solidityConfig === \"string\") {\n    return {\n      compilers: [\n        {\n          version: solidityConfig,\n        },\n      ],\n    };\n  }\n\n  if (\"version\" in solidityConfig) {\n    return { compilers: [solidityConfig] };\n  }\n\n  return solidityConfig;\n}\n\nfunction resolveCompiler(compiler: SolcUserConfig): SolcConfig {\n  const resolved: SolcConfig = {\n    version: compiler.version,\n    settings: compiler.settings ?? {},\n  };\n\n  resolved.settings.optimizer = {\n    enabled: false,\n    runs: 200,\n    ...resolved.settings.optimizer,\n  };\n\n  if (resolved.settings.outputSelection === undefined) {\n    resolved.settings.outputSelection = {};\n  }\n\n  for (const [file, contractSelection] of Object.entries(\n    defaultSolcOutputSelection\n  )) {\n    if (resolved.settings.outputSelection[file] === undefined) {\n      resolved.settings.outputSelection[file] = {};\n    }\n\n    for (const [contract, outputs] of Object.entries(contractSelection)) {\n      if (resolved.settings.outputSelection[file][contract] === undefined) {\n        resolved.settings.outputSelection[file][contract] = [];\n      }\n\n      for (const output of outputs) {\n        if (\n          !resolved.settings.outputSelection[file][contract].includes(output)\n        ) {\n          resolved.settings.outputSelection[file][contract].push(output);\n        }\n      }\n    }\n  }\n\n  return resolved;\n}\n\nfunction resolveMochaConfig(userConfig: HardhatUserConfig): Mocha.MochaOptions {\n  return {\n    ...cloneDeep(defaultMochaOptions),\n    ...userConfig.mocha,\n  };\n}\n\n/**\n * This function resolves the ProjectPathsConfig object from the user-provided config\n * and its path. The logic of this is not obvious and should well be document.\n * The good thing is that most users will never use this.\n *\n * Explanation:\n *    - paths.configFile is not overridable\n *    - If a path is absolute it is used \"as is\".\n *    - If the root path is relative, it's resolved from paths.configFile's dir.\n *    - If any other path is relative, it's resolved from paths.root.\n *    - Plugin-defined paths are not resolved, but encouraged to follow the same pattern.\n */\nexport function resolveProjectPaths(\n  userConfigPath: string,\n  userPaths: ProjectPathsUserConfig = {}\n): ProjectPathsConfig {\n  const configFile = getRealPathSync(userConfigPath);\n  const configDir = path.dirname(configFile);\n\n  const root = resolvePathFrom(configDir, \"\", userPaths.root);\n\n  return {\n    ...userPaths,\n    root,\n    configFile,\n    sources: resolvePathFrom(root, \"contracts\", userPaths.sources),\n    cache: resolvePathFrom(root, \"cache\", userPaths.cache),\n    artifacts: resolvePathFrom(root, \"artifacts\", userPaths.artifacts),\n    tests: resolvePathFrom(root, \"test\", userPaths.tests),\n  };\n}\n\nfunction resolvePathFrom(\n  from: string,\n  defaultPath: string,\n  relativeOrAbsolutePath: string = defaultPath\n) {\n  if (path.isAbsolute(relativeOrAbsolutePath)) {\n    return relativeOrAbsolutePath;\n  }\n\n  return path.join(from, relativeOrAbsolutePath);\n}\n"]},"metadata":{},"sourceType":"script"}