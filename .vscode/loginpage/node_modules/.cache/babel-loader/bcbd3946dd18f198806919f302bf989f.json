{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findDistance = exports.parseName = exports.parseFullyQualifiedName = exports.isFullyQualifiedName = exports.getFullyQualifiedName = void 0;\n\nconst errors_1 = require(\"../internal/core/errors\");\n\nconst errors_list_1 = require(\"../internal/core/errors-list\");\n/**\n * Returns a fully qualified name from a sourceName and contractName.\n */\n\n\nfunction getFullyQualifiedName(sourceName, contractName) {\n  return `${sourceName}:${contractName}`;\n}\n\nexports.getFullyQualifiedName = getFullyQualifiedName;\n/**\n * Returns true if a name is fully qualified, and not just a bare contract name.\n */\n\nfunction isFullyQualifiedName(name) {\n  return name.includes(\":\");\n}\n\nexports.isFullyQualifiedName = isFullyQualifiedName;\n/**\n * Parses a fully qualified name.\n *\n * @param fullyQualifiedName It MUST be a fully qualified name.\n */\n\nfunction parseFullyQualifiedName(fullyQualifiedName) {\n  const {\n    sourceName,\n    contractName\n  } = parseName(fullyQualifiedName);\n\n  if (sourceName === undefined) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.CONTRACT_NAMES.INVALID_FULLY_QUALIFIED_NAME, {\n      name: fullyQualifiedName\n    });\n  }\n\n  return {\n    sourceName,\n    contractName\n  };\n}\n\nexports.parseFullyQualifiedName = parseFullyQualifiedName;\n/**\n * Parses a name, which can be a bare contract name, or a fully qualified name.\n */\n\nfunction parseName(name) {\n  const parts = name.split(\":\");\n\n  if (parts.length === 1) {\n    return {\n      contractName: parts[0]\n    };\n  }\n\n  const contractName = parts[parts.length - 1];\n  const sourceName = parts.slice(0, parts.length - 1).join(\":\");\n  return {\n    sourceName,\n    contractName\n  };\n}\n\nexports.parseName = parseName;\n/**\n * Returns the edit-distance between two given strings using Levenshtein distance.\n *\n * @param a First string being compared\n * @param b Second string being compared\n * @returns distance between the two strings (lower number == more similar)\n * @see https://github.com/gustf/js-levenshtein\n * @license MIT - https://github.com/gustf/js-levenshtein/blob/master/LICENSE\n */\n\nfunction findDistance(a, b) {\n  function _min(_d0, _d1, _d2, _bx, _ay) {\n    return _d0 < _d1 || _d2 < _d1 ? _d0 > _d2 ? _d2 + 1 : _d0 + 1 : _bx === _ay ? _d1 : _d1 + 1;\n  }\n\n  if (a === b) {\n    return 0;\n  }\n\n  if (a.length > b.length) {\n    [a, b] = [b, a];\n  }\n\n  let la = a.length;\n  let lb = b.length;\n\n  while (la > 0 && a.charCodeAt(la - 1) === b.charCodeAt(lb - 1)) {\n    la--;\n    lb--;\n  }\n\n  let offset = 0;\n\n  while (offset < la && a.charCodeAt(offset) === b.charCodeAt(offset)) {\n    offset++;\n  }\n\n  la -= offset;\n  lb -= offset;\n\n  if (la === 0 || lb < 3) {\n    return lb;\n  }\n\n  let x = 0;\n  let y;\n  let d0;\n  let d1;\n  let d2;\n  let d3;\n  let dd = 0; // typescript gets angry if we don't assign here\n\n  let dy;\n  let ay;\n  let bx0;\n  let bx1;\n  let bx2;\n  let bx3;\n  const vector = [];\n\n  for (y = 0; y < la; y++) {\n    vector.push(y + 1);\n    vector.push(a.charCodeAt(offset + y));\n  }\n\n  const len = vector.length - 1;\n\n  for (; x < lb - 3;) {\n    bx0 = b.charCodeAt(offset + (d0 = x));\n    bx1 = b.charCodeAt(offset + (d1 = x + 1));\n    bx2 = b.charCodeAt(offset + (d2 = x + 2));\n    bx3 = b.charCodeAt(offset + (d3 = x + 3));\n    dd = x += 4;\n\n    for (y = 0; y < len; y += 2) {\n      dy = vector[y];\n      ay = vector[y + 1];\n      d0 = _min(dy, d0, d1, bx0, ay);\n      d1 = _min(d0, d1, d2, bx1, ay);\n      d2 = _min(d1, d2, d3, bx2, ay);\n      dd = _min(d2, d3, dd, bx3, ay);\n      vector[y] = dd;\n      d3 = d2;\n      d2 = d1;\n      d1 = d0;\n      d0 = dy;\n    }\n  }\n\n  for (; x < lb;) {\n    bx0 = b.charCodeAt(offset + (d0 = x));\n    dd = ++x;\n\n    for (y = 0; y < len; y += 2) {\n      dy = vector[y];\n      vector[y] = dd = _min(dy, d0, dd, bx0, vector[y + 1]);\n      d0 = dy;\n    }\n  }\n\n  return dd;\n}\n\nexports.findDistance = findDistance;","map":{"version":3,"mappings":"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","names":["getFullyQualifiedName","sourceName","contractName","exports","isFullyQualifiedName","name","includes","parseFullyQualifiedName","fullyQualifiedName","parseName","undefined","errors_1","errors_list_1","CONTRACT_NAMES","INVALID_FULLY_QUALIFIED_NAME","parts","split","length","slice","join","findDistance","a","b","_min","_d0","_d1","_d2","_bx","_ay","la","lb","charCodeAt","offset","x","y","d0","d1","d2","d3","dd","dy","ay","bx0","bx1","bx2","bx3","vector","push","len"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\hardhat\\src\\utils\\contract-names.ts"],"sourcesContent":["import { HardhatError } from \"../internal/core/errors\";\nimport { ERRORS } from \"../internal/core/errors-list\";\n\n/**\n * Returns a fully qualified name from a sourceName and contractName.\n */\nexport function getFullyQualifiedName(\n  sourceName: string,\n  contractName: string\n): string {\n  return `${sourceName}:${contractName}`;\n}\n\n/**\n * Returns true if a name is fully qualified, and not just a bare contract name.\n */\nexport function isFullyQualifiedName(name: string): boolean {\n  return name.includes(\":\");\n}\n\n/**\n * Parses a fully qualified name.\n *\n * @param fullyQualifiedName It MUST be a fully qualified name.\n */\nexport function parseFullyQualifiedName(fullyQualifiedName: string): {\n  sourceName: string;\n  contractName: string;\n} {\n  const { sourceName, contractName } = parseName(fullyQualifiedName);\n\n  if (sourceName === undefined) {\n    throw new HardhatError(ERRORS.CONTRACT_NAMES.INVALID_FULLY_QUALIFIED_NAME, {\n      name: fullyQualifiedName,\n    });\n  }\n\n  return { sourceName, contractName };\n}\n\n/**\n * Parses a name, which can be a bare contract name, or a fully qualified name.\n */\nexport function parseName(name: string): {\n  sourceName?: string;\n  contractName: string;\n} {\n  const parts = name.split(\":\");\n\n  if (parts.length === 1) {\n    return { contractName: parts[0] };\n  }\n\n  const contractName = parts[parts.length - 1];\n  const sourceName = parts.slice(0, parts.length - 1).join(\":\");\n\n  return { sourceName, contractName };\n}\n\n/**\n * Returns the edit-distance between two given strings using Levenshtein distance.\n *\n * @param a First string being compared\n * @param b Second string being compared\n * @returns distance between the two strings (lower number == more similar)\n * @see https://github.com/gustf/js-levenshtein\n * @license MIT - https://github.com/gustf/js-levenshtein/blob/master/LICENSE\n */\nexport function findDistance(a: string, b: string): number {\n  function _min(\n    _d0: number,\n    _d1: number,\n    _d2: number,\n    _bx: number,\n    _ay: number\n  ): number {\n    return _d0 < _d1 || _d2 < _d1\n      ? _d0 > _d2\n        ? _d2 + 1\n        : _d0 + 1\n      : _bx === _ay\n      ? _d1\n      : _d1 + 1;\n  }\n\n  if (a === b) {\n    return 0;\n  }\n\n  if (a.length > b.length) {\n    [a, b] = [b, a];\n  }\n\n  let la = a.length;\n  let lb = b.length;\n\n  while (la > 0 && a.charCodeAt(la - 1) === b.charCodeAt(lb - 1)) {\n    la--;\n    lb--;\n  }\n\n  let offset = 0;\n\n  while (offset < la && a.charCodeAt(offset) === b.charCodeAt(offset)) {\n    offset++;\n  }\n\n  la -= offset;\n  lb -= offset;\n\n  if (la === 0 || lb < 3) {\n    return lb;\n  }\n\n  let x = 0;\n  let y: number;\n  let d0: number;\n  let d1: number;\n  let d2: number;\n  let d3: number;\n  let dd: number = 0; // typescript gets angry if we don't assign here\n  let dy: number;\n  let ay: number;\n  let bx0: number;\n  let bx1: number;\n  let bx2: number;\n  let bx3: number;\n\n  const vector = [];\n\n  for (y = 0; y < la; y++) {\n    vector.push(y + 1);\n    vector.push(a.charCodeAt(offset + y));\n  }\n\n  const len = vector.length - 1;\n\n  for (; x < lb - 3; ) {\n    bx0 = b.charCodeAt(offset + (d0 = x));\n    bx1 = b.charCodeAt(offset + (d1 = x + 1));\n    bx2 = b.charCodeAt(offset + (d2 = x + 2));\n    bx3 = b.charCodeAt(offset + (d3 = x + 3));\n    dd = x += 4;\n    for (y = 0; y < len; y += 2) {\n      dy = vector[y];\n      ay = vector[y + 1];\n      d0 = _min(dy, d0, d1, bx0, ay);\n      d1 = _min(d0, d1, d2, bx1, ay);\n      d2 = _min(d1, d2, d3, bx2, ay);\n      dd = _min(d2, d3, dd, bx3, ay);\n      vector[y] = dd;\n      d3 = d2;\n      d2 = d1;\n      d1 = d0;\n      d0 = dy;\n    }\n  }\n\n  for (; x < lb; ) {\n    bx0 = b.charCodeAt(offset + (d0 = x));\n    dd = ++x;\n    for (y = 0; y < len; y += 2) {\n      dy = vector[y];\n      vector[y] = dd = _min(dy, d0, dd, bx0, vector[y + 1]);\n      d0 = dy;\n    }\n  }\n\n  return dd;\n}\n"]},"metadata":{},"sourceType":"script"}