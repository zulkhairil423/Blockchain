{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.normalizeHardhatNetworkAccountsConfig = exports.derivePrivateKeys = void 0;\n\nconst keys_derivation_1 = require(\"../../util/keys-derivation\");\n\nconst default_config_1 = require(\"../config/default-config\");\n\nconst errors_1 = require(\"../errors\");\n\nconst errors_list_1 = require(\"../errors-list\");\n\nconst HD_PATH_REGEX = /^m(:?\\/\\d+'?)+\\/?$/;\n\nfunction derivePrivateKeys(mnemonic, hdpath, initialIndex, count, passphrase) {\n  if (hdpath.match(HD_PATH_REGEX) === null) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.INVALID_HD_PATH, {\n      path: hdpath\n    });\n  }\n\n  if (!hdpath.endsWith(\"/\")) {\n    hdpath += \"/\";\n  }\n\n  const privateKeys = [];\n\n  for (let i = initialIndex; i < initialIndex + count; i++) {\n    const privateKey = (0, keys_derivation_1.deriveKeyFromMnemonicAndPath)(mnemonic, hdpath + i.toString(), passphrase);\n\n    if (privateKey === undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.CANT_DERIVE_KEY, {\n        mnemonic,\n        path: hdpath\n      });\n    }\n\n    privateKeys.push(privateKey);\n  }\n\n  return privateKeys;\n}\n\nexports.derivePrivateKeys = derivePrivateKeys;\n\nfunction normalizeHardhatNetworkAccountsConfig(accountsConfig) {\n  if (Array.isArray(accountsConfig)) {\n    return accountsConfig;\n  }\n\n  const {\n    bufferToHex\n  } = require(\"@nomicfoundation/ethereumjs-util\");\n\n  return derivePrivateKeys(accountsConfig.mnemonic, accountsConfig.path, accountsConfig.initialIndex, accountsConfig.count, accountsConfig.passphrase).map(pk => ({\n    privateKey: bufferToHex(pk),\n    balance: accountsConfig.accountsBalance ?? default_config_1.DEFAULT_HARDHAT_NETWORK_BALANCE\n  }));\n}\n\nexports.normalizeHardhatNetworkAccountsConfig = normalizeHardhatNetworkAccountsConfig;","map":{"version":3,"mappings":";;;;;;;AAIA;;AACA;;AACA;;AACA;;AAEA,MAAMA,aAAa,GAAG,oBAAtB;;AAEA,SAAgBC,iBAAhB,CACEC,QADF,EAEEC,MAFF,EAGEC,YAHF,EAIEC,KAJF,EAKEC,UALF,EAKoB;EAElB,IAAIH,MAAM,CAACI,KAAP,CAAaP,aAAb,MAAgC,IAApC,EAA0C;IACxC,MAAM,IAAIQ,qBAAJ,CAAiBC,qBAAOC,OAAP,CAAeC,eAAhC,EAAiD;MAAEC,IAAI,EAAET;IAAR,CAAjD,CAAN;EACD;;EAED,IAAI,CAACA,MAAM,CAACU,QAAP,CAAgB,GAAhB,CAAL,EAA2B;IACzBV,MAAM,IAAI,GAAV;EACD;;EAED,MAAMW,WAAW,GAAa,EAA9B;;EAEA,KAAK,IAAIC,CAAC,GAAGX,YAAb,EAA2BW,CAAC,GAAGX,YAAY,GAAGC,KAA9C,EAAqDU,CAAC,EAAtD,EAA0D;IACxD,MAAMC,UAAU,GAAG,oDACjBd,QADiB,EAEjBC,MAAM,GAAGY,CAAC,CAACE,QAAF,EAFQ,EAGjBX,UAHiB,CAAnB;;IAMA,IAAIU,UAAU,KAAKE,SAAnB,EAA8B;MAC5B,MAAM,IAAIV,qBAAJ,CAAiBC,qBAAOC,OAAP,CAAeS,eAAhC,EAAiD;QACrDjB,QADqD;QAErDU,IAAI,EAAET;MAF+C,CAAjD,CAAN;IAID;;IAEDW,WAAW,CAACM,IAAZ,CAAiBJ,UAAjB;EACD;;EAED,OAAOF,WAAP;AACD;;AAnCDO;;AAqCA,SAAgBC,qCAAhB,CACEC,cADF,EAC8C;EAE5C,IAAIC,KAAK,CAACC,OAAN,CAAcF,cAAd,CAAJ,EAAmC;IACjC,OAAOA,cAAP;EACD;;EAED,MAAM;IAAEG;EAAF,IAAkBC,OAAO,CAAC,kCAAD,CAA/B;;EAEA,OAAO1B,iBAAiB,CACtBsB,cAAc,CAACrB,QADO,EAEtBqB,cAAc,CAACX,IAFO,EAGtBW,cAAc,CAACnB,YAHO,EAItBmB,cAAc,CAAClB,KAJO,EAKtBkB,cAAc,CAACjB,UALO,CAAjB,CAMLsB,GANK,CAMAC,EAAD,KAAS;IACbb,UAAU,EAAEU,WAAW,CAACG,EAAD,CADV;IAEbC,OAAO,EAAEP,cAAc,CAACQ,eAAf,IAAkCC;EAF9B,CAAT,CANC,CAAP;AAUD;;AAnBDX","names":["HD_PATH_REGEX","derivePrivateKeys","mnemonic","hdpath","initialIndex","count","passphrase","match","errors_1","errors_list_1","NETWORK","INVALID_HD_PATH","path","endsWith","privateKeys","i","privateKey","toString","undefined","CANT_DERIVE_KEY","push","exports","normalizeHardhatNetworkAccountsConfig","accountsConfig","Array","isArray","bufferToHex","require","map","pk","balance","accountsBalance","default_config_1"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\hardhat\\src\\internal\\core\\providers\\util.ts"],"sourcesContent":["import {\n  HardhatNetworkAccountConfig,\n  HardhatNetworkAccountsConfig,\n} from \"../../../types\";\nimport { deriveKeyFromMnemonicAndPath } from \"../../util/keys-derivation\";\nimport { DEFAULT_HARDHAT_NETWORK_BALANCE } from \"../config/default-config\";\nimport { HardhatError } from \"../errors\";\nimport { ERRORS } from \"../errors-list\";\n\nconst HD_PATH_REGEX = /^m(:?\\/\\d+'?)+\\/?$/;\n\nexport function derivePrivateKeys(\n  mnemonic: string,\n  hdpath: string,\n  initialIndex: number,\n  count: number,\n  passphrase: string\n): Buffer[] {\n  if (hdpath.match(HD_PATH_REGEX) === null) {\n    throw new HardhatError(ERRORS.NETWORK.INVALID_HD_PATH, { path: hdpath });\n  }\n\n  if (!hdpath.endsWith(\"/\")) {\n    hdpath += \"/\";\n  }\n\n  const privateKeys: Buffer[] = [];\n\n  for (let i = initialIndex; i < initialIndex + count; i++) {\n    const privateKey = deriveKeyFromMnemonicAndPath(\n      mnemonic,\n      hdpath + i.toString(),\n      passphrase\n    );\n\n    if (privateKey === undefined) {\n      throw new HardhatError(ERRORS.NETWORK.CANT_DERIVE_KEY, {\n        mnemonic,\n        path: hdpath,\n      });\n    }\n\n    privateKeys.push(privateKey);\n  }\n\n  return privateKeys;\n}\n\nexport function normalizeHardhatNetworkAccountsConfig(\n  accountsConfig: HardhatNetworkAccountsConfig\n): HardhatNetworkAccountConfig[] {\n  if (Array.isArray(accountsConfig)) {\n    return accountsConfig;\n  }\n\n  const { bufferToHex } = require(\"@nomicfoundation/ethereumjs-util\");\n\n  return derivePrivateKeys(\n    accountsConfig.mnemonic,\n    accountsConfig.path,\n    accountsConfig.initialIndex,\n    accountsConfig.count,\n    accountsConfig.passphrase\n  ).map((pk) => ({\n    privateKey: bufferToHex(pk),\n    balance: accountsConfig.accountsBalance ?? DEFAULT_HARDHAT_NETWORK_BALANCE,\n  }));\n}\n"]},"metadata":{},"sourceType":"script"}