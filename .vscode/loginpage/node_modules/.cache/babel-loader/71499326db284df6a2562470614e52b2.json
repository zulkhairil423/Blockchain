{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { BaseBackend, getCurrentHub } from '@sentry/core';\nimport { Severity } from '@sentry/types';\nimport { addExceptionMechanism, addExceptionTypeValue, Dsn, extractExceptionKeysForMessage, isError, isPlainObject, normalizeToSize, SyncPromise } from '@sentry/utils';\nimport { extractStackFromError, parseError, parseStack, prepareFramesForEvent } from './parsers';\nimport { HTTPSTransport, HTTPTransport } from './transports';\n/**\n * The Sentry Node SDK Backend.\n * @hidden\n */\n\nvar NodeBackend =\n/** @class */\nfunction (_super) {\n  __extends(NodeBackend, _super);\n\n  function NodeBackend() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n\n\n  NodeBackend.prototype.eventFromException = function (exception, hint) {\n    var _this = this; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    var ex = exception;\n    var mechanism = {\n      handled: true,\n      type: 'generic'\n    };\n\n    if (!isError(exception)) {\n      if (isPlainObject(exception)) {\n        // This will allow us to group events based on top-level keys\n        // which is much better than creating new group when any key/value change\n        var message = \"Non-Error exception captured with keys: \" + extractExceptionKeysForMessage(exception);\n        getCurrentHub().configureScope(function (scope) {\n          scope.setExtra('__serialized__', normalizeToSize(exception));\n        });\n        ex = hint && hint.syntheticException || new Error(message);\n        ex.message = message;\n      } else {\n        // This handles when someone does: `throw \"something awesome\";`\n        // We use synthesized Error here so we can extract a (rough) stack trace.\n        ex = hint && hint.syntheticException || new Error(exception);\n        ex.message = exception;\n      }\n\n      mechanism.synthetic = true;\n    }\n\n    return new SyncPromise(function (resolve, reject) {\n      return parseError(ex, _this._options).then(function (event) {\n        addExceptionTypeValue(event, undefined, undefined);\n        addExceptionMechanism(event, mechanism);\n        resolve(__assign(__assign({}, event), {\n          event_id: hint && hint.event_id\n        }));\n      }).then(null, reject);\n    });\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  NodeBackend.prototype.eventFromMessage = function (message, level, hint) {\n    var _this = this;\n\n    if (level === void 0) {\n      level = Severity.Info;\n    }\n\n    var event = {\n      event_id: hint && hint.event_id,\n      level: level,\n      message: message\n    };\n    return new SyncPromise(function (resolve) {\n      if (_this._options.attachStacktrace && hint && hint.syntheticException) {\n        var stack = hint.syntheticException ? extractStackFromError(hint.syntheticException) : [];\n        parseStack(stack, _this._options).then(function (frames) {\n          event.stacktrace = {\n            frames: prepareFramesForEvent(frames)\n          };\n          resolve(event);\n        }).then(null, function () {\n          resolve(event);\n        });\n      } else {\n        resolve(event);\n      }\n    });\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  NodeBackend.prototype._setupTransport = function () {\n    if (!this._options.dsn) {\n      // We return the noop transport here in case there is no Dsn.\n      return _super.prototype._setupTransport.call(this);\n    }\n\n    var dsn = new Dsn(this._options.dsn);\n\n    var transportOptions = __assign(__assign(__assign(__assign(__assign({}, this._options.transportOptions), this._options.httpProxy && {\n      httpProxy: this._options.httpProxy\n    }), this._options.httpsProxy && {\n      httpsProxy: this._options.httpsProxy\n    }), this._options.caCerts && {\n      caCerts: this._options.caCerts\n    }), {\n      dsn: this._options.dsn\n    });\n\n    if (this._options.transport) {\n      return new this._options.transport(transportOptions);\n    }\n\n    if (dsn.protocol === 'http') {\n      return new HTTPTransport(transportOptions);\n    }\n\n    return new HTTPSTransport(transportOptions);\n  };\n\n  return NodeBackend;\n}(BaseBackend);\n\nexport { NodeBackend };","map":{"version":3,"mappings":"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","names":["BaseBackend","getCurrentHub","Severity","addExceptionMechanism","addExceptionTypeValue","Dsn","extractExceptionKeysForMessage","isError","isPlainObject","normalizeToSize","SyncPromise","extractStackFromError","parseError","parseStack","prepareFramesForEvent","HTTPSTransport","HTTPTransport","__extends","NodeBackend","exception","hint","ex","mechanism","handled","type","message","configureScope","scope","setExtra","syntheticException","Error","synthetic","resolve","reject","_this","_options","then","event","undefined","event_id","level","Info","attachStacktrace","stack","stacktrace","frames","dsn","_super","_setupTransport","call","transportOptions","httpProxy","httpsProxy","caCerts","transport","protocol"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\@sentry\\node\\src\\backend.ts"],"sourcesContent":["import { BaseBackend, getCurrentHub } from '@sentry/core';\nimport { Event, EventHint, Mechanism, Options, Severity, Transport, TransportOptions } from '@sentry/types';\nimport {\n  addExceptionMechanism,\n  addExceptionTypeValue,\n  Dsn,\n  extractExceptionKeysForMessage,\n  isError,\n  isPlainObject,\n  normalizeToSize,\n  SyncPromise,\n} from '@sentry/utils';\n\nimport { extractStackFromError, parseError, parseStack, prepareFramesForEvent } from './parsers';\nimport { HTTPSTransport, HTTPTransport } from './transports';\n\n/**\n * Configuration options for the Sentry Node SDK.\n * @see NodeClient for more information.\n */\nexport interface NodeOptions extends Options {\n  /** Sets an optional server name (device name) */\n  serverName?: string;\n\n  /** Maximum time in milliseconds to wait to drain the request queue, before the process is allowed to exit. */\n  shutdownTimeout?: number;\n\n  /** Set a HTTP proxy that should be used for outbound requests. */\n  httpProxy?: string;\n\n  /** Set a HTTPS proxy that should be used for outbound requests. */\n  httpsProxy?: string;\n\n  /** HTTPS proxy certificates path */\n  caCerts?: string;\n\n  /** Sets the number of context lines for each frame when loading a file. */\n  frameContextLines?: number;\n\n  /** Callback that is executed when a fatal global error occurs. */\n  onFatalError?(error: Error): void;\n}\n\n/**\n * The Sentry Node SDK Backend.\n * @hidden\n */\nexport class NodeBackend extends BaseBackend<NodeOptions> {\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public eventFromException(exception: any, hint?: EventHint): PromiseLike<Event> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let ex: any = exception;\n    const mechanism: Mechanism = {\n      handled: true,\n      type: 'generic',\n    };\n\n    if (!isError(exception)) {\n      if (isPlainObject(exception)) {\n        // This will allow us to group events based on top-level keys\n        // which is much better than creating new group when any key/value change\n        const message = `Non-Error exception captured with keys: ${extractExceptionKeysForMessage(exception)}`;\n\n        getCurrentHub().configureScope(scope => {\n          scope.setExtra('__serialized__', normalizeToSize(exception as Record<string, unknown>));\n        });\n\n        ex = (hint && hint.syntheticException) || new Error(message);\n        (ex as Error).message = message;\n      } else {\n        // This handles when someone does: `throw \"something awesome\";`\n        // We use synthesized Error here so we can extract a (rough) stack trace.\n        ex = (hint && hint.syntheticException) || new Error(exception as string);\n        (ex as Error).message = exception;\n      }\n      mechanism.synthetic = true;\n    }\n\n    return new SyncPromise<Event>((resolve, reject) =>\n      parseError(ex as Error, this._options)\n        .then(event => {\n          addExceptionTypeValue(event, undefined, undefined);\n          addExceptionMechanism(event, mechanism);\n\n          resolve({\n            ...event,\n            event_id: hint && hint.event_id,\n          });\n        })\n        .then(null, reject),\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public eventFromMessage(message: string, level: Severity = Severity.Info, hint?: EventHint): PromiseLike<Event> {\n    const event: Event = {\n      event_id: hint && hint.event_id,\n      level,\n      message,\n    };\n\n    return new SyncPromise<Event>(resolve => {\n      if (this._options.attachStacktrace && hint && hint.syntheticException) {\n        const stack = hint.syntheticException ? extractStackFromError(hint.syntheticException) : [];\n        parseStack(stack, this._options)\n          .then(frames => {\n            event.stacktrace = {\n              frames: prepareFramesForEvent(frames),\n            };\n            resolve(event);\n          })\n          .then(null, () => {\n            resolve(event);\n          });\n      } else {\n        resolve(event);\n      }\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  protected _setupTransport(): Transport {\n    if (!this._options.dsn) {\n      // We return the noop transport here in case there is no Dsn.\n      return super._setupTransport();\n    }\n\n    const dsn = new Dsn(this._options.dsn);\n\n    const transportOptions: TransportOptions = {\n      ...this._options.transportOptions,\n      ...(this._options.httpProxy && { httpProxy: this._options.httpProxy }),\n      ...(this._options.httpsProxy && { httpsProxy: this._options.httpsProxy }),\n      ...(this._options.caCerts && { caCerts: this._options.caCerts }),\n      dsn: this._options.dsn,\n    };\n\n    if (this._options.transport) {\n      return new this._options.transport(transportOptions);\n    }\n    if (dsn.protocol === 'http') {\n      return new HTTPTransport(transportOptions);\n    }\n    return new HTTPSTransport(transportOptions);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}