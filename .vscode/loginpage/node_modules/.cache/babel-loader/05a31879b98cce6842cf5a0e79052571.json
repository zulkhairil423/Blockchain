{"ast":null,"code":"import { isRegExp, isString } from './is';\n/**\n * Truncates given string to the maximum characters count\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string (0 = unlimited)\n * @returns string Encoded\n */\n\nexport function truncate(str, max) {\n  if (max === void 0) {\n    max = 0;\n  }\n\n  if (typeof str !== 'string' || max === 0) {\n    return str;\n  }\n\n  return str.length <= max ? str : str.substr(0, max) + \"...\";\n}\n/**\n * This is basically just `trim_line` from\n * https://github.com/getsentry/sentry/blob/master/src/sentry/lang/javascript/processor.py#L67\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string\n * @returns string Encoded\n */\n\nexport function snipLine(line, colno) {\n  var newLine = line;\n  var ll = newLine.length;\n\n  if (ll <= 150) {\n    return newLine;\n  }\n\n  if (colno > ll) {\n    // eslint-disable-next-line no-param-reassign\n    colno = ll;\n  }\n\n  var start = Math.max(colno - 60, 0);\n\n  if (start < 5) {\n    start = 0;\n  }\n\n  var end = Math.min(start + 140, ll);\n\n  if (end > ll - 5) {\n    end = ll;\n  }\n\n  if (end === ll) {\n    start = Math.max(end - 140, 0);\n  }\n\n  newLine = newLine.slice(start, end);\n\n  if (start > 0) {\n    newLine = \"'{snip} \" + newLine;\n  }\n\n  if (end < ll) {\n    newLine += ' {snip}';\n  }\n\n  return newLine;\n}\n/**\n * Join values in array\n * @param input array of values to be joined together\n * @param delimiter string to be placed in-between values\n * @returns Joined values\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nexport function safeJoin(input, delimiter) {\n  if (!Array.isArray(input)) {\n    return '';\n  }\n\n  var output = []; // eslint-disable-next-line @typescript-eslint/prefer-for-of\n\n  for (var i = 0; i < input.length; i++) {\n    var value = input[i];\n\n    try {\n      output.push(String(value));\n    } catch (e) {\n      output.push('[value cannot be serialized]');\n    }\n  }\n\n  return output.join(delimiter);\n}\n/**\n * Checks if the value matches a regex or includes the string\n * @param value The string value to be checked against\n * @param pattern Either a regex or a string that must be contained in value\n */\n\nexport function isMatchingPattern(value, pattern) {\n  if (!isString(value)) {\n    return false;\n  }\n\n  if (isRegExp(pattern)) {\n    return pattern.test(value);\n  }\n\n  if (typeof pattern === 'string') {\n    return value.indexOf(pattern) !== -1;\n  }\n\n  return false;\n}","map":{"version":3,"mappings":"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","names":["isRegExp","isString","truncate","str","max","length","substr","snipLine","line","colno","newLine","ll","start","Math","end","min","slice","safeJoin","input","delimiter","Array","isArray","output","i","value","push","String","e","join","isMatchingPattern","pattern","test","indexOf"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\@sentry\\utils\\src\\string.ts"],"sourcesContent":["import { isRegExp, isString } from './is';\n\n/**\n * Truncates given string to the maximum characters count\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string (0 = unlimited)\n * @returns string Encoded\n */\nexport function truncate(str: string, max: number = 0): string {\n  if (typeof str !== 'string' || max === 0) {\n    return str;\n  }\n  return str.length <= max ? str : `${str.substr(0, max)}...`;\n}\n\n/**\n * This is basically just `trim_line` from\n * https://github.com/getsentry/sentry/blob/master/src/sentry/lang/javascript/processor.py#L67\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string\n * @returns string Encoded\n */\nexport function snipLine(line: string, colno: number): string {\n  let newLine = line;\n  const ll = newLine.length;\n  if (ll <= 150) {\n    return newLine;\n  }\n  if (colno > ll) {\n    // eslint-disable-next-line no-param-reassign\n    colno = ll;\n  }\n\n  let start = Math.max(colno - 60, 0);\n  if (start < 5) {\n    start = 0;\n  }\n\n  let end = Math.min(start + 140, ll);\n  if (end > ll - 5) {\n    end = ll;\n  }\n  if (end === ll) {\n    start = Math.max(end - 140, 0);\n  }\n\n  newLine = newLine.slice(start, end);\n  if (start > 0) {\n    newLine = `'{snip} ${newLine}`;\n  }\n  if (end < ll) {\n    newLine += ' {snip}';\n  }\n\n  return newLine;\n}\n\n/**\n * Join values in array\n * @param input array of values to be joined together\n * @param delimiter string to be placed in-between values\n * @returns Joined values\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function safeJoin(input: any[], delimiter?: string): string {\n  if (!Array.isArray(input)) {\n    return '';\n  }\n\n  const output = [];\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of\n  for (let i = 0; i < input.length; i++) {\n    const value = input[i];\n    try {\n      output.push(String(value));\n    } catch (e) {\n      output.push('[value cannot be serialized]');\n    }\n  }\n\n  return output.join(delimiter);\n}\n\n/**\n * Checks if the value matches a regex or includes the string\n * @param value The string value to be checked against\n * @param pattern Either a regex or a string that must be contained in value\n */\nexport function isMatchingPattern(value: string, pattern: RegExp | string): boolean {\n  if (!isString(value)) {\n    return false;\n  }\n\n  if (isRegExp(pattern)) {\n    return (pattern as RegExp).test(value);\n  }\n  if (typeof pattern === 'string') {\n    return value.indexOf(pattern) !== -1;\n  }\n  return false;\n}\n"]},"metadata":{},"sourceType":"module"}