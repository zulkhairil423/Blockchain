{"ast":null,"code":"'use strict';\n\nconst DispatcherBase = require('./dispatcher-base');\n\nconst FixedQueue = require('./node/fixed-queue');\n\nconst {\n  kConnected,\n  kSize,\n  kRunning,\n  kPending,\n  kQueued,\n  kBusy,\n  kFree,\n  kUrl,\n  kClose,\n  kDestroy,\n  kDispatch\n} = require('./core/symbols');\n\nconst PoolStats = require('./pool-stats');\n\nconst kClients = Symbol('clients');\nconst kNeedDrain = Symbol('needDrain');\nconst kQueue = Symbol('queue');\nconst kClosedResolve = Symbol('closed resolve');\nconst kOnDrain = Symbol('onDrain');\nconst kOnConnect = Symbol('onConnect');\nconst kOnDisconnect = Symbol('onDisconnect');\nconst kOnConnectionError = Symbol('onConnectionError');\nconst kGetDispatcher = Symbol('get dispatcher');\nconst kAddClient = Symbol('add client');\nconst kRemoveClient = Symbol('remove client');\nconst kStats = Symbol('stats');\n\nclass PoolBase extends DispatcherBase {\n  constructor() {\n    super();\n    this[kQueue] = new FixedQueue();\n    this[kClients] = [];\n    this[kQueued] = 0;\n    const pool = this;\n\n    this[kOnDrain] = function onDrain(origin, targets) {\n      const queue = pool[kQueue];\n      let needDrain = false;\n\n      while (!needDrain) {\n        const item = queue.shift();\n\n        if (!item) {\n          break;\n        }\n\n        pool[kQueued]--;\n        needDrain = !this.dispatch(item.opts, item.handler);\n      }\n\n      this[kNeedDrain] = needDrain;\n\n      if (!this[kNeedDrain] && pool[kNeedDrain]) {\n        pool[kNeedDrain] = false;\n        pool.emit('drain', origin, [pool, ...targets]);\n      }\n\n      if (pool[kClosedResolve] && queue.isEmpty()) {\n        Promise.all(pool[kClients].map(c => c.close())).then(pool[kClosedResolve]);\n      }\n    };\n\n    this[kOnConnect] = (origin, targets) => {\n      pool.emit('connect', origin, [pool, ...targets]);\n    };\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      pool.emit('disconnect', origin, [pool, ...targets], err);\n    };\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      pool.emit('connectionError', origin, [pool, ...targets], err);\n    };\n\n    this[kStats] = new PoolStats(this);\n  }\n\n  get [kBusy]() {\n    return this[kNeedDrain];\n  }\n\n  get [kConnected]() {\n    return this[kClients].filter(client => client[kConnected]).length;\n  }\n\n  get [kFree]() {\n    return this[kClients].filter(client => client[kConnected] && !client[kNeedDrain]).length;\n  }\n\n  get [kPending]() {\n    let ret = this[kQueued];\n\n    for (const {\n      [kPending]: pending\n    } of this[kClients]) {\n      ret += pending;\n    }\n\n    return ret;\n  }\n\n  get [kRunning]() {\n    let ret = 0;\n\n    for (const {\n      [kRunning]: running\n    } of this[kClients]) {\n      ret += running;\n    }\n\n    return ret;\n  }\n\n  get [kSize]() {\n    let ret = this[kQueued];\n\n    for (const {\n      [kSize]: size\n    } of this[kClients]) {\n      ret += size;\n    }\n\n    return ret;\n  }\n\n  get stats() {\n    return this[kStats];\n  }\n\n  async [kClose]() {\n    if (this[kQueue].isEmpty()) {\n      return Promise.all(this[kClients].map(c => c.close()));\n    } else {\n      return new Promise(resolve => {\n        this[kClosedResolve] = resolve;\n      });\n    }\n  }\n\n  async [kDestroy](err) {\n    while (true) {\n      const item = this[kQueue].shift();\n\n      if (!item) {\n        break;\n      }\n\n      item.handler.onError(err);\n    }\n\n    return Promise.all(this[kClients].map(c => c.destroy(err)));\n  }\n\n  [kDispatch](opts, handler) {\n    const dispatcher = this[kGetDispatcher]();\n\n    if (!dispatcher) {\n      this[kNeedDrain] = true;\n      this[kQueue].push({\n        opts,\n        handler\n      });\n      this[kQueued]++;\n    } else if (!dispatcher.dispatch(opts, handler)) {\n      dispatcher[kNeedDrain] = true;\n      this[kNeedDrain] = !this[kGetDispatcher]();\n    }\n\n    return !this[kNeedDrain];\n  }\n\n  [kAddClient](client) {\n    client.on('drain', this[kOnDrain]).on('connect', this[kOnConnect]).on('disconnect', this[kOnDisconnect]).on('connectionError', this[kOnConnectionError]);\n    this[kClients].push(client);\n\n    if (this[kNeedDrain]) {\n      process.nextTick(() => {\n        if (this[kNeedDrain]) {\n          this[kOnDrain](client[kUrl], [this, client]);\n        }\n      });\n    }\n\n    return this;\n  }\n\n  [kRemoveClient](client) {\n    client.close(() => {\n      const idx = this[kClients].indexOf(client);\n\n      if (idx !== -1) {\n        this[kClients].splice(idx, 1);\n      }\n    });\n    this[kNeedDrain] = this[kClients].some(dispatcher => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);\n  }\n\n}\n\nmodule.exports = {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n};","map":{"version":3,"names":["DispatcherBase","require","FixedQueue","kConnected","kSize","kRunning","kPending","kQueued","kBusy","kFree","kUrl","kClose","kDestroy","kDispatch","PoolStats","kClients","Symbol","kNeedDrain","kQueue","kClosedResolve","kOnDrain","kOnConnect","kOnDisconnect","kOnConnectionError","kGetDispatcher","kAddClient","kRemoveClient","kStats","PoolBase","constructor","pool","onDrain","origin","targets","queue","needDrain","item","shift","dispatch","opts","handler","emit","isEmpty","Promise","all","map","c","close","then","err","filter","client","length","ret","pending","running","size","stats","resolve","onError","destroy","dispatcher","push","on","process","nextTick","idx","indexOf","splice","some","closed","destroyed","module","exports"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/undici/lib/pool-base.js"],"sourcesContent":["'use strict'\n\nconst DispatcherBase = require('./dispatcher-base')\nconst FixedQueue = require('./node/fixed-queue')\nconst { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require('./core/symbols')\nconst PoolStats = require('./pool-stats')\n\nconst kClients = Symbol('clients')\nconst kNeedDrain = Symbol('needDrain')\nconst kQueue = Symbol('queue')\nconst kClosedResolve = Symbol('closed resolve')\nconst kOnDrain = Symbol('onDrain')\nconst kOnConnect = Symbol('onConnect')\nconst kOnDisconnect = Symbol('onDisconnect')\nconst kOnConnectionError = Symbol('onConnectionError')\nconst kGetDispatcher = Symbol('get dispatcher')\nconst kAddClient = Symbol('add client')\nconst kRemoveClient = Symbol('remove client')\nconst kStats = Symbol('stats')\n\nclass PoolBase extends DispatcherBase {\n  constructor () {\n    super()\n\n    this[kQueue] = new FixedQueue()\n    this[kClients] = []\n    this[kQueued] = 0\n\n    const pool = this\n\n    this[kOnDrain] = function onDrain (origin, targets) {\n      const queue = pool[kQueue]\n\n      let needDrain = false\n\n      while (!needDrain) {\n        const item = queue.shift()\n        if (!item) {\n          break\n        }\n        pool[kQueued]--\n        needDrain = !this.dispatch(item.opts, item.handler)\n      }\n\n      this[kNeedDrain] = needDrain\n\n      if (!this[kNeedDrain] && pool[kNeedDrain]) {\n        pool[kNeedDrain] = false\n        pool.emit('drain', origin, [pool, ...targets])\n      }\n\n      if (pool[kClosedResolve] && queue.isEmpty()) {\n        Promise\n          .all(pool[kClients].map(c => c.close()))\n          .then(pool[kClosedResolve])\n      }\n    }\n\n    this[kOnConnect] = (origin, targets) => {\n      pool.emit('connect', origin, [pool, ...targets])\n    }\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      pool.emit('disconnect', origin, [pool, ...targets], err)\n    }\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      pool.emit('connectionError', origin, [pool, ...targets], err)\n    }\n\n    this[kStats] = new PoolStats(this)\n  }\n\n  get [kBusy] () {\n    return this[kNeedDrain]\n  }\n\n  get [kConnected] () {\n    return this[kClients].filter(client => client[kConnected]).length\n  }\n\n  get [kFree] () {\n    return this[kClients].filter(client => client[kConnected] && !client[kNeedDrain]).length\n  }\n\n  get [kPending] () {\n    let ret = this[kQueued]\n    for (const { [kPending]: pending } of this[kClients]) {\n      ret += pending\n    }\n    return ret\n  }\n\n  get [kRunning] () {\n    let ret = 0\n    for (const { [kRunning]: running } of this[kClients]) {\n      ret += running\n    }\n    return ret\n  }\n\n  get [kSize] () {\n    let ret = this[kQueued]\n    for (const { [kSize]: size } of this[kClients]) {\n      ret += size\n    }\n    return ret\n  }\n\n  get stats () {\n    return this[kStats]\n  }\n\n  async [kClose] () {\n    if (this[kQueue].isEmpty()) {\n      return Promise.all(this[kClients].map(c => c.close()))\n    } else {\n      return new Promise((resolve) => {\n        this[kClosedResolve] = resolve\n      })\n    }\n  }\n\n  async [kDestroy] (err) {\n    while (true) {\n      const item = this[kQueue].shift()\n      if (!item) {\n        break\n      }\n      item.handler.onError(err)\n    }\n\n    return Promise.all(this[kClients].map(c => c.destroy(err)))\n  }\n\n  [kDispatch] (opts, handler) {\n    const dispatcher = this[kGetDispatcher]()\n\n    if (!dispatcher) {\n      this[kNeedDrain] = true\n      this[kQueue].push({ opts, handler })\n      this[kQueued]++\n    } else if (!dispatcher.dispatch(opts, handler)) {\n      dispatcher[kNeedDrain] = true\n      this[kNeedDrain] = !this[kGetDispatcher]()\n    }\n\n    return !this[kNeedDrain]\n  }\n\n  [kAddClient] (client) {\n    client\n      .on('drain', this[kOnDrain])\n      .on('connect', this[kOnConnect])\n      .on('disconnect', this[kOnDisconnect])\n      .on('connectionError', this[kOnConnectionError])\n\n    this[kClients].push(client)\n\n    if (this[kNeedDrain]) {\n      process.nextTick(() => {\n        if (this[kNeedDrain]) {\n          this[kOnDrain](client[kUrl], [this, client])\n        }\n      })\n    }\n\n    return this\n  }\n\n  [kRemoveClient] (client) {\n    client.close(() => {\n      const idx = this[kClients].indexOf(client)\n      if (idx !== -1) {\n        this[kClients].splice(idx, 1)\n      }\n    })\n\n    this[kNeedDrain] = this[kClients].some(dispatcher => (\n      !dispatcher[kNeedDrain] &&\n      dispatcher.closed !== true &&\n      dispatcher.destroyed !== true\n    ))\n  }\n}\n\nmodule.exports = {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}