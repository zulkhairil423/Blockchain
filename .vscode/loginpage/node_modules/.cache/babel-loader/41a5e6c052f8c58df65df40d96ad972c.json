{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lazyFunction = exports.lazyObject = void 0;\n\nconst util_1 = __importDefault(require(\"util\"));\n\nconst errors_1 = require(\"../core/errors\");\n\nconst errors_list_1 = require(\"../core/errors-list\");\n\nconst inspect = Symbol.for(\"nodejs.util.inspect.custom\");\n/**\n * This module provides function to implement proxy-based object, functions, and\n * classes (they are functions). They receive an initializer function that it's\n * not used until someone interacts with the lazy element.\n *\n * This functions can also be used like a lazy `require`, creating a proxy that\n * doesn't require the module until needed.\n *\n * The disadvantage of using this technique is that the type information is\n * lost wrt `import`, as `require` returns an `any. If done with enough care,\n * this can be manually fixed.\n *\n * TypeScript doesn't emit `require` calls for modules that are imported only\n * because of their types. So if one uses lazyObject or lazyFunction along with\n * a normal ESM import you can pass the module's type to this function.\n *\n * An example of this can be:\n *\n *    import findUpT from \"find-up\";\n *    export const findUp = lazyFunction<typeof findUpT>(() => require(\"find-up\"));\n *\n * You can also use it with named exports:\n *\n *    import { EthT } from \"web3x/eth\";\n *    const Eth = lazyFunction<typeof EthT>(() => require(\"web3x/eth\").Eth);\n */\n\nfunction lazyObject(objectCreator) {\n  return createLazyProxy(objectCreator, getRealTarget => ({\n    [inspect](depth, options) {\n      let inspectFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : util_1.default.inspect;\n      const realTarget = getRealTarget();\n      const newOptions = { ...options,\n        depth\n      };\n      return inspectFn(realTarget, newOptions);\n    }\n\n  }), object => {\n    if (object instanceof Function) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n        operation: \"Creating lazy functions or classes with lazyObject\"\n      });\n    }\n\n    if (typeof object !== \"object\" || object === null) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n        operation: \"Using lazyObject with anything other than objects\"\n      });\n    }\n  });\n}\n\nexports.lazyObject = lazyObject; // eslint-disable-next-line @typescript-eslint/ban-types\n\nfunction lazyFunction(functionCreator) {\n  return createLazyProxy(functionCreator, getRealTarget => {\n    function dummyTarget() {}\n\n    dummyTarget[inspect] = function (depth, options) {\n      let inspectFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : util_1.default.inspect;\n      const realTarget = getRealTarget();\n      const newOptions = { ...options,\n        depth\n      };\n      return inspectFn(realTarget, newOptions);\n    };\n\n    return dummyTarget;\n  }, object => {\n    if (!(object instanceof Function)) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n        operation: \"Using lazyFunction with anything other than functions or classes\"\n      });\n    }\n  });\n}\n\nexports.lazyFunction = lazyFunction;\n\nfunction createLazyProxy(targetCreator, dummyTargetCreator, validator) {\n  let realTarget;\n  const dummyTarget = dummyTargetCreator(getRealTarget);\n\n  function getRealTarget() {\n    if (realTarget === undefined) {\n      const target = targetCreator();\n      validator(target); // We copy all properties. We won't use them, but help us avoid Proxy\n      // invariant violations\n\n      const properties = Object.getOwnPropertyNames(target);\n\n      for (const property of properties) {\n        const descriptor = Object.getOwnPropertyDescriptor(target, property);\n        Object.defineProperty(dummyTarget, property, descriptor);\n      }\n\n      Object.setPrototypeOf(dummyTarget, Object.getPrototypeOf(target)); // Using a null prototype seems to tirgger a V8 bug, so we forbid it\n      // See: https://github.com/nodejs/node/issues/29730\n\n      if (Object.getPrototypeOf(target) === null) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n          operation: \"Using lazyFunction or lazyObject to construct objects/functions with prototype null\"\n        });\n      }\n\n      if (!Object.isExtensible(target)) {\n        Object.preventExtensions(dummyTarget);\n      }\n\n      realTarget = target;\n    }\n\n    return realTarget;\n  }\n\n  const handler = {\n    defineProperty(target, property, descriptor) {\n      Reflect.defineProperty(dummyTarget, property, descriptor);\n      return Reflect.defineProperty(getRealTarget(), property, descriptor);\n    },\n\n    deleteProperty(target, property) {\n      Reflect.deleteProperty(dummyTarget, property);\n      return Reflect.deleteProperty(getRealTarget(), property);\n    },\n\n    get(target, property, receiver) {\n      // We have this short-circuit logic here to avoid a cyclic require when\n      // loading Web3.js.\n      //\n      // If a lazy object is somehow accessed while its real target is being\n      // created, it would trigger an endless loop of recreation, which node\n      // detects and resolve to an empty object.\n      //\n      // This happens with Web3.js because we a lazyObject that loads it,\n      // and expose it as `global.web3`. This Web3.js file accesses\n      // `global.web3` when it's being loaded, triggering the loop we mentioned\n      // before: https://github.com/ethereum/web3.js/blob/8574bd3bf11a2e9cf4bcf8850cab13e1db56653f/packages/web3-core-requestmanager/src/givenProvider.js#L41\n      //\n      // We just return `undefined` in that case, to not enter into the loop.\n      //\n      // **SUPER IMPORTANT NOTE:** Removing this is very tempting, I know. This\n      // is a horrible hack. The most obvious approach for doing so is to\n      // remove the `global` elements that trigger this crazy behavior right\n      // before doing our `require(\"web3\")`, and restore them afterwards.\n      // **THIS IS NOT ENOUGH** Users, and libraries (!!!!), will have their own\n      // `require`s that we can't control and will trigger the same bug.\n      const stack = new Error().stack;\n\n      if (stack !== undefined && stack.includes(\"givenProvider.js\") && realTarget === undefined) {\n        return undefined;\n      }\n\n      return Reflect.get(getRealTarget(), property, receiver);\n    },\n\n    getOwnPropertyDescriptor(target, property) {\n      const descriptor = Reflect.getOwnPropertyDescriptor(getRealTarget(), property);\n\n      if (descriptor !== undefined) {\n        Object.defineProperty(dummyTarget, property, descriptor);\n      }\n\n      return descriptor;\n    },\n\n    getPrototypeOf(_target) {\n      return Reflect.getPrototypeOf(getRealTarget());\n    },\n\n    has(target, property) {\n      return Reflect.has(getRealTarget(), property);\n    },\n\n    isExtensible(_target) {\n      return Reflect.isExtensible(getRealTarget());\n    },\n\n    ownKeys(_target) {\n      return Reflect.ownKeys(getRealTarget());\n    },\n\n    preventExtensions(_target) {\n      Object.preventExtensions(dummyTarget);\n      return Reflect.preventExtensions(getRealTarget());\n    },\n\n    set(target, property, value, receiver) {\n      Reflect.set(dummyTarget, property, value, receiver);\n      return Reflect.set(getRealTarget(), property, value, receiver);\n    },\n\n    setPrototypeOf(target, prototype) {\n      Reflect.setPrototypeOf(dummyTarget, prototype);\n      return Reflect.setPrototypeOf(getRealTarget(), prototype);\n    }\n\n  };\n\n  if (dummyTarget instanceof Function) {\n    // If dummy target is a function, the actual target must be a function too.\n    handler.apply = (target, thisArg, argArray) => {\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      return Reflect.apply(getRealTarget(), thisArg, argArray);\n    };\n\n    handler.construct = (target, argArray, _newTarget) => {\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      return Reflect.construct(getRealTarget(), argArray);\n    };\n  }\n\n  return new Proxy(dummyTarget, handler);\n}","map":{"version":3,"mappings":"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","names":["inspect","Symbol","for","lazyObject","objectCreator","createLazyProxy","getRealTarget","depth","options","inspectFn","util_1","realTarget","newOptions","object","Function","errors_1","errors_list_1","GENERAL","UNSUPPORTED_OPERATION","operation","exports","lazyFunction","functionCreator","dummyTarget","targetCreator","dummyTargetCreator","validator","undefined","target","properties","Object","getOwnPropertyNames","property","descriptor","getOwnPropertyDescriptor","defineProperty","setPrototypeOf","getPrototypeOf","isExtensible","preventExtensions","handler","Reflect","deleteProperty","get","receiver","stack","Error","includes","_target","has","ownKeys","set","value","prototype","apply","thisArg","argArray","construct","_newTarget","Proxy"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\hardhat\\src\\internal\\util\\lazy.ts"],"sourcesContent":["import util, { InspectOptions } from \"util\";\n\nimport { HardhatError } from \"../core/errors\";\nimport { ERRORS } from \"../core/errors-list\";\n\nconst inspect = Symbol.for(\"nodejs.util.inspect.custom\");\n\n/**\n * This module provides function to implement proxy-based object, functions, and\n * classes (they are functions). They receive an initializer function that it's\n * not used until someone interacts with the lazy element.\n *\n * This functions can also be used like a lazy `require`, creating a proxy that\n * doesn't require the module until needed.\n *\n * The disadvantage of using this technique is that the type information is\n * lost wrt `import`, as `require` returns an `any. If done with enough care,\n * this can be manually fixed.\n *\n * TypeScript doesn't emit `require` calls for modules that are imported only\n * because of their types. So if one uses lazyObject or lazyFunction along with\n * a normal ESM import you can pass the module's type to this function.\n *\n * An example of this can be:\n *\n *    import findUpT from \"find-up\";\n *    export const findUp = lazyFunction<typeof findUpT>(() => require(\"find-up\"));\n *\n * You can also use it with named exports:\n *\n *    import { EthT } from \"web3x/eth\";\n *    const Eth = lazyFunction<typeof EthT>(() => require(\"web3x/eth\").Eth);\n */\n\nexport function lazyObject<T extends object>(objectCreator: () => T): T {\n  return createLazyProxy(\n    objectCreator,\n    (getRealTarget) => ({\n      [inspect](\n        depth: number,\n        options: InspectOptions,\n        inspectFn: (\n          object: any,\n          options: InspectOptions\n        ) => string = util.inspect\n      ) {\n        const realTarget = getRealTarget();\n        const newOptions = { ...options, depth };\n        return inspectFn(realTarget, newOptions);\n      },\n    }),\n    (object) => {\n      if (object instanceof Function) {\n        throw new HardhatError(ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n          operation: \"Creating lazy functions or classes with lazyObject\",\n        });\n      }\n\n      if (typeof object !== \"object\" || object === null) {\n        throw new HardhatError(ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n          operation: \"Using lazyObject with anything other than objects\",\n        });\n      }\n    }\n  );\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function lazyFunction<T extends Function>(functionCreator: () => T): T {\n  return createLazyProxy(\n    functionCreator,\n    (getRealTarget) => {\n      function dummyTarget() {}\n\n      (dummyTarget as any)[inspect] = function (\n        depth: number,\n        options: InspectOptions,\n        inspectFn: (\n          object: any,\n          options: InspectOptions\n        ) => string = util.inspect\n      ) {\n        const realTarget = getRealTarget();\n        const newOptions = { ...options, depth };\n        return inspectFn(realTarget, newOptions);\n      };\n\n      return dummyTarget;\n    },\n    (object) => {\n      if (!(object instanceof Function)) {\n        throw new HardhatError(ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n          operation:\n            \"Using lazyFunction with anything other than functions or classes\",\n        });\n      }\n    }\n  );\n}\n\nfunction createLazyProxy<ActualT extends GuardT, GuardT extends object>(\n  targetCreator: () => ActualT,\n  dummyTargetCreator: (getRealTarget: () => ActualT) => GuardT,\n  validator: (target: any) => void\n): ActualT {\n  let realTarget: ActualT | undefined;\n\n  const dummyTarget: ActualT = dummyTargetCreator(getRealTarget) as any;\n\n  function getRealTarget(): ActualT {\n    if (realTarget === undefined) {\n      const target = targetCreator();\n      validator(target);\n\n      // We copy all properties. We won't use them, but help us avoid Proxy\n      // invariant violations\n      const properties = Object.getOwnPropertyNames(target);\n      for (const property of properties) {\n        const descriptor = Object.getOwnPropertyDescriptor(target, property)!;\n        Object.defineProperty(dummyTarget, property, descriptor);\n      }\n\n      Object.setPrototypeOf(dummyTarget, Object.getPrototypeOf(target));\n\n      // Using a null prototype seems to tirgger a V8 bug, so we forbid it\n      // See: https://github.com/nodejs/node/issues/29730\n      if (Object.getPrototypeOf(target) === null) {\n        throw new HardhatError(ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n          operation:\n            \"Using lazyFunction or lazyObject to construct objects/functions with prototype null\",\n        });\n      }\n\n      if (!Object.isExtensible(target)) {\n        Object.preventExtensions(dummyTarget);\n      }\n\n      realTarget = target;\n    }\n\n    return realTarget;\n  }\n\n  const handler: ProxyHandler<ActualT> = {\n    defineProperty(target, property, descriptor) {\n      Reflect.defineProperty(dummyTarget, property, descriptor);\n      return Reflect.defineProperty(getRealTarget(), property, descriptor);\n    },\n\n    deleteProperty(target, property) {\n      Reflect.deleteProperty(dummyTarget, property);\n      return Reflect.deleteProperty(getRealTarget(), property);\n    },\n\n    get(target, property, receiver) {\n      // We have this short-circuit logic here to avoid a cyclic require when\n      // loading Web3.js.\n      //\n      // If a lazy object is somehow accessed while its real target is being\n      // created, it would trigger an endless loop of recreation, which node\n      // detects and resolve to an empty object.\n      //\n      // This happens with Web3.js because we a lazyObject that loads it,\n      // and expose it as `global.web3`. This Web3.js file accesses\n      // `global.web3` when it's being loaded, triggering the loop we mentioned\n      // before: https://github.com/ethereum/web3.js/blob/8574bd3bf11a2e9cf4bcf8850cab13e1db56653f/packages/web3-core-requestmanager/src/givenProvider.js#L41\n      //\n      // We just return `undefined` in that case, to not enter into the loop.\n      //\n      // **SUPER IMPORTANT NOTE:** Removing this is very tempting, I know. This\n      // is a horrible hack. The most obvious approach for doing so is to\n      // remove the `global` elements that trigger this crazy behavior right\n      // before doing our `require(\"web3\")`, and restore them afterwards.\n      // **THIS IS NOT ENOUGH** Users, and libraries (!!!!), will have their own\n      // `require`s that we can't control and will trigger the same bug.\n      const stack = new Error().stack;\n      if (\n        stack !== undefined &&\n        stack.includes(\"givenProvider.js\") &&\n        realTarget === undefined\n      ) {\n        return undefined;\n      }\n\n      return Reflect.get(getRealTarget(), property, receiver);\n    },\n\n    getOwnPropertyDescriptor(target, property) {\n      const descriptor = Reflect.getOwnPropertyDescriptor(\n        getRealTarget(),\n        property\n      );\n\n      if (descriptor !== undefined) {\n        Object.defineProperty(dummyTarget, property, descriptor);\n      }\n\n      return descriptor;\n    },\n\n    getPrototypeOf(_target) {\n      return Reflect.getPrototypeOf(getRealTarget());\n    },\n\n    has(target, property) {\n      return Reflect.has(getRealTarget(), property);\n    },\n\n    isExtensible(_target) {\n      return Reflect.isExtensible(getRealTarget());\n    },\n\n    ownKeys(_target) {\n      return Reflect.ownKeys(getRealTarget());\n    },\n\n    preventExtensions(_target) {\n      Object.preventExtensions(dummyTarget);\n      return Reflect.preventExtensions(getRealTarget());\n    },\n\n    set(target, property, value, receiver) {\n      Reflect.set(dummyTarget, property, value, receiver);\n      return Reflect.set(getRealTarget(), property, value, receiver);\n    },\n\n    setPrototypeOf(target, prototype) {\n      Reflect.setPrototypeOf(dummyTarget, prototype);\n      return Reflect.setPrototypeOf(getRealTarget(), prototype);\n    },\n  };\n\n  if (dummyTarget instanceof Function) {\n    // If dummy target is a function, the actual target must be a function too.\n    handler.apply = (target, thisArg: any, argArray?: any) => {\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      return Reflect.apply(getRealTarget() as Function, thisArg, argArray);\n    };\n\n    handler.construct = (target, argArray: any, _newTarget?: any) => {\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      return Reflect.construct(getRealTarget() as Function, argArray);\n    };\n  }\n\n  return new Proxy(dummyTarget, handler);\n}\n"]},"metadata":{},"sourceType":"script"}