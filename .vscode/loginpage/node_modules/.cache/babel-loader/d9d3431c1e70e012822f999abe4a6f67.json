{"ast":null,"code":"//\n// Dotty makes it easy to programmatically access arbitrarily nested objects and\n// their properties.\n//\n//\n// `object` is an object, `path` is the path to the property you want to check\n// for existence of.\n//\n// `path` can be provided as either a `\"string.separated.with.dots\"` or as\n// `[\"an\", \"array\"]`.\n//\n// Returns `true` if the path can be completely resolved, `false` otherwise.\n//\nvar exists = module.exports.exists = function exists(object, path) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return false;\n  }\n\n  path = path.slice();\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return false;\n  }\n\n  if (path.length === 0) {\n    return Object.hasOwnProperty.apply(object, [key]);\n  } else {\n    return exists(object[key], path);\n  }\n}; //\n// These arguments are the same as those for `exists`.\n//\n// The return value, however, is the property you're trying to access, or\n// `undefined` if it can't be found. This means you won't be able to tell\n// the difference between an unresolved path and an undefined property, so you \n// should not use `get` to check for the existence of a property. Use `exists`\n// instead.\n//\n\n\nvar get = module.exports.get = function get(object, path) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return;\n  }\n\n  path = path.slice();\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return;\n  }\n\n  if (path.length === 0) {\n    return object[key];\n  }\n\n  if (path.length) {\n    return get(object[key], path);\n  }\n}; //\n// Arguments are similar to `exists` and `get`, with the exception that path\n// components are regexes with some special cases. If a path component is `\"*\"`\n// on its own, it'll be converted to `/.*/`.\n//\n// The return value is an array of values where the key path matches the\n// specified criterion. If none match, an empty array will be returned.\n//\n\n\nvar search = module.exports.search = function search(object, path) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return;\n  }\n\n  path = path.slice();\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return;\n  }\n\n  if (key === \"*\") {\n    key = \".*\";\n  }\n\n  if (typeof key === \"string\") {\n    key = new RegExp(key);\n  }\n\n  if (path.length === 0) {\n    return Object.keys(object).filter(key.test.bind(key)).map(function (k) {\n      return object[k];\n    });\n  } else {\n    return Array.prototype.concat.apply([], Object.keys(object).filter(key.test.bind(key)).map(function (k) {\n      return search(object[k], path);\n    }));\n  }\n}; //\n// The first two arguments for `put` are the same as `exists` and `get`.\n//\n// The third argument is a value to `put` at the `path` of the `object`.\n// Objects in the middle will be created if they don't exist, or added to if\n// they do. If a value is encountered in the middle of the path that is *not*\n// an object, it will not be overwritten.\n//\n// The return value is `true` in the case that the value was `put`\n// successfully, or `false` otherwise.\n//\n\n\nvar put = module.exports.put = function put(object, path, value) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return false;\n  }\n\n  path = path.slice();\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return false;\n  }\n\n  if (path.length === 0) {\n    object[key] = value;\n  } else {\n    if (typeof object[key] === \"undefined\") {\n      object[key] = {};\n    }\n\n    if (typeof object[key] !== \"object\" || object[key] === null) {\n      return false;\n    }\n\n    return put(object[key], path, value);\n  }\n}; //\n// `remove` is like `put` in reverse!\n//\n// The return value is `true` in the case that the value existed and was removed\n// successfully, or `false` otherwise.\n//\n\n\nvar remove = module.exports.remove = function remove(object, path, value) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return false;\n  }\n\n  path = path.slice();\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return false;\n  }\n\n  if (path.length === 0) {\n    if (!Object.hasOwnProperty.call(object, key)) {\n      return false;\n    }\n\n    delete object[key];\n    return true;\n  } else {\n    return remove(object[key], path, value);\n  }\n}; //\n// `deepKeys` creates a list of all possible key paths for a given object.\n//\n// The return value is always an array, the members of which are paths in array\n// format. If you want them in dot-notation format, do something like this:\n//\n// ```js\n// dotty.deepKeys(obj).map(function(e) {\n//   return e.join(\".\");\n// });\n// ```\n//\n// *Note: this will probably explode on recursive objects. Be careful.*\n//\n\n\nvar deepKeys = module.exports.deepKeys = function deepKeys(object, prefix) {\n  if (typeof prefix === \"undefined\") {\n    prefix = [];\n  }\n\n  var keys = [];\n\n  for (var k in object) {\n    if (!Object.hasOwnProperty.call(object, k)) {\n      continue;\n    }\n\n    keys.push(prefix.concat([k]));\n\n    if (typeof object[k] === \"object\" && object[k] !== null) {\n      keys = keys.concat(deepKeys(object[k], prefix.concat([k])));\n    }\n  }\n\n  return keys;\n};","map":{"version":3,"names":["exists","module","exports","object","path","split","Array","length","slice","key","shift","Object","hasOwnProperty","apply","get","search","RegExp","keys","filter","test","bind","map","k","prototype","concat","put","value","remove","call","deepKeys","prefix","push"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/dotty/lib/index.js"],"sourcesContent":["//\n// Dotty makes it easy to programmatically access arbitrarily nested objects and\n// their properties.\n//\n\n//\n// `object` is an object, `path` is the path to the property you want to check\n// for existence of.\n//\n// `path` can be provided as either a `\"string.separated.with.dots\"` or as\n// `[\"an\", \"array\"]`.\n//\n// Returns `true` if the path can be completely resolved, `false` otherwise.\n//\n\nvar exists = module.exports.exists = function exists(object, path) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return false;\n  }\n\n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return false;\n  }\n\n  if (path.length === 0) {\n    return Object.hasOwnProperty.apply(object, [key]);\n  } else {\n    return exists(object[key], path);\n  }\n};\n\n//\n// These arguments are the same as those for `exists`.\n//\n// The return value, however, is the property you're trying to access, or\n// `undefined` if it can't be found. This means you won't be able to tell\n// the difference between an unresolved path and an undefined property, so you \n// should not use `get` to check for the existence of a property. Use `exists`\n// instead.\n//\n\nvar get = module.exports.get = function get(object, path) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return;\n  }\n\n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return;\n  }\n\n  if (path.length === 0) {\n    return object[key];\n  }\n\n  if (path.length) {\n    return get(object[key], path);\n  }\n};\n\n//\n// Arguments are similar to `exists` and `get`, with the exception that path\n// components are regexes with some special cases. If a path component is `\"*\"`\n// on its own, it'll be converted to `/.*/`.\n//\n// The return value is an array of values where the key path matches the\n// specified criterion. If none match, an empty array will be returned.\n//\n\nvar search = module.exports.search = function search(object, path) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return;\n  }\n\n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return;\n  }\n\n  if (key === \"*\") {\n    key = \".*\";\n  }\n\n  if (typeof key === \"string\") {\n    key = new RegExp(key);\n  }\n\n  if (path.length === 0) {\n    return Object.keys(object).filter(key.test.bind(key)).map(function(k) { return object[k]; });\n  } else {\n    return Array.prototype.concat.apply([], Object.keys(object).filter(key.test.bind(key)).map(function(k) { return search(object[k], path); }));\n  }\n};\n\n//\n// The first two arguments for `put` are the same as `exists` and `get`.\n//\n// The third argument is a value to `put` at the `path` of the `object`.\n// Objects in the middle will be created if they don't exist, or added to if\n// they do. If a value is encountered in the middle of the path that is *not*\n// an object, it will not be overwritten.\n//\n// The return value is `true` in the case that the value was `put`\n// successfully, or `false` otherwise.\n//\n\nvar put = module.exports.put = function put(object, path, value) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return false;\n  }\n  \n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return false;\n  }\n\n  if (path.length === 0) {\n    object[key] = value;\n  } else {\n    if (typeof object[key] === \"undefined\") {\n      object[key] = {};\n    }\n\n    if (typeof object[key] !== \"object\" || object[key] === null) {\n      return false;\n    }\n\n    return put(object[key], path, value);\n  }\n};\n\n//\n// `remove` is like `put` in reverse!\n//\n// The return value is `true` in the case that the value existed and was removed\n// successfully, or `false` otherwise.\n//\n\nvar remove = module.exports.remove = function remove(object, path, value) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return false;\n  }\n  \n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return false;\n  }\n\n  if (path.length === 0) {\n    if (!Object.hasOwnProperty.call(object, key)) {\n      return false;\n    }\n\n    delete object[key];\n\n    return true;\n  } else {\n    return remove(object[key], path, value);\n  }\n};\n\n//\n// `deepKeys` creates a list of all possible key paths for a given object.\n//\n// The return value is always an array, the members of which are paths in array\n// format. If you want them in dot-notation format, do something like this:\n//\n// ```js\n// dotty.deepKeys(obj).map(function(e) {\n//   return e.join(\".\");\n// });\n// ```\n//\n// *Note: this will probably explode on recursive objects. Be careful.*\n//\n\nvar deepKeys = module.exports.deepKeys = function deepKeys(object, prefix) {\n  if (typeof prefix === \"undefined\") {\n    prefix = [];\n  }\n\n  var keys = [];\n\n  for (var k in object) {\n    if (!Object.hasOwnProperty.call(object, k)) {\n      continue;\n    }\n\n    keys.push(prefix.concat([k]));\n\n    if (typeof object[k] === \"object\" && object[k] !== null) {\n      keys = keys.concat(deepKeys(object[k], prefix.concat([k])));\n    }\n  }\n\n  return keys;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}