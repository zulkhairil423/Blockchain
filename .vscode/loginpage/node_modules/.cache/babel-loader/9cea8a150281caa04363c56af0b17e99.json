{"ast":null,"code":"// Ported from https://github.com/nodejs/undici/pull/907\n'use strict';\n\nconst assert = require('assert');\n\nconst {\n  Readable\n} = require('stream');\n\nconst {\n  RequestAbortedError,\n  NotSupportedError\n} = require('../core/errors');\n\nconst util = require('../core/util');\n\nconst {\n  ReadableStreamFrom,\n  toUSVString\n} = require('../core/util');\n\nlet Blob;\nconst kConsume = Symbol('kConsume');\nconst kReading = Symbol('kReading');\nconst kBody = Symbol('kBody');\nconst kAbort = Symbol('abort');\nconst kContentType = Symbol('kContentType');\nmodule.exports = class BodyReadable extends Readable {\n  constructor(resume, abort) {\n    let contentType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    super({\n      autoDestroy: true,\n      read: resume,\n      highWaterMark: 64 * 1024 // Same as nodejs fs streams.\n\n    });\n    this._readableState.dataEmitted = false;\n    this[kAbort] = abort;\n    this[kConsume] = null;\n    this[kBody] = null;\n    this[kContentType] = contentType; // Is stream being consumed through Readable API?\n    // This is an optimization so that we avoid checking\n    // for 'data' and 'readable' listeners in the hot path\n    // inside push().\n\n    this[kReading] = false;\n  }\n\n  destroy(err) {\n    if (this.destroyed) {\n      // Node < 16\n      return this;\n    }\n\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError();\n    }\n\n    if (err) {\n      this[kAbort]();\n    }\n\n    return super.destroy(err);\n  }\n\n  emit(ev) {\n    if (ev === 'data') {\n      // Node < 16.7\n      this._readableState.dataEmitted = true;\n    } else if (ev === 'error') {\n      // Node < 16\n      this._readableState.errorEmitted = true;\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return super.emit(ev, ...args);\n  }\n\n  on(ev) {\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = true;\n    }\n\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    return super.on(ev, ...args);\n  }\n\n  addListener(ev) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n\n    return this.on(ev, ...args);\n  }\n\n  off(ev) {\n    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      args[_key4 - 1] = arguments[_key4];\n    }\n\n    const ret = super.off(ev, ...args);\n\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = this.listenerCount('data') > 0 || this.listenerCount('readable') > 0;\n    }\n\n    return ret;\n  }\n\n  removeListener(ev) {\n    for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      args[_key5 - 1] = arguments[_key5];\n    }\n\n    return this.off(ev, ...args);\n  }\n\n  push(chunk) {\n    if (this[kConsume] && chunk !== null && this.readableLength === 0) {\n      consumePush(this[kConsume], chunk);\n      return this[kReading] ? super.push(chunk) : true;\n    }\n\n    return super.push(chunk);\n  } // https://fetch.spec.whatwg.org/#dom-body-text\n\n\n  async text() {\n    return consume(this, 'text');\n  } // https://fetch.spec.whatwg.org/#dom-body-json\n\n\n  async json() {\n    return consume(this, 'json');\n  } // https://fetch.spec.whatwg.org/#dom-body-blob\n\n\n  async blob() {\n    return consume(this, 'blob');\n  } // https://fetch.spec.whatwg.org/#dom-body-arraybuffer\n\n\n  async arrayBuffer() {\n    return consume(this, 'arrayBuffer');\n  } // https://fetch.spec.whatwg.org/#dom-body-formdata\n\n\n  async formData() {\n    // TODO: Implement.\n    throw new NotSupportedError();\n  } // https://fetch.spec.whatwg.org/#dom-body-bodyused\n\n\n  get bodyUsed() {\n    return util.isDisturbed(this);\n  } // https://fetch.spec.whatwg.org/#dom-body-body\n\n\n  get body() {\n    if (!this[kBody]) {\n      this[kBody] = ReadableStreamFrom(this);\n\n      if (this[kConsume]) {\n        // TODO: Is this the best way to force a lock?\n        this[kBody].getReader(); // Ensure stream is locked.\n\n        assert(this[kBody].locked);\n      }\n    }\n\n    return this[kBody];\n  }\n\n  async dump(opts) {\n    let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;\n\n    try {\n      for await (const chunk of this) {\n        limit -= Buffer.byteLength(chunk);\n\n        if (limit < 0) {\n          return;\n        }\n      }\n    } catch {// Do nothing...\n    }\n  }\n\n}; // https://streams.spec.whatwg.org/#readablestream-locked\n\nfunction isLocked(self) {\n  // Consume is an implicit lock.\n  return self[kBody] && self[kBody].locked === true || self[kConsume];\n} // https://fetch.spec.whatwg.org/#body-unusable\n\n\nfunction isUnusable(self) {\n  return util.isDisturbed(self) || isLocked(self);\n}\n\nasync function consume(stream, type) {\n  if (isUnusable(stream)) {\n    throw new TypeError('unusable');\n  }\n\n  assert(!stream[kConsume]);\n  return new Promise((resolve, reject) => {\n    stream[kConsume] = {\n      type,\n      stream,\n      resolve,\n      reject,\n      length: 0,\n      body: []\n    };\n    stream.on('error', function (err) {\n      consumeFinish(this[kConsume], err);\n    }).on('close', function () {\n      if (this[kConsume].body !== null) {\n        consumeFinish(this[kConsume], new RequestAbortedError());\n      }\n    });\n    process.nextTick(consumeStart, stream[kConsume]);\n  });\n}\n\nfunction consumeStart(consume) {\n  if (consume.body === null) {\n    return;\n  }\n\n  const {\n    _readableState: state\n  } = consume.stream;\n\n  for (const chunk of state.buffer) {\n    consumePush(consume, chunk);\n  }\n\n  if (state.endEmitted) {\n    consumeEnd(this[kConsume]);\n  } else {\n    consume.stream.on('end', function () {\n      consumeEnd(this[kConsume]);\n    });\n  }\n\n  consume.stream.resume();\n\n  while (consume.stream.read() != null) {// Loop\n  }\n}\n\nfunction consumeEnd(consume) {\n  const {\n    type,\n    body,\n    resolve,\n    stream,\n    length\n  } = consume;\n\n  try {\n    if (type === 'text') {\n      resolve(toUSVString(Buffer.concat(body)));\n    } else if (type === 'json') {\n      resolve(JSON.parse(Buffer.concat(body)));\n    } else if (type === 'arrayBuffer') {\n      const dst = new Uint8Array(length);\n      let pos = 0;\n\n      for (const buf of body) {\n        dst.set(buf, pos);\n        pos += buf.byteLength;\n      }\n\n      resolve(dst);\n    } else if (type === 'blob') {\n      if (!Blob) {\n        Blob = require('buffer').Blob;\n      }\n\n      resolve(new Blob(body, {\n        type: stream[kContentType]\n      }));\n    }\n\n    consumeFinish(consume);\n  } catch (err) {\n    stream.destroy(err);\n  }\n}\n\nfunction consumePush(consume, chunk) {\n  consume.length += chunk.length;\n  consume.body.push(chunk);\n}\n\nfunction consumeFinish(consume, err) {\n  if (consume.body === null) {\n    return;\n  }\n\n  if (err) {\n    consume.reject(err);\n  } else {\n    consume.resolve();\n  }\n\n  consume.type = null;\n  consume.stream = null;\n  consume.resolve = null;\n  consume.reject = null;\n  consume.length = 0;\n  consume.body = null;\n}","map":{"version":3,"names":["assert","require","Readable","RequestAbortedError","NotSupportedError","util","ReadableStreamFrom","toUSVString","Blob","kConsume","Symbol","kReading","kBody","kAbort","kContentType","module","exports","BodyReadable","constructor","resume","abort","contentType","autoDestroy","read","highWaterMark","_readableState","dataEmitted","destroy","err","destroyed","endEmitted","emit","ev","errorEmitted","args","on","addListener","off","ret","listenerCount","removeListener","push","chunk","readableLength","consumePush","text","consume","json","blob","arrayBuffer","formData","bodyUsed","isDisturbed","body","getReader","locked","dump","opts","limit","Number","isFinite","Buffer","byteLength","isLocked","self","isUnusable","stream","type","TypeError","Promise","resolve","reject","length","consumeFinish","process","nextTick","consumeStart","state","buffer","consumeEnd","concat","JSON","parse","dst","Uint8Array","pos","buf","set"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/undici/lib/api/readable.js"],"sourcesContent":["// Ported from https://github.com/nodejs/undici/pull/907\n\n'use strict'\n\nconst assert = require('assert')\nconst { Readable } = require('stream')\nconst { RequestAbortedError, NotSupportedError } = require('../core/errors')\nconst util = require('../core/util')\nconst { ReadableStreamFrom, toUSVString } = require('../core/util')\n\nlet Blob\n\nconst kConsume = Symbol('kConsume')\nconst kReading = Symbol('kReading')\nconst kBody = Symbol('kBody')\nconst kAbort = Symbol('abort')\nconst kContentType = Symbol('kContentType')\n\nmodule.exports = class BodyReadable extends Readable {\n  constructor (resume, abort, contentType = '') {\n    super({\n      autoDestroy: true,\n      read: resume,\n      highWaterMark: 64 * 1024 // Same as nodejs fs streams.\n    })\n\n    this._readableState.dataEmitted = false\n\n    this[kAbort] = abort\n    this[kConsume] = null\n    this[kBody] = null\n    this[kContentType] = contentType\n\n    // Is stream being consumed through Readable API?\n    // This is an optimization so that we avoid checking\n    // for 'data' and 'readable' listeners in the hot path\n    // inside push().\n    this[kReading] = false\n  }\n\n  destroy (err) {\n    if (this.destroyed) {\n      // Node < 16\n      return this\n    }\n\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError()\n    }\n\n    if (err) {\n      this[kAbort]()\n    }\n\n    return super.destroy(err)\n  }\n\n  emit (ev, ...args) {\n    if (ev === 'data') {\n      // Node < 16.7\n      this._readableState.dataEmitted = true\n    } else if (ev === 'error') {\n      // Node < 16\n      this._readableState.errorEmitted = true\n    }\n    return super.emit(ev, ...args)\n  }\n\n  on (ev, ...args) {\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = true\n    }\n    return super.on(ev, ...args)\n  }\n\n  addListener (ev, ...args) {\n    return this.on(ev, ...args)\n  }\n\n  off (ev, ...args) {\n    const ret = super.off(ev, ...args)\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = (\n        this.listenerCount('data') > 0 ||\n        this.listenerCount('readable') > 0\n      )\n    }\n    return ret\n  }\n\n  removeListener (ev, ...args) {\n    return this.off(ev, ...args)\n  }\n\n  push (chunk) {\n    if (this[kConsume] && chunk !== null && this.readableLength === 0) {\n      consumePush(this[kConsume], chunk)\n      return this[kReading] ? super.push(chunk) : true\n    }\n    return super.push(chunk)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-text\n  async text () {\n    return consume(this, 'text')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-json\n  async json () {\n    return consume(this, 'json')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-blob\n  async blob () {\n    return consume(this, 'blob')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-arraybuffer\n  async arrayBuffer () {\n    return consume(this, 'arrayBuffer')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-formdata\n  async formData () {\n    // TODO: Implement.\n    throw new NotSupportedError()\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-bodyused\n  get bodyUsed () {\n    return util.isDisturbed(this)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-body\n  get body () {\n    if (!this[kBody]) {\n      this[kBody] = ReadableStreamFrom(this)\n      if (this[kConsume]) {\n        // TODO: Is this the best way to force a lock?\n        this[kBody].getReader() // Ensure stream is locked.\n        assert(this[kBody].locked)\n      }\n    }\n    return this[kBody]\n  }\n\n  async dump (opts) {\n    let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144\n    try {\n      for await (const chunk of this) {\n        limit -= Buffer.byteLength(chunk)\n        if (limit < 0) {\n          return\n        }\n      }\n    } catch {\n      // Do nothing...\n    }\n  }\n}\n\n// https://streams.spec.whatwg.org/#readablestream-locked\nfunction isLocked (self) {\n  // Consume is an implicit lock.\n  return (self[kBody] && self[kBody].locked === true) || self[kConsume]\n}\n\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction isUnusable (self) {\n  return util.isDisturbed(self) || isLocked(self)\n}\n\nasync function consume (stream, type) {\n  if (isUnusable(stream)) {\n    throw new TypeError('unusable')\n  }\n\n  assert(!stream[kConsume])\n\n  return new Promise((resolve, reject) => {\n    stream[kConsume] = {\n      type,\n      stream,\n      resolve,\n      reject,\n      length: 0,\n      body: []\n    }\n\n    stream\n      .on('error', function (err) {\n        consumeFinish(this[kConsume], err)\n      })\n      .on('close', function () {\n        if (this[kConsume].body !== null) {\n          consumeFinish(this[kConsume], new RequestAbortedError())\n        }\n      })\n\n    process.nextTick(consumeStart, stream[kConsume])\n  })\n}\n\nfunction consumeStart (consume) {\n  if (consume.body === null) {\n    return\n  }\n\n  const { _readableState: state } = consume.stream\n\n  for (const chunk of state.buffer) {\n    consumePush(consume, chunk)\n  }\n\n  if (state.endEmitted) {\n    consumeEnd(this[kConsume])\n  } else {\n    consume.stream.on('end', function () {\n      consumeEnd(this[kConsume])\n    })\n  }\n\n  consume.stream.resume()\n\n  while (consume.stream.read() != null) {\n    // Loop\n  }\n}\n\nfunction consumeEnd (consume) {\n  const { type, body, resolve, stream, length } = consume\n\n  try {\n    if (type === 'text') {\n      resolve(toUSVString(Buffer.concat(body)))\n    } else if (type === 'json') {\n      resolve(JSON.parse(Buffer.concat(body)))\n    } else if (type === 'arrayBuffer') {\n      const dst = new Uint8Array(length)\n\n      let pos = 0\n      for (const buf of body) {\n        dst.set(buf, pos)\n        pos += buf.byteLength\n      }\n\n      resolve(dst)\n    } else if (type === 'blob') {\n      if (!Blob) {\n        Blob = require('buffer').Blob\n      }\n      resolve(new Blob(body, { type: stream[kContentType] }))\n    }\n\n    consumeFinish(consume)\n  } catch (err) {\n    stream.destroy(err)\n  }\n}\n\nfunction consumePush (consume, chunk) {\n  consume.length += chunk.length\n  consume.body.push(chunk)\n}\n\nfunction consumeFinish (consume, err) {\n  if (consume.body === null) {\n    return\n  }\n\n  if (err) {\n    consume.reject(err)\n  } else {\n    consume.resolve()\n  }\n\n  consume.type = null\n  consume.stream = null\n  consume.resolve = null\n  consume.reject = null\n  consume.length = 0\n  consume.body = null\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}