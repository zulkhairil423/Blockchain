{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.classifyModule = void 0;\n\nconst node_internal_modules_cjs_loader_1 = require(\"../dist-raw/node-internal-modules-cjs-loader\");\n/**\n * Determine how to emit a module based on tsconfig \"module\" and package.json \"type\"\n *\n * Supports module=nodenext/node16 with transpileOnly, where we cannot ask the\n * TS typechecker to tell us if a file is CJS or ESM.\n *\n * Return values indicate:\n * - cjs\n * - esm\n * - nodecjs == node-flavored cjs where dynamic imports are *not* transformed into `require()`\n * - undefined == emit according to tsconfig `module` config, whatever that is\n * @internal\n */\n\n\nfunction classifyModule(nativeFilename, isNodeModuleType) {\n  // [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n  const lastDotIndex = nativeFilename.lastIndexOf('.');\n  const ext = lastDotIndex >= 0 ? nativeFilename.slice(lastDotIndex) : '';\n\n  switch (ext) {\n    case '.cjs':\n    case '.cts':\n      return isNodeModuleType ? 'nodecjs' : 'cjs';\n\n    case '.mjs':\n    case '.mts':\n      return isNodeModuleType ? 'nodeesm' : 'esm';\n  }\n\n  if (isNodeModuleType) {\n    const packageScope = (0, node_internal_modules_cjs_loader_1.readPackageScope)(nativeFilename);\n    if (packageScope && packageScope.data.type === 'module') return 'nodeesm';\n    return 'nodecjs';\n  }\n\n  return undefined;\n}\n\nexports.classifyModule = classifyModule;","map":{"version":3,"mappings":";;;;;;;AAAA;AAEA;;;;;;;;;;;;;;;AAaA,SAAgBA,cAAhB,CACEC,cADF,EAEEC,gBAFF,EAE2B;EAEzB;EACA,MAAMC,YAAY,GAAGF,cAAc,CAACG,WAAf,CAA2B,GAA3B,CAArB;EACA,MAAMC,GAAG,GAAGF,YAAY,IAAI,CAAhB,GAAoBF,cAAc,CAACK,KAAf,CAAqBH,YAArB,CAApB,GAAyD,EAArE;;EACA,QAAQE,GAAR;IACE,KAAK,MAAL;IACA,KAAK,MAAL;MACE,OAAOH,gBAAgB,GAAG,SAAH,GAAe,KAAtC;;IACF,KAAK,MAAL;IACA,KAAK,MAAL;MACE,OAAOA,gBAAgB,GAAG,SAAH,GAAe,KAAtC;EANJ;;EAQA,IAAIA,gBAAJ,EAAsB;IACpB,MAAMK,YAAY,GAAG,yDAAiBN,cAAjB,CAArB;IACA,IAAIM,YAAY,IAAIA,YAAY,CAACC,IAAb,CAAkBC,IAAlB,KAA2B,QAA/C,EAAyD,OAAO,SAAP;IACzD,OAAO,SAAP;EACD;;EACD,OAAOC,SAAP;AACD;;AArBDC","names":["classifyModule","nativeFilename","isNodeModuleType","lastDotIndex","lastIndexOf","ext","slice","packageScope","data","type","undefined","exports"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\ts-node\\src\\node-module-type-classifier.ts"],"sourcesContent":["import { readPackageScope } from '../dist-raw/node-internal-modules-cjs-loader';\n\n/**\n * Determine how to emit a module based on tsconfig \"module\" and package.json \"type\"\n *\n * Supports module=nodenext/node16 with transpileOnly, where we cannot ask the\n * TS typechecker to tell us if a file is CJS or ESM.\n *\n * Return values indicate:\n * - cjs\n * - esm\n * - nodecjs == node-flavored cjs where dynamic imports are *not* transformed into `require()`\n * - undefined == emit according to tsconfig `module` config, whatever that is\n * @internal\n */\nexport function classifyModule(\n  nativeFilename: string,\n  isNodeModuleType: boolean\n): 'nodecjs' | 'cjs' | 'esm' | 'nodeesm' | undefined {\n  // [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n  const lastDotIndex = nativeFilename.lastIndexOf('.');\n  const ext = lastDotIndex >= 0 ? nativeFilename.slice(lastDotIndex) : '';\n  switch (ext) {\n    case '.cjs':\n    case '.cts':\n      return isNodeModuleType ? 'nodecjs' : 'cjs';\n    case '.mjs':\n    case '.mts':\n      return isNodeModuleType ? 'nodeesm' : 'esm';\n  }\n  if (isNodeModuleType) {\n    const packageScope = readPackageScope(nativeFilename);\n    if (packageScope && packageScope.data.type === 'module') return 'nodeesm';\n    return 'nodecjs';\n  }\n  return undefined;\n}\n"]},"metadata":{},"sourceType":"script"}