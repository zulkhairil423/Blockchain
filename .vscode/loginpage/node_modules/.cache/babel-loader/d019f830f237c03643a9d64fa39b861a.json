{"ast":null,"code":"/*istanbul ignore start*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyPatch = applyPatch;\nexports.applyPatches = applyPatches;\n/*istanbul ignore end*/\n\nvar\n/*istanbul ignore start*/\n_parse = require(\"./parse\")\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_distanceIterator = _interopRequireDefault(require(\"../util/distance-iterator\"))\n/*istanbul ignore end*/\n;\n/*istanbul ignore start*/\n\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n/*istanbul ignore end*/\n\n\nfunction applyPatch(source, uniDiff) {\n  /*istanbul ignore start*/\n  var\n  /*istanbul ignore end*/\n  options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (typeof uniDiff === 'string') {\n    uniDiff =\n    /*istanbul ignore start*/\n    (0,\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    _parse\n    /*istanbul ignore end*/\n    .\n    /*istanbul ignore start*/\n    parsePatch\n    /*istanbul ignore end*/\n    )(uniDiff);\n  }\n\n  if (Array.isArray(uniDiff)) {\n    if (uniDiff.length > 1) {\n      throw new Error('applyPatch only works with a single input.');\n    }\n\n    uniDiff = uniDiff[0];\n  } // Apply the diff to the input\n\n\n  var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      hunks = uniDiff.hunks,\n      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent)\n  /*istanbul ignore start*/\n  {\n    return (\n      /*istanbul ignore end*/\n      line === patchContent\n    );\n  },\n      errorCount = 0,\n      fuzzFactor = options.fuzzFactor || 0,\n      minLine = 0,\n      offset = 0,\n      removeEOFNL,\n      addEOFNL;\n  /**\n   * Checks if the hunk exactly fits on the provided location\n   */\n\n\n  function hunkFits(hunk, toPos) {\n    for (var j = 0; j < hunk.lines.length; j++) {\n      var line = hunk.lines[j],\n          operation = line.length > 0 ? line[0] : ' ',\n          content = line.length > 0 ? line.substr(1) : line;\n\n      if (operation === ' ' || operation === '-') {\n        // Context sanity check\n        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n          errorCount++;\n\n          if (errorCount > fuzzFactor) {\n            return false;\n          }\n        }\n\n        toPos++;\n      }\n    }\n\n    return true;\n  } // Search best fit offsets for each hunk based on the previous ones\n\n\n  for (var i = 0; i < hunks.length; i++) {\n    var hunk = hunks[i],\n        maxLine = lines.length - hunk.oldLines,\n        localOffset = 0,\n        toPos = offset + hunk.oldStart - 1;\n    var iterator =\n    /*istanbul ignore start*/\n    (0,\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    _distanceIterator\n    /*istanbul ignore end*/\n    [\n    /*istanbul ignore start*/\n    \"default\"\n    /*istanbul ignore end*/\n    ])(toPos, minLine, maxLine);\n\n    for (; localOffset !== undefined; localOffset = iterator()) {\n      if (hunkFits(hunk, toPos + localOffset)) {\n        hunk.offset = offset += localOffset;\n        break;\n      }\n    }\n\n    if (localOffset === undefined) {\n      return false;\n    } // Set lower text limit to end of the current hunk, so next ones don't try\n    // to fit over already patched text\n\n\n    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n  } // Apply patch hunks\n\n\n  var diffOffset = 0;\n\n  for (var _i = 0; _i < hunks.length; _i++) {\n    var _hunk = hunks[_i],\n        _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n\n    diffOffset += _hunk.newLines - _hunk.oldLines;\n\n    for (var j = 0; j < _hunk.lines.length; j++) {\n      var line = _hunk.lines[j],\n          operation = line.length > 0 ? line[0] : ' ',\n          content = line.length > 0 ? line.substr(1) : line,\n          delimiter = _hunk.linedelimiters[j];\n\n      if (operation === ' ') {\n        _toPos++;\n      } else if (operation === '-') {\n        lines.splice(_toPos, 1);\n        delimiters.splice(_toPos, 1);\n        /* istanbul ignore else */\n      } else if (operation === '+') {\n        lines.splice(_toPos, 0, content);\n        delimiters.splice(_toPos, 0, delimiter);\n        _toPos++;\n      } else if (operation === '\\\\') {\n        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n\n        if (previousOperation === '+') {\n          removeEOFNL = true;\n        } else if (previousOperation === '-') {\n          addEOFNL = true;\n        }\n      }\n    }\n  } // Handle EOFNL insertion/removal\n\n\n  if (removeEOFNL) {\n    while (!lines[lines.length - 1]) {\n      lines.pop();\n      delimiters.pop();\n    }\n  } else if (addEOFNL) {\n    lines.push('');\n    delimiters.push('\\n');\n  }\n\n  for (var _k = 0; _k < lines.length - 1; _k++) {\n    lines[_k] = lines[_k] + delimiters[_k];\n  }\n\n  return lines.join('');\n} // Wrapper that supports multiple file patches via callbacks.\n\n\nfunction applyPatches(uniDiff, options) {\n  if (typeof uniDiff === 'string') {\n    uniDiff =\n    /*istanbul ignore start*/\n    (0,\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    _parse\n    /*istanbul ignore end*/\n    .\n    /*istanbul ignore start*/\n    parsePatch\n    /*istanbul ignore end*/\n    )(uniDiff);\n  }\n\n  var currentIndex = 0;\n\n  function processIndex() {\n    var index = uniDiff[currentIndex++];\n\n    if (!index) {\n      return options.complete();\n    }\n\n    options.loadFile(index, function (err, data) {\n      if (err) {\n        return options.complete(err);\n      }\n\n      var updatedContent = applyPatch(data, index, options);\n      options.patched(index, updatedContent, function (err) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        processIndex();\n      });\n    });\n  }\n\n  processIndex();\n}","map":{"version":3,"mappings":"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","names":["_parse","_distanceIterator","applyPatch","source","uniDiff","options","parsePatch","Array","isArray","length","Error","lines","split","delimiters","match","hunks","compareLine","lineNumber","line","operation","patchContent","errorCount","fuzzFactor","minLine","offset","removeEOFNL","addEOFNL","hunkFits","hunk","toPos","j","content","substr","i","maxLine","oldLines","localOffset","oldStart","iterator","distanceIterator","undefined","diffOffset","newLines","delimiter","linedelimiters","splice","previousOperation","pop","push","_k","join","applyPatches","currentIndex","processIndex","index","complete","loadFile","err","data","updatedContent","patched"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\diff\\src\\patch\\apply.js"],"sourcesContent":["import {parsePatch} from './parse';\nimport distanceIterator from '../util/distance-iterator';\n\nexport function applyPatch(source, uniDiff, options = {}) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  if (Array.isArray(uniDiff)) {\n    if (uniDiff.length > 1) {\n      throw new Error('applyPatch only works with a single input.');\n    }\n\n    uniDiff = uniDiff[0];\n  }\n\n  // Apply the diff to the input\n  let lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      hunks = uniDiff.hunks,\n\n      compareLine = options.compareLine || ((lineNumber, line, operation, patchContent) => line === patchContent),\n      errorCount = 0,\n      fuzzFactor = options.fuzzFactor || 0,\n      minLine = 0,\n      offset = 0,\n\n      removeEOFNL,\n      addEOFNL;\n\n  /**\n   * Checks if the hunk exactly fits on the provided location\n   */\n  function hunkFits(hunk, toPos) {\n    for (let j = 0; j < hunk.lines.length; j++) {\n      let line = hunk.lines[j],\n          operation = (line.length > 0 ? line[0] : ' '),\n          content = (line.length > 0 ? line.substr(1) : line);\n\n      if (operation === ' ' || operation === '-') {\n        // Context sanity check\n        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n          errorCount++;\n\n          if (errorCount > fuzzFactor) {\n            return false;\n          }\n        }\n        toPos++;\n      }\n    }\n\n    return true;\n  }\n\n  // Search best fit offsets for each hunk based on the previous ones\n  for (let i = 0; i < hunks.length; i++) {\n    let hunk = hunks[i],\n        maxLine = lines.length - hunk.oldLines,\n        localOffset = 0,\n        toPos = offset + hunk.oldStart - 1;\n\n    let iterator = distanceIterator(toPos, minLine, maxLine);\n\n    for (; localOffset !== undefined; localOffset = iterator()) {\n      if (hunkFits(hunk, toPos + localOffset)) {\n        hunk.offset = offset += localOffset;\n        break;\n      }\n    }\n\n    if (localOffset === undefined) {\n      return false;\n    }\n\n    // Set lower text limit to end of the current hunk, so next ones don't try\n    // to fit over already patched text\n    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n  }\n\n  // Apply patch hunks\n  let diffOffset = 0;\n  for (let i = 0; i < hunks.length; i++) {\n    let hunk = hunks[i],\n        toPos = hunk.oldStart + hunk.offset + diffOffset - 1;\n    diffOffset += hunk.newLines - hunk.oldLines;\n\n    for (let j = 0; j < hunk.lines.length; j++) {\n      let line = hunk.lines[j],\n          operation = (line.length > 0 ? line[0] : ' '),\n          content = (line.length > 0 ? line.substr(1) : line),\n          delimiter = hunk.linedelimiters[j];\n\n      if (operation === ' ') {\n        toPos++;\n      } else if (operation === '-') {\n        lines.splice(toPos, 1);\n        delimiters.splice(toPos, 1);\n      /* istanbul ignore else */\n      } else if (operation === '+') {\n        lines.splice(toPos, 0, content);\n        delimiters.splice(toPos, 0, delimiter);\n        toPos++;\n      } else if (operation === '\\\\') {\n        let previousOperation = hunk.lines[j - 1] ? hunk.lines[j - 1][0] : null;\n        if (previousOperation === '+') {\n          removeEOFNL = true;\n        } else if (previousOperation === '-') {\n          addEOFNL = true;\n        }\n      }\n    }\n  }\n\n  // Handle EOFNL insertion/removal\n  if (removeEOFNL) {\n    while (!lines[lines.length - 1]) {\n      lines.pop();\n      delimiters.pop();\n    }\n  } else if (addEOFNL) {\n    lines.push('');\n    delimiters.push('\\n');\n  }\n  for (let _k = 0; _k < lines.length - 1; _k++) {\n    lines[_k] = lines[_k] + delimiters[_k];\n  }\n  return lines.join('');\n}\n\n// Wrapper that supports multiple file patches via callbacks.\nexport function applyPatches(uniDiff, options) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  let currentIndex = 0;\n  function processIndex() {\n    let index = uniDiff[currentIndex++];\n    if (!index) {\n      return options.complete();\n    }\n\n    options.loadFile(index, function(err, data) {\n      if (err) {\n        return options.complete(err);\n      }\n\n      let updatedContent = applyPatch(data, index, options);\n      options.patched(index, updatedContent, function(err) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        processIndex();\n      });\n    });\n  }\n  processIndex();\n}\n"]},"metadata":{},"sourceType":"script"}