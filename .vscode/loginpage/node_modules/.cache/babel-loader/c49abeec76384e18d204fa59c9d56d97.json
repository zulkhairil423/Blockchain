{"ast":null,"code":"\"use strict\";\n\nvar _a;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.versionGteLt = exports.once = exports.getBasePathForProjectLocalDependencyResolution = exports.createProjectLocalResolveHelper = exports.attemptRequireWithV8CompileCache = exports.cachedLookup = exports.hasOwnProperty = exports.normalizeSlashes = exports.parse = exports.split = exports.assign = exports.yn = exports.createRequire = void 0;\n\nconst module_1 = require(\"module\");\n\nconst ynModule = require(\"yn\");\n\nconst path_1 = require(\"path\");\n/** @internal */\n\n\nexports.createRequire = (_a = module_1.createRequire !== null && module_1.createRequire !== void 0 ? module_1.createRequire : module_1.createRequireFromPath) !== null && _a !== void 0 ? _a : require('create-require');\n/**\n * Wrapper around yn module that returns `undefined` instead of `null`.\n * This is implemented by yn v4, but we're staying on v3 to avoid v4's node 10 requirement.\n * @internal\n */\n\nfunction yn(value) {\n  var _a;\n\n  return (_a = ynModule(value)) !== null && _a !== void 0 ? _a : undefined;\n}\n\nexports.yn = yn;\n/**\n * Like `Object.assign`, but ignores `undefined` properties.\n *\n * @internal\n */\n\nfunction assign(initialValue) {\n  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    sources[_key - 1] = arguments[_key];\n  }\n\n  for (const source of sources) {\n    for (const key of Object.keys(source)) {\n      const value = source[key];\n      if (value !== undefined) initialValue[key] = value;\n    }\n  }\n\n  return initialValue;\n}\n\nexports.assign = assign;\n/**\n * Split a string array of values\n * and remove empty strings from the resulting array.\n * @internal\n */\n\nfunction split(value) {\n  return typeof value === 'string' ? value.split(/ *, */g).filter(v => v !== '') : undefined;\n}\n\nexports.split = split;\n/**\n * Parse a string as JSON.\n * @internal\n */\n\nfunction parse(value) {\n  return typeof value === 'string' ? JSON.parse(value) : undefined;\n}\n\nexports.parse = parse;\nconst directorySeparator = '/';\nconst backslashRegExp = /\\\\/g;\n/**\n * Replace backslashes with forward slashes.\n * @internal\n */\n\nfunction normalizeSlashes(value) {\n  return value.replace(backslashRegExp, directorySeparator);\n}\n\nexports.normalizeSlashes = normalizeSlashes;\n/**\n * Safe `hasOwnProperty`\n * @internal\n */\n\nfunction hasOwnProperty(object, property) {\n  return Object.prototype.hasOwnProperty.call(object, property);\n}\n\nexports.hasOwnProperty = hasOwnProperty;\n/**\n * Cached fs operation wrapper.\n */\n\nfunction cachedLookup(fn) {\n  const cache = new Map();\n  return arg => {\n    if (!cache.has(arg)) {\n      const v = fn(arg);\n      cache.set(arg, v);\n      return v;\n    }\n\n    return cache.get(arg);\n  };\n}\n\nexports.cachedLookup = cachedLookup;\n/**\n * @internal\n * Require something with v8-compile-cache, which should make subsequent requires faster.\n * Do lots of error-handling so that, worst case, we require without the cache, and users are not blocked.\n */\n\nfunction attemptRequireWithV8CompileCache(requireFn, specifier) {\n  try {\n    const v8CC = require('v8-compile-cache-lib').install();\n\n    try {\n      return requireFn(specifier);\n    } finally {\n      v8CC === null || v8CC === void 0 ? void 0 : v8CC.uninstall();\n    }\n  } catch (e) {\n    return requireFn(specifier);\n  }\n}\n\nexports.attemptRequireWithV8CompileCache = attemptRequireWithV8CompileCache;\n/**\n * Helper to discover dependencies relative to a user's project, optionally\n * falling back to relative to ts-node.  This supports global installations of\n * ts-node, for example where someone does `#!/usr/bin/env -S ts-node --swc` and\n * we need to fallback to a global install of @swc/core\n * @internal\n */\n\nfunction createProjectLocalResolveHelper(localDirectory) {\n  return function projectLocalResolveHelper(specifier, fallbackToTsNodeRelative) {\n    return require.resolve(specifier, {\n      paths: fallbackToTsNodeRelative ? [localDirectory, __dirname] : [localDirectory]\n    });\n  };\n}\n\nexports.createProjectLocalResolveHelper = createProjectLocalResolveHelper;\n/**\n * Used as a reminder of all the factors we must consider when finding project-local dependencies and when a config file\n * on disk may or may not exist.\n * @internal\n */\n\nfunction getBasePathForProjectLocalDependencyResolution(configFilePath, projectSearchDirOption, projectOption, cwdOption) {\n  var _a;\n\n  if (configFilePath != null) return (0, path_1.dirname)(configFilePath);\n  return (_a = projectSearchDirOption !== null && projectSearchDirOption !== void 0 ? projectSearchDirOption : projectOption) !== null && _a !== void 0 ? _a : cwdOption; // TODO technically breaks if projectOption is path to a file, not a directory,\n  // and we attempt to resolve relative specifiers.  By the time we resolve relative specifiers,\n  // should have configFilePath, so not reach this codepath.\n}\n\nexports.getBasePathForProjectLocalDependencyResolution = getBasePathForProjectLocalDependencyResolution;\n/** @internal */\n\nfunction once(fn) {\n  let value;\n  let ran = false;\n\n  function onceFn() {\n    if (ran) return value;\n    value = fn(...arguments);\n    ran = true;\n    return value;\n  }\n\n  return onceFn;\n}\n\nexports.once = once;\n/** @internal */\n\nfunction versionGteLt(version, gteRequirement, ltRequirement) {\n  const [major, minor, patch, extra] = parse(version);\n  const [gteMajor, gteMinor, gtePatch] = parse(gteRequirement);\n  const isGte = major > gteMajor || major === gteMajor && (minor > gteMinor || minor === gteMinor && patch >= gtePatch);\n  let isLt = true;\n\n  if (ltRequirement) {\n    const [ltMajor, ltMinor, ltPatch] = parse(ltRequirement);\n    isLt = major < ltMajor || major === ltMajor && (minor < ltMinor || minor === ltMinor && patch < ltPatch);\n  }\n\n  return isGte && isLt;\n\n  function parse(requirement) {\n    return requirement.split(/[\\.-]/).map(s => parseInt(s, 10));\n  }\n}\n\nexports.versionGteLt = versionGteLt;","map":{"version":3,"mappings":"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","names":["exports","module_1","_a","require","yn","value","undefined","assign","initialValue","sources","source","key","Object","keys","split","filter","v","parse","JSON","directorySeparator","backslashRegExp","normalizeSlashes","replace","hasOwnProperty","object","property","prototype","call","cachedLookup","fn","cache","Map","arg","has","set","get","attemptRequireWithV8CompileCache","requireFn","specifier","v8CC","install","uninstall","e","createProjectLocalResolveHelper","localDirectory","projectLocalResolveHelper","fallbackToTsNodeRelative","resolve","paths","__dirname","getBasePathForProjectLocalDependencyResolution","configFilePath","projectSearchDirOption","projectOption","cwdOption","once","ran","onceFn","versionGteLt","version","gteRequirement","ltRequirement","major","minor","patch","extra","gteMajor","gteMinor","gtePatch","isGte","isLt","ltMajor","ltMinor","ltPatch","requirement","map","s","parseInt"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\ts-node\\src\\util.ts"],"sourcesContent":["import {\n  createRequire as nodeCreateRequire,\n  createRequireFromPath as nodeCreateRequireFromPath,\n} from 'module';\nimport type _createRequire from 'create-require';\nimport * as ynModule from 'yn';\nimport { dirname } from 'path';\n\n/** @internal */\nexport const createRequire =\n  nodeCreateRequire ??\n  nodeCreateRequireFromPath ??\n  (require('create-require') as typeof _createRequire);\n\n/**\n * Wrapper around yn module that returns `undefined` instead of `null`.\n * This is implemented by yn v4, but we're staying on v3 to avoid v4's node 10 requirement.\n * @internal\n */\nexport function yn(value: string | undefined) {\n  return ynModule(value) ?? undefined;\n}\n\n/**\n * Like `Object.assign`, but ignores `undefined` properties.\n *\n * @internal\n */\nexport function assign<T extends object>(\n  initialValue: T,\n  ...sources: Array<T>\n): T {\n  for (const source of sources) {\n    for (const key of Object.keys(source)) {\n      const value = (source as any)[key];\n      if (value !== undefined) (initialValue as any)[key] = value;\n    }\n  }\n  return initialValue;\n}\n\n/**\n * Split a string array of values\n * and remove empty strings from the resulting array.\n * @internal\n */\nexport function split(value: string | undefined) {\n  return typeof value === 'string'\n    ? value.split(/ *, */g).filter((v) => v !== '')\n    : undefined;\n}\n\n/**\n * Parse a string as JSON.\n * @internal\n */\nexport function parse(value: string | undefined): object | undefined {\n  return typeof value === 'string' ? JSON.parse(value) : undefined;\n}\n\nconst directorySeparator = '/';\nconst backslashRegExp = /\\\\/g;\n/**\n * Replace backslashes with forward slashes.\n * @internal\n */\nexport function normalizeSlashes(value: string): string {\n  return value.replace(backslashRegExp, directorySeparator);\n}\n\n/**\n * Safe `hasOwnProperty`\n * @internal\n */\nexport function hasOwnProperty(object: any, property: string): boolean {\n  return Object.prototype.hasOwnProperty.call(object, property);\n}\n\n/**\n * Cached fs operation wrapper.\n */\nexport function cachedLookup<T, R>(fn: (arg: T) => R): (arg: T) => R {\n  const cache = new Map<T, R>();\n\n  return (arg: T): R => {\n    if (!cache.has(arg)) {\n      const v = fn(arg);\n      cache.set(arg, v);\n      return v;\n    }\n    return cache.get(arg)!;\n  };\n}\n\n/**\n * @internal\n * Require something with v8-compile-cache, which should make subsequent requires faster.\n * Do lots of error-handling so that, worst case, we require without the cache, and users are not blocked.\n */\nexport function attemptRequireWithV8CompileCache(\n  requireFn: typeof require,\n  specifier: string\n) {\n  try {\n    const v8CC = (\n      require('v8-compile-cache-lib') as typeof import('v8-compile-cache-lib')\n    ).install();\n    try {\n      return requireFn(specifier);\n    } finally {\n      v8CC?.uninstall();\n    }\n  } catch (e) {\n    return requireFn(specifier);\n  }\n}\n\n/**\n * Helper to discover dependencies relative to a user's project, optionally\n * falling back to relative to ts-node.  This supports global installations of\n * ts-node, for example where someone does `#!/usr/bin/env -S ts-node --swc` and\n * we need to fallback to a global install of @swc/core\n * @internal\n */\nexport function createProjectLocalResolveHelper(localDirectory: string) {\n  return function projectLocalResolveHelper(\n    specifier: string,\n    fallbackToTsNodeRelative: boolean\n  ) {\n    return require.resolve(specifier, {\n      paths: fallbackToTsNodeRelative\n        ? [localDirectory, __dirname]\n        : [localDirectory],\n    });\n  };\n}\n/** @internal */\nexport type ProjectLocalResolveHelper = ReturnType<\n  typeof createProjectLocalResolveHelper\n>;\n\n/**\n * Used as a reminder of all the factors we must consider when finding project-local dependencies and when a config file\n * on disk may or may not exist.\n * @internal\n */\nexport function getBasePathForProjectLocalDependencyResolution(\n  configFilePath: string | undefined,\n  projectSearchDirOption: string | undefined,\n  projectOption: string | undefined,\n  cwdOption: string\n) {\n  if (configFilePath != null) return dirname(configFilePath);\n  return projectSearchDirOption ?? projectOption ?? cwdOption;\n  // TODO technically breaks if projectOption is path to a file, not a directory,\n  // and we attempt to resolve relative specifiers.  By the time we resolve relative specifiers,\n  // should have configFilePath, so not reach this codepath.\n}\n\n/** @internal */\nexport function once<Fn extends (...args: any[]) => any>(fn: Fn) {\n  let value: ReturnType<Fn>;\n  let ran = false;\n  function onceFn(...args: Parameters<Fn>): ReturnType<Fn> {\n    if (ran) return value;\n    value = fn(...args);\n    ran = true;\n    return value;\n  }\n  return onceFn;\n}\n\n/** @internal */\nexport function versionGteLt(\n  version: string,\n  gteRequirement: string,\n  ltRequirement?: string\n) {\n  const [major, minor, patch, extra] = parse(version);\n  const [gteMajor, gteMinor, gtePatch] = parse(gteRequirement);\n  const isGte =\n    major > gteMajor ||\n    (major === gteMajor &&\n      (minor > gteMinor || (minor === gteMinor && patch >= gtePatch)));\n  let isLt = true;\n  if (ltRequirement) {\n    const [ltMajor, ltMinor, ltPatch] = parse(ltRequirement);\n    isLt =\n      major < ltMajor ||\n      (major === ltMajor &&\n        (minor < ltMinor || (minor === ltMinor && patch < ltPatch)));\n  }\n  return isGte && isLt;\n\n  function parse(requirement: string) {\n    return requirement.split(/[\\.-]/).map((s) => parseInt(s, 10));\n  }\n}\n"]},"metadata":{},"sourceType":"script"}