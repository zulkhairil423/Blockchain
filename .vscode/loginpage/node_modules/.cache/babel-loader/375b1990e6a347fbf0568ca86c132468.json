{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst os_1 = __importDefault(require(\"os\"));\n\nconst chalk_1 = __importDefault(require(\"chalk\"));\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nconst semver_1 = __importDefault(require(\"semver\"));\n\nconst aggregate_error_1 = __importDefault(require(\"aggregate-error\"));\n\nconst artifacts_1 = require(\"../internal/artifacts\");\n\nconst config_env_1 = require(\"../internal/core/config/config-env\");\n\nconst errors_1 = require(\"../internal/core/errors\");\n\nconst errors_list_1 = require(\"../internal/core/errors-list\");\n\nconst compilation_job_1 = require(\"../internal/solidity/compilation-job\");\n\nconst compiler_1 = require(\"../internal/solidity/compiler\");\n\nconst compiler_input_1 = require(\"../internal/solidity/compiler/compiler-input\");\n\nconst downloader_1 = require(\"../internal/solidity/compiler/downloader\");\n\nconst dependencyGraph_1 = require(\"../internal/solidity/dependencyGraph\");\n\nconst parse_1 = require(\"../internal/solidity/parse\");\n\nconst resolver_1 = require(\"../internal/solidity/resolver\");\n\nconst global_dir_1 = require(\"../internal/util/global-dir\");\n\nconst strings_1 = require(\"../internal/util/strings\");\n\nconst builtin_tasks_1 = require(\"../types/builtin-tasks\");\n\nconst contract_names_1 = require(\"../utils/contract-names\");\n\nconst source_names_1 = require(\"../utils/source-names\");\n\nconst fs_utils_1 = require(\"../internal/util/fs-utils\");\n\nconst task_names_1 = require(\"./task-names\");\n\nconst solidity_files_cache_1 = require(\"./utils/solidity-files-cache\");\n\nfunction isConsoleLogError(error) {\n  return error.type === \"TypeError\" && typeof error.message === \"string\" && error.message.includes(\"log\") && error.message.includes(\"type(library console)\");\n}\n\nconst log = (0, debug_1.default)(\"hardhat:core:tasks:compile\");\nconst COMPILE_TASK_FIRST_SOLC_VERSION_SUPPORTED = \"0.4.11\";\nconst DEFAULT_CONCURRENCY_LEVEL = Math.max(os_1.default.cpus().length - 1, 1);\n/**\n * Returns a list of absolute paths to all the solidity files in the project.\n * This list doesn't include dependencies, for example solidity files inside\n * node_modules.\n *\n * This is the right task to override to change how the solidity files of the\n * project are obtained.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS, async (_, _ref) => {\n  let {\n    config\n  } = _ref;\n  const paths = await (0, fs_utils_1.getAllFilesMatching)(config.paths.sources, f => f.endsWith(\".sol\"));\n  return paths;\n});\n/**\n * Receives a list of absolute paths and returns a list of source names\n * corresponding to each path. For example, receives\n * [\"/home/user/project/contracts/Foo.sol\"] and returns\n * [\"contracts/Foo.sol\"]. These source names will be used when the solc input\n * is generated.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES).addParam(\"sourcePaths\", undefined, undefined, config_env_1.types.any).setAction(async (_ref2, _ref3) => {\n  let {\n    sourcePaths\n  } = _ref2;\n  let {\n    config\n  } = _ref3;\n  const sourceNames = await Promise.all(sourcePaths.map(p => (0, source_names_1.localPathToSourceName)(config.paths.root, p)));\n  return sourceNames;\n});\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_READ_FILE).addParam(\"absolutePath\", undefined, undefined, config_env_1.types.string).setAction(async _ref4 => {\n  let {\n    absolutePath\n  } = _ref4;\n  const content = await fs_extra_1.default.readFile(absolutePath, {\n    encoding: \"utf8\"\n  });\n  return content;\n});\n/**\n * Receives a list of source names and returns a dependency graph. This task\n * is responsible for both resolving dependencies (like getting files from\n * node_modules) and generating the graph.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH).addParam(\"sourceNames\", undefined, undefined, config_env_1.types.any).addOptionalParam(\"solidityFilesCache\", undefined, undefined, config_env_1.types.any).setAction(async (_ref5, _ref6) => {\n  let {\n    sourceNames,\n    solidityFilesCache\n  } = _ref5;\n  let {\n    config,\n    run\n  } = _ref6;\n  const parser = new parse_1.Parser(solidityFilesCache);\n  const resolver = new resolver_1.Resolver(config.paths.root, parser, absolutePath => run(task_names_1.TASK_COMPILE_SOLIDITY_READ_FILE, {\n    absolutePath\n  }));\n  const resolvedFiles = await Promise.all(sourceNames.map(sn => resolver.resolveSourceName(sn)));\n  const dependencyGraph = await dependencyGraph_1.DependencyGraph.createFromResolvedFiles(resolver, resolvedFiles);\n  return dependencyGraph;\n});\n/**\n * Receives a dependency graph and a file in it, and returns the compilation\n * job for that file. The compilation job should have everything that is\n * necessary to compile that file: a compiler config to be used and a list of\n * files to use as input of the compilation.\n *\n * If the file cannot be compiled, a MatchingCompilerFailure should be\n * returned instead.\n *\n * This is the right task to override to change the compiler configuration.\n * For example, if you want to change the compiler settings when targetting\n * rinkeby, you could do something like this:\n *\n *   const compilationJob = await runSuper();\n *   if (config.network.name === 'rinkeby') {\n *     compilationJob.solidityConfig.settings = newSettings;\n *   }\n *   return compilationJob;\n *\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE).addParam(\"dependencyGraph\", undefined, undefined, config_env_1.types.any).addParam(\"file\", undefined, undefined, config_env_1.types.any).addOptionalParam(\"solidityFilesCache\", undefined, undefined, config_env_1.types.any).setAction(async (_ref7, _ref8) => {\n  let {\n    dependencyGraph,\n    file\n  } = _ref7;\n  let {\n    config\n  } = _ref8;\n  return (0, compilation_job_1.createCompilationJobFromFile)(dependencyGraph, file, config.solidity);\n});\n/**\n * Receives a dependency graph and returns a tuple with two arrays. The first\n * array is a list of CompilationJobsSuccess, where each item has a list of\n * compilation jobs. The second array is a list of CompilationJobsFailure,\n * where each item has a list of files that couldn't be compiled, grouped by\n * the reason for the failure.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS).addParam(\"dependencyGraph\", undefined, undefined, config_env_1.types.any).addOptionalParam(\"solidityFilesCache\", undefined, undefined, config_env_1.types.any).setAction(async (_ref9, _ref10) => {\n  let {\n    dependencyGraph,\n    solidityFilesCache\n  } = _ref9;\n  let {\n    run\n  } = _ref10;\n  const connectedComponents = dependencyGraph.getConnectedComponents();\n  log(`The dependency graph was divided in '${connectedComponents.length}' connected components`);\n  const compilationJobsCreationResults = await Promise.all(connectedComponents.map(graph => (0, compilation_job_1.createCompilationJobsFromConnectedComponent)(graph, file => run(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE, {\n    file,\n    dependencyGraph,\n    solidityFilesCache\n  }))));\n  let jobs = [];\n  let errors = [];\n\n  for (const result of compilationJobsCreationResults) {\n    jobs = jobs.concat(result.jobs);\n    errors = errors.concat(result.errors);\n  }\n\n  return {\n    jobs,\n    errors\n  };\n});\n/**\n * Receives a list of compilation jobs and returns a new list where some of\n * the compilation jobs might've been removed.\n *\n * This task can be overriden to change the way the cache is used, or to use\n * a different approach to filtering out compilation jobs.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_FILTER_COMPILATION_JOBS).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).addParam(\"force\", undefined, undefined, config_env_1.types.boolean).addOptionalParam(\"solidityFilesCache\", undefined, undefined, config_env_1.types.any).setAction(async _ref11 => {\n  let {\n    compilationJobs,\n    force,\n    solidityFilesCache\n  } = _ref11;\n  (0, errors_1.assertHardhatInvariant)(solidityFilesCache !== undefined, \"The implementation of this task needs a defined solidityFilesCache\");\n\n  if (force) {\n    log(`force flag enabled, not filtering`);\n    return compilationJobs;\n  }\n\n  const neededCompilationJobs = compilationJobs.filter(job => needsCompilation(job, solidityFilesCache));\n  const jobsFilteredOutCount = compilationJobs.length - neededCompilationJobs.length;\n  log(`'${jobsFilteredOutCount}' jobs were filtered out`);\n  return neededCompilationJobs;\n});\n/**\n * Receives a list of compilation jobs and returns a new list where some of\n * the jobs might've been merged.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_MERGE_COMPILATION_JOBS).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).setAction(async _ref12 => {\n  let {\n    compilationJobs\n  } = _ref12;\n  return (0, compilation_job_1.mergeCompilationJobsWithoutBug)(compilationJobs);\n});\n/**\n * Prints a message when there's nothing to compile.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_LOG_NOTHING_TO_COMPILE).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async _ref13 => {\n  let {\n    quiet\n  } = _ref13;\n\n  if (!quiet) {\n    console.log(\"Nothing to compile\");\n  }\n});\n/**\n * Receives a list of compilation jobs and sends each one to be compiled.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_JOBS).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).addParam(\"concurrency\", undefined, DEFAULT_CONCURRENCY_LEVEL, config_env_1.types.int).setAction(async (_ref14, _ref15) => {\n  let {\n    compilationJobs,\n    quiet,\n    concurrency\n  } = _ref14;\n  let {\n    run\n  } = _ref15;\n\n  if (compilationJobs.length === 0) {\n    log(`No compilation jobs to compile`);\n    await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_NOTHING_TO_COMPILE, {\n      quiet\n    });\n    return {\n      artifactsEmittedPerJob: []\n    };\n  }\n\n  log(`Compiling ${compilationJobs.length} jobs`);\n  const versionList = [];\n\n  for (const job of compilationJobs) {\n    const solcVersion = job.getSolcConfig().version;\n\n    if (!versionList.includes(solcVersion)) {\n      // versions older than 0.4.11 don't work with hardhat\n      // see issue https://github.com/nomiclabs/hardhat/issues/2004\n      if (semver_1.default.lt(solcVersion, COMPILE_TASK_FIRST_SOLC_VERSION_SUPPORTED)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.COMPILE_TASK_UNSUPPORTED_SOLC_VERSION, {\n          version: solcVersion,\n          firstSupportedVersion: COMPILE_TASK_FIRST_SOLC_VERSION_SUPPORTED\n        });\n      }\n\n      versionList.push(solcVersion);\n    }\n  }\n\n  const {\n    default: pMap\n  } = await Promise.resolve().then(() => __importStar(require(\"p-map\")));\n  const pMapOptions = {\n    concurrency,\n    stopOnError: false\n  };\n\n  try {\n    const artifactsEmittedPerJob = await pMap(compilationJobs, async (compilationJob, compilationJobIndex) => {\n      const result = await run(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_JOB, {\n        compilationJob,\n        compilationJobs,\n        compilationJobIndex,\n        quiet\n      });\n      return {\n        compilationJob: result.compilationJob,\n        artifactsEmittedPerFile: result.artifactsEmittedPerFile\n      };\n    }, pMapOptions);\n    return {\n      artifactsEmittedPerJob\n    };\n  } catch (e) {\n    if (!(e instanceof aggregate_error_1.default)) {\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    }\n\n    for (const error of e) {\n      if (!errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.BUILTIN_TASKS.COMPILE_FAILURE)) {\n        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n        throw error;\n      }\n    } // error is an aggregate error, and all errors are compilation failures\n\n\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.COMPILE_FAILURE);\n  }\n});\n/**\n * Receives a compilation job and returns a CompilerInput.\n *\n * It's not recommended to override this task to modify the solc\n * configuration, override\n * TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE instead.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILER_INPUT).addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any).setAction(async _ref16 => {\n  let {\n    compilationJob\n  } = _ref16;\n  return (0, compiler_input_1.getInputFromCompilationJob)(compilationJob);\n});\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_START).addParam(\"isCompilerDownloaded\", undefined, undefined, config_env_1.types.boolean).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).addParam(\"solcVersion\", undefined, undefined, config_env_1.types.string).setAction(async _ref17 => {\n  let {\n    isCompilerDownloaded,\n    solcVersion\n  } = _ref17;\n\n  if (isCompilerDownloaded) {\n    return;\n  }\n\n  console.log(`Downloading compiler ${solcVersion}`);\n});\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_END).addParam(\"isCompilerDownloaded\", undefined, undefined, config_env_1.types.boolean).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).addParam(\"solcVersion\", undefined, undefined, config_env_1.types.string).setAction(async _ref18 => {\n  let {} = _ref18;\n});\n/**\n * Receives a solc version and returns a path to a solc binary or to a\n * downloaded solcjs module. It also returns a flag indicating if the returned\n * path corresponds to solc or solcjs.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOLC_BUILD).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).addParam(\"solcVersion\", undefined, undefined, config_env_1.types.string).setAction(async (_ref19, _ref20) => {\n  let {\n    quiet,\n    solcVersion\n  } = _ref19;\n  let {\n    run\n  } = _ref20;\n  const compilersCache = await (0, global_dir_1.getCompilersDir)();\n  const compilerPlatform = downloader_1.CompilerDownloader.getCompilerPlatform();\n  const downloader = downloader_1.CompilerDownloader.getConcurrencySafeDownloader(compilerPlatform, compilersCache);\n  const isCompilerDownloaded = await downloader.isCompilerDownloaded(solcVersion);\n\n  if (!isCompilerDownloaded) {\n    await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_START, {\n      solcVersion,\n      isCompilerDownloaded,\n      quiet\n    });\n    await downloader.downloadCompiler(solcVersion);\n    await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_END, {\n      solcVersion,\n      isCompilerDownloaded,\n      quiet\n    });\n  }\n\n  const compiler = await downloader.getCompiler(solcVersion);\n\n  if (compiler !== undefined) {\n    return compiler;\n  }\n\n  log(\"Native solc binary doesn't work, using solcjs instead. Try running npx hardhat clean --global\");\n  const wasmDownloader = downloader_1.CompilerDownloader.getConcurrencySafeDownloader(downloader_1.CompilerPlatform.WASM, compilersCache);\n  const isWasmCompilerDownloader = await wasmDownloader.isCompilerDownloaded(solcVersion);\n\n  if (!isWasmCompilerDownloader) {\n    await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_START, {\n      solcVersion,\n      isCompilerDownloaded,\n      quiet\n    });\n    await wasmDownloader.downloadCompiler(solcVersion);\n    await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_END, {\n      solcVersion,\n      isCompilerDownloaded,\n      quiet\n    });\n  }\n\n  const wasmCompiler = await wasmDownloader.getCompiler(solcVersion);\n  (0, errors_1.assertHardhatInvariant)(wasmCompiler !== undefined, `WASM build of solc ${solcVersion} isn't working`);\n  return wasmCompiler;\n});\n/**\n * Receives an absolute path to a solcjs module and the input to be compiled,\n * and returns the generated output\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_RUN_SOLCJS).addParam(\"input\", undefined, undefined, config_env_1.types.any).addParam(\"solcJsPath\", undefined, undefined, config_env_1.types.string).setAction(async _ref21 => {\n  let {\n    input,\n    solcJsPath\n  } = _ref21;\n  const compiler = new compiler_1.Compiler(solcJsPath);\n  const output = await compiler.compile(input);\n  return output;\n});\n/**\n * Receives an absolute path to a solc binary and the input to be compiled,\n * and returns the generated output\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_RUN_SOLC).addParam(\"input\", undefined, undefined, config_env_1.types.any).addParam(\"solcPath\", undefined, undefined, config_env_1.types.string).setAction(async _ref22 => {\n  let {\n    input,\n    solcPath\n  } = _ref22;\n  const compiler = new compiler_1.NativeCompiler(solcPath);\n  const output = await compiler.compile(input);\n  return output;\n});\n/**\n * Receives a CompilerInput and a solc version, compiles the input using a native\n * solc binary or, if that's not possible, using solcjs. Returns the generated\n * output.\n *\n * This task can be overriden to change how solc is obtained or used.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_SOLC).addParam(\"input\", undefined, undefined, config_env_1.types.any).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).addParam(\"solcVersion\", undefined, undefined, config_env_1.types.string).addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobIndex\", undefined, undefined, config_env_1.types.int).setAction(async (_ref23, _ref24) => {\n  let {\n    input,\n    quiet,\n    solcVersion,\n    compilationJob,\n    compilationJobs,\n    compilationJobIndex\n  } = _ref23;\n  let {\n    run\n  } = _ref24;\n  const solcBuild = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOLC_BUILD, {\n    quiet,\n    solcVersion\n  });\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_START, {\n    compilationJob,\n    compilationJobs,\n    compilationJobIndex,\n    quiet\n  });\n  let output;\n\n  if (solcBuild.isSolcJs) {\n    output = await run(task_names_1.TASK_COMPILE_SOLIDITY_RUN_SOLCJS, {\n      input,\n      solcJsPath: solcBuild.compilerPath\n    });\n  } else {\n    output = await run(task_names_1.TASK_COMPILE_SOLIDITY_RUN_SOLC, {\n      input,\n      solcPath: solcBuild.compilerPath\n    });\n  }\n\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_END, {\n    compilationJob,\n    compilationJobs,\n    compilationJobIndex,\n    output,\n    quiet\n  });\n  return {\n    output,\n    solcBuild\n  };\n});\n/**\n * This task is just a proxy to the task that compiles with solc.\n *\n * Override this to use a different task to compile a job.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE, async (taskArgs, _ref25) => {\n  let {\n    run\n  } = _ref25;\n  return run(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_SOLC, taskArgs);\n});\n/**\n * Receives a compilation output and prints its errors and any other\n * information useful to the user.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_LOG_COMPILATION_ERRORS).addParam(\"output\", undefined, undefined, config_env_1.types.any).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async _ref26 => {\n  let {\n    output\n  } = _ref26;\n\n  if (output?.errors === undefined) {\n    return;\n  }\n\n  for (const error of output.errors) {\n    if (error.severity === \"error\") {\n      const errorMessage = getFormattedInternalCompilerErrorMessage(error) ?? error.formattedMessage;\n      console.error(chalk_1.default.red(errorMessage));\n    } else {\n      console.warn(chalk_1.default.yellow(error.formattedMessage));\n    }\n  }\n\n  const hasConsoleErrors = output.errors.some(isConsoleLogError);\n\n  if (hasConsoleErrors) {\n    console.error(chalk_1.default.red(`The console.log call you made isn’t supported. See https://hardhat.org/console-log for the list of supported methods.`));\n    console.log();\n  }\n});\n/**\n * Receives a solc output and checks if there are errors. Throws if there are\n * errors.\n *\n * Override this task to avoid interrupting the compilation process if some\n * job has compilation errors.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_CHECK_ERRORS).addParam(\"output\", undefined, undefined, config_env_1.types.any).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async (_ref27, _ref28) => {\n  let {\n    output,\n    quiet\n  } = _ref27;\n  let {\n    run\n  } = _ref28;\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_COMPILATION_ERRORS, {\n    output,\n    quiet\n  });\n\n  if (hasCompilationErrors(output)) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.COMPILE_FAILURE);\n  }\n});\n/**\n * Saves to disk the artifacts for a compilation job. These artifacts\n * include the main artifacts, the debug files, and the build info.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_EMIT_ARTIFACTS).addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any).addParam(\"input\", undefined, undefined, config_env_1.types.any).addParam(\"output\", undefined, undefined, config_env_1.types.any).addParam(\"solcBuild\", undefined, undefined, config_env_1.types.any).setAction(async (_ref29, _ref30) => {\n  let {\n    compilationJob,\n    input,\n    output,\n    solcBuild\n  } = _ref29;\n  let {\n    artifacts,\n    run\n  } = _ref30;\n  const pathToBuildInfo = await artifacts.saveBuildInfo(compilationJob.getSolcConfig().version, solcBuild.longVersion, input, output);\n  const artifactsEmittedPerFile = await Promise.all(compilationJob.getResolvedFiles().filter(f => compilationJob.emitsArtifacts(f)).map(async file => {\n    const artifactsEmitted = await Promise.all(Object.entries(output.contracts?.[file.sourceName] ?? {}).map(async _ref31 => {\n      let [contractName, contractOutput] = _ref31;\n      log(`Emitting artifact for contract '${contractName}'`);\n      const artifact = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_ARTIFACT_FROM_COMPILATION_OUTPUT, {\n        sourceName: file.sourceName,\n        contractName,\n        contractOutput\n      });\n      await artifacts.saveArtifactAndDebugFile(artifact, pathToBuildInfo);\n      return artifact.contractName;\n    }));\n    return {\n      file,\n      artifactsEmitted\n    };\n  }));\n  return {\n    artifactsEmittedPerFile\n  };\n});\n/**\n * Generates the artifact for contract `contractName` given its compilation\n * output.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_ARTIFACT_FROM_COMPILATION_OUTPUT).addParam(\"sourceName\", undefined, undefined, config_env_1.types.string).addParam(\"contractName\", undefined, undefined, config_env_1.types.string).addParam(\"contractOutput\", undefined, undefined, config_env_1.types.any).setAction(async _ref32 => {\n  let {\n    sourceName,\n    contractName,\n    contractOutput\n  } = _ref32;\n  return (0, artifacts_1.getArtifactFromContractOutput)(sourceName, contractName, contractOutput);\n});\n/**\n * Prints a message before running soljs with some input.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_START).addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobIndex\", undefined, undefined, config_env_1.types.int).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async _ref33 => {\n  let {} = _ref33;\n});\n/**\n * Prints a message after compiling some input\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_END).addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobIndex\", undefined, undefined, config_env_1.types.int).addParam(\"output\", undefined, undefined, config_env_1.types.any).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async _ref34 => {\n  let {} = _ref34;\n});\n/**\n * This is an orchestrator task that uses other subtasks to compile a\n * compilation job.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_JOB).addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobIndex\", undefined, undefined, config_env_1.types.int).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).addOptionalParam(\"emitsArtifacts\", undefined, true, config_env_1.types.boolean).setAction(async (_ref35, _ref36) => {\n  let {\n    compilationJob,\n    compilationJobs,\n    compilationJobIndex,\n    quiet,\n    emitsArtifacts\n  } = _ref35;\n  let {\n    run\n  } = _ref36;\n  log(`Compiling job with version '${compilationJob.getSolcConfig().version}'`);\n  const input = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILER_INPUT, {\n    compilationJob\n  });\n  const {\n    output,\n    solcBuild\n  } = await run(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE, {\n    solcVersion: compilationJob.getSolcConfig().version,\n    input,\n    quiet,\n    compilationJob,\n    compilationJobs,\n    compilationJobIndex\n  });\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_CHECK_ERRORS, {\n    output,\n    quiet\n  });\n  let artifactsEmittedPerFile = [];\n\n  if (emitsArtifacts) {\n    artifactsEmittedPerFile = (await run(task_names_1.TASK_COMPILE_SOLIDITY_EMIT_ARTIFACTS, {\n      compilationJob,\n      input,\n      output,\n      solcBuild\n    })).artifactsEmittedPerFile;\n  }\n\n  return {\n    artifactsEmittedPerFile,\n    compilationJob,\n    input,\n    output,\n    solcBuild\n  };\n});\n/**\n * Receives a list of CompilationJobsFailure and throws an error if it's not\n * empty.\n *\n * This task could be overriden to avoid interrupting the compilation if\n * there's some part of the project that can't be compiled.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_HANDLE_COMPILATION_JOBS_FAILURES).addParam(\"compilationJobsCreationErrors\", undefined, undefined, config_env_1.types.any).setAction(async (_ref37, _ref38) => {\n  let {\n    compilationJobsCreationErrors\n  } = _ref37;\n  let {\n    run\n  } = _ref38;\n  const hasErrors = compilationJobsCreationErrors.length > 0;\n\n  if (hasErrors) {\n    log(`There were errors creating the compilation jobs, throwing`);\n    const reasons = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS_FAILURE_REASONS, {\n      compilationJobsCreationErrors\n    });\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.COMPILATION_JOBS_CREATION_FAILURE, {\n      reasons\n    });\n  }\n});\n/**\n * Receives a list of CompilationJobsFailure and returns an error message\n * that describes the failure.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS_FAILURE_REASONS).addParam(\"compilationJobsCreationErrors\", undefined, undefined, config_env_1.types.any).setAction(async _ref39 => {\n  let {\n    compilationJobsCreationErrors: errors\n  } = _ref39;\n  const noCompatibleSolc = [];\n  const incompatibleOverridenSolc = [];\n  const directlyImportsIncompatibleFile = [];\n  const indirectlyImportsIncompatibleFile = [];\n  const other = [];\n\n  for (const error of errors) {\n    if (error.reason === builtin_tasks_1.CompilationJobCreationErrorReason.NO_COMPATIBLE_SOLC_VERSION_FOUND) {\n      noCompatibleSolc.push(error);\n    } else if (error.reason === builtin_tasks_1.CompilationJobCreationErrorReason.INCOMPATIBLE_OVERRIDEN_SOLC_VERSION) {\n      incompatibleOverridenSolc.push(error);\n    } else if (error.reason === builtin_tasks_1.CompilationJobCreationErrorReason.DIRECTLY_IMPORTS_INCOMPATIBLE_FILE) {\n      directlyImportsIncompatibleFile.push(error);\n    } else if (error.reason === builtin_tasks_1.CompilationJobCreationErrorReason.INDIRECTLY_IMPORTS_INCOMPATIBLE_FILE) {\n      indirectlyImportsIncompatibleFile.push(error);\n    } else if (error.reason === builtin_tasks_1.CompilationJobCreationErrorReason.OTHER_ERROR) {\n      other.push(error);\n    } else {\n      // add unrecognized errors to `other`\n      other.push(error);\n    }\n  }\n\n  let errorMessage = \"\";\n\n  if (incompatibleOverridenSolc.length > 0) {\n    errorMessage += `The compiler version for the following files is fixed through an override in your config file to a version that is incompatible with their Solidity version pragmas.\n\n`;\n\n    for (const error of incompatibleOverridenSolc) {\n      const {\n        sourceName\n      } = error.file;\n      const {\n        versionPragmas\n      } = error.file.content;\n      const versionsRange = versionPragmas.join(\" \");\n      log(`File ${sourceName} has an incompatible overriden compiler`);\n      errorMessage += `  * ${sourceName} (${versionsRange})\\n`;\n    }\n\n    errorMessage += \"\\n\";\n  }\n\n  if (noCompatibleSolc.length > 0) {\n    errorMessage += `The Solidity version pragma statement in these files doesn't match any of the configured compilers in your config. Change the pragma or configure additional compiler versions in your hardhat config.\n\n`;\n\n    for (const error of noCompatibleSolc) {\n      const {\n        sourceName\n      } = error.file;\n      const {\n        versionPragmas\n      } = error.file.content;\n      const versionsRange = versionPragmas.join(\" \");\n      log(`File ${sourceName} doesn't match any of the configured compilers`);\n      errorMessage += `  * ${sourceName} (${versionsRange})\\n`;\n    }\n\n    errorMessage += \"\\n\";\n  }\n\n  if (directlyImportsIncompatibleFile.length > 0) {\n    errorMessage += `These files import other files that use a different and incompatible version of Solidity:\n\n`;\n\n    for (const error of directlyImportsIncompatibleFile) {\n      const {\n        sourceName\n      } = error.file;\n      const {\n        versionPragmas\n      } = error.file.content;\n      const versionsRange = versionPragmas.join(\" \");\n      const incompatibleDirectImportsFiles = error.extra?.incompatibleDirectImports ?? [];\n      const incompatibleDirectImports = incompatibleDirectImportsFiles.map(x => `${x.sourceName} (${x.content.versionPragmas.join(\" \")})`);\n      log(`File ${sourceName} imports files ${incompatibleDirectImportsFiles.map(x => x.sourceName).join(\", \")} that use an incompatible version of Solidity`);\n      let directImportsText = \"\";\n\n      if (incompatibleDirectImports.length === 1) {\n        directImportsText = ` imports ${incompatibleDirectImports[0]}`;\n      } else if (incompatibleDirectImports.length === 2) {\n        directImportsText = ` imports ${incompatibleDirectImports[0]} and ${incompatibleDirectImports[1]}`;\n      } else if (incompatibleDirectImports.length > 2) {\n        const otherImportsCount = incompatibleDirectImports.length - 2;\n        directImportsText = ` imports ${incompatibleDirectImports[0]}, ${incompatibleDirectImports[1]} and ${otherImportsCount} other ${(0, strings_1.pluralize)(otherImportsCount, \"file\")}. Use --verbose to see the full list.`;\n      }\n\n      errorMessage += `  * ${sourceName} (${versionsRange})${directImportsText}\\n`;\n    }\n\n    errorMessage += \"\\n\";\n  }\n\n  if (indirectlyImportsIncompatibleFile.length > 0) {\n    errorMessage += `These files depend on other files that use a different and incompatible version of Solidity:\n\n`;\n\n    for (const error of indirectlyImportsIncompatibleFile) {\n      const {\n        sourceName\n      } = error.file;\n      const {\n        versionPragmas\n      } = error.file.content;\n      const versionsRange = versionPragmas.join(\" \");\n      const incompatibleIndirectImports = error.extra?.incompatibleIndirectImports ?? [];\n      const incompatibleImports = incompatibleIndirectImports.map(_ref40 => {\n        let {\n          dependency\n        } = _ref40;\n        return `${dependency.sourceName} (${dependency.content.versionPragmas.join(\" \")})`;\n      });\n\n      for (const {\n        dependency,\n        path: dependencyPath\n      } of incompatibleIndirectImports) {\n        const dependencyPathText = [sourceName, ...dependencyPath.map(x => x.sourceName), dependency.sourceName].join(\" -> \");\n        log(`File ${sourceName} depends on file ${dependency.sourceName} that uses an incompatible version of Solidity\nThe dependency path is ${dependencyPathText}\n`);\n      }\n\n      let indirectImportsText = \"\";\n\n      if (incompatibleImports.length === 1) {\n        indirectImportsText = ` depends on ${incompatibleImports[0]}`;\n      } else if (incompatibleImports.length === 2) {\n        indirectImportsText = ` depends on ${incompatibleImports[0]} and ${incompatibleImports[1]}`;\n      } else if (incompatibleImports.length > 2) {\n        const otherImportsCount = incompatibleImports.length - 2;\n        indirectImportsText = ` depends on ${incompatibleImports[0]}, ${incompatibleImports[1]} and ${otherImportsCount} other ${(0, strings_1.pluralize)(otherImportsCount, \"file\")}. Use --verbose to see the full list.`;\n      }\n\n      errorMessage += `  * ${sourceName} (${versionsRange})${indirectImportsText}\\n`;\n    }\n\n    errorMessage += \"\\n\";\n  }\n\n  if (other.length > 0) {\n    errorMessage += `These files and its dependencies cannot be compiled with your config. This can happen because they have incompatible Solidity pragmas, or don't match any of your configured Solidity compilers.\n\n${other.map(x => `  * ${x.file.sourceName}`).join(\"\\n\")}\n\n`;\n  }\n\n  errorMessage += `To learn more, run the command again with --verbose\n\nRead about compiler configuration at https://hardhat.org/config\n`;\n  return errorMessage;\n});\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_LOG_COMPILATION_RESULT).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async _ref41 => {\n  let {\n    compilationJobs\n  } = _ref41;\n  let count = 0;\n\n  for (const job of compilationJobs) {\n    count += job.getResolvedFiles().filter(file => job.emitsArtifacts(file)).length;\n  }\n\n  if (count > 0) {\n    console.log(`Compiled ${count} Solidity ${(0, strings_1.pluralize)(count, \"file\")} successfully`);\n  }\n});\n/**\n * Main task for compiling the solidity files in the project.\n *\n * The main responsibility of this task is to orchestrate and connect most of\n * the subtasks related to compiling solidity.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY).addParam(\"force\", undefined, undefined, config_env_1.types.boolean).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).addParam(\"concurrency\", undefined, DEFAULT_CONCURRENCY_LEVEL, config_env_1.types.int).setAction(async (_ref42, _ref43) => {\n  let {\n    force,\n    quiet,\n    concurrency\n  } = _ref42;\n  let {\n    artifacts,\n    config,\n    run\n  } = _ref43;\n  const sourcePaths = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS);\n  const sourceNames = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES, {\n    sourcePaths\n  });\n  const solidityFilesCachePath = (0, solidity_files_cache_1.getSolidityFilesCachePath)(config.paths);\n  let solidityFilesCache = await solidity_files_cache_1.SolidityFilesCache.readFromFile(solidityFilesCachePath);\n  const dependencyGraph = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH, {\n    sourceNames,\n    solidityFilesCache\n  });\n  solidityFilesCache = await invalidateCacheMissingArtifacts(solidityFilesCache, artifacts, dependencyGraph.getResolvedFiles());\n  const compilationJobsCreationResult = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS, {\n    dependencyGraph,\n    solidityFilesCache\n  });\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_HANDLE_COMPILATION_JOBS_FAILURES, {\n    compilationJobsCreationErrors: compilationJobsCreationResult.errors\n  });\n  const compilationJobs = compilationJobsCreationResult.jobs;\n  const filteredCompilationJobs = await run(task_names_1.TASK_COMPILE_SOLIDITY_FILTER_COMPILATION_JOBS, {\n    compilationJobs,\n    force,\n    solidityFilesCache\n  });\n  const mergedCompilationJobs = await run(task_names_1.TASK_COMPILE_SOLIDITY_MERGE_COMPILATION_JOBS, {\n    compilationJobs: filteredCompilationJobs\n  });\n  const {\n    artifactsEmittedPerJob\n  } = await run(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_JOBS, {\n    compilationJobs: mergedCompilationJobs,\n    quiet,\n    concurrency\n  }); // update cache using the information about the emitted artifacts\n\n  for (const {\n    compilationJob: compilationJob,\n    artifactsEmittedPerFile: artifactsEmittedPerFile\n  } of artifactsEmittedPerJob) {\n    for (const {\n      file,\n      artifactsEmitted\n    } of artifactsEmittedPerFile) {\n      solidityFilesCache.addFile(file.absolutePath, {\n        lastModificationDate: file.lastModificationDate.valueOf(),\n        contentHash: file.contentHash,\n        sourceName: file.sourceName,\n        solcConfig: compilationJob.getSolcConfig(),\n        imports: file.content.imports,\n        versionPragmas: file.content.versionPragmas,\n        artifacts: artifactsEmitted\n      });\n    }\n  }\n\n  const allArtifactsEmittedPerFile = solidityFilesCache.getEntries(); // We know this is the actual implementation, so we use some\n  // non-public methods here.\n\n  const artifactsImpl = artifacts;\n  artifactsImpl.addValidArtifacts(allArtifactsEmittedPerFile);\n  await solidityFilesCache.writeToFile(solidityFilesCachePath);\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_COMPILATION_RESULT, {\n    compilationJobs: mergedCompilationJobs,\n    quiet\n  });\n});\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_REMOVE_OBSOLETE_ARTIFACTS, async (_, _ref44) => {\n  let {\n    artifacts\n  } = _ref44;\n  // We know this is the actual implementation, so we use some\n  // non-public methods here.\n  const artifactsImpl = artifacts;\n  await artifactsImpl.removeObsoleteArtifacts();\n});\n/**\n * Returns a list of compilation tasks.\n *\n * This is the task to override to add support for other languages.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_GET_COMPILATION_TASKS, async () => {\n  return [task_names_1.TASK_COMPILE_SOLIDITY];\n});\n/**\n * Main compile task.\n *\n * This is a meta-task that just gets all the compilation tasks and runs them.\n * Right now there's only a \"compile solidity\" task.\n */\n\n(0, config_env_1.task)(task_names_1.TASK_COMPILE, \"Compiles the entire project, building all artifacts\").addFlag(\"force\", \"Force compilation ignoring cache\").addFlag(\"quiet\", \"Makes the compilation process less verbose\").addParam(\"concurrency\", \"Number of compilation jobs executed in parallel. Defaults to the number of CPU cores - 1\", DEFAULT_CONCURRENCY_LEVEL, config_env_1.types.int).setAction(async (compilationArgs, _ref45) => {\n  let {\n    run\n  } = _ref45;\n  const compilationTasks = await run(task_names_1.TASK_COMPILE_GET_COMPILATION_TASKS);\n\n  for (const compilationTask of compilationTasks) {\n    await run(compilationTask, compilationArgs);\n  }\n\n  await run(task_names_1.TASK_COMPILE_REMOVE_OBSOLETE_ARTIFACTS);\n});\n/**\n * If a file is present in the cache, but some of its artifacts are missing on\n * disk, we remove it from the cache to force it to be recompiled.\n */\n\nasync function invalidateCacheMissingArtifacts(solidityFilesCache, artifacts, resolvedFiles) {\n  const paths = new Set(await artifacts.getArtifactPaths());\n\n  for (const file of resolvedFiles) {\n    const cacheEntry = solidityFilesCache.getEntry(file.absolutePath);\n\n    if (cacheEntry === undefined) {\n      continue;\n    }\n\n    const {\n      artifacts: emittedArtifacts\n    } = cacheEntry;\n\n    for (const emittedArtifact of emittedArtifacts) {\n      const fqn = (0, contract_names_1.getFullyQualifiedName)(file.sourceName, emittedArtifact);\n      const path = artifacts.formArtifactPathFromFullyQualifiedName(fqn);\n\n      if (!paths.has(path)) {\n        log(`Invalidate cache for '${file.absolutePath}' because artifact '${fqn}' doesn't exist`);\n        solidityFilesCache.removeEntry(file.absolutePath);\n        break;\n      }\n    }\n  }\n\n  artifacts.clearCache?.();\n  return solidityFilesCache;\n}\n/**\n * Checks if the given compilation job needs to be done.\n */\n\n\nfunction needsCompilation(job, cache) {\n  for (const file of job.getResolvedFiles()) {\n    const hasChanged = cache.hasFileChanged(file.absolutePath, file.contentHash, // we only check if the solcConfig is different for files that\n    // emit artifacts\n    job.emitsArtifacts(file) ? job.getSolcConfig() : undefined);\n\n    if (hasChanged) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction hasCompilationErrors(output) {\n  return output.errors && output.errors.some(x => x.severity === \"error\");\n}\n/**\n * This function returns a properly formatted Internal Compiler Error message.\n *\n * This is present due to a bug in Solidity. See: https://github.com/ethereum/solidity/issues/9926\n *\n * If the error is not an ICE, or if it's properly formatted, this function returns undefined.\n */\n\n\nfunction getFormattedInternalCompilerErrorMessage(error) {\n  if (error.formattedMessage.trim() !== \"InternalCompilerError:\") {\n    return;\n  } // We trim any final `:`, as we found some at the end of the error messages,\n  // and then trim just in case a blank space was left\n\n\n  return `${error.type}: ${error.message}`.replace(/[:\\s]*$/g, \"\").trim();\n}","map":{"version":3,"mappings":"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","names":["isConsoleLogError","error","type","message","includes","log","COMPILE_TASK_FIRST_SOLC_VERSION_SUPPORTED","DEFAULT_CONCURRENCY_LEVEL","Math","max","os_1","cpus","length","task_names_1","_","config","paths","sources","f","endsWith","addParam","undefined","config_env_1","any","setAction","sourcePaths","sourceNames","Promise","all","map","p","root","string","absolutePath","content","fs_extra_1","readFile","encoding","addOptionalParam","solidityFilesCache","run","parser","parse_1","resolver","resolver_1","resolvedFiles","sn","resolveSourceName","dependencyGraph","dependencyGraph_1","createFromResolvedFiles","file","solidity","connectedComponents","getConnectedComponents","compilationJobsCreationResults","graph","jobs","errors","result","concat","boolean","compilationJobs","force","neededCompilationJobs","filter","job","needsCompilation","jobsFilteredOutCount","quiet","console","int","concurrency","artifactsEmittedPerJob","versionList","solcVersion","getSolcConfig","version","semver_1","lt","errors_1","errors_list_1","BUILTIN_TASKS","COMPILE_TASK_UNSUPPORTED_SOLC_VERSION","firstSupportedVersion","push","default","pMap","pMapOptions","stopOnError","compilationJob","compilationJobIndex","artifactsEmittedPerFile","e","aggregate_error_1","isHardhatErrorType","COMPILE_FAILURE","isCompilerDownloaded","compilersCache","compilerPlatform","downloader_1","getCompilerPlatform","downloader","getConcurrencySafeDownloader","downloadCompiler","compiler","getCompiler","wasmDownloader","WASM","isWasmCompilerDownloader","wasmCompiler","input","solcJsPath","compiler_1","output","compile","solcPath","solcBuild","isSolcJs","compilerPath","taskArgs","severity","errorMessage","getFormattedInternalCompilerErrorMessage","formattedMessage","chalk_1","red","warn","yellow","hasConsoleErrors","some","hasCompilationErrors","artifacts","pathToBuildInfo","saveBuildInfo","longVersion","getResolvedFiles","emitsArtifacts","artifactsEmitted","Object","entries","contracts","sourceName","contractName","contractOutput","artifact","saveArtifactAndDebugFile","compilationJobsCreationErrors","hasErrors","reasons","COMPILATION_JOBS_CREATION_FAILURE","noCompatibleSolc","incompatibleOverridenSolc","directlyImportsIncompatibleFile","indirectlyImportsIncompatibleFile","other","reason","builtin_tasks_1","NO_COMPATIBLE_SOLC_VERSION_FOUND","INCOMPATIBLE_OVERRIDEN_SOLC_VERSION","DIRECTLY_IMPORTS_INCOMPATIBLE_FILE","INDIRECTLY_IMPORTS_INCOMPATIBLE_FILE","OTHER_ERROR","versionPragmas","versionsRange","join","incompatibleDirectImportsFiles","extra","incompatibleDirectImports","x","directImportsText","otherImportsCount","incompatibleIndirectImports","incompatibleImports","dependency","path","dependencyPath","dependencyPathText","indirectImportsText","count","solidityFilesCachePath","solidity_files_cache_1","readFromFile","invalidateCacheMissingArtifacts","compilationJobsCreationResult","filteredCompilationJobs","mergedCompilationJobs","addFile","lastModificationDate","valueOf","contentHash","solcConfig","imports","allArtifactsEmittedPerFile","getEntries","artifactsImpl","addValidArtifacts","writeToFile","removeObsoleteArtifacts","addFlag","compilationArgs","compilationTasks","compilationTask","Set","getArtifactPaths","cacheEntry","getEntry","emittedArtifacts","emittedArtifact","fqn","formArtifactPathFromFullyQualifiedName","has","removeEntry","clearCache","cache","hasChanged","hasFileChanged","trim","replace"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\hardhat\\src\\builtin-tasks\\compile.ts"],"sourcesContent":["import os from \"os\";\nimport chalk from \"chalk\";\nimport debug from \"debug\";\nimport fsExtra from \"fs-extra\";\nimport semver from \"semver\";\nimport AggregateError from \"aggregate-error\";\n\nimport {\n  Artifacts as ArtifactsImpl,\n  getArtifactFromContractOutput,\n} from \"../internal/artifacts\";\nimport { subtask, task, types } from \"../internal/core/config/config-env\";\nimport { assertHardhatInvariant, HardhatError } from \"../internal/core/errors\";\nimport { ERRORS } from \"../internal/core/errors-list\";\nimport {\n  createCompilationJobFromFile,\n  createCompilationJobsFromConnectedComponent,\n  mergeCompilationJobsWithoutBug,\n} from \"../internal/solidity/compilation-job\";\nimport { Compiler, NativeCompiler } from \"../internal/solidity/compiler\";\nimport { getInputFromCompilationJob } from \"../internal/solidity/compiler/compiler-input\";\nimport {\n  CompilerDownloader,\n  CompilerPlatform,\n} from \"../internal/solidity/compiler/downloader\";\nimport { DependencyGraph } from \"../internal/solidity/dependencyGraph\";\nimport { Parser } from \"../internal/solidity/parse\";\nimport { ResolvedFile, Resolver } from \"../internal/solidity/resolver\";\nimport { getCompilersDir } from \"../internal/util/global-dir\";\nimport { pluralize } from \"../internal/util/strings\";\nimport { Artifacts, CompilerInput, CompilerOutput, SolcBuild } from \"../types\";\nimport * as taskTypes from \"../types/builtin-tasks\";\nimport {\n  CompilationJob,\n  CompilationJobCreationError,\n  CompilationJobCreationErrorReason,\n  CompilationJobsCreationResult,\n} from \"../types/builtin-tasks\";\nimport { getFullyQualifiedName } from \"../utils/contract-names\";\nimport { localPathToSourceName } from \"../utils/source-names\";\n\nimport { getAllFilesMatching } from \"../internal/util/fs-utils\";\nimport {\n  TASK_COMPILE,\n  TASK_COMPILE_GET_COMPILATION_TASKS,\n  TASK_COMPILE_SOLIDITY,\n  TASK_COMPILE_SOLIDITY_CHECK_ERRORS,\n  TASK_COMPILE_SOLIDITY_COMPILE,\n  TASK_COMPILE_SOLIDITY_COMPILE_JOB,\n  TASK_COMPILE_SOLIDITY_COMPILE_JOBS,\n  TASK_COMPILE_SOLIDITY_COMPILE_SOLC,\n  TASK_COMPILE_SOLIDITY_EMIT_ARTIFACTS,\n  TASK_COMPILE_SOLIDITY_FILTER_COMPILATION_JOBS,\n  TASK_COMPILE_SOLIDITY_GET_ARTIFACT_FROM_COMPILATION_OUTPUT,\n  TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE,\n  TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS,\n  TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS_FAILURE_REASONS,\n  TASK_COMPILE_SOLIDITY_GET_COMPILER_INPUT,\n  TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH,\n  TASK_COMPILE_SOLIDITY_GET_SOLC_BUILD,\n  TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES,\n  TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS,\n  TASK_COMPILE_SOLIDITY_HANDLE_COMPILATION_JOBS_FAILURES,\n  TASK_COMPILE_SOLIDITY_LOG_COMPILATION_ERRORS,\n  TASK_COMPILE_SOLIDITY_LOG_COMPILATION_RESULT,\n  TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_END,\n  TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_START,\n  TASK_COMPILE_SOLIDITY_LOG_NOTHING_TO_COMPILE,\n  TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_END,\n  TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_START,\n  TASK_COMPILE_SOLIDITY_MERGE_COMPILATION_JOBS,\n  TASK_COMPILE_SOLIDITY_READ_FILE,\n  TASK_COMPILE_SOLIDITY_RUN_SOLC,\n  TASK_COMPILE_SOLIDITY_RUN_SOLCJS,\n  TASK_COMPILE_REMOVE_OBSOLETE_ARTIFACTS,\n} from \"./task-names\";\nimport {\n  getSolidityFilesCachePath,\n  SolidityFilesCache,\n} from \"./utils/solidity-files-cache\";\n\ntype ArtifactsEmittedPerFile = Array<{\n  file: taskTypes.ResolvedFile;\n  artifactsEmitted: string[];\n}>;\n\ntype ArtifactsEmittedPerJob = Array<{\n  compilationJob: CompilationJob;\n  artifactsEmittedPerFile: ArtifactsEmittedPerFile;\n}>;\n\nfunction isConsoleLogError(error: any): boolean {\n  return (\n    error.type === \"TypeError\" &&\n    typeof error.message === \"string\" &&\n    error.message.includes(\"log\") &&\n    error.message.includes(\"type(library console)\")\n  );\n}\n\nconst log = debug(\"hardhat:core:tasks:compile\");\n\nconst COMPILE_TASK_FIRST_SOLC_VERSION_SUPPORTED = \"0.4.11\";\n\nconst DEFAULT_CONCURRENCY_LEVEL = Math.max(os.cpus().length - 1, 1);\n\n/**\n * Returns a list of absolute paths to all the solidity files in the project.\n * This list doesn't include dependencies, for example solidity files inside\n * node_modules.\n *\n * This is the right task to override to change how the solidity files of the\n * project are obtained.\n */\nsubtask(\n  TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS,\n  async (_, { config }): Promise<string[]> => {\n    const paths = await getAllFilesMatching(config.paths.sources, (f) =>\n      f.endsWith(\".sol\")\n    );\n\n    return paths;\n  }\n);\n\n/**\n * Receives a list of absolute paths and returns a list of source names\n * corresponding to each path. For example, receives\n * [\"/home/user/project/contracts/Foo.sol\"] and returns\n * [\"contracts/Foo.sol\"]. These source names will be used when the solc input\n * is generated.\n */\nsubtask(TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES)\n  .addParam(\"sourcePaths\", undefined, undefined, types.any)\n  .setAction(\n    async (\n      { sourcePaths }: { sourcePaths: string[] },\n      { config }\n    ): Promise<string[]> => {\n      const sourceNames = await Promise.all(\n        sourcePaths.map((p) => localPathToSourceName(config.paths.root, p))\n      );\n\n      return sourceNames;\n    }\n  );\n\nsubtask(TASK_COMPILE_SOLIDITY_READ_FILE)\n  .addParam(\"absolutePath\", undefined, undefined, types.string)\n  .setAction(\n    async ({ absolutePath }: { absolutePath: string }): Promise<string> => {\n      const content = await fsExtra.readFile(absolutePath, {\n        encoding: \"utf8\",\n      });\n\n      return content;\n    }\n  );\n\n/**\n * Receives a list of source names and returns a dependency graph. This task\n * is responsible for both resolving dependencies (like getting files from\n * node_modules) and generating the graph.\n */\nsubtask(TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH)\n  .addParam(\"sourceNames\", undefined, undefined, types.any)\n  .addOptionalParam(\"solidityFilesCache\", undefined, undefined, types.any)\n  .setAction(\n    async (\n      {\n        sourceNames,\n        solidityFilesCache,\n      }: { sourceNames: string[]; solidityFilesCache?: SolidityFilesCache },\n      { config, run }\n    ): Promise<taskTypes.DependencyGraph> => {\n      const parser = new Parser(solidityFilesCache);\n      const resolver = new Resolver(\n        config.paths.root,\n        parser,\n        (absolutePath: string) =>\n          run(TASK_COMPILE_SOLIDITY_READ_FILE, { absolutePath })\n      );\n\n      const resolvedFiles = await Promise.all(\n        sourceNames.map((sn) => resolver.resolveSourceName(sn))\n      );\n      const dependencyGraph = await DependencyGraph.createFromResolvedFiles(\n        resolver,\n        resolvedFiles\n      );\n\n      return dependencyGraph;\n    }\n  );\n\n/**\n * Receives a dependency graph and a file in it, and returns the compilation\n * job for that file. The compilation job should have everything that is\n * necessary to compile that file: a compiler config to be used and a list of\n * files to use as input of the compilation.\n *\n * If the file cannot be compiled, a MatchingCompilerFailure should be\n * returned instead.\n *\n * This is the right task to override to change the compiler configuration.\n * For example, if you want to change the compiler settings when targetting\n * rinkeby, you could do something like this:\n *\n *   const compilationJob = await runSuper();\n *   if (config.network.name === 'rinkeby') {\n *     compilationJob.solidityConfig.settings = newSettings;\n *   }\n *   return compilationJob;\n *\n */\nsubtask(TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE)\n  .addParam(\"dependencyGraph\", undefined, undefined, types.any)\n  .addParam(\"file\", undefined, undefined, types.any)\n  .addOptionalParam(\"solidityFilesCache\", undefined, undefined, types.any)\n  .setAction(\n    async (\n      {\n        dependencyGraph,\n        file,\n      }: {\n        dependencyGraph: taskTypes.DependencyGraph;\n        file: taskTypes.ResolvedFile;\n        solidityFilesCache?: SolidityFilesCache;\n      },\n      { config }\n    ): Promise<CompilationJob | CompilationJobCreationError> => {\n      return createCompilationJobFromFile(\n        dependencyGraph,\n        file,\n        config.solidity\n      );\n    }\n  );\n\n/**\n * Receives a dependency graph and returns a tuple with two arrays. The first\n * array is a list of CompilationJobsSuccess, where each item has a list of\n * compilation jobs. The second array is a list of CompilationJobsFailure,\n * where each item has a list of files that couldn't be compiled, grouped by\n * the reason for the failure.\n */\nsubtask(TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS)\n  .addParam(\"dependencyGraph\", undefined, undefined, types.any)\n  .addOptionalParam(\"solidityFilesCache\", undefined, undefined, types.any)\n  .setAction(\n    async (\n      {\n        dependencyGraph,\n        solidityFilesCache,\n      }: {\n        dependencyGraph: taskTypes.DependencyGraph;\n        solidityFilesCache?: SolidityFilesCache;\n      },\n      { run }\n    ): Promise<CompilationJobsCreationResult> => {\n      const connectedComponents = dependencyGraph.getConnectedComponents();\n\n      log(\n        `The dependency graph was divided in '${connectedComponents.length}' connected components`\n      );\n\n      const compilationJobsCreationResults = await Promise.all(\n        connectedComponents.map((graph) =>\n          createCompilationJobsFromConnectedComponent(\n            graph,\n            (file: taskTypes.ResolvedFile) =>\n              run(TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE, {\n                file,\n                dependencyGraph,\n                solidityFilesCache,\n              })\n          )\n        )\n      );\n\n      let jobs: CompilationJob[] = [];\n      let errors: CompilationJobCreationError[] = [];\n\n      for (const result of compilationJobsCreationResults) {\n        jobs = jobs.concat(result.jobs);\n        errors = errors.concat(result.errors);\n      }\n\n      return { jobs, errors };\n    }\n  );\n\n/**\n * Receives a list of compilation jobs and returns a new list where some of\n * the compilation jobs might've been removed.\n *\n * This task can be overriden to change the way the cache is used, or to use\n * a different approach to filtering out compilation jobs.\n */\nsubtask(TASK_COMPILE_SOLIDITY_FILTER_COMPILATION_JOBS)\n  .addParam(\"compilationJobs\", undefined, undefined, types.any)\n  .addParam(\"force\", undefined, undefined, types.boolean)\n  .addOptionalParam(\"solidityFilesCache\", undefined, undefined, types.any)\n  .setAction(\n    async ({\n      compilationJobs,\n      force,\n      solidityFilesCache,\n    }: {\n      compilationJobs: CompilationJob[];\n      force: boolean;\n      solidityFilesCache?: SolidityFilesCache;\n    }): Promise<CompilationJob[]> => {\n      assertHardhatInvariant(\n        solidityFilesCache !== undefined,\n        \"The implementation of this task needs a defined solidityFilesCache\"\n      );\n\n      if (force) {\n        log(`force flag enabled, not filtering`);\n        return compilationJobs;\n      }\n\n      const neededCompilationJobs = compilationJobs.filter((job) =>\n        needsCompilation(job, solidityFilesCache)\n      );\n\n      const jobsFilteredOutCount =\n        compilationJobs.length - neededCompilationJobs.length;\n      log(`'${jobsFilteredOutCount}' jobs were filtered out`);\n\n      return neededCompilationJobs;\n    }\n  );\n\n/**\n * Receives a list of compilation jobs and returns a new list where some of\n * the jobs might've been merged.\n */\nsubtask(TASK_COMPILE_SOLIDITY_MERGE_COMPILATION_JOBS)\n  .addParam(\"compilationJobs\", undefined, undefined, types.any)\n  .setAction(\n    async ({\n      compilationJobs,\n    }: {\n      compilationJobs: CompilationJob[];\n    }): Promise<CompilationJob[]> => {\n      return mergeCompilationJobsWithoutBug(compilationJobs);\n    }\n  );\n\n/**\n * Prints a message when there's nothing to compile.\n */\nsubtask(TASK_COMPILE_SOLIDITY_LOG_NOTHING_TO_COMPILE)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .setAction(async ({ quiet }: { quiet: boolean }) => {\n    if (!quiet) {\n      console.log(\"Nothing to compile\");\n    }\n  });\n\n/**\n * Receives a list of compilation jobs and sends each one to be compiled.\n */\nsubtask(TASK_COMPILE_SOLIDITY_COMPILE_JOBS)\n  .addParam(\"compilationJobs\", undefined, undefined, types.any)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .addParam(\"concurrency\", undefined, DEFAULT_CONCURRENCY_LEVEL, types.int)\n  .setAction(\n    async (\n      {\n        compilationJobs,\n        quiet,\n        concurrency,\n      }: {\n        compilationJobs: CompilationJob[];\n        quiet: boolean;\n        concurrency: number;\n      },\n      { run }\n    ): Promise<{ artifactsEmittedPerJob: ArtifactsEmittedPerJob }> => {\n      if (compilationJobs.length === 0) {\n        log(`No compilation jobs to compile`);\n        await run(TASK_COMPILE_SOLIDITY_LOG_NOTHING_TO_COMPILE, { quiet });\n        return { artifactsEmittedPerJob: [] };\n      }\n\n      log(`Compiling ${compilationJobs.length} jobs`);\n\n      const versionList: string[] = [];\n      for (const job of compilationJobs) {\n        const solcVersion = job.getSolcConfig().version;\n\n        if (!versionList.includes(solcVersion)) {\n          // versions older than 0.4.11 don't work with hardhat\n          // see issue https://github.com/nomiclabs/hardhat/issues/2004\n          if (\n            semver.lt(solcVersion, COMPILE_TASK_FIRST_SOLC_VERSION_SUPPORTED)\n          ) {\n            throw new HardhatError(\n              ERRORS.BUILTIN_TASKS.COMPILE_TASK_UNSUPPORTED_SOLC_VERSION,\n              {\n                version: solcVersion,\n                firstSupportedVersion:\n                  COMPILE_TASK_FIRST_SOLC_VERSION_SUPPORTED,\n              }\n            );\n          }\n\n          versionList.push(solcVersion);\n        }\n      }\n\n      const { default: pMap } = await import(\"p-map\");\n      const pMapOptions = { concurrency, stopOnError: false };\n      try {\n        const artifactsEmittedPerJob: ArtifactsEmittedPerJob = await pMap(\n          compilationJobs,\n          async (compilationJob, compilationJobIndex) => {\n            const result = await run(TASK_COMPILE_SOLIDITY_COMPILE_JOB, {\n              compilationJob,\n              compilationJobs,\n              compilationJobIndex,\n              quiet,\n            });\n\n            return {\n              compilationJob: result.compilationJob,\n              artifactsEmittedPerFile: result.artifactsEmittedPerFile,\n            };\n          },\n          pMapOptions\n        );\n\n        return { artifactsEmittedPerJob };\n      } catch (e) {\n        if (!(e instanceof AggregateError)) {\n          // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n          throw e;\n        }\n\n        for (const error of e) {\n          if (\n            !HardhatError.isHardhatErrorType(\n              error,\n              ERRORS.BUILTIN_TASKS.COMPILE_FAILURE\n            )\n          ) {\n            // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n            throw error;\n          }\n        }\n\n        // error is an aggregate error, and all errors are compilation failures\n        throw new HardhatError(ERRORS.BUILTIN_TASKS.COMPILE_FAILURE);\n      }\n    }\n  );\n\n/**\n * Receives a compilation job and returns a CompilerInput.\n *\n * It's not recommended to override this task to modify the solc\n * configuration, override\n * TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE instead.\n */\nsubtask(TASK_COMPILE_SOLIDITY_GET_COMPILER_INPUT)\n  .addParam(\"compilationJob\", undefined, undefined, types.any)\n  .setAction(\n    async ({\n      compilationJob,\n    }: {\n      compilationJob: CompilationJob;\n    }): Promise<CompilerInput> => {\n      return getInputFromCompilationJob(compilationJob);\n    }\n  );\n\nsubtask(TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_START)\n  .addParam(\"isCompilerDownloaded\", undefined, undefined, types.boolean)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .addParam(\"solcVersion\", undefined, undefined, types.string)\n  .setAction(\n    async ({\n      isCompilerDownloaded,\n      solcVersion,\n    }: {\n      isCompilerDownloaded: boolean;\n      quiet: boolean;\n      solcVersion: string;\n    }) => {\n      if (isCompilerDownloaded) {\n        return;\n      }\n\n      console.log(`Downloading compiler ${solcVersion}`);\n    }\n  );\n\nsubtask(TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_END)\n  .addParam(\"isCompilerDownloaded\", undefined, undefined, types.boolean)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .addParam(\"solcVersion\", undefined, undefined, types.string)\n  .setAction(\n    async ({}: {\n      isCompilerDownloaded: boolean;\n      quiet: boolean;\n      solcVersion: string;\n    }) => {}\n  );\n\n/**\n * Receives a solc version and returns a path to a solc binary or to a\n * downloaded solcjs module. It also returns a flag indicating if the returned\n * path corresponds to solc or solcjs.\n */\nsubtask(TASK_COMPILE_SOLIDITY_GET_SOLC_BUILD)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .addParam(\"solcVersion\", undefined, undefined, types.string)\n  .setAction(\n    async (\n      {\n        quiet,\n        solcVersion,\n      }: {\n        quiet: boolean;\n        solcVersion: string;\n      },\n      { run }\n    ): Promise<SolcBuild> => {\n      const compilersCache = await getCompilersDir();\n\n      const compilerPlatform = CompilerDownloader.getCompilerPlatform();\n      const downloader = CompilerDownloader.getConcurrencySafeDownloader(\n        compilerPlatform,\n        compilersCache\n      );\n\n      const isCompilerDownloaded = await downloader.isCompilerDownloaded(\n        solcVersion\n      );\n\n      if (!isCompilerDownloaded) {\n        await run(TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_START, {\n          solcVersion,\n          isCompilerDownloaded,\n          quiet,\n        });\n\n        await downloader.downloadCompiler(solcVersion);\n\n        await run(TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_END, {\n          solcVersion,\n          isCompilerDownloaded,\n          quiet,\n        });\n      }\n\n      const compiler = await downloader.getCompiler(solcVersion);\n\n      if (compiler !== undefined) {\n        return compiler;\n      }\n\n      log(\n        \"Native solc binary doesn't work, using solcjs instead. Try running npx hardhat clean --global\"\n      );\n\n      const wasmDownloader = CompilerDownloader.getConcurrencySafeDownloader(\n        CompilerPlatform.WASM,\n        compilersCache\n      );\n\n      const isWasmCompilerDownloader =\n        await wasmDownloader.isCompilerDownloaded(solcVersion);\n\n      if (!isWasmCompilerDownloader) {\n        await run(TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_START, {\n          solcVersion,\n          isCompilerDownloaded,\n          quiet,\n        });\n\n        await wasmDownloader.downloadCompiler(solcVersion);\n\n        await run(TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_END, {\n          solcVersion,\n          isCompilerDownloaded,\n          quiet,\n        });\n      }\n\n      const wasmCompiler = await wasmDownloader.getCompiler(solcVersion);\n\n      assertHardhatInvariant(\n        wasmCompiler !== undefined,\n        `WASM build of solc ${solcVersion} isn't working`\n      );\n\n      return wasmCompiler;\n    }\n  );\n\n/**\n * Receives an absolute path to a solcjs module and the input to be compiled,\n * and returns the generated output\n */\nsubtask(TASK_COMPILE_SOLIDITY_RUN_SOLCJS)\n  .addParam(\"input\", undefined, undefined, types.any)\n  .addParam(\"solcJsPath\", undefined, undefined, types.string)\n  .setAction(\n    async ({\n      input,\n      solcJsPath,\n    }: {\n      input: CompilerInput;\n      solcJsPath: string;\n    }) => {\n      const compiler = new Compiler(solcJsPath);\n\n      const output = await compiler.compile(input);\n\n      return output;\n    }\n  );\n\n/**\n * Receives an absolute path to a solc binary and the input to be compiled,\n * and returns the generated output\n */\nsubtask(TASK_COMPILE_SOLIDITY_RUN_SOLC)\n  .addParam(\"input\", undefined, undefined, types.any)\n  .addParam(\"solcPath\", undefined, undefined, types.string)\n  .setAction(\n    async ({ input, solcPath }: { input: CompilerInput; solcPath: string }) => {\n      const compiler = new NativeCompiler(solcPath);\n\n      const output = await compiler.compile(input);\n\n      return output;\n    }\n  );\n\n/**\n * Receives a CompilerInput and a solc version, compiles the input using a native\n * solc binary or, if that's not possible, using solcjs. Returns the generated\n * output.\n *\n * This task can be overriden to change how solc is obtained or used.\n */\nsubtask(TASK_COMPILE_SOLIDITY_COMPILE_SOLC)\n  .addParam(\"input\", undefined, undefined, types.any)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .addParam(\"solcVersion\", undefined, undefined, types.string)\n  .addParam(\"compilationJob\", undefined, undefined, types.any)\n  .addParam(\"compilationJobs\", undefined, undefined, types.any)\n  .addParam(\"compilationJobIndex\", undefined, undefined, types.int)\n  .setAction(\n    async (\n      {\n        input,\n        quiet,\n        solcVersion,\n        compilationJob,\n        compilationJobs,\n        compilationJobIndex,\n      }: {\n        input: CompilerInput;\n        quiet: boolean;\n        solcVersion: string;\n        compilationJob: CompilationJob;\n        compilationJobs: CompilationJob[];\n        compilationJobIndex: number;\n      },\n      { run }\n    ): Promise<{ output: CompilerOutput; solcBuild: SolcBuild }> => {\n      const solcBuild: SolcBuild = await run(\n        TASK_COMPILE_SOLIDITY_GET_SOLC_BUILD,\n        {\n          quiet,\n          solcVersion,\n        }\n      );\n\n      await run(TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_START, {\n        compilationJob,\n        compilationJobs,\n        compilationJobIndex,\n        quiet,\n      });\n\n      let output;\n      if (solcBuild.isSolcJs) {\n        output = await run(TASK_COMPILE_SOLIDITY_RUN_SOLCJS, {\n          input,\n          solcJsPath: solcBuild.compilerPath,\n        });\n      } else {\n        output = await run(TASK_COMPILE_SOLIDITY_RUN_SOLC, {\n          input,\n          solcPath: solcBuild.compilerPath,\n        });\n      }\n\n      await run(TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_END, {\n        compilationJob,\n        compilationJobs,\n        compilationJobIndex,\n        output,\n        quiet,\n      });\n\n      return { output, solcBuild };\n    }\n  );\n\n/**\n * This task is just a proxy to the task that compiles with solc.\n *\n * Override this to use a different task to compile a job.\n */\nsubtask(TASK_COMPILE_SOLIDITY_COMPILE, async (taskArgs: any, { run }) => {\n  return run(TASK_COMPILE_SOLIDITY_COMPILE_SOLC, taskArgs);\n});\n\n/**\n * Receives a compilation output and prints its errors and any other\n * information useful to the user.\n */\nsubtask(TASK_COMPILE_SOLIDITY_LOG_COMPILATION_ERRORS)\n  .addParam(\"output\", undefined, undefined, types.any)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .setAction(async ({ output }: { output: any; quiet: boolean }) => {\n    if (output?.errors === undefined) {\n      return;\n    }\n\n    for (const error of output.errors) {\n      if (error.severity === \"error\") {\n        const errorMessage =\n          getFormattedInternalCompilerErrorMessage(error) ??\n          error.formattedMessage;\n\n        console.error(chalk.red(errorMessage));\n      } else {\n        console.warn(chalk.yellow(error.formattedMessage));\n      }\n    }\n\n    const hasConsoleErrors = output.errors.some(isConsoleLogError);\n    if (hasConsoleErrors) {\n      console.error(\n        chalk.red(\n          `The console.log call you made isn’t supported. See https://hardhat.org/console-log for the list of supported methods.`\n        )\n      );\n      console.log();\n    }\n  });\n\n/**\n * Receives a solc output and checks if there are errors. Throws if there are\n * errors.\n *\n * Override this task to avoid interrupting the compilation process if some\n * job has compilation errors.\n */\nsubtask(TASK_COMPILE_SOLIDITY_CHECK_ERRORS)\n  .addParam(\"output\", undefined, undefined, types.any)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .setAction(\n    async ({ output, quiet }: { output: any; quiet: boolean }, { run }) => {\n      await run(TASK_COMPILE_SOLIDITY_LOG_COMPILATION_ERRORS, {\n        output,\n        quiet,\n      });\n\n      if (hasCompilationErrors(output)) {\n        throw new HardhatError(ERRORS.BUILTIN_TASKS.COMPILE_FAILURE);\n      }\n    }\n  );\n\n/**\n * Saves to disk the artifacts for a compilation job. These artifacts\n * include the main artifacts, the debug files, and the build info.\n */\nsubtask(TASK_COMPILE_SOLIDITY_EMIT_ARTIFACTS)\n  .addParam(\"compilationJob\", undefined, undefined, types.any)\n  .addParam(\"input\", undefined, undefined, types.any)\n  .addParam(\"output\", undefined, undefined, types.any)\n  .addParam(\"solcBuild\", undefined, undefined, types.any)\n  .setAction(\n    async (\n      {\n        compilationJob,\n        input,\n        output,\n        solcBuild,\n      }: {\n        compilationJob: CompilationJob;\n        input: CompilerInput;\n        output: CompilerOutput;\n        solcBuild: SolcBuild;\n      },\n      { artifacts, run }\n    ): Promise<{\n      artifactsEmittedPerFile: ArtifactsEmittedPerFile;\n    }> => {\n      const pathToBuildInfo = await artifacts.saveBuildInfo(\n        compilationJob.getSolcConfig().version,\n        solcBuild.longVersion,\n        input,\n        output\n      );\n\n      const artifactsEmittedPerFile: ArtifactsEmittedPerFile =\n        await Promise.all(\n          compilationJob\n            .getResolvedFiles()\n            .filter((f) => compilationJob.emitsArtifacts(f))\n            .map(async (file) => {\n              const artifactsEmitted = await Promise.all(\n                Object.entries(output.contracts?.[file.sourceName] ?? {}).map(\n                  async ([contractName, contractOutput]) => {\n                    log(`Emitting artifact for contract '${contractName}'`);\n                    const artifact = await run(\n                      TASK_COMPILE_SOLIDITY_GET_ARTIFACT_FROM_COMPILATION_OUTPUT,\n                      {\n                        sourceName: file.sourceName,\n                        contractName,\n                        contractOutput,\n                      }\n                    );\n\n                    await artifacts.saveArtifactAndDebugFile(\n                      artifact,\n                      pathToBuildInfo\n                    );\n\n                    return artifact.contractName;\n                  }\n                )\n              );\n\n              return {\n                file,\n                artifactsEmitted,\n              };\n            })\n        );\n\n      return { artifactsEmittedPerFile };\n    }\n  );\n\n/**\n * Generates the artifact for contract `contractName` given its compilation\n * output.\n */\nsubtask(TASK_COMPILE_SOLIDITY_GET_ARTIFACT_FROM_COMPILATION_OUTPUT)\n  .addParam(\"sourceName\", undefined, undefined, types.string)\n  .addParam(\"contractName\", undefined, undefined, types.string)\n  .addParam(\"contractOutput\", undefined, undefined, types.any)\n  .setAction(\n    async ({\n      sourceName,\n      contractName,\n      contractOutput,\n    }: {\n      sourceName: string;\n      contractName: string;\n      contractOutput: any;\n    }): Promise<any> => {\n      return getArtifactFromContractOutput(\n        sourceName,\n        contractName,\n        contractOutput\n      );\n    }\n  );\n\n/**\n * Prints a message before running soljs with some input.\n */\nsubtask(TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_START)\n  .addParam(\"compilationJob\", undefined, undefined, types.any)\n  .addParam(\"compilationJobs\", undefined, undefined, types.any)\n  .addParam(\"compilationJobIndex\", undefined, undefined, types.int)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .setAction(\n    async ({}: {\n      compilationJob: CompilationJob;\n      compilationJobs: CompilationJob[];\n      compilationJobIndex: number;\n    }) => {}\n  );\n\n/**\n * Prints a message after compiling some input\n */\nsubtask(TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_END)\n  .addParam(\"compilationJob\", undefined, undefined, types.any)\n  .addParam(\"compilationJobs\", undefined, undefined, types.any)\n  .addParam(\"compilationJobIndex\", undefined, undefined, types.int)\n  .addParam(\"output\", undefined, undefined, types.any)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .setAction(\n    async ({}: {\n      compilationJob: CompilationJob;\n      compilationJobs: CompilationJob[];\n      compilationJobIndex: number;\n      output: any;\n      quiet: boolean;\n    }) => {}\n  );\n\n/**\n * This is an orchestrator task that uses other subtasks to compile a\n * compilation job.\n */\nsubtask(TASK_COMPILE_SOLIDITY_COMPILE_JOB)\n  .addParam(\"compilationJob\", undefined, undefined, types.any)\n  .addParam(\"compilationJobs\", undefined, undefined, types.any)\n  .addParam(\"compilationJobIndex\", undefined, undefined, types.int)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .addOptionalParam(\"emitsArtifacts\", undefined, true, types.boolean)\n  .setAction(\n    async (\n      {\n        compilationJob,\n        compilationJobs,\n        compilationJobIndex,\n        quiet,\n        emitsArtifacts,\n      }: {\n        compilationJob: CompilationJob;\n        compilationJobs: CompilationJob[];\n        compilationJobIndex: number;\n        quiet: boolean;\n        emitsArtifacts: boolean;\n      },\n      { run }\n    ): Promise<{\n      artifactsEmittedPerFile: ArtifactsEmittedPerFile;\n      compilationJob: taskTypes.CompilationJob;\n      input: CompilerInput;\n      output: CompilerOutput;\n      solcBuild: any;\n    }> => {\n      log(\n        `Compiling job with version '${compilationJob.getSolcConfig().version}'`\n      );\n      const input: CompilerInput = await run(\n        TASK_COMPILE_SOLIDITY_GET_COMPILER_INPUT,\n        {\n          compilationJob,\n        }\n      );\n\n      const { output, solcBuild } = await run(TASK_COMPILE_SOLIDITY_COMPILE, {\n        solcVersion: compilationJob.getSolcConfig().version,\n        input,\n        quiet,\n        compilationJob,\n        compilationJobs,\n        compilationJobIndex,\n      });\n\n      await run(TASK_COMPILE_SOLIDITY_CHECK_ERRORS, { output, quiet });\n\n      let artifactsEmittedPerFile = [];\n      if (emitsArtifacts) {\n        artifactsEmittedPerFile = (\n          await run(TASK_COMPILE_SOLIDITY_EMIT_ARTIFACTS, {\n            compilationJob,\n            input,\n            output,\n            solcBuild,\n          })\n        ).artifactsEmittedPerFile;\n      }\n\n      return {\n        artifactsEmittedPerFile,\n        compilationJob,\n        input,\n        output,\n        solcBuild,\n      };\n    }\n  );\n\n/**\n * Receives a list of CompilationJobsFailure and throws an error if it's not\n * empty.\n *\n * This task could be overriden to avoid interrupting the compilation if\n * there's some part of the project that can't be compiled.\n */\nsubtask(TASK_COMPILE_SOLIDITY_HANDLE_COMPILATION_JOBS_FAILURES)\n  .addParam(\"compilationJobsCreationErrors\", undefined, undefined, types.any)\n  .setAction(\n    async (\n      {\n        compilationJobsCreationErrors,\n      }: {\n        compilationJobsCreationErrors: CompilationJobCreationError[];\n      },\n      { run }\n    ) => {\n      const hasErrors = compilationJobsCreationErrors.length > 0;\n\n      if (hasErrors) {\n        log(`There were errors creating the compilation jobs, throwing`);\n        const reasons: string = await run(\n          TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS_FAILURE_REASONS,\n          { compilationJobsCreationErrors }\n        );\n\n        throw new HardhatError(\n          ERRORS.BUILTIN_TASKS.COMPILATION_JOBS_CREATION_FAILURE,\n          {\n            reasons,\n          }\n        );\n      }\n    }\n  );\n\n/**\n * Receives a list of CompilationJobsFailure and returns an error message\n * that describes the failure.\n */\nsubtask(TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS_FAILURE_REASONS)\n  .addParam(\"compilationJobsCreationErrors\", undefined, undefined, types.any)\n  .setAction(\n    async ({\n      compilationJobsCreationErrors: errors,\n    }: {\n      compilationJobsCreationErrors: CompilationJobCreationError[];\n    }): Promise<string> => {\n      const noCompatibleSolc: CompilationJobCreationError[] = [];\n      const incompatibleOverridenSolc: CompilationJobCreationError[] = [];\n      const directlyImportsIncompatibleFile: CompilationJobCreationError[] = [];\n      const indirectlyImportsIncompatibleFile: CompilationJobCreationError[] =\n        [];\n      const other: CompilationJobCreationError[] = [];\n\n      for (const error of errors) {\n        if (\n          error.reason ===\n          CompilationJobCreationErrorReason.NO_COMPATIBLE_SOLC_VERSION_FOUND\n        ) {\n          noCompatibleSolc.push(error);\n        } else if (\n          error.reason ===\n          CompilationJobCreationErrorReason.INCOMPATIBLE_OVERRIDEN_SOLC_VERSION\n        ) {\n          incompatibleOverridenSolc.push(error);\n        } else if (\n          error.reason ===\n          CompilationJobCreationErrorReason.DIRECTLY_IMPORTS_INCOMPATIBLE_FILE\n        ) {\n          directlyImportsIncompatibleFile.push(error);\n        } else if (\n          error.reason ===\n          CompilationJobCreationErrorReason.INDIRECTLY_IMPORTS_INCOMPATIBLE_FILE\n        ) {\n          indirectlyImportsIncompatibleFile.push(error);\n        } else if (\n          error.reason === CompilationJobCreationErrorReason.OTHER_ERROR\n        ) {\n          other.push(error);\n        } else {\n          // add unrecognized errors to `other`\n          other.push(error);\n        }\n      }\n\n      let errorMessage = \"\";\n      if (incompatibleOverridenSolc.length > 0) {\n        errorMessage += `The compiler version for the following files is fixed through an override in your config file to a version that is incompatible with their Solidity version pragmas.\n\n`;\n\n        for (const error of incompatibleOverridenSolc) {\n          const { sourceName } = error.file;\n          const { versionPragmas } = error.file.content;\n          const versionsRange = versionPragmas.join(\" \");\n\n          log(`File ${sourceName} has an incompatible overriden compiler`);\n\n          errorMessage += `  * ${sourceName} (${versionsRange})\\n`;\n        }\n\n        errorMessage += \"\\n\";\n      }\n\n      if (noCompatibleSolc.length > 0) {\n        errorMessage += `The Solidity version pragma statement in these files doesn't match any of the configured compilers in your config. Change the pragma or configure additional compiler versions in your hardhat config.\n\n`;\n\n        for (const error of noCompatibleSolc) {\n          const { sourceName } = error.file;\n          const { versionPragmas } = error.file.content;\n          const versionsRange = versionPragmas.join(\" \");\n\n          log(\n            `File ${sourceName} doesn't match any of the configured compilers`\n          );\n\n          errorMessage += `  * ${sourceName} (${versionsRange})\\n`;\n        }\n\n        errorMessage += \"\\n\";\n      }\n\n      if (directlyImportsIncompatibleFile.length > 0) {\n        errorMessage += `These files import other files that use a different and incompatible version of Solidity:\n\n`;\n\n        for (const error of directlyImportsIncompatibleFile) {\n          const { sourceName } = error.file;\n          const { versionPragmas } = error.file.content;\n          const versionsRange = versionPragmas.join(\" \");\n\n          const incompatibleDirectImportsFiles: ResolvedFile[] =\n            error.extra?.incompatibleDirectImports ?? [];\n\n          const incompatibleDirectImports = incompatibleDirectImportsFiles.map(\n            (x: ResolvedFile) =>\n              `${x.sourceName} (${x.content.versionPragmas.join(\" \")})`\n          );\n\n          log(\n            `File ${sourceName} imports files ${incompatibleDirectImportsFiles\n              .map((x) => x.sourceName)\n              .join(\", \")} that use an incompatible version of Solidity`\n          );\n\n          let directImportsText = \"\";\n          if (incompatibleDirectImports.length === 1) {\n            directImportsText = ` imports ${incompatibleDirectImports[0]}`;\n          } else if (incompatibleDirectImports.length === 2) {\n            directImportsText = ` imports ${incompatibleDirectImports[0]} and ${incompatibleDirectImports[1]}`;\n          } else if (incompatibleDirectImports.length > 2) {\n            const otherImportsCount = incompatibleDirectImports.length - 2;\n            directImportsText = ` imports ${incompatibleDirectImports[0]}, ${\n              incompatibleDirectImports[1]\n            } and ${otherImportsCount} other ${pluralize(\n              otherImportsCount,\n              \"file\"\n            )}. Use --verbose to see the full list.`;\n          }\n\n          errorMessage += `  * ${sourceName} (${versionsRange})${directImportsText}\\n`;\n        }\n\n        errorMessage += \"\\n\";\n      }\n\n      if (indirectlyImportsIncompatibleFile.length > 0) {\n        errorMessage += `These files depend on other files that use a different and incompatible version of Solidity:\n\n`;\n\n        for (const error of indirectlyImportsIncompatibleFile) {\n          const { sourceName } = error.file;\n          const { versionPragmas } = error.file.content;\n          const versionsRange = versionPragmas.join(\" \");\n\n          const incompatibleIndirectImports: taskTypes.TransitiveDependency[] =\n            error.extra?.incompatibleIndirectImports ?? [];\n\n          const incompatibleImports = incompatibleIndirectImports.map(\n            ({ dependency }) =>\n              `${\n                dependency.sourceName\n              } (${dependency.content.versionPragmas.join(\" \")})`\n          );\n\n          for (const {\n            dependency,\n            path: dependencyPath,\n          } of incompatibleIndirectImports) {\n            const dependencyPathText = [\n              sourceName,\n              ...dependencyPath.map((x) => x.sourceName),\n              dependency.sourceName,\n            ].join(\" -> \");\n\n            log(\n              `File ${sourceName} depends on file ${dependency.sourceName} that uses an incompatible version of Solidity\nThe dependency path is ${dependencyPathText}\n`\n            );\n          }\n\n          let indirectImportsText = \"\";\n          if (incompatibleImports.length === 1) {\n            indirectImportsText = ` depends on ${incompatibleImports[0]}`;\n          } else if (incompatibleImports.length === 2) {\n            indirectImportsText = ` depends on ${incompatibleImports[0]} and ${incompatibleImports[1]}`;\n          } else if (incompatibleImports.length > 2) {\n            const otherImportsCount = incompatibleImports.length - 2;\n            indirectImportsText = ` depends on ${incompatibleImports[0]}, ${\n              incompatibleImports[1]\n            } and ${otherImportsCount} other ${pluralize(\n              otherImportsCount,\n              \"file\"\n            )}. Use --verbose to see the full list.`;\n          }\n\n          errorMessage += `  * ${sourceName} (${versionsRange})${indirectImportsText}\\n`;\n        }\n\n        errorMessage += \"\\n\";\n      }\n\n      if (other.length > 0) {\n        errorMessage += `These files and its dependencies cannot be compiled with your config. This can happen because they have incompatible Solidity pragmas, or don't match any of your configured Solidity compilers.\n\n${other.map((x) => `  * ${x.file.sourceName}`).join(\"\\n\")}\n\n`;\n      }\n\n      errorMessage += `To learn more, run the command again with --verbose\n\nRead about compiler configuration at https://hardhat.org/config\n`;\n\n      return errorMessage;\n    }\n  );\n\nsubtask(TASK_COMPILE_SOLIDITY_LOG_COMPILATION_RESULT)\n  .addParam(\"compilationJobs\", undefined, undefined, types.any)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .setAction(\n    async ({ compilationJobs }: { compilationJobs: CompilationJob[] }) => {\n      let count = 0;\n      for (const job of compilationJobs) {\n        count += job\n          .getResolvedFiles()\n          .filter((file) => job.emitsArtifacts(file)).length;\n      }\n\n      if (count > 0) {\n        console.log(\n          `Compiled ${count} Solidity ${pluralize(count, \"file\")} successfully`\n        );\n      }\n    }\n  );\n\n/**\n * Main task for compiling the solidity files in the project.\n *\n * The main responsibility of this task is to orchestrate and connect most of\n * the subtasks related to compiling solidity.\n */\nsubtask(TASK_COMPILE_SOLIDITY)\n  .addParam(\"force\", undefined, undefined, types.boolean)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .addParam(\"concurrency\", undefined, DEFAULT_CONCURRENCY_LEVEL, types.int)\n  .setAction(\n    async (\n      {\n        force,\n        quiet,\n        concurrency,\n      }: { force: boolean; quiet: boolean; concurrency: number },\n      { artifacts, config, run }\n    ) => {\n      const sourcePaths: string[] = await run(\n        TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS\n      );\n\n      const sourceNames: string[] = await run(\n        TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES,\n        {\n          sourcePaths,\n        }\n      );\n\n      const solidityFilesCachePath = getSolidityFilesCachePath(config.paths);\n      let solidityFilesCache = await SolidityFilesCache.readFromFile(\n        solidityFilesCachePath\n      );\n\n      const dependencyGraph: taskTypes.DependencyGraph = await run(\n        TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH,\n        { sourceNames, solidityFilesCache }\n      );\n\n      solidityFilesCache = await invalidateCacheMissingArtifacts(\n        solidityFilesCache,\n        artifacts,\n        dependencyGraph.getResolvedFiles()\n      );\n\n      const compilationJobsCreationResult: CompilationJobsCreationResult =\n        await run(TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS, {\n          dependencyGraph,\n          solidityFilesCache,\n        });\n\n      await run(TASK_COMPILE_SOLIDITY_HANDLE_COMPILATION_JOBS_FAILURES, {\n        compilationJobsCreationErrors: compilationJobsCreationResult.errors,\n      });\n\n      const compilationJobs = compilationJobsCreationResult.jobs;\n\n      const filteredCompilationJobs: CompilationJob[] = await run(\n        TASK_COMPILE_SOLIDITY_FILTER_COMPILATION_JOBS,\n        { compilationJobs, force, solidityFilesCache }\n      );\n\n      const mergedCompilationJobs: CompilationJob[] = await run(\n        TASK_COMPILE_SOLIDITY_MERGE_COMPILATION_JOBS,\n        { compilationJobs: filteredCompilationJobs }\n      );\n\n      const {\n        artifactsEmittedPerJob,\n      }: { artifactsEmittedPerJob: ArtifactsEmittedPerJob } = await run(\n        TASK_COMPILE_SOLIDITY_COMPILE_JOBS,\n        {\n          compilationJobs: mergedCompilationJobs,\n          quiet,\n          concurrency,\n        }\n      );\n\n      // update cache using the information about the emitted artifacts\n      for (const {\n        compilationJob: compilationJob,\n        artifactsEmittedPerFile: artifactsEmittedPerFile,\n      } of artifactsEmittedPerJob) {\n        for (const { file, artifactsEmitted } of artifactsEmittedPerFile) {\n          solidityFilesCache.addFile(file.absolutePath, {\n            lastModificationDate: file.lastModificationDate.valueOf(),\n            contentHash: file.contentHash,\n            sourceName: file.sourceName,\n            solcConfig: compilationJob.getSolcConfig(),\n            imports: file.content.imports,\n            versionPragmas: file.content.versionPragmas,\n            artifacts: artifactsEmitted,\n          });\n        }\n      }\n\n      const allArtifactsEmittedPerFile = solidityFilesCache.getEntries();\n\n      // We know this is the actual implementation, so we use some\n      // non-public methods here.\n      const artifactsImpl = artifacts as ArtifactsImpl;\n      artifactsImpl.addValidArtifacts(allArtifactsEmittedPerFile);\n\n      await solidityFilesCache.writeToFile(solidityFilesCachePath);\n\n      await run(TASK_COMPILE_SOLIDITY_LOG_COMPILATION_RESULT, {\n        compilationJobs: mergedCompilationJobs,\n        quiet,\n      });\n    }\n  );\n\nsubtask(TASK_COMPILE_REMOVE_OBSOLETE_ARTIFACTS, async (_, { artifacts }) => {\n  // We know this is the actual implementation, so we use some\n  // non-public methods here.\n  const artifactsImpl = artifacts as ArtifactsImpl;\n  await artifactsImpl.removeObsoleteArtifacts();\n});\n\n/**\n * Returns a list of compilation tasks.\n *\n * This is the task to override to add support for other languages.\n */\nsubtask(TASK_COMPILE_GET_COMPILATION_TASKS, async (): Promise<string[]> => {\n  return [TASK_COMPILE_SOLIDITY];\n});\n\n/**\n * Main compile task.\n *\n * This is a meta-task that just gets all the compilation tasks and runs them.\n * Right now there's only a \"compile solidity\" task.\n */\ntask(TASK_COMPILE, \"Compiles the entire project, building all artifacts\")\n  .addFlag(\"force\", \"Force compilation ignoring cache\")\n  .addFlag(\"quiet\", \"Makes the compilation process less verbose\")\n  .addParam(\n    \"concurrency\",\n    \"Number of compilation jobs executed in parallel. Defaults to the number of CPU cores - 1\",\n    DEFAULT_CONCURRENCY_LEVEL,\n    types.int\n  )\n  .setAction(async (compilationArgs: any, { run }) => {\n    const compilationTasks: string[] = await run(\n      TASK_COMPILE_GET_COMPILATION_TASKS\n    );\n\n    for (const compilationTask of compilationTasks) {\n      await run(compilationTask, compilationArgs);\n    }\n\n    await run(TASK_COMPILE_REMOVE_OBSOLETE_ARTIFACTS);\n  });\n\n/**\n * If a file is present in the cache, but some of its artifacts are missing on\n * disk, we remove it from the cache to force it to be recompiled.\n */\nasync function invalidateCacheMissingArtifacts(\n  solidityFilesCache: SolidityFilesCache,\n  artifacts: Artifacts,\n  resolvedFiles: ResolvedFile[]\n): Promise<SolidityFilesCache> {\n  const paths = new Set(await artifacts.getArtifactPaths());\n\n  for (const file of resolvedFiles) {\n    const cacheEntry = solidityFilesCache.getEntry(file.absolutePath);\n\n    if (cacheEntry === undefined) {\n      continue;\n    }\n\n    const { artifacts: emittedArtifacts } = cacheEntry;\n    for (const emittedArtifact of emittedArtifacts) {\n      const fqn = getFullyQualifiedName(file.sourceName, emittedArtifact);\n      const path = artifacts.formArtifactPathFromFullyQualifiedName(fqn);\n\n      if (!paths.has(path)) {\n        log(\n          `Invalidate cache for '${file.absolutePath}' because artifact '${fqn}' doesn't exist`\n        );\n\n        solidityFilesCache.removeEntry(file.absolutePath);\n        break;\n      }\n    }\n  }\n\n  artifacts.clearCache?.();\n\n  return solidityFilesCache;\n}\n\n/**\n * Checks if the given compilation job needs to be done.\n */\nfunction needsCompilation(\n  job: taskTypes.CompilationJob,\n  cache: SolidityFilesCache\n): boolean {\n  for (const file of job.getResolvedFiles()) {\n    const hasChanged = cache.hasFileChanged(\n      file.absolutePath,\n      file.contentHash,\n      // we only check if the solcConfig is different for files that\n      // emit artifacts\n      job.emitsArtifacts(file) ? job.getSolcConfig() : undefined\n    );\n\n    if (hasChanged) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction hasCompilationErrors(output: any): boolean {\n  return (\n    output.errors && output.errors.some((x: any) => x.severity === \"error\")\n  );\n}\n\n/**\n * This function returns a properly formatted Internal Compiler Error message.\n *\n * This is present due to a bug in Solidity. See: https://github.com/ethereum/solidity/issues/9926\n *\n * If the error is not an ICE, or if it's properly formatted, this function returns undefined.\n */\nfunction getFormattedInternalCompilerErrorMessage(error: {\n  formattedMessage: string;\n  message: string;\n  type: string;\n}): string | undefined {\n  if (error.formattedMessage.trim() !== \"InternalCompilerError:\") {\n    return;\n  }\n\n  // We trim any final `:`, as we found some at the end of the error messages,\n  // and then trim just in case a blank space was left\n  return `${error.type}: ${error.message}`.replace(/[:\\s]*$/g, \"\").trim();\n}\n"]},"metadata":{},"sourceType":"script"}