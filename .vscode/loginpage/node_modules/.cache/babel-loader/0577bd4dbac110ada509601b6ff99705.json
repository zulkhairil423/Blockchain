{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createModuleTypeClassifier = void 0;\n\nconst ts_internals_1 = require(\"./ts-internals\");\n\nconst util_1 = require(\"./util\");\n/**\n * @internal\n * May receive non-normalized options -- basePath and patterns -- and will normalize them\n * internally.\n * However, calls to `classifyModule` must pass pre-normalized paths!\n */\n\n\nfunction createModuleTypeClassifier(options) {\n  const {\n    patterns,\n    basePath: _basePath\n  } = options;\n  const basePath = _basePath !== undefined ? (0, util_1.normalizeSlashes)(_basePath).replace(/\\/$/, '') : undefined;\n  const patternTypePairs = Object.entries(patterns !== null && patterns !== void 0 ? patterns : []).map(_ref => {\n    let [_pattern, type] = _ref;\n    const pattern = (0, util_1.normalizeSlashes)(_pattern);\n    return {\n      pattern: parsePattern(basePath, pattern),\n      type\n    };\n  });\n  const classifications = {\n    package: {\n      moduleType: 'auto'\n    },\n    cjs: {\n      moduleType: 'cjs'\n    },\n    esm: {\n      moduleType: 'esm'\n    }\n  };\n  const auto = classifications.package; // Passed path must be normalized!\n\n  function classifyModuleNonCached(path) {\n    const matched = matchPatterns(patternTypePairs, _ => _.pattern, path);\n    if (matched) return classifications[matched.type];\n    return auto;\n  }\n\n  const classifyModule = (0, util_1.cachedLookup)(classifyModuleNonCached);\n\n  function classifyModuleAuto(path) {\n    return auto;\n  }\n\n  return {\n    classifyModuleByModuleTypeOverrides: patternTypePairs.length ? classifyModule : classifyModuleAuto\n  };\n}\n\nexports.createModuleTypeClassifier = createModuleTypeClassifier;\n\nfunction parsePattern(basePath, patternString) {\n  const pattern = (0, ts_internals_1.getPatternFromSpec)(patternString, basePath);\n  return pattern !== undefined ? new RegExp(pattern) : /(?:)/;\n}\n\nfunction matchPatterns(objects, getPattern, candidate) {\n  for (let i = objects.length - 1; i >= 0; i--) {\n    const object = objects[i];\n    const pattern = getPattern(object);\n\n    if (pattern === null || pattern === void 0 ? void 0 : pattern.test(candidate)) {\n      return object;\n    }\n  }\n}","map":{"version":3,"mappings":";;;;;;;AACA;;AACA;AAwBA;;;;;;;;AAMA,SAAgBA,0BAAhB,CACEC,OADF,EACsC;EAEpC,MAAM;IAAEC,QAAF;IAAYC,QAAQ,EAAEC;EAAtB,IAAoCH,OAA1C;EACA,MAAME,QAAQ,GACZC,SAAS,KAAKC,SAAd,GACI,6BAAiBD,SAAjB,EAA4BE,OAA5B,CAAoC,KAApC,EAA2C,EAA3C,CADJ,GAEID,SAHN;EAKA,MAAME,gBAAgB,GAAGC,MAAM,CAACC,OAAP,CAAeP,QAAQ,SAAR,YAAQ,WAAR,cAAY,EAA3B,EAA+BQ,GAA/B,CACvB,QAAqB;IAAA,IAApB,CAACC,QAAD,EAAWC,IAAX,CAAoB;IACnB,MAAMC,OAAO,GAAG,6BAAiBF,QAAjB,CAAhB;IACA,OAAO;MAAEE,OAAO,EAAEC,YAAY,CAACX,QAAD,EAAYU,OAAZ,CAAvB;MAA6CD;IAA7C,CAAP;EACD,CAJsB,CAAzB;EAOA,MAAMG,eAAe,GACnB;IACEC,OAAO,EAAE;MACPC,UAAU,EAAE;IADL,CADX;IAIEC,GAAG,EAAE;MACHD,UAAU,EAAE;IADT,CAJP;IAOEE,GAAG,EAAE;MACHF,UAAU,EAAE;IADT;EAPP,CADF;EAYA,MAAMG,IAAI,GAAGL,eAAe,CAACC,OAA7B,CA3BoC,CA6BpC;;EACA,SAASK,uBAAT,CAAiCC,IAAjC,EAA6C;IAC3C,MAAMC,OAAO,GAAGC,aAAa,CAACjB,gBAAD,EAAoBkB,CAAD,IAAOA,CAAC,CAACZ,OAA5B,EAAqCS,IAArC,CAA7B;IACA,IAAIC,OAAJ,EAAa,OAAOR,eAAe,CAACQ,OAAO,CAACX,IAAT,CAAtB;IACb,OAAOQ,IAAP;EACD;;EAED,MAAMM,cAAc,GAAG,yBAAaL,uBAAb,CAAvB;;EAEA,SAASM,kBAAT,CAA4BL,IAA5B,EAAwC;IACtC,OAAOF,IAAP;EACD;;EAED,OAAO;IACLQ,mCAAmC,EAAErB,gBAAgB,CAACsB,MAAjB,GACjCH,cADiC,GAEjCC;EAHC,CAAP;AAKD;;AAhDDG;;AAkDA,SAAShB,YAAT,CAAsBX,QAAtB,EAAwC4B,aAAxC,EAA6D;EAC3D,MAAMlB,OAAO,GAAG,uCAAmBkB,aAAnB,EAAkC5B,QAAlC,CAAhB;EACA,OAAOU,OAAO,KAAKR,SAAZ,GAAwB,IAAI2B,MAAJ,CAAWnB,OAAX,CAAxB,GAA8C,MAArD;AACD;;AAED,SAASW,aAAT,CACES,OADF,EAEEC,UAFF,EAGEC,SAHF,EAGmB;EAEjB,KAAK,IAAIC,CAAC,GAAGH,OAAO,CAACJ,MAAR,GAAiB,CAA9B,EAAiCO,CAAC,IAAI,CAAtC,EAAyCA,CAAC,EAA1C,EAA8C;IAC5C,MAAMC,MAAM,GAAGJ,OAAO,CAACG,CAAD,CAAtB;IACA,MAAMvB,OAAO,GAAGqB,UAAU,CAACG,MAAD,CAA1B;;IAEA,IAAIxB,OAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAEyB,IAAT,CAAcH,SAAd,CAAJ,EAA8B;MAC5B,OAAOE,MAAP;IACD;EACF;AACF","names":["createModuleTypeClassifier","options","patterns","basePath","_basePath","undefined","replace","patternTypePairs","Object","entries","map","_pattern","type","pattern","parsePattern","classifications","package","moduleType","cjs","esm","auto","classifyModuleNonCached","path","matched","matchPatterns","_","classifyModule","classifyModuleAuto","classifyModuleByModuleTypeOverrides","length","exports","patternString","RegExp","objects","getPattern","candidate","i","object","test"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\ts-node\\src\\module-type-classifier.ts"],"sourcesContent":["import type { ModuleTypeOverride, ModuleTypes } from '.';\nimport { getPatternFromSpec } from './ts-internals';\nimport { cachedLookup, normalizeSlashes } from './util';\n\n// Logic to support our `moduleTypes` option, which allows overriding node's default ESM / CJS\n// classification of `.js` files based on package.json `type` field.\n\n/**\n * Seperate internal type because `auto` is clearer than `package`, but changing\n * the public API is a breaking change.\n * @internal\n */\nexport type InternalModuleTypeOverride = 'cjs' | 'esm' | 'auto';\n/** @internal */\nexport interface ModuleTypeClassification {\n  moduleType: InternalModuleTypeOverride;\n}\n/** @internal */\nexport interface ModuleTypeClassifierOptions {\n  basePath?: string;\n  patterns?: ModuleTypes;\n}\n/** @internal */\nexport type ModuleTypeClassifier = ReturnType<\n  typeof createModuleTypeClassifier\n>;\n/**\n * @internal\n * May receive non-normalized options -- basePath and patterns -- and will normalize them\n * internally.\n * However, calls to `classifyModule` must pass pre-normalized paths!\n */\nexport function createModuleTypeClassifier(\n  options: ModuleTypeClassifierOptions\n) {\n  const { patterns, basePath: _basePath } = options;\n  const basePath =\n    _basePath !== undefined\n      ? normalizeSlashes(_basePath).replace(/\\/$/, '')\n      : undefined;\n\n  const patternTypePairs = Object.entries(patterns ?? []).map(\n    ([_pattern, type]) => {\n      const pattern = normalizeSlashes(_pattern);\n      return { pattern: parsePattern(basePath!, pattern), type };\n    }\n  );\n\n  const classifications: Record<ModuleTypeOverride, ModuleTypeClassification> =\n    {\n      package: {\n        moduleType: 'auto',\n      },\n      cjs: {\n        moduleType: 'cjs',\n      },\n      esm: {\n        moduleType: 'esm',\n      },\n    };\n  const auto = classifications.package;\n\n  // Passed path must be normalized!\n  function classifyModuleNonCached(path: string): ModuleTypeClassification {\n    const matched = matchPatterns(patternTypePairs, (_) => _.pattern, path);\n    if (matched) return classifications[matched.type];\n    return auto;\n  }\n\n  const classifyModule = cachedLookup(classifyModuleNonCached);\n\n  function classifyModuleAuto(path: String) {\n    return auto;\n  }\n\n  return {\n    classifyModuleByModuleTypeOverrides: patternTypePairs.length\n      ? classifyModule\n      : classifyModuleAuto,\n  };\n}\n\nfunction parsePattern(basePath: string, patternString: string): RegExp {\n  const pattern = getPatternFromSpec(patternString, basePath);\n  return pattern !== undefined ? new RegExp(pattern) : /(?:)/;\n}\n\nfunction matchPatterns<T>(\n  objects: T[],\n  getPattern: (t: T) => RegExp,\n  candidate: string\n): T | undefined {\n  for (let i = objects.length - 1; i >= 0; i--) {\n    const object = objects[i];\n    const pattern = getPattern(object);\n\n    if (pattern?.test(candidate)) {\n      return object;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}