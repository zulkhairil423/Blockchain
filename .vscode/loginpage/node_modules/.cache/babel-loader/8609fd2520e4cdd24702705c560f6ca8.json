{"ast":null,"code":"import { addContextToFrame, basename, dirname, SyncPromise } from '@sentry/utils';\nimport { readFile } from 'fs';\nimport { LRUMap } from 'lru_map';\nimport * as stacktrace from './stacktrace';\nvar DEFAULT_LINES_OF_CONTEXT = 7;\nvar FILE_CONTENT_CACHE = new LRUMap(100);\n/**\n * Resets the file cache. Exists for testing purposes.\n * @hidden\n */\n\nexport function resetFileContentCache() {\n  FILE_CONTENT_CACHE.clear();\n}\n/** JSDoc */\n\nfunction getFunction(frame) {\n  try {\n    return frame.functionName || frame.typeName + \".\" + (frame.methodName || '<anonymous>');\n  } catch (e) {\n    // This seems to happen sometimes when using 'use strict',\n    // stemming from `getTypeName`.\n    // [TypeError: Cannot read property 'constructor' of undefined]\n    return '<anonymous>';\n  }\n}\n\nvar mainModule = (require.main && require.main.filename && dirname(require.main.filename) || global.process.cwd()) + \"/\";\n/** JSDoc */\n\nfunction getModule(filename, base) {\n  if (!base) {\n    // eslint-disable-next-line no-param-reassign\n    base = mainModule;\n  } // It's specifically a module\n\n\n  var file = basename(filename, '.js'); // eslint-disable-next-line no-param-reassign\n\n  filename = dirname(filename);\n  var n = filename.lastIndexOf('/node_modules/');\n\n  if (n > -1) {\n    // /node_modules/ is 14 chars\n    return filename.substr(n + 14).replace(/\\//g, '.') + \":\" + file;\n  } // Let's see if it's a part of the main module\n  // To be a part of main module, it has to share the same base\n\n\n  n = (filename + \"/\").lastIndexOf(base, 0);\n\n  if (n === 0) {\n    var moduleName = filename.substr(base.length).replace(/\\//g, '.');\n\n    if (moduleName) {\n      moduleName += ':';\n    }\n\n    moduleName += file;\n    return moduleName;\n  }\n\n  return file;\n}\n/**\n * This function reads file contents and caches them in a global LRU cache.\n * Returns a Promise filepath => content array for all files that we were able to read.\n *\n * @param filenames Array of filepaths to read content from.\n */\n\n\nfunction readSourceFiles(filenames) {\n  // we're relying on filenames being de-duped already\n  if (filenames.length === 0) {\n    return SyncPromise.resolve({});\n  }\n\n  return new SyncPromise(function (resolve) {\n    var sourceFiles = {};\n    var count = 0;\n\n    var _loop_1 = function (i) {\n      var filename = filenames[i];\n      var cache = FILE_CONTENT_CACHE.get(filename); // We have a cache hit\n\n      if (cache !== undefined) {\n        // If it's not null (which means we found a file and have a content)\n        // we set the content and return it later.\n        if (cache !== null) {\n          sourceFiles[filename] = cache;\n        } // eslint-disable-next-line no-plusplus\n\n\n        count++; // In any case we want to skip here then since we have a content already or we couldn't\n        // read the file and don't want to try again.\n\n        if (count === filenames.length) {\n          resolve(sourceFiles);\n        }\n\n        return \"continue\";\n      }\n\n      readFile(filename, function (err, data) {\n        var content = err ? null : data.toString();\n        sourceFiles[filename] = content; // We always want to set the cache, even to null which means there was an error reading the file.\n        // We do not want to try to read the file again.\n\n        FILE_CONTENT_CACHE.set(filename, content); // eslint-disable-next-line no-plusplus\n\n        count++;\n\n        if (count === filenames.length) {\n          resolve(sourceFiles);\n        }\n      });\n    }; // eslint-disable-next-line @typescript-eslint/prefer-for-of\n\n\n    for (var i = 0; i < filenames.length; i++) {\n      _loop_1(i);\n    }\n  });\n}\n/**\n * @hidden\n */\n\n\nexport function extractStackFromError(error) {\n  var stack = stacktrace.parse(error);\n\n  if (!stack) {\n    return [];\n  }\n\n  return stack;\n}\n/**\n * @hidden\n */\n\nexport function parseStack(stack, options) {\n  var filesToRead = [];\n  var linesOfContext = options && options.frameContextLines !== undefined ? options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;\n  var frames = stack.map(function (frame) {\n    var parsedFrame = {\n      colno: frame.columnNumber,\n      filename: frame.fileName || '',\n      function: getFunction(frame),\n      lineno: frame.lineNumber\n    };\n    var isInternal = frame.native || parsedFrame.filename && !parsedFrame.filename.startsWith('/') && !parsedFrame.filename.startsWith('.') && parsedFrame.filename.indexOf(':\\\\') !== 1; // in_app is all that's not an internal Node function or a module within node_modules\n    // note that isNative appears to return true even for node core libraries\n    // see https://github.com/getsentry/raven-node/issues/176\n\n    parsedFrame.in_app = !isInternal && parsedFrame.filename !== undefined && parsedFrame.filename.indexOf('node_modules/') === -1; // Extract a module name based on the filename\n\n    if (parsedFrame.filename) {\n      parsedFrame.module = getModule(parsedFrame.filename);\n\n      if (!isInternal && linesOfContext > 0 && filesToRead.indexOf(parsedFrame.filename) === -1) {\n        filesToRead.push(parsedFrame.filename);\n      }\n    }\n\n    return parsedFrame;\n  }); // We do an early return if we do not want to fetch context liens\n\n  if (linesOfContext <= 0) {\n    return SyncPromise.resolve(frames);\n  }\n\n  try {\n    return addPrePostContext(filesToRead, frames, linesOfContext);\n  } catch (_) {\n    // This happens in electron for example where we are not able to read files from asar.\n    // So it's fine, we recover be just returning all frames without pre/post context.\n    return SyncPromise.resolve(frames);\n  }\n}\n/**\n * This function tries to read the source files + adding pre and post context (source code)\n * to a frame.\n * @param filesToRead string[] of filepaths\n * @param frames StackFrame[] containg all frames\n */\n\nfunction addPrePostContext(filesToRead, frames, linesOfContext) {\n  return new SyncPromise(function (resolve) {\n    return readSourceFiles(filesToRead).then(function (sourceFiles) {\n      var result = frames.map(function (frame) {\n        if (frame.filename && sourceFiles[frame.filename]) {\n          try {\n            var lines = sourceFiles[frame.filename].split('\\n');\n            addContextToFrame(lines, frame, linesOfContext);\n          } catch (e) {// anomaly, being defensive in case\n            // unlikely to ever happen in practice but can definitely happen in theory\n          }\n        }\n\n        return frame;\n      });\n      resolve(result);\n    });\n  });\n}\n/**\n * @hidden\n */\n\n\nexport function getExceptionFromError(error, options) {\n  var name = error.name || error.constructor.name;\n  var stack = extractStackFromError(error);\n  return new SyncPromise(function (resolve) {\n    return parseStack(stack, options).then(function (frames) {\n      var result = {\n        stacktrace: {\n          frames: prepareFramesForEvent(frames)\n        },\n        type: name,\n        value: error.message\n      };\n      resolve(result);\n    });\n  });\n}\n/**\n * @hidden\n */\n\nexport function parseError(error, options) {\n  return new SyncPromise(function (resolve) {\n    return getExceptionFromError(error, options).then(function (exception) {\n      resolve({\n        exception: {\n          values: [exception]\n        }\n      });\n    });\n  });\n}\n/**\n * @hidden\n */\n\nexport function prepareFramesForEvent(stack) {\n  if (!stack || !stack.length) {\n    return [];\n  }\n\n  var localStack = stack;\n  var firstFrameFunction = localStack[0].function || '';\n\n  if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {\n    localStack = localStack.slice(1);\n  } // The frame where the crash happened, should be the last entry in the array\n\n\n  return localStack.reverse();\n}","map":{"version":3,"mappings":"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","names":["addContextToFrame","basename","dirname","SyncPromise","readFile","LRUMap","stacktrace","DEFAULT_LINES_OF_CONTEXT","FILE_CONTENT_CACHE","resetFileContentCache","clear","getFunction","frame","functionName","typeName","methodName","e","mainModule","require","main","filename","global","process","cwd","getModule","base","file","n","lastIndexOf","substr","replace","moduleName","length","readSourceFiles","filenames","resolve","sourceFiles","count","i","cache","get","undefined","err","data","content","toString","set","extractStackFromError","error","stack","parse","parseStack","options","filesToRead","linesOfContext","frameContextLines","frames","map","parsedFrame","colno","columnNumber","fileName","function","lineno","lineNumber","isInternal","native","startsWith","indexOf","in_app","module","push","addPrePostContext","_","then","result","lines","split","getExceptionFromError","name","constructor","prepareFramesForEvent","type","value","message","parseError","exception","values","localStack","firstFrameFunction","slice","reverse"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\@sentry\\node\\src\\parsers.ts"],"sourcesContent":["import { Event, Exception, ExtendedError, StackFrame } from '@sentry/types';\nimport { addContextToFrame, basename, dirname, SyncPromise } from '@sentry/utils';\nimport { readFile } from 'fs';\nimport { LRUMap } from 'lru_map';\n\nimport { NodeOptions } from './backend';\nimport * as stacktrace from './stacktrace';\n\nconst DEFAULT_LINES_OF_CONTEXT: number = 7;\nconst FILE_CONTENT_CACHE = new LRUMap<string, string | null>(100);\n\n/**\n * Resets the file cache. Exists for testing purposes.\n * @hidden\n */\nexport function resetFileContentCache(): void {\n  FILE_CONTENT_CACHE.clear();\n}\n\n/** JSDoc */\nfunction getFunction(frame: stacktrace.StackFrame): string {\n  try {\n    return frame.functionName || `${frame.typeName}.${frame.methodName || '<anonymous>'}`;\n  } catch (e) {\n    // This seems to happen sometimes when using 'use strict',\n    // stemming from `getTypeName`.\n    // [TypeError: Cannot read property 'constructor' of undefined]\n    return '<anonymous>';\n  }\n}\n\nconst mainModule: string = `${(require.main && require.main.filename && dirname(require.main.filename)) ||\n  global.process.cwd()}/`;\n\n/** JSDoc */\nfunction getModule(filename: string, base?: string): string {\n  if (!base) {\n    // eslint-disable-next-line no-param-reassign\n    base = mainModule;\n  }\n\n  // It's specifically a module\n  const file = basename(filename, '.js');\n  // eslint-disable-next-line no-param-reassign\n  filename = dirname(filename);\n  let n = filename.lastIndexOf('/node_modules/');\n  if (n > -1) {\n    // /node_modules/ is 14 chars\n    return `${filename.substr(n + 14).replace(/\\//g, '.')}:${file}`;\n  }\n  // Let's see if it's a part of the main module\n  // To be a part of main module, it has to share the same base\n  n = `${filename}/`.lastIndexOf(base, 0);\n  if (n === 0) {\n    let moduleName = filename.substr(base.length).replace(/\\//g, '.');\n    if (moduleName) {\n      moduleName += ':';\n    }\n    moduleName += file;\n    return moduleName;\n  }\n  return file;\n}\n\n/**\n * This function reads file contents and caches them in a global LRU cache.\n * Returns a Promise filepath => content array for all files that we were able to read.\n *\n * @param filenames Array of filepaths to read content from.\n */\nfunction readSourceFiles(filenames: string[]): PromiseLike<{ [key: string]: string | null }> {\n  // we're relying on filenames being de-duped already\n  if (filenames.length === 0) {\n    return SyncPromise.resolve({});\n  }\n\n  return new SyncPromise<{\n    [key: string]: string | null;\n  }>(resolve => {\n    const sourceFiles: {\n      [key: string]: string | null;\n    } = {};\n\n    let count = 0;\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (let i = 0; i < filenames.length; i++) {\n      const filename = filenames[i];\n\n      const cache = FILE_CONTENT_CACHE.get(filename);\n      // We have a cache hit\n      if (cache !== undefined) {\n        // If it's not null (which means we found a file and have a content)\n        // we set the content and return it later.\n        if (cache !== null) {\n          sourceFiles[filename] = cache;\n        }\n        // eslint-disable-next-line no-plusplus\n        count++;\n        // In any case we want to skip here then since we have a content already or we couldn't\n        // read the file and don't want to try again.\n        if (count === filenames.length) {\n          resolve(sourceFiles);\n        }\n        continue;\n      }\n\n      readFile(filename, (err: Error | null, data: Buffer) => {\n        const content = err ? null : data.toString();\n        sourceFiles[filename] = content;\n\n        // We always want to set the cache, even to null which means there was an error reading the file.\n        // We do not want to try to read the file again.\n        FILE_CONTENT_CACHE.set(filename, content);\n        // eslint-disable-next-line no-plusplus\n        count++;\n        if (count === filenames.length) {\n          resolve(sourceFiles);\n        }\n      });\n    }\n  });\n}\n\n/**\n * @hidden\n */\nexport function extractStackFromError(error: Error): stacktrace.StackFrame[] {\n  const stack = stacktrace.parse(error);\n  if (!stack) {\n    return [];\n  }\n  return stack;\n}\n\n/**\n * @hidden\n */\nexport function parseStack(stack: stacktrace.StackFrame[], options?: NodeOptions): PromiseLike<StackFrame[]> {\n  const filesToRead: string[] = [];\n\n  const linesOfContext =\n    options && options.frameContextLines !== undefined ? options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;\n\n  const frames: StackFrame[] = stack.map(frame => {\n    const parsedFrame: StackFrame = {\n      colno: frame.columnNumber,\n      filename: frame.fileName || '',\n      function: getFunction(frame),\n      lineno: frame.lineNumber,\n    };\n\n    const isInternal =\n      frame.native ||\n      (parsedFrame.filename &&\n        !parsedFrame.filename.startsWith('/') &&\n        !parsedFrame.filename.startsWith('.') &&\n        parsedFrame.filename.indexOf(':\\\\') !== 1);\n\n    // in_app is all that's not an internal Node function or a module within node_modules\n    // note that isNative appears to return true even for node core libraries\n    // see https://github.com/getsentry/raven-node/issues/176\n    parsedFrame.in_app =\n      !isInternal && parsedFrame.filename !== undefined && parsedFrame.filename.indexOf('node_modules/') === -1;\n\n    // Extract a module name based on the filename\n    if (parsedFrame.filename) {\n      parsedFrame.module = getModule(parsedFrame.filename);\n\n      if (!isInternal && linesOfContext > 0 && filesToRead.indexOf(parsedFrame.filename) === -1) {\n        filesToRead.push(parsedFrame.filename);\n      }\n    }\n\n    return parsedFrame;\n  });\n\n  // We do an early return if we do not want to fetch context liens\n  if (linesOfContext <= 0) {\n    return SyncPromise.resolve(frames);\n  }\n\n  try {\n    return addPrePostContext(filesToRead, frames, linesOfContext);\n  } catch (_) {\n    // This happens in electron for example where we are not able to read files from asar.\n    // So it's fine, we recover be just returning all frames without pre/post context.\n    return SyncPromise.resolve(frames);\n  }\n}\n\n/**\n * This function tries to read the source files + adding pre and post context (source code)\n * to a frame.\n * @param filesToRead string[] of filepaths\n * @param frames StackFrame[] containg all frames\n */\nfunction addPrePostContext(\n  filesToRead: string[],\n  frames: StackFrame[],\n  linesOfContext: number,\n): PromiseLike<StackFrame[]> {\n  return new SyncPromise<StackFrame[]>(resolve =>\n    readSourceFiles(filesToRead).then(sourceFiles => {\n      const result = frames.map(frame => {\n        if (frame.filename && sourceFiles[frame.filename]) {\n          try {\n            const lines = (sourceFiles[frame.filename] as string).split('\\n');\n\n            addContextToFrame(lines, frame, linesOfContext);\n          } catch (e) {\n            // anomaly, being defensive in case\n            // unlikely to ever happen in practice but can definitely happen in theory\n          }\n        }\n        return frame;\n      });\n\n      resolve(result);\n    }),\n  );\n}\n\n/**\n * @hidden\n */\nexport function getExceptionFromError(error: Error, options?: NodeOptions): PromiseLike<Exception> {\n  const name = error.name || error.constructor.name;\n  const stack = extractStackFromError(error);\n  return new SyncPromise<Exception>(resolve =>\n    parseStack(stack, options).then(frames => {\n      const result = {\n        stacktrace: {\n          frames: prepareFramesForEvent(frames),\n        },\n        type: name,\n        value: error.message,\n      };\n      resolve(result);\n    }),\n  );\n}\n\n/**\n * @hidden\n */\nexport function parseError(error: ExtendedError, options?: NodeOptions): PromiseLike<Event> {\n  return new SyncPromise<Event>(resolve =>\n    getExceptionFromError(error, options).then((exception: Exception) => {\n      resolve({\n        exception: {\n          values: [exception],\n        },\n      });\n    }),\n  );\n}\n\n/**\n * @hidden\n */\nexport function prepareFramesForEvent(stack: StackFrame[]): StackFrame[] {\n  if (!stack || !stack.length) {\n    return [];\n  }\n\n  let localStack = stack;\n  const firstFrameFunction = localStack[0].function || '';\n\n  if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {\n    localStack = localStack.slice(1);\n  }\n\n  // The frame where the crash happened, should be the last entry in the array\n  return localStack.reverse();\n}\n"]},"metadata":{},"sourceType":"module"}