{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.accountBodyToRLP = exports.accountBodyToSlim = exports.accountBodyFromSlim = exports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\n\nconst ethereumjs_rlp_1 = require(\"@nomicfoundation/ethereumjs-rlp\");\n\nconst keccak_1 = require(\"ethereum-cryptography/keccak\");\n\nconst secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\n\nconst bytes_1 = require(\"./bytes\");\n\nconst constants_1 = require(\"./constants\");\n\nconst helpers_1 = require(\"./helpers\");\n\nconst internal_1 = require(\"./internal\");\n\nconst _0n = BigInt(0);\n\nclass Account {\n  /**\n   * This constructor assigns and validates the values.\n   * Use the static factory methods to assist in creating an Account from varying data types.\n   */\n  constructor() {\n    let nonce = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _0n;\n    let balance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _0n;\n    let storageRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : constants_1.KECCAK256_RLP;\n    let codeHash = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : constants_1.KECCAK256_NULL;\n    this.nonce = nonce;\n    this.balance = balance;\n    this.storageRoot = storageRoot;\n    this.codeHash = codeHash;\n\n    this._validate();\n  }\n\n  static fromAccountData(accountData) {\n    const {\n      nonce,\n      balance,\n      storageRoot,\n      codeHash\n    } = accountData;\n    return new Account(nonce !== undefined ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(nonce)) : undefined, balance !== undefined ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(balance)) : undefined, storageRoot !== undefined ? (0, bytes_1.toBuffer)(storageRoot) : undefined, codeHash !== undefined ? (0, bytes_1.toBuffer)(codeHash) : undefined);\n  }\n\n  static fromRlpSerializedAccount(serialized) {\n    const values = (0, bytes_1.arrToBufArr)(ethereumjs_rlp_1.RLP.decode(Uint8Array.from(serialized)));\n\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized account input. Must be array');\n    }\n\n    return this.fromValuesArray(values);\n  }\n\n  static fromValuesArray(values) {\n    const [nonce, balance, storageRoot, codeHash] = values;\n    return new Account((0, bytes_1.bufferToBigInt)(nonce), (0, bytes_1.bufferToBigInt)(balance), storageRoot, codeHash);\n  }\n\n  _validate() {\n    if (this.nonce < _0n) {\n      throw new Error('nonce must be greater than zero');\n    }\n\n    if (this.balance < _0n) {\n      throw new Error('balance must be greater than zero');\n    }\n\n    if (this.storageRoot.length !== 32) {\n      throw new Error('storageRoot must have a length of 32');\n    }\n\n    if (this.codeHash.length !== 32) {\n      throw new Error('codeHash must have a length of 32');\n    }\n  }\n  /**\n   * Returns a Buffer Array of the raw Buffers for the account, in order.\n   */\n\n\n  raw() {\n    return [(0, bytes_1.bigIntToUnpaddedBuffer)(this.nonce), (0, bytes_1.bigIntToUnpaddedBuffer)(this.balance), this.storageRoot, this.codeHash];\n  }\n  /**\n   * Returns the RLP serialization of the account as a `Buffer`.\n   */\n\n\n  serialize() {\n    return Buffer.from(ethereumjs_rlp_1.RLP.encode((0, bytes_1.bufArrToArr)(this.raw())));\n  }\n  /**\n   * Returns a `Boolean` determining if the account is a contract.\n   */\n\n\n  isContract() {\n    return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n  }\n  /**\n   * Returns a `Boolean` determining if the account is empty complying to the definition of\n   * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n   * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n   */\n\n\n  isEmpty() {\n    return this.balance === _0n && this.nonce === _0n && this.codeHash.equals(constants_1.KECCAK256_NULL);\n  }\n\n}\n\nexports.Account = Account;\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\n\nconst isValidAddress = function (hexAddress) {\n  try {\n    (0, helpers_1.assertIsString)(hexAddress);\n  } catch (e) {\n    return false;\n  }\n\n  return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\n\nexports.isValidAddress = isValidAddress;\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */\n\nconst toChecksumAddress = function (hexAddress, eip1191ChainId) {\n  (0, helpers_1.assertIsHexString)(hexAddress);\n  const address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();\n  let prefix = '';\n\n  if (eip1191ChainId !== undefined) {\n    const chainId = (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(eip1191ChainId));\n    prefix = chainId.toString() + '0x';\n  }\n\n  const buf = Buffer.from(prefix + address, 'utf8');\n  const hash = (0, keccak_1.keccak256)(buf).toString('hex');\n  let ret = '0x';\n\n  for (let i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase();\n    } else {\n      ret += address[i];\n    }\n  }\n\n  return ret;\n};\n\nexports.toChecksumAddress = toChecksumAddress;\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\n\nconst isValidChecksumAddress = function (hexAddress, eip1191ChainId) {\n  return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;\n};\n\nexports.isValidChecksumAddress = isValidChecksumAddress;\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\n\nconst generateAddress = function (from, nonce) {\n  (0, helpers_1.assertIsBuffer)(from);\n  (0, helpers_1.assertIsBuffer)(nonce);\n\n  if ((0, bytes_1.bufferToBigInt)(nonce) === BigInt(0)) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return Buffer.from((0, keccak_1.keccak256)((0, bytes_1.arrToBufArr)(ethereumjs_rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, null]))))).slice(-20);\n  } // Only take the lower 160bits of the hash\n\n\n  return Buffer.from((0, keccak_1.keccak256)((0, bytes_1.arrToBufArr)(ethereumjs_rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, nonce]))))).slice(-20);\n};\n\nexports.generateAddress = generateAddress;\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\n\nconst generateAddress2 = function (from, salt, initCode) {\n  (0, helpers_1.assertIsBuffer)(from);\n  (0, helpers_1.assertIsBuffer)(salt);\n  (0, helpers_1.assertIsBuffer)(initCode);\n\n  if (from.length !== 20) {\n    throw new Error('Expected from to be of length 20');\n  }\n\n  if (salt.length !== 32) {\n    throw new Error('Expected salt to be of length 32');\n  }\n\n  const address = (0, keccak_1.keccak256)(Buffer.concat([Buffer.from('ff', 'hex'), from, salt, (0, keccak_1.keccak256)(initCode)]));\n  return (0, bytes_1.toBuffer)(address).slice(-20);\n};\n\nexports.generateAddress2 = generateAddress2;\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\n\nconst isValidPrivate = function (privateKey) {\n  return (0, secp256k1_1.privateKeyVerify)(privateKey);\n};\n\nexports.isValidPrivate = isValidPrivate;\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\n\nconst isValidPublic = function (publicKey) {\n  let sanitize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  (0, helpers_1.assertIsBuffer)(publicKey);\n\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    return (0, secp256k1_1.publicKeyVerify)(Buffer.concat([Buffer.from([4]), publicKey]));\n  }\n\n  if (!sanitize) {\n    return false;\n  }\n\n  return (0, secp256k1_1.publicKeyVerify)(publicKey);\n};\n\nexports.isValidPublic = isValidPublic;\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\n\nconst pubToAddress = function (pubKey) {\n  let sanitize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  (0, helpers_1.assertIsBuffer)(pubKey);\n\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(pubKey, false).slice(1));\n  }\n\n  if (pubKey.length !== 64) {\n    throw new Error('Expected pubKey to be of length 64');\n  } // Only take the lower 160bits of the hash\n\n\n  return Buffer.from((0, keccak_1.keccak256)(pubKey)).slice(-20);\n};\n\nexports.pubToAddress = pubToAddress;\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\n\nconst privateToPublic = function (privateKey) {\n  (0, helpers_1.assertIsBuffer)(privateKey); // skip the type flag and use the X, Y points\n\n  return Buffer.from((0, secp256k1_1.publicKeyCreate)(privateKey, false)).slice(1);\n};\n\nexports.privateToPublic = privateToPublic;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\n\nconst privateToAddress = function (privateKey) {\n  return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));\n};\n\nexports.privateToAddress = privateToAddress;\n/**\n * Converts a public key to the Ethereum format.\n */\n\nconst importPublic = function (publicKey) {\n  (0, helpers_1.assertIsBuffer)(publicKey);\n\n  if (publicKey.length !== 64) {\n    publicKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(publicKey, false).slice(1));\n  }\n\n  return publicKey;\n};\n\nexports.importPublic = importPublic;\n/**\n * Returns the zero address.\n */\n\nconst zeroAddress = function () {\n  const addressLength = 20;\n  const addr = (0, bytes_1.zeros)(addressLength);\n  return (0, bytes_1.bufferToHex)(addr);\n};\n\nexports.zeroAddress = zeroAddress;\n/**\n * Checks if a given address is the zero address.\n */\n\nconst isZeroAddress = function (hexAddress) {\n  try {\n    (0, helpers_1.assertIsString)(hexAddress);\n  } catch (e) {\n    return false;\n  }\n\n  const zeroAddr = (0, exports.zeroAddress)();\n  return zeroAddr === hexAddress;\n};\n\nexports.isZeroAddress = isZeroAddress;\n\nfunction accountBodyFromSlim(body) {\n  const [nonce, balance, storageRoot, codeHash] = body;\n  return [nonce, balance, (0, bytes_1.arrToBufArr)(storageRoot).length === 0 ? constants_1.KECCAK256_RLP : storageRoot, (0, bytes_1.arrToBufArr)(codeHash).length === 0 ? constants_1.KECCAK256_NULL : codeHash];\n}\n\nexports.accountBodyFromSlim = accountBodyFromSlim;\nconst emptyUint8Arr = new Uint8Array(0);\n\nfunction accountBodyToSlim(body) {\n  const [nonce, balance, storageRoot, codeHash] = body;\n  return [nonce, balance, (0, bytes_1.arrToBufArr)(storageRoot).equals(constants_1.KECCAK256_RLP) ? emptyUint8Arr : storageRoot, (0, bytes_1.arrToBufArr)(codeHash).equals(constants_1.KECCAK256_NULL) ? emptyUint8Arr : codeHash];\n}\n\nexports.accountBodyToSlim = accountBodyToSlim;\n/**\n * Converts a slim account RLP to a normal account RLP\n */\n\nfunction accountBodyToRLP(body) {\n  let couldBeSlim = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  const accountBody = couldBeSlim ? accountBodyFromSlim(body) : body;\n  return (0, bytes_1.arrToBufArr)(ethereumjs_rlp_1.RLP.encode(accountBody));\n}\n\nexports.accountBodyToRLP = accountBodyToRLP;","map":{"version":3,"mappings":"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","names":["_0n","BigInt","Account","constructor","nonce","balance","storageRoot","constants_1","codeHash","_validate","fromAccountData","accountData","undefined","fromRlpSerializedAccount","serialized","values","ethereumjs_rlp_1","decode","Uint8Array","from","Array","isArray","Error","fromValuesArray","length","raw","serialize","Buffer","encode","isContract","equals","isEmpty","exports","isValidAddress","hexAddress","e","test","toChecksumAddress","eip1191ChainId","address","toLowerCase","prefix","chainId","toString","buf","hash","ret","i","parseInt","toUpperCase","isValidChecksumAddress","generateAddress","slice","generateAddress2","salt","initCode","concat","isValidPrivate","privateKey","isValidPublic","publicKey","sanitize","pubToAddress","pubKey","privateToPublic","privateToAddress","importPublic","zeroAddress","addressLength","addr","isZeroAddress","zeroAddr","accountBodyFromSlim","body","emptyUint8Arr","accountBodyToSlim","accountBodyToRLP","couldBeSlim","accountBody"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\@nomicfoundation\\ethereumjs-util\\src\\account.ts"],"sourcesContent":["import { RLP } from '@nomicfoundation/ethereumjs-rlp'\nimport { keccak256 } from 'ethereum-cryptography/keccak'\nimport {\n  privateKeyVerify,\n  publicKeyConvert,\n  publicKeyCreate,\n  publicKeyVerify,\n} from 'ethereum-cryptography/secp256k1'\n\nimport {\n  arrToBufArr,\n  bigIntToUnpaddedBuffer,\n  bufArrToArr,\n  bufferToBigInt,\n  bufferToHex,\n  toBuffer,\n  zeros,\n} from './bytes'\nimport { KECCAK256_NULL, KECCAK256_RLP } from './constants'\nimport { assertIsBuffer, assertIsHexString, assertIsString } from './helpers'\nimport { stripHexPrefix } from './internal'\n\nimport type { BigIntLike, BufferLike } from './types'\n\nconst _0n = BigInt(0)\n\nexport interface AccountData {\n  nonce?: BigIntLike\n  balance?: BigIntLike\n  storageRoot?: BufferLike\n  codeHash?: BufferLike\n}\n\nexport type AccountBodyBuffer = [Buffer, Buffer, Buffer | Uint8Array, Buffer | Uint8Array]\n\nexport class Account {\n  nonce: bigint\n  balance: bigint\n  storageRoot: Buffer\n  codeHash: Buffer\n\n  static fromAccountData(accountData: AccountData) {\n    const { nonce, balance, storageRoot, codeHash } = accountData\n\n    return new Account(\n      nonce !== undefined ? bufferToBigInt(toBuffer(nonce)) : undefined,\n      balance !== undefined ? bufferToBigInt(toBuffer(balance)) : undefined,\n      storageRoot !== undefined ? toBuffer(storageRoot) : undefined,\n      codeHash !== undefined ? toBuffer(codeHash) : undefined\n    )\n  }\n\n  public static fromRlpSerializedAccount(serialized: Buffer) {\n    const values = arrToBufArr(RLP.decode(Uint8Array.from(serialized)) as Uint8Array[]) as Buffer[]\n\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized account input. Must be array')\n    }\n\n    return this.fromValuesArray(values)\n  }\n\n  public static fromValuesArray(values: Buffer[]) {\n    const [nonce, balance, storageRoot, codeHash] = values\n\n    return new Account(bufferToBigInt(nonce), bufferToBigInt(balance), storageRoot, codeHash)\n  }\n\n  /**\n   * This constructor assigns and validates the values.\n   * Use the static factory methods to assist in creating an Account from varying data types.\n   */\n  constructor(nonce = _0n, balance = _0n, storageRoot = KECCAK256_RLP, codeHash = KECCAK256_NULL) {\n    this.nonce = nonce\n    this.balance = balance\n    this.storageRoot = storageRoot\n    this.codeHash = codeHash\n\n    this._validate()\n  }\n\n  private _validate() {\n    if (this.nonce < _0n) {\n      throw new Error('nonce must be greater than zero')\n    }\n    if (this.balance < _0n) {\n      throw new Error('balance must be greater than zero')\n    }\n    if (this.storageRoot.length !== 32) {\n      throw new Error('storageRoot must have a length of 32')\n    }\n    if (this.codeHash.length !== 32) {\n      throw new Error('codeHash must have a length of 32')\n    }\n  }\n\n  /**\n   * Returns a Buffer Array of the raw Buffers for the account, in order.\n   */\n  raw(): Buffer[] {\n    return [\n      bigIntToUnpaddedBuffer(this.nonce),\n      bigIntToUnpaddedBuffer(this.balance),\n      this.storageRoot,\n      this.codeHash,\n    ]\n  }\n\n  /**\n   * Returns the RLP serialization of the account as a `Buffer`.\n   */\n  serialize(): Buffer {\n    return Buffer.from(RLP.encode(bufArrToArr(this.raw())))\n  }\n\n  /**\n   * Returns a `Boolean` determining if the account is a contract.\n   */\n  isContract(): boolean {\n    return !this.codeHash.equals(KECCAK256_NULL)\n  }\n\n  /**\n   * Returns a `Boolean` determining if the account is empty complying to the definition of\n   * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n   * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n   */\n  isEmpty(): boolean {\n    return this.balance === _0n && this.nonce === _0n && this.codeHash.equals(KECCAK256_NULL)\n  }\n}\n\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nexport const isValidAddress = function (hexAddress: string): boolean {\n  try {\n    assertIsString(hexAddress)\n  } catch (e: any) {\n    return false\n  }\n\n  return /^0x[0-9a-fA-F]{40}$/.test(hexAddress)\n}\n\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */\nexport const toChecksumAddress = function (\n  hexAddress: string,\n  eip1191ChainId?: BigIntLike\n): string {\n  assertIsHexString(hexAddress)\n  const address = stripHexPrefix(hexAddress).toLowerCase()\n\n  let prefix = ''\n  if (eip1191ChainId !== undefined) {\n    const chainId = bufferToBigInt(toBuffer(eip1191ChainId))\n    prefix = chainId.toString() + '0x'\n  }\n\n  const buf = Buffer.from(prefix + address, 'utf8')\n  const hash = keccak256(buf).toString('hex')\n  let ret = '0x'\n\n  for (let i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase()\n    } else {\n      ret += address[i]\n    }\n  }\n\n  return ret\n}\n\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nexport const isValidChecksumAddress = function (\n  hexAddress: string,\n  eip1191ChainId?: BigIntLike\n): boolean {\n  return isValidAddress(hexAddress) && toChecksumAddress(hexAddress, eip1191ChainId) === hexAddress\n}\n\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nexport const generateAddress = function (from: Buffer, nonce: Buffer): Buffer {\n  assertIsBuffer(from)\n  assertIsBuffer(nonce)\n\n  if (bufferToBigInt(nonce) === BigInt(0)) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return Buffer.from(keccak256(arrToBufArr(RLP.encode(bufArrToArr([from, null] as any))))).slice(\n      -20\n    )\n  }\n\n  // Only take the lower 160bits of the hash\n  return Buffer.from(keccak256(arrToBufArr(RLP.encode(bufArrToArr([from, nonce]))))).slice(-20)\n}\n\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nexport const generateAddress2 = function (from: Buffer, salt: Buffer, initCode: Buffer): Buffer {\n  assertIsBuffer(from)\n  assertIsBuffer(salt)\n  assertIsBuffer(initCode)\n\n  if (from.length !== 20) {\n    throw new Error('Expected from to be of length 20')\n  }\n  if (salt.length !== 32) {\n    throw new Error('Expected salt to be of length 32')\n  }\n\n  const address = keccak256(\n    Buffer.concat([Buffer.from('ff', 'hex'), from, salt, keccak256(initCode)])\n  )\n\n  return toBuffer(address).slice(-20)\n}\n\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nexport const isValidPrivate = function (privateKey: Buffer): boolean {\n  return privateKeyVerify(privateKey)\n}\n\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexport const isValidPublic = function (publicKey: Buffer, sanitize: boolean = false): boolean {\n  assertIsBuffer(publicKey)\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    return publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]))\n  }\n\n  if (!sanitize) {\n    return false\n  }\n\n  return publicKeyVerify(publicKey)\n}\n\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexport const pubToAddress = function (pubKey: Buffer, sanitize: boolean = false): Buffer {\n  assertIsBuffer(pubKey)\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = Buffer.from(publicKeyConvert(pubKey, false).slice(1))\n  }\n  if (pubKey.length !== 64) {\n    throw new Error('Expected pubKey to be of length 64')\n  }\n  // Only take the lower 160bits of the hash\n  return Buffer.from(keccak256(pubKey)).slice(-20)\n}\nexport const publicToAddress = pubToAddress\n\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexport const privateToPublic = function (privateKey: Buffer): Buffer {\n  assertIsBuffer(privateKey)\n  // skip the type flag and use the X, Y points\n  return Buffer.from(publicKeyCreate(privateKey, false)).slice(1)\n}\n\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexport const privateToAddress = function (privateKey: Buffer): Buffer {\n  return publicToAddress(privateToPublic(privateKey))\n}\n\n/**\n * Converts a public key to the Ethereum format.\n */\nexport const importPublic = function (publicKey: Buffer): Buffer {\n  assertIsBuffer(publicKey)\n  if (publicKey.length !== 64) {\n    publicKey = Buffer.from(publicKeyConvert(publicKey, false).slice(1))\n  }\n  return publicKey\n}\n\n/**\n * Returns the zero address.\n */\nexport const zeroAddress = function (): string {\n  const addressLength = 20\n  const addr = zeros(addressLength)\n  return bufferToHex(addr)\n}\n\n/**\n * Checks if a given address is the zero address.\n */\nexport const isZeroAddress = function (hexAddress: string): boolean {\n  try {\n    assertIsString(hexAddress)\n  } catch (e: any) {\n    return false\n  }\n\n  const zeroAddr = zeroAddress()\n  return zeroAddr === hexAddress\n}\n\nexport function accountBodyFromSlim(body: AccountBodyBuffer) {\n  const [nonce, balance, storageRoot, codeHash] = body\n  return [\n    nonce,\n    balance,\n    arrToBufArr(storageRoot).length === 0 ? KECCAK256_RLP : storageRoot,\n    arrToBufArr(codeHash).length === 0 ? KECCAK256_NULL : codeHash,\n  ]\n}\n\nconst emptyUint8Arr = new Uint8Array(0)\nexport function accountBodyToSlim(body: AccountBodyBuffer) {\n  const [nonce, balance, storageRoot, codeHash] = body\n  return [\n    nonce,\n    balance,\n    arrToBufArr(storageRoot).equals(KECCAK256_RLP) ? emptyUint8Arr : storageRoot,\n    arrToBufArr(codeHash).equals(KECCAK256_NULL) ? emptyUint8Arr : codeHash,\n  ]\n}\n\n/**\n * Converts a slim account RLP to a normal account RLP\n */\nexport function accountBodyToRLP(body: AccountBodyBuffer, couldBeSlim = true) {\n  const accountBody = couldBeSlim ? accountBodyFromSlim(body) : body\n  return arrToBufArr(RLP.encode(accountBody))\n}\n"]},"metadata":{},"sourceType":"script"}