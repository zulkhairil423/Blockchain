{"ast":null,"code":"import { __rest } from \"tslib\";\n/** Creates a SentryRequest from an event. */\n\nexport function sessionToSentryRequest(session, api) {\n  var envelopeHeaders = JSON.stringify({\n    sent_at: new Date().toISOString()\n  });\n  var itemHeaders = JSON.stringify({\n    type: 'session'\n  });\n  return {\n    body: envelopeHeaders + \"\\n\" + itemHeaders + \"\\n\" + JSON.stringify(session),\n    type: 'session',\n    url: api.getEnvelopeEndpointWithUrlEncodedAuth()\n  };\n}\n/** Creates a SentryRequest from an event. */\n\nexport function eventToSentryRequest(event, api) {\n  // since JS has no Object.prototype.pop()\n  var _a = event.tags || {},\n      samplingMethod = _a.__sentry_samplingMethod,\n      sampleRate = _a.__sentry_sampleRate,\n      otherTags = __rest(_a, [\"__sentry_samplingMethod\", \"__sentry_sampleRate\"]);\n\n  event.tags = otherTags;\n  var useEnvelope = event.type === 'transaction';\n  var req = {\n    body: JSON.stringify(event),\n    type: event.type || 'event',\n    url: useEnvelope ? api.getEnvelopeEndpointWithUrlEncodedAuth() : api.getStoreEndpointWithUrlEncodedAuth()\n  }; // https://develop.sentry.dev/sdk/envelopes/\n  // Since we don't need to manipulate envelopes nor store them, there is no\n  // exported concept of an Envelope with operations including serialization and\n  // deserialization. Instead, we only implement a minimal subset of the spec to\n  // serialize events inline here.\n\n  if (useEnvelope) {\n    var envelopeHeaders = JSON.stringify({\n      event_id: event.event_id,\n      sent_at: new Date().toISOString()\n    });\n    var itemHeaders = JSON.stringify({\n      type: event.type,\n      // TODO: Right now, sampleRate may or may not be defined (it won't be in the cases of inheritance and\n      // explicitly-set sampling decisions). Are we good with that?\n      sample_rates: [{\n        id: samplingMethod,\n        rate: sampleRate\n      }]\n    }); // The trailing newline is optional. We intentionally don't send it to avoid\n    // sending unnecessary bytes.\n    //\n    // const envelope = `${envelopeHeaders}\\n${itemHeaders}\\n${req.body}\\n`;\n\n    var envelope = envelopeHeaders + \"\\n\" + itemHeaders + \"\\n\" + req.body;\n    req.body = envelope;\n  }\n\n  return req;\n}","map":{"version":3,"mappings":";AAIA;;AACA,OAAM,SAAUA,sBAAV,CAAiCC,OAAjC,EAAmDC,GAAnD,EAA2D;EAC/D,IAAMC,eAAe,GAAGC,IAAI,CAACC,SAAL,CAAe;IACrCC,OAAO,EAAE,IAAIC,IAAJ,GAAWC,WAAX;EAD4B,CAAf,CAAxB;EAGA,IAAMC,WAAW,GAAGL,IAAI,CAACC,SAAL,CAAe;IACjCK,IAAI,EAAE;EAD2B,CAAf,CAApB;EAIA,OAAO;IACLC,IAAI,EAAKR,eAAe,OAAf,GAAoBM,WAApB,GAA+B,IAA/B,GAAoCL,IAAI,CAACC,SAAL,CAAeJ,OAAf,CADxC;IAELS,IAAI,EAAE,SAFD;IAGLE,GAAG,EAAEV,GAAG,CAACW,qCAAJ;EAHA,CAAP;AAKD;AAED;;AACA,OAAM,SAAUC,oBAAV,CAA+BC,KAA/B,EAA6Cb,GAA7C,EAAqD;EACzD;EACA,IAAMc,qBAAN;EAAA,IAAQC,2CAAR;EAAA,IAAiDC,mCAAjD;EAAA,IAAkFC,0EAAlF;;EACAJ,KAAK,CAACK,IAAN,GAAaD,SAAb;EAEA,IAAME,WAAW,GAAGN,KAAK,CAACL,IAAN,KAAe,aAAnC;EAEA,IAAMY,GAAG,GAAkB;IACzBX,IAAI,EAAEP,IAAI,CAACC,SAAL,CAAeU,KAAf,CADmB;IAEzBL,IAAI,EAAEK,KAAK,CAACL,IAAN,IAAc,OAFK;IAGzBE,GAAG,EAAES,WAAW,GAAGnB,GAAG,CAACW,qCAAJ,EAAH,GAAiDX,GAAG,CAACqB,kCAAJ;EAHxC,CAA3B,CAPyD,CAazD;EAEA;EACA;EACA;EACA;;EACA,IAAIF,WAAJ,EAAiB;IACf,IAAMlB,eAAe,GAAGC,IAAI,CAACC,SAAL,CAAe;MACrCmB,QAAQ,EAAET,KAAK,CAACS,QADqB;MAErClB,OAAO,EAAE,IAAIC,IAAJ,GAAWC,WAAX;IAF4B,CAAf,CAAxB;IAIA,IAAMC,WAAW,GAAGL,IAAI,CAACC,SAAL,CAAe;MACjCK,IAAI,EAAEK,KAAK,CAACL,IADqB;MAGjC;MACA;MACAe,YAAY,EAAE,CAAC;QAAEC,EAAE,EAAET,cAAN;QAAsBU,IAAI,EAAET;MAA5B,CAAD;IALmB,CAAf,CAApB,CALe,CA0Bf;IACA;IACA;IACA;;IACA,IAAMU,QAAQ,GAAMzB,eAAe,OAAf,GAAoBM,WAApB,GAA+B,IAA/B,GAAoCa,GAAG,CAACX,IAA5D;IACAW,GAAG,CAACX,IAAJ,GAAWiB,QAAX;EACD;;EAED,OAAON,GAAP;AACD","names":["sessionToSentryRequest","session","api","envelopeHeaders","JSON","stringify","sent_at","Date","toISOString","itemHeaders","type","body","url","getEnvelopeEndpointWithUrlEncodedAuth","eventToSentryRequest","event","_a","samplingMethod","sampleRate","otherTags","tags","useEnvelope","req","getStoreEndpointWithUrlEncodedAuth","event_id","sample_rates","id","rate","envelope"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\@sentry\\core\\src\\request.ts"],"sourcesContent":["import { Event, SentryRequest, Session } from '@sentry/types';\n\nimport { API } from './api';\n\n/** Creates a SentryRequest from an event. */\nexport function sessionToSentryRequest(session: Session, api: API): SentryRequest {\n  const envelopeHeaders = JSON.stringify({\n    sent_at: new Date().toISOString(),\n  });\n  const itemHeaders = JSON.stringify({\n    type: 'session',\n  });\n\n  return {\n    body: `${envelopeHeaders}\\n${itemHeaders}\\n${JSON.stringify(session)}`,\n    type: 'session',\n    url: api.getEnvelopeEndpointWithUrlEncodedAuth(),\n  };\n}\n\n/** Creates a SentryRequest from an event. */\nexport function eventToSentryRequest(event: Event, api: API): SentryRequest {\n  // since JS has no Object.prototype.pop()\n  const { __sentry_samplingMethod: samplingMethod, __sentry_sampleRate: sampleRate, ...otherTags } = event.tags || {};\n  event.tags = otherTags;\n\n  const useEnvelope = event.type === 'transaction';\n\n  const req: SentryRequest = {\n    body: JSON.stringify(event),\n    type: event.type || 'event',\n    url: useEnvelope ? api.getEnvelopeEndpointWithUrlEncodedAuth() : api.getStoreEndpointWithUrlEncodedAuth(),\n  };\n\n  // https://develop.sentry.dev/sdk/envelopes/\n\n  // Since we don't need to manipulate envelopes nor store them, there is no\n  // exported concept of an Envelope with operations including serialization and\n  // deserialization. Instead, we only implement a minimal subset of the spec to\n  // serialize events inline here.\n  if (useEnvelope) {\n    const envelopeHeaders = JSON.stringify({\n      event_id: event.event_id,\n      sent_at: new Date().toISOString(),\n    });\n    const itemHeaders = JSON.stringify({\n      type: event.type,\n\n      // TODO: Right now, sampleRate may or may not be defined (it won't be in the cases of inheritance and\n      // explicitly-set sampling decisions). Are we good with that?\n      sample_rates: [{ id: samplingMethod, rate: sampleRate }],\n\n      // The content-type is assumed to be 'application/json' and not part of\n      // the current spec for transaction items, so we don't bloat the request\n      // body with it.\n      //\n      // content_type: 'application/json',\n      //\n      // The length is optional. It must be the number of bytes in req.Body\n      // encoded as UTF-8. Since the server can figure this out and would\n      // otherwise refuse events that report the length incorrectly, we decided\n      // not to send the length to avoid problems related to reporting the wrong\n      // size and to reduce request body size.\n      //\n      // length: new TextEncoder().encode(req.body).length,\n    });\n    // The trailing newline is optional. We intentionally don't send it to avoid\n    // sending unnecessary bytes.\n    //\n    // const envelope = `${envelopeHeaders}\\n${itemHeaders}\\n${req.body}\\n`;\n    const envelope = `${envelopeHeaders}\\n${itemHeaders}\\n${req.body}`;\n    req.body = envelope;\n  }\n\n  return req;\n}\n"]},"metadata":{},"sourceType":"module"}