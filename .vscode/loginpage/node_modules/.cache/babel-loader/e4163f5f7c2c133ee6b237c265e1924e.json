{"ast":null,"code":"/*istanbul ignore start*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.calcLineCount = calcLineCount;\nexports.merge = merge;\n/*istanbul ignore end*/\n\nvar\n/*istanbul ignore start*/\n_create = require(\"./create\")\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_parse = require(\"./parse\")\n/*istanbul ignore end*/\n;\n\nvar\n/*istanbul ignore start*/\n_array = require(\"../util/array\")\n/*istanbul ignore end*/\n;\n/*istanbul ignore start*/\n\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n/*istanbul ignore end*/\n\n\nfunction calcLineCount(hunk) {\n  /*istanbul ignore start*/\n  var _calcOldNewLineCount =\n  /*istanbul ignore end*/\n  calcOldNewLineCount(hunk.lines),\n      oldLines = _calcOldNewLineCount.oldLines,\n      newLines = _calcOldNewLineCount.newLines;\n\n  if (oldLines !== undefined) {\n    hunk.oldLines = oldLines;\n  } else {\n    delete hunk.oldLines;\n  }\n\n  if (newLines !== undefined) {\n    hunk.newLines = newLines;\n  } else {\n    delete hunk.newLines;\n  }\n}\n\nfunction merge(mine, theirs, base) {\n  mine = loadPatch(mine, base);\n  theirs = loadPatch(theirs, base);\n  var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.\n  // Leaving sanity checks on this to the API consumer that may know more about the\n  // meaning in their own context.\n\n  if (mine.index || theirs.index) {\n    ret.index = mine.index || theirs.index;\n  }\n\n  if (mine.newFileName || theirs.newFileName) {\n    if (!fileNameChanged(mine)) {\n      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n      ret.newFileName = theirs.newFileName || mine.newFileName;\n      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n      ret.newHeader = theirs.newHeader || mine.newHeader;\n    } else if (!fileNameChanged(theirs)) {\n      // No header or no change in theirs, use ours\n      ret.oldFileName = mine.oldFileName;\n      ret.newFileName = mine.newFileName;\n      ret.oldHeader = mine.oldHeader;\n      ret.newHeader = mine.newHeader;\n    } else {\n      // Both changed... figure it out\n      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n    }\n  }\n\n  ret.hunks = [];\n  var mineIndex = 0,\n      theirsIndex = 0,\n      mineOffset = 0,\n      theirsOffset = 0;\n\n  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n    var mineCurrent = mine.hunks[mineIndex] || {\n      oldStart: Infinity\n    },\n        theirsCurrent = theirs.hunks[theirsIndex] || {\n      oldStart: Infinity\n    };\n\n    if (hunkBefore(mineCurrent, theirsCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n      mineIndex++;\n      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n      theirsIndex++;\n      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n    } else {\n      // Overlap, merge as best we can\n      var mergedHunk = {\n        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n        oldLines: 0,\n        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n        newLines: 0,\n        lines: []\n      };\n      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n      theirsIndex++;\n      mineIndex++;\n      ret.hunks.push(mergedHunk);\n    }\n  }\n\n  return ret;\n}\n\nfunction loadPatch(param, base) {\n  if (typeof param === 'string') {\n    if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n      return (\n        /*istanbul ignore start*/\n        (0,\n        /*istanbul ignore end*/\n\n        /*istanbul ignore start*/\n        _parse\n        /*istanbul ignore end*/\n        .\n        /*istanbul ignore start*/\n        parsePatch\n        /*istanbul ignore end*/\n        )(param)[0]\n      );\n    }\n\n    if (!base) {\n      throw new Error('Must provide a base reference or pass in a patch');\n    }\n\n    return (\n      /*istanbul ignore start*/\n      (0,\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n      _create\n      /*istanbul ignore end*/\n      .\n      /*istanbul ignore start*/\n      structuredPatch\n      /*istanbul ignore end*/\n      )(undefined, undefined, base, param)\n    );\n  }\n\n  return param;\n}\n\nfunction fileNameChanged(patch) {\n  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\n\nfunction selectField(index, mine, theirs) {\n  if (mine === theirs) {\n    return mine;\n  } else {\n    index.conflict = true;\n    return {\n      mine: mine,\n      theirs: theirs\n    };\n  }\n}\n\nfunction hunkBefore(test, check) {\n  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n}\n\nfunction cloneHunk(hunk, offset) {\n  return {\n    oldStart: hunk.oldStart,\n    oldLines: hunk.oldLines,\n    newStart: hunk.newStart + offset,\n    newLines: hunk.newLines,\n    lines: hunk.lines\n  };\n}\n\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n  // This will generally result in a conflicted hunk, but there are cases where the context\n  // is the only overlap where we can successfully merge the content here.\n  var mine = {\n    offset: mineOffset,\n    lines: mineLines,\n    index: 0\n  },\n      their = {\n    offset: theirOffset,\n    lines: theirLines,\n    index: 0\n  }; // Handle any leading content\n\n  insertLeading(hunk, mine, their);\n  insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.\n\n  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n    var mineCurrent = mine.lines[mine.index],\n        theirCurrent = their.lines[their.index];\n\n    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n      // Both modified ...\n      mutualChange(hunk, mine, their);\n    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n      /*istanbul ignore start*/\n      var _hunk$lines;\n      /*istanbul ignore end*/\n      // Mine inserted\n\n      /*istanbul ignore start*/\n\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n\n\n      (_hunk$lines =\n      /*istanbul ignore end*/\n      hunk.lines).push.apply(\n      /*istanbul ignore start*/\n      _hunk$lines\n      /*istanbul ignore end*/\n      ,\n      /*istanbul ignore start*/\n      _toConsumableArray(\n      /*istanbul ignore end*/\n      collectChange(mine)));\n    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n      /*istanbul ignore start*/\n      var _hunk$lines2;\n      /*istanbul ignore end*/\n      // Theirs inserted\n\n      /*istanbul ignore start*/\n\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n\n\n      (_hunk$lines2 =\n      /*istanbul ignore end*/\n      hunk.lines).push.apply(\n      /*istanbul ignore start*/\n      _hunk$lines2\n      /*istanbul ignore end*/\n      ,\n      /*istanbul ignore start*/\n      _toConsumableArray(\n      /*istanbul ignore end*/\n      collectChange(their)));\n    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n      // Mine removed or edited\n      removal(hunk, mine, their);\n    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n      // Their removed or edited\n      removal(hunk, their, mine, true);\n    } else if (mineCurrent === theirCurrent) {\n      // Context identity\n      hunk.lines.push(mineCurrent);\n      mine.index++;\n      their.index++;\n    } else {\n      // Context mismatch\n      conflict(hunk, collectChange(mine), collectChange(their));\n    }\n  } // Now push anything that may be remaining\n\n\n  insertTrailing(hunk, mine);\n  insertTrailing(hunk, their);\n  calcLineCount(hunk);\n}\n\nfunction mutualChange(hunk, mine, their) {\n  var myChanges = collectChange(mine),\n      theirChanges = collectChange(their);\n\n  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n    // Special case for remove changes that are supersets of one another\n    if (\n    /*istanbul ignore start*/\n    (0,\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    _array\n    /*istanbul ignore end*/\n    .\n    /*istanbul ignore start*/\n    arrayStartsWith\n    /*istanbul ignore end*/\n    )(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n      /*istanbul ignore start*/\n      var _hunk$lines3;\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n\n\n      (_hunk$lines3 =\n      /*istanbul ignore end*/\n      hunk.lines).push.apply(\n      /*istanbul ignore start*/\n      _hunk$lines3\n      /*istanbul ignore end*/\n      ,\n      /*istanbul ignore start*/\n      _toConsumableArray(\n      /*istanbul ignore end*/\n      myChanges));\n\n      return;\n    } else if (\n    /*istanbul ignore start*/\n    (0,\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    _array\n    /*istanbul ignore end*/\n    .\n    /*istanbul ignore start*/\n    arrayStartsWith\n    /*istanbul ignore end*/\n    )(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n      /*istanbul ignore start*/\n      var _hunk$lines4;\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n\n\n      (_hunk$lines4 =\n      /*istanbul ignore end*/\n      hunk.lines).push.apply(\n      /*istanbul ignore start*/\n      _hunk$lines4\n      /*istanbul ignore end*/\n      ,\n      /*istanbul ignore start*/\n      _toConsumableArray(\n      /*istanbul ignore end*/\n      theirChanges));\n\n      return;\n    }\n  } else if (\n  /*istanbul ignore start*/\n  (0,\n  /*istanbul ignore end*/\n\n  /*istanbul ignore start*/\n  _array\n  /*istanbul ignore end*/\n  .\n  /*istanbul ignore start*/\n  arrayEqual\n  /*istanbul ignore end*/\n  )(myChanges, theirChanges)) {\n    /*istanbul ignore start*/\n    var _hunk$lines5;\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n\n\n    (_hunk$lines5 =\n    /*istanbul ignore end*/\n    hunk.lines).push.apply(\n    /*istanbul ignore start*/\n    _hunk$lines5\n    /*istanbul ignore end*/\n    ,\n    /*istanbul ignore start*/\n    _toConsumableArray(\n    /*istanbul ignore end*/\n    myChanges));\n\n    return;\n  }\n\n  conflict(hunk, myChanges, theirChanges);\n}\n\nfunction removal(hunk, mine, their, swap) {\n  var myChanges = collectChange(mine),\n      theirChanges = collectContext(their, myChanges);\n\n  if (theirChanges.merged) {\n    /*istanbul ignore start*/\n    var _hunk$lines6;\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n\n\n    (_hunk$lines6 =\n    /*istanbul ignore end*/\n    hunk.lines).push.apply(\n    /*istanbul ignore start*/\n    _hunk$lines6\n    /*istanbul ignore end*/\n    ,\n    /*istanbul ignore start*/\n    _toConsumableArray(\n    /*istanbul ignore end*/\n    theirChanges.merged));\n  } else {\n    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n  }\n}\n\nfunction conflict(hunk, mine, their) {\n  hunk.conflict = true;\n  hunk.lines.push({\n    conflict: true,\n    mine: mine,\n    theirs: their\n  });\n}\n\nfunction insertLeading(hunk, insert, their) {\n  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n    insert.offset++;\n  }\n}\n\nfunction insertTrailing(hunk, insert) {\n  while (insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n  }\n}\n\nfunction collectChange(state) {\n  var ret = [],\n      operation = state.lines[state.index][0];\n\n  while (state.index < state.lines.length) {\n    var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n\n    if (operation === '-' && line[0] === '+') {\n      operation = '+';\n    }\n\n    if (operation === line[0]) {\n      ret.push(line);\n      state.index++;\n    } else {\n      break;\n    }\n  }\n\n  return ret;\n}\n\nfunction collectContext(state, matchChanges) {\n  var changes = [],\n      merged = [],\n      matchIndex = 0,\n      contextChanges = false,\n      conflicted = false;\n\n  while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n    var change = state.lines[state.index],\n        match = matchChanges[matchIndex]; // Once we've hit our add, then we are done\n\n    if (match[0] === '+') {\n      break;\n    }\n\n    contextChanges = contextChanges || change[0] !== ' ';\n    merged.push(match);\n    matchIndex++; // Consume any additions in the other block as a conflict to attempt\n    // to pull in the remaining context after this\n\n    if (change[0] === '+') {\n      conflicted = true;\n\n      while (change[0] === '+') {\n        changes.push(change);\n        change = state.lines[++state.index];\n      }\n    }\n\n    if (match.substr(1) === change.substr(1)) {\n      changes.push(change);\n      state.index++;\n    } else {\n      conflicted = true;\n    }\n  }\n\n  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n    conflicted = true;\n  }\n\n  if (conflicted) {\n    return changes;\n  }\n\n  while (matchIndex < matchChanges.length) {\n    merged.push(matchChanges[matchIndex++]);\n  }\n\n  return {\n    merged: merged,\n    changes: changes\n  };\n}\n\nfunction allRemoves(changes) {\n  return changes.reduce(function (prev, change) {\n    return prev && change[0] === '-';\n  }, true);\n}\n\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n  for (var i = 0; i < delta; i++) {\n    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n\n    if (state.lines[state.index + i] !== ' ' + changeContent) {\n      return false;\n    }\n  }\n\n  state.index += delta;\n  return true;\n}\n\nfunction calcOldNewLineCount(lines) {\n  var oldLines = 0;\n  var newLines = 0;\n  lines.forEach(function (line) {\n    if (typeof line !== 'string') {\n      var myCount = calcOldNewLineCount(line.mine);\n      var theirCount = calcOldNewLineCount(line.theirs);\n\n      if (oldLines !== undefined) {\n        if (myCount.oldLines === theirCount.oldLines) {\n          oldLines += myCount.oldLines;\n        } else {\n          oldLines = undefined;\n        }\n      }\n\n      if (newLines !== undefined) {\n        if (myCount.newLines === theirCount.newLines) {\n          newLines += myCount.newLines;\n        } else {\n          newLines = undefined;\n        }\n      }\n    } else {\n      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n        newLines++;\n      }\n\n      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n        oldLines++;\n      }\n    }\n  });\n  return {\n    oldLines: oldLines,\n    newLines: newLines\n  };\n}","map":{"version":3,"mappings":"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","names":["_create","_parse","_array","calcLineCount","hunk","calcOldNewLineCount","lines","oldLines","newLines","undefined","merge","mine","theirs","base","loadPatch","ret","index","newFileName","fileNameChanged","oldFileName","oldHeader","newHeader","selectField","hunks","mineIndex","theirsIndex","mineOffset","theirsOffset","length","mineCurrent","oldStart","Infinity","theirsCurrent","hunkBefore","push","cloneHunk","mergedHunk","Math","min","newStart","mergeLines","param","test","parsePatch","Error","structuredPatch","patch","conflict","check","offset","mineLines","theirOffset","theirLines","their","insertLeading","theirCurrent","mutualChange","_hunk$lines","_toConsumableArray","collectChange","_hunk$lines2","removal","insertTrailing","myChanges","theirChanges","allRemoves","arrayStartsWith","skipRemoveSuperset","_hunk$lines3","_hunk$lines4","arrayEqual","_hunk$lines5","swap","collectContext","merged","_hunk$lines6","insert","line","state","operation","matchChanges","changes","matchIndex","contextChanges","conflicted","change","match","substr","reduce","prev","removeChanges","delta","i","changeContent","forEach","myCount","theirCount"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\diff\\src\\patch\\merge.js"],"sourcesContent":["import {structuredPatch} from './create';\nimport {parsePatch} from './parse';\n\nimport {arrayEqual, arrayStartsWith} from '../util/array';\n\nexport function calcLineCount(hunk) {\n  const {oldLines, newLines} = calcOldNewLineCount(hunk.lines);\n\n  if (oldLines !== undefined) {\n    hunk.oldLines = oldLines;\n  } else {\n    delete hunk.oldLines;\n  }\n\n  if (newLines !== undefined) {\n    hunk.newLines = newLines;\n  } else {\n    delete hunk.newLines;\n  }\n}\n\nexport function merge(mine, theirs, base) {\n  mine = loadPatch(mine, base);\n  theirs = loadPatch(theirs, base);\n\n  let ret = {};\n\n  // For index we just let it pass through as it doesn't have any necessary meaning.\n  // Leaving sanity checks on this to the API consumer that may know more about the\n  // meaning in their own context.\n  if (mine.index || theirs.index) {\n    ret.index = mine.index || theirs.index;\n  }\n\n  if (mine.newFileName || theirs.newFileName) {\n    if (!fileNameChanged(mine)) {\n      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n      ret.newFileName = theirs.newFileName || mine.newFileName;\n      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n      ret.newHeader = theirs.newHeader || mine.newHeader;\n    } else if (!fileNameChanged(theirs)) {\n      // No header or no change in theirs, use ours\n      ret.oldFileName = mine.oldFileName;\n      ret.newFileName = mine.newFileName;\n      ret.oldHeader = mine.oldHeader;\n      ret.newHeader = mine.newHeader;\n    } else {\n      // Both changed... figure it out\n      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n    }\n  }\n\n  ret.hunks = [];\n\n  let mineIndex = 0,\n      theirsIndex = 0,\n      mineOffset = 0,\n      theirsOffset = 0;\n\n  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n    let mineCurrent = mine.hunks[mineIndex] || {oldStart: Infinity},\n        theirsCurrent = theirs.hunks[theirsIndex] || {oldStart: Infinity};\n\n    if (hunkBefore(mineCurrent, theirsCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n      mineIndex++;\n      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n      theirsIndex++;\n      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n    } else {\n      // Overlap, merge as best we can\n      let mergedHunk = {\n        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n        oldLines: 0,\n        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n        newLines: 0,\n        lines: []\n      };\n      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n      theirsIndex++;\n      mineIndex++;\n\n      ret.hunks.push(mergedHunk);\n    }\n  }\n\n  return ret;\n}\n\nfunction loadPatch(param, base) {\n  if (typeof param === 'string') {\n    if ((/^@@/m).test(param) || ((/^Index:/m).test(param))) {\n      return parsePatch(param)[0];\n    }\n\n    if (!base) {\n      throw new Error('Must provide a base reference or pass in a patch');\n    }\n    return structuredPatch(undefined, undefined, base, param);\n  }\n\n  return param;\n}\n\nfunction fileNameChanged(patch) {\n  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\n\nfunction selectField(index, mine, theirs) {\n  if (mine === theirs) {\n    return mine;\n  } else {\n    index.conflict = true;\n    return {mine, theirs};\n  }\n}\n\nfunction hunkBefore(test, check) {\n  return test.oldStart < check.oldStart\n    && (test.oldStart + test.oldLines) < check.oldStart;\n}\n\nfunction cloneHunk(hunk, offset) {\n  return {\n    oldStart: hunk.oldStart, oldLines: hunk.oldLines,\n    newStart: hunk.newStart + offset, newLines: hunk.newLines,\n    lines: hunk.lines\n  };\n}\n\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n  // This will generally result in a conflicted hunk, but there are cases where the context\n  // is the only overlap where we can successfully merge the content here.\n  let mine = {offset: mineOffset, lines: mineLines, index: 0},\n      their = {offset: theirOffset, lines: theirLines, index: 0};\n\n  // Handle any leading content\n  insertLeading(hunk, mine, their);\n  insertLeading(hunk, their, mine);\n\n  // Now in the overlap content. Scan through and select the best changes from each.\n  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n    let mineCurrent = mine.lines[mine.index],\n        theirCurrent = their.lines[their.index];\n\n    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+')\n        && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n      // Both modified ...\n      mutualChange(hunk, mine, their);\n    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n      // Mine inserted\n      hunk.lines.push(... collectChange(mine));\n    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n      // Theirs inserted\n      hunk.lines.push(... collectChange(their));\n    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n      // Mine removed or edited\n      removal(hunk, mine, their);\n    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n      // Their removed or edited\n      removal(hunk, their, mine, true);\n    } else if (mineCurrent === theirCurrent) {\n      // Context identity\n      hunk.lines.push(mineCurrent);\n      mine.index++;\n      their.index++;\n    } else {\n      // Context mismatch\n      conflict(hunk, collectChange(mine), collectChange(their));\n    }\n  }\n\n  // Now push anything that may be remaining\n  insertTrailing(hunk, mine);\n  insertTrailing(hunk, their);\n\n  calcLineCount(hunk);\n}\n\nfunction mutualChange(hunk, mine, their) {\n  let myChanges = collectChange(mine),\n      theirChanges = collectChange(their);\n\n  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n    // Special case for remove changes that are supersets of one another\n    if (arrayStartsWith(myChanges, theirChanges)\n        && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n      hunk.lines.push(... myChanges);\n      return;\n    } else if (arrayStartsWith(theirChanges, myChanges)\n        && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n      hunk.lines.push(... theirChanges);\n      return;\n    }\n  } else if (arrayEqual(myChanges, theirChanges)) {\n    hunk.lines.push(... myChanges);\n    return;\n  }\n\n  conflict(hunk, myChanges, theirChanges);\n}\n\nfunction removal(hunk, mine, their, swap) {\n  let myChanges = collectChange(mine),\n      theirChanges = collectContext(their, myChanges);\n  if (theirChanges.merged) {\n    hunk.lines.push(... theirChanges.merged);\n  } else {\n    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n  }\n}\n\nfunction conflict(hunk, mine, their) {\n  hunk.conflict = true;\n  hunk.lines.push({\n    conflict: true,\n    mine: mine,\n    theirs: their\n  });\n}\n\nfunction insertLeading(hunk, insert, their) {\n  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n    let line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n    insert.offset++;\n  }\n}\nfunction insertTrailing(hunk, insert) {\n  while (insert.index < insert.lines.length) {\n    let line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n  }\n}\n\nfunction collectChange(state) {\n  let ret = [],\n      operation = state.lines[state.index][0];\n  while (state.index < state.lines.length) {\n    let line = state.lines[state.index];\n\n    // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n    if (operation === '-' && line[0] === '+') {\n      operation = '+';\n    }\n\n    if (operation === line[0]) {\n      ret.push(line);\n      state.index++;\n    } else {\n      break;\n    }\n  }\n\n  return ret;\n}\nfunction collectContext(state, matchChanges) {\n  let changes = [],\n      merged = [],\n      matchIndex = 0,\n      contextChanges = false,\n      conflicted = false;\n  while (matchIndex < matchChanges.length\n        && state.index < state.lines.length) {\n    let change = state.lines[state.index],\n        match = matchChanges[matchIndex];\n\n    // Once we've hit our add, then we are done\n    if (match[0] === '+') {\n      break;\n    }\n\n    contextChanges = contextChanges || change[0] !== ' ';\n\n    merged.push(match);\n    matchIndex++;\n\n    // Consume any additions in the other block as a conflict to attempt\n    // to pull in the remaining context after this\n    if (change[0] === '+') {\n      conflicted = true;\n\n      while (change[0] === '+') {\n        changes.push(change);\n        change = state.lines[++state.index];\n      }\n    }\n\n    if (match.substr(1) === change.substr(1)) {\n      changes.push(change);\n      state.index++;\n    } else {\n      conflicted = true;\n    }\n  }\n\n  if ((matchChanges[matchIndex] || '')[0] === '+'\n      && contextChanges) {\n    conflicted = true;\n  }\n\n  if (conflicted) {\n    return changes;\n  }\n\n  while (matchIndex < matchChanges.length) {\n    merged.push(matchChanges[matchIndex++]);\n  }\n\n  return {\n    merged,\n    changes\n  };\n}\n\nfunction allRemoves(changes) {\n  return changes.reduce(function(prev, change) {\n    return prev && change[0] === '-';\n  }, true);\n}\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n  for (let i = 0; i < delta; i++) {\n    let changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n    if (state.lines[state.index + i] !== ' ' + changeContent) {\n      return false;\n    }\n  }\n\n  state.index += delta;\n  return true;\n}\n\nfunction calcOldNewLineCount(lines) {\n  let oldLines = 0;\n  let newLines = 0;\n\n  lines.forEach(function(line) {\n    if (typeof line !== 'string') {\n      let myCount = calcOldNewLineCount(line.mine);\n      let theirCount = calcOldNewLineCount(line.theirs);\n\n      if (oldLines !== undefined) {\n        if (myCount.oldLines === theirCount.oldLines) {\n          oldLines += myCount.oldLines;\n        } else {\n          oldLines = undefined;\n        }\n      }\n\n      if (newLines !== undefined) {\n        if (myCount.newLines === theirCount.newLines) {\n          newLines += myCount.newLines;\n        } else {\n          newLines = undefined;\n        }\n      }\n    } else {\n      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n        newLines++;\n      }\n      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n        oldLines++;\n      }\n    }\n  });\n\n  return {oldLines, newLines};\n}\n"]},"metadata":{},"sourceType":"script"}