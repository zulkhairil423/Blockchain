{"ast":null,"code":"/*istanbul ignore start*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parsePatch = parsePatch;\n/*istanbul ignore end*/\n\nfunction parsePatch(uniDiff) {\n  /*istanbul ignore start*/\n  var\n  /*istanbul ignore end*/\n  options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      list = [],\n      i = 0;\n\n  function parseIndex() {\n    var index = {};\n    list.push(index); // Parse diff metadata\n\n    while (i < diffstr.length) {\n      var line = diffstr[i]; // File header found, end parsing diff metadata\n\n      if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n        break;\n      } // Diff index\n\n\n      var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n\n      if (header) {\n        index.index = header[1];\n      }\n\n      i++;\n    } // Parse file headers if they are defined. Unified diff requires them, but\n    // there's no technical issues to have an isolated hunk without file header\n\n\n    parseFileHeader(index);\n    parseFileHeader(index); // Parse hunks\n\n    index.hunks = [];\n\n    while (i < diffstr.length) {\n      var _line = diffstr[i];\n\n      if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n        break;\n      } else if (/^@@/.test(_line)) {\n        index.hunks.push(parseHunk());\n      } else if (_line && options.strict) {\n        // Ignore unexpected content unless in strict mode\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n      } else {\n        i++;\n      }\n    }\n  } // Parses the --- and +++ headers, if none are found, no lines\n  // are consumed.\n\n\n  function parseFileHeader(index) {\n    var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n\n    if (fileHeader) {\n      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n      var data = fileHeader[2].split('\\t', 2);\n      var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n\n      if (/^\".*\"$/.test(fileName)) {\n        fileName = fileName.substr(1, fileName.length - 2);\n      }\n\n      index[keyPrefix + 'FileName'] = fileName;\n      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n      i++;\n    }\n  } // Parses a hunk\n  // This assumes that we are at the start of a hunk.\n\n\n  function parseHunk() {\n    var chunkHeaderIndex = i,\n        chunkHeaderLine = diffstr[i++],\n        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n    var hunk = {\n      oldStart: +chunkHeader[1],\n      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n      newStart: +chunkHeader[3],\n      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n      lines: [],\n      linedelimiters: []\n    }; // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n    if (hunk.oldLines === 0) {\n      hunk.oldStart += 1;\n    }\n\n    if (hunk.newLines === 0) {\n      hunk.newStart += 1;\n    }\n\n    var addCount = 0,\n        removeCount = 0;\n\n    for (; i < diffstr.length; i++) {\n      // Lines starting with '---' could be mistaken for the \"remove line\" operation\n      // But they could be the header for the next file. Therefore prune such cases out.\n      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n        break;\n      }\n\n      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n        hunk.lines.push(diffstr[i]);\n        hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n        if (operation === '+') {\n          addCount++;\n        } else if (operation === '-') {\n          removeCount++;\n        } else if (operation === ' ') {\n          addCount++;\n          removeCount++;\n        }\n      } else {\n        break;\n      }\n    } // Handle the empty block count case\n\n\n    if (!addCount && hunk.newLines === 1) {\n      hunk.newLines = 0;\n    }\n\n    if (!removeCount && hunk.oldLines === 1) {\n      hunk.oldLines = 0;\n    } // Perform optional sanity checking\n\n\n    if (options.strict) {\n      if (addCount !== hunk.newLines) {\n        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n\n      if (removeCount !== hunk.oldLines) {\n        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n    }\n\n    return hunk;\n  }\n\n  while (i < diffstr.length) {\n    parseIndex();\n  }\n\n  return list;\n}","map":{"version":3,"mappings":"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","names":["parsePatch","uniDiff","options","diffstr","split","delimiters","match","list","i","parseIndex","index","push","length","line","test","header","exec","parseFileHeader","hunks","parseHunk","strict","Error","JSON","stringify","fileHeader","keyPrefix","data","fileName","replace","substr","trim","chunkHeaderIndex","chunkHeaderLine","chunkHeader","hunk","oldStart","oldLines","newStart","newLines","lines","linedelimiters","addCount","removeCount","indexOf","operation"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\diff\\src\\patch\\parse.js"],"sourcesContent":["export function parsePatch(uniDiff, options = {}) {\n  let diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      list = [],\n      i = 0;\n\n  function parseIndex() {\n    let index = {};\n    list.push(index);\n\n    // Parse diff metadata\n    while (i < diffstr.length) {\n      let line = diffstr[i];\n\n      // File header found, end parsing diff metadata\n      if ((/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/).test(line)) {\n        break;\n      }\n\n      // Diff index\n      let header = (/^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/).exec(line);\n      if (header) {\n        index.index = header[1];\n      }\n\n      i++;\n    }\n\n    // Parse file headers if they are defined. Unified diff requires them, but\n    // there's no technical issues to have an isolated hunk without file header\n    parseFileHeader(index);\n    parseFileHeader(index);\n\n    // Parse hunks\n    index.hunks = [];\n\n    while (i < diffstr.length) {\n      let line = diffstr[i];\n\n      if ((/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/).test(line)) {\n        break;\n      } else if ((/^@@/).test(line)) {\n        index.hunks.push(parseHunk());\n      } else if (line && options.strict) {\n        // Ignore unexpected content unless in strict mode\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(line));\n      } else {\n        i++;\n      }\n    }\n  }\n\n  // Parses the --- and +++ headers, if none are found, no lines\n  // are consumed.\n  function parseFileHeader(index) {\n    const fileHeader = (/^(---|\\+\\+\\+)\\s+(.*)$/).exec(diffstr[i]);\n    if (fileHeader) {\n      let keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n      const data = fileHeader[2].split('\\t', 2);\n      let fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n      if ((/^\".*\"$/).test(fileName)) {\n        fileName = fileName.substr(1, fileName.length - 2);\n      }\n      index[keyPrefix + 'FileName'] = fileName;\n      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n\n      i++;\n    }\n  }\n\n  // Parses a hunk\n  // This assumes that we are at the start of a hunk.\n  function parseHunk() {\n    let chunkHeaderIndex = i,\n        chunkHeaderLine = diffstr[i++],\n        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n\n    let hunk = {\n      oldStart: +chunkHeader[1],\n      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n      newStart: +chunkHeader[3],\n      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n      lines: [],\n      linedelimiters: []\n    };\n\n    // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n    if (hunk.oldLines === 0) {\n      hunk.oldStart += 1;\n    }\n    if (hunk.newLines === 0) {\n      hunk.newStart += 1;\n    }\n\n    let addCount = 0,\n        removeCount = 0;\n    for (; i < diffstr.length; i++) {\n      // Lines starting with '---' could be mistaken for the \"remove line\" operation\n      // But they could be the header for the next file. Therefore prune such cases out.\n      if (diffstr[i].indexOf('--- ') === 0\n            && (i + 2 < diffstr.length)\n            && diffstr[i + 1].indexOf('+++ ') === 0\n            && diffstr[i + 2].indexOf('@@') === 0) {\n          break;\n      }\n      let operation = (diffstr[i].length == 0 && i != (diffstr.length - 1)) ? ' ' : diffstr[i][0];\n\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n        hunk.lines.push(diffstr[i]);\n        hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n        if (operation === '+') {\n          addCount++;\n        } else if (operation === '-') {\n          removeCount++;\n        } else if (operation === ' ') {\n          addCount++;\n          removeCount++;\n        }\n      } else {\n        break;\n      }\n    }\n\n    // Handle the empty block count case\n    if (!addCount && hunk.newLines === 1) {\n      hunk.newLines = 0;\n    }\n    if (!removeCount && hunk.oldLines === 1) {\n      hunk.oldLines = 0;\n    }\n\n    // Perform optional sanity checking\n    if (options.strict) {\n      if (addCount !== hunk.newLines) {\n        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n      if (removeCount !== hunk.oldLines) {\n        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n    }\n\n    return hunk;\n  }\n\n  while (i < diffstr.length) {\n    parseIndex();\n  }\n\n  return list;\n}\n"]},"metadata":{},"sourceType":"script"}