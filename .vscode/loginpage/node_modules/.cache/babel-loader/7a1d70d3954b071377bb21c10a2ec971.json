{"ast":null,"code":"var Utils = require(\"./util\"),\n    Headers = require(\"./headers\"),\n    Constants = Utils.Constants,\n    Methods = require(\"./methods\");\n\nmodule.exports = function (\n/*Buffer*/\ninput) {\n  var _entryHeader = new Headers.EntryHeader(),\n      _entryName = Buffer.alloc(0),\n      _comment = Buffer.alloc(0),\n      _isDirectory = false,\n      uncompressedData = null,\n      _extra = Buffer.alloc(0);\n\n  function getCompressedDataFromZip() {\n    if (!input || !Buffer.isBuffer(input)) {\n      return Buffer.alloc(0);\n    }\n\n    _entryHeader.loadDataHeaderFromBinary(input);\n\n    return input.slice(_entryHeader.realDataOffset, _entryHeader.realDataOffset + _entryHeader.compressedSize);\n  }\n\n  function crc32OK(data) {\n    // if bit 3 (0x08) of the general-purpose flags field is set, then the CRC-32 and file sizes are not known when the header is written\n    if ((_entryHeader.flags & 0x8) !== 0x8) {\n      if (Utils.crc32(data) !== _entryHeader.dataHeader.crc) {\n        return false;\n      }\n    } else {// @TODO: load and check data descriptor header\n      // The fields in the local header are filled with zero, and the CRC-32 and size are appended in a 12-byte structure\n      // (optionally preceded by a 4-byte signature) immediately after the compressed data:\n    }\n\n    return true;\n  }\n\n  function decompress(\n  /*Boolean*/\n  async,\n  /*Function*/\n  callback,\n  /*String*/\n  pass) {\n    if (typeof callback === 'undefined' && typeof async === 'string') {\n      pass = async;\n      async = void 0;\n    }\n\n    if (_isDirectory) {\n      if (async && callback) {\n        callback(Buffer.alloc(0), Utils.Errors.DIRECTORY_CONTENT_ERROR); //si added error.\n      }\n\n      return Buffer.alloc(0);\n    }\n\n    var compressedData = getCompressedDataFromZip();\n\n    if (compressedData.length === 0) {\n      // File is empty, nothing to decompress.\n      if (async && callback) callback(compressedData);\n      return compressedData;\n    }\n\n    var data = Buffer.alloc(_entryHeader.size);\n\n    switch (_entryHeader.method) {\n      case Utils.Constants.STORED:\n        compressedData.copy(data);\n\n        if (!crc32OK(data)) {\n          if (async && callback) callback(data, Utils.Errors.BAD_CRC); //si added error\n\n          throw new Error(Utils.Errors.BAD_CRC);\n        } else {\n          //si added otherwise did not seem to return data.\n          if (async && callback) callback(data);\n          return data;\n        }\n\n      case Utils.Constants.DEFLATED:\n        var inflater = new Methods.Inflater(compressedData);\n\n        if (!async) {\n          var result = inflater.inflate(data);\n          result.copy(data, 0);\n\n          if (!crc32OK(data)) {\n            throw new Error(Utils.Errors.BAD_CRC + \" \" + _entryName.toString());\n          }\n\n          return data;\n        } else {\n          inflater.inflateAsync(function (result) {\n            result.copy(data, 0);\n\n            if (!crc32OK(data)) {\n              if (callback) callback(data, Utils.Errors.BAD_CRC); //si added error\n            } else {\n              //si added otherwise did not seem to return data.\n              if (callback) callback(data);\n            }\n          });\n        }\n\n        break;\n\n      default:\n        if (async && callback) callback(Buffer.alloc(0), Utils.Errors.UNKNOWN_METHOD);\n        throw new Error(Utils.Errors.UNKNOWN_METHOD);\n    }\n  }\n\n  function compress(\n  /*Boolean*/\n  async,\n  /*Function*/\n  callback) {\n    if ((!uncompressedData || !uncompressedData.length) && Buffer.isBuffer(input)) {\n      // no data set or the data wasn't changed to require recompression\n      if (async && callback) callback(getCompressedDataFromZip());\n      return getCompressedDataFromZip();\n    }\n\n    if (uncompressedData.length && !_isDirectory) {\n      var compressedData; // Local file header\n\n      switch (_entryHeader.method) {\n        case Utils.Constants.STORED:\n          _entryHeader.compressedSize = _entryHeader.size;\n          compressedData = Buffer.alloc(uncompressedData.length);\n          uncompressedData.copy(compressedData);\n          if (async && callback) callback(compressedData);\n          return compressedData;\n\n        default:\n        case Utils.Constants.DEFLATED:\n          var deflater = new Methods.Deflater(uncompressedData);\n\n          if (!async) {\n            var deflated = deflater.deflate();\n            _entryHeader.compressedSize = deflated.length;\n            return deflated;\n          } else {\n            deflater.deflateAsync(function (data) {\n              compressedData = Buffer.alloc(data.length);\n              _entryHeader.compressedSize = data.length;\n              data.copy(compressedData);\n              callback && callback(compressedData);\n            });\n          }\n\n          deflater = null;\n          break;\n      }\n    } else {\n      if (async && callback) {\n        callback(Buffer.alloc(0));\n      } else {\n        return Buffer.alloc(0);\n      }\n    }\n  }\n\n  function readUInt64LE(buffer, offset) {\n    return (buffer.readUInt32LE(offset + 4) << 4) + buffer.readUInt32LE(offset);\n  }\n\n  function parseExtra(data) {\n    var offset = 0;\n    var signature, size, part;\n\n    while (offset < data.length) {\n      signature = data.readUInt16LE(offset);\n      offset += 2;\n      size = data.readUInt16LE(offset);\n      offset += 2;\n      part = data.slice(offset, offset + size);\n      offset += size;\n\n      if (Constants.ID_ZIP64 === signature) {\n        parseZip64ExtendedInformation(part);\n      }\n    }\n  } //Override header field values with values from the ZIP64 extra field\n\n\n  function parseZip64ExtendedInformation(data) {\n    var size, compressedSize, offset, diskNumStart;\n\n    if (data.length >= Constants.EF_ZIP64_SCOMP) {\n      size = readUInt64LE(data, Constants.EF_ZIP64_SUNCOMP);\n\n      if (_entryHeader.size === Constants.EF_ZIP64_OR_32) {\n        _entryHeader.size = size;\n      }\n    }\n\n    if (data.length >= Constants.EF_ZIP64_RHO) {\n      compressedSize = readUInt64LE(data, Constants.EF_ZIP64_SCOMP);\n\n      if (_entryHeader.compressedSize === Constants.EF_ZIP64_OR_32) {\n        _entryHeader.compressedSize = compressedSize;\n      }\n    }\n\n    if (data.length >= Constants.EF_ZIP64_DSN) {\n      offset = readUInt64LE(data, Constants.EF_ZIP64_RHO);\n\n      if (_entryHeader.offset === Constants.EF_ZIP64_OR_32) {\n        _entryHeader.offset = offset;\n      }\n    }\n\n    if (data.length >= Constants.EF_ZIP64_DSN + 4) {\n      diskNumStart = data.readUInt32LE(Constants.EF_ZIP64_DSN);\n\n      if (_entryHeader.diskNumStart === Constants.EF_ZIP64_OR_16) {\n        _entryHeader.diskNumStart = diskNumStart;\n      }\n    }\n  }\n\n  return {\n    get entryName() {\n      return _entryName.toString();\n    },\n\n    get rawEntryName() {\n      return _entryName;\n    },\n\n    set entryName(val) {\n      _entryName = Utils.toBuffer(val);\n      var lastChar = _entryName[_entryName.length - 1];\n      _isDirectory = lastChar === 47 || lastChar === 92;\n      _entryHeader.fileNameLength = _entryName.length;\n    },\n\n    get extra() {\n      return _extra;\n    },\n\n    set extra(val) {\n      _extra = val;\n      _entryHeader.extraLength = val.length;\n      parseExtra(val);\n    },\n\n    get comment() {\n      return _comment.toString();\n    },\n\n    set comment(val) {\n      _comment = Utils.toBuffer(val);\n      _entryHeader.commentLength = _comment.length;\n    },\n\n    get name() {\n      var n = _entryName.toString();\n\n      return _isDirectory ? n.substr(n.length - 1).split(\"/\").pop() : n.split(\"/\").pop();\n    },\n\n    get isDirectory() {\n      return _isDirectory;\n    },\n\n    getCompressedData: function () {\n      return compress(false, null);\n    },\n    getCompressedDataAsync: function (\n    /*Function*/\n    callback) {\n      compress(true, callback);\n    },\n    setData: function (value) {\n      uncompressedData = Utils.toBuffer(value);\n\n      if (!_isDirectory && uncompressedData.length) {\n        _entryHeader.size = uncompressedData.length;\n        _entryHeader.method = Utils.Constants.DEFLATED;\n        _entryHeader.crc = Utils.crc32(value);\n        _entryHeader.changed = true;\n      } else {\n        // folders and blank files should be stored\n        _entryHeader.method = Utils.Constants.STORED;\n      }\n    },\n    getData: function (pass) {\n      if (_entryHeader.changed) {\n        return uncompressedData;\n      } else {\n        return decompress(false, null, pass);\n      }\n    },\n    getDataAsync: function (\n    /*Function*/\n    callback, pass) {\n      if (_entryHeader.changed) {\n        callback(uncompressedData);\n      } else {\n        decompress(true, callback, pass);\n      }\n    },\n\n    set attr(attr) {\n      _entryHeader.attr = attr;\n    },\n\n    get attr() {\n      return _entryHeader.attr;\n    },\n\n    set header(\n    /*Buffer*/\n    data) {\n      _entryHeader.loadFromBinary(data);\n    },\n\n    get header() {\n      return _entryHeader;\n    },\n\n    packHeader: function () {\n      var header = _entryHeader.entryHeaderToBinary(); // add\n\n\n      _entryName.copy(header, Utils.Constants.CENHDR);\n\n      if (_entryHeader.extraLength) {\n        _extra.copy(header, Utils.Constants.CENHDR + _entryName.length);\n      }\n\n      if (_entryHeader.commentLength) {\n        _comment.copy(header, Utils.Constants.CENHDR + _entryName.length + _entryHeader.extraLength, _comment.length);\n      }\n\n      return header;\n    },\n    toString: function () {\n      return '{\\n' + '\\t\"entryName\" : \"' + _entryName.toString() + \"\\\",\\n\" + '\\t\"name\" : \"' + (_isDirectory ? _entryName.toString().replace(/\\/$/, '').split(\"/\").pop() : _entryName.toString().split(\"/\").pop()) + \"\\\",\\n\" + '\\t\"comment\" : \"' + _comment.toString() + \"\\\",\\n\" + '\\t\"isDirectory\" : ' + _isDirectory + \",\\n\" + '\\t\"header\" : ' + _entryHeader.toString().replace(/\\t/mg, \"\\t\\t\").replace(/}/mg, \"\\t}\") + \",\\n\" + '\\t\"compressedData\" : <' + (input && input.length + \" bytes buffer\" || \"null\") + \">\\n\" + '\\t\"data\" : <' + (uncompressedData && uncompressedData.length + \" bytes buffer\" || \"null\") + \">\\n\" + '}';\n    }\n  };\n};","map":{"version":3,"names":["Utils","require","Headers","Constants","Methods","module","exports","input","_entryHeader","EntryHeader","_entryName","Buffer","alloc","_comment","_isDirectory","uncompressedData","_extra","getCompressedDataFromZip","isBuffer","loadDataHeaderFromBinary","slice","realDataOffset","compressedSize","crc32OK","data","flags","crc32","dataHeader","crc","decompress","async","callback","pass","Errors","DIRECTORY_CONTENT_ERROR","compressedData","length","size","method","STORED","copy","BAD_CRC","Error","DEFLATED","inflater","Inflater","result","inflate","toString","inflateAsync","UNKNOWN_METHOD","compress","deflater","Deflater","deflated","deflate","deflateAsync","readUInt64LE","buffer","offset","readUInt32LE","parseExtra","signature","part","readUInt16LE","ID_ZIP64","parseZip64ExtendedInformation","diskNumStart","EF_ZIP64_SCOMP","EF_ZIP64_SUNCOMP","EF_ZIP64_OR_32","EF_ZIP64_RHO","EF_ZIP64_DSN","EF_ZIP64_OR_16","entryName","rawEntryName","val","toBuffer","lastChar","fileNameLength","extra","extraLength","comment","commentLength","name","n","substr","split","pop","isDirectory","getCompressedData","getCompressedDataAsync","setData","value","changed","getData","getDataAsync","attr","header","loadFromBinary","packHeader","entryHeaderToBinary","CENHDR","replace"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/adm-zip/zipEntry.js"],"sourcesContent":["var Utils = require(\"./util\"),\r\n    Headers = require(\"./headers\"),\r\n    Constants = Utils.Constants,\r\n    Methods = require(\"./methods\");\r\n\r\nmodule.exports = function (/*Buffer*/input) {\r\n\r\n    var _entryHeader = new Headers.EntryHeader(),\r\n        _entryName = Buffer.alloc(0),\r\n        _comment = Buffer.alloc(0),\r\n        _isDirectory = false,\r\n        uncompressedData = null,\r\n        _extra = Buffer.alloc(0);\r\n\r\n    function getCompressedDataFromZip() {\r\n        if (!input || !Buffer.isBuffer(input)) {\r\n            return Buffer.alloc(0);\r\n        }\r\n        _entryHeader.loadDataHeaderFromBinary(input);\r\n        return input.slice(_entryHeader.realDataOffset, _entryHeader.realDataOffset + _entryHeader.compressedSize)\r\n    }\r\n\r\n    function crc32OK(data) {\r\n        // if bit 3 (0x08) of the general-purpose flags field is set, then the CRC-32 and file sizes are not known when the header is written\r\n        if ((_entryHeader.flags & 0x8) !== 0x8) {\r\n           if (Utils.crc32(data) !== _entryHeader.dataHeader.crc) {\r\n               return false;\r\n           }\r\n        } else {\r\n            // @TODO: load and check data descriptor header\r\n            // The fields in the local header are filled with zero, and the CRC-32 and size are appended in a 12-byte structure\r\n            // (optionally preceded by a 4-byte signature) immediately after the compressed data:\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function decompress(/*Boolean*/async, /*Function*/callback, /*String*/pass) {\r\n        if(typeof callback === 'undefined' && typeof async === 'string') {\r\n            pass=async;\r\n            async=void 0;\r\n        }\r\n        if (_isDirectory) {\r\n            if (async && callback) {\r\n                callback(Buffer.alloc(0), Utils.Errors.DIRECTORY_CONTENT_ERROR); //si added error.\r\n            }\r\n            return Buffer.alloc(0);\r\n        }\r\n\r\n        var compressedData = getCompressedDataFromZip();\r\n\r\n        if (compressedData.length === 0) {\r\n            // File is empty, nothing to decompress.\r\n            if (async && callback) callback(compressedData);\r\n            return compressedData;\r\n        }\r\n\r\n        var data = Buffer.alloc(_entryHeader.size);\r\n\r\n        switch (_entryHeader.method) {\r\n            case Utils.Constants.STORED:\r\n                compressedData.copy(data);\r\n                if (!crc32OK(data)) {\r\n                    if (async && callback) callback(data, Utils.Errors.BAD_CRC);//si added error\r\n                    throw new Error(Utils.Errors.BAD_CRC);\r\n                } else {//si added otherwise did not seem to return data.\r\n                    if (async && callback) callback(data);\r\n                    return data;\r\n                }\r\n            case Utils.Constants.DEFLATED:\r\n                var inflater = new Methods.Inflater(compressedData);\r\n                if (!async) {\r\n                    var result = inflater.inflate(data);\r\n                    result.copy(data, 0);\r\n                    if (!crc32OK(data)) {\r\n                        throw new Error(Utils.Errors.BAD_CRC + \" \" + _entryName.toString());\r\n                    }\r\n                    return data;\r\n                } else {\r\n                    inflater.inflateAsync(function(result) {\r\n                        result.copy(data, 0);\r\n                        if (!crc32OK(data)) {\r\n                            if (callback) callback(data, Utils.Errors.BAD_CRC); //si added error\r\n                        } else { //si added otherwise did not seem to return data.\r\n                            if (callback) callback(data);\r\n                        }\r\n                    })\r\n                }\r\n                break;\r\n            default:\r\n                if (async && callback) callback(Buffer.alloc(0), Utils.Errors.UNKNOWN_METHOD);\r\n                throw new Error(Utils.Errors.UNKNOWN_METHOD);\r\n        }\r\n    }\r\n\r\n    function compress(/*Boolean*/async, /*Function*/callback) {\r\n        if ((!uncompressedData || !uncompressedData.length) && Buffer.isBuffer(input)) {\r\n            // no data set or the data wasn't changed to require recompression\r\n            if (async && callback) callback(getCompressedDataFromZip());\r\n            return getCompressedDataFromZip();\r\n        }\r\n\r\n        if (uncompressedData.length && !_isDirectory) {\r\n            var compressedData;\r\n            // Local file header\r\n            switch (_entryHeader.method) {\r\n                case Utils.Constants.STORED:\r\n                    _entryHeader.compressedSize = _entryHeader.size;\r\n\r\n                    compressedData = Buffer.alloc(uncompressedData.length);\r\n                    uncompressedData.copy(compressedData);\r\n\r\n                    if (async && callback) callback(compressedData);\r\n                    return compressedData;\r\n                default:\r\n                case Utils.Constants.DEFLATED:\r\n\r\n                    var deflater = new Methods.Deflater(uncompressedData);\r\n                    if (!async) {\r\n                        var deflated = deflater.deflate();\r\n                        _entryHeader.compressedSize = deflated.length;\r\n                        return deflated;\r\n                    } else {\r\n                        deflater.deflateAsync(function(data) {\r\n                            compressedData = Buffer.alloc(data.length);\r\n                            _entryHeader.compressedSize = data.length;\r\n                            data.copy(compressedData);\r\n                            callback && callback(compressedData);\r\n                        })\r\n                    }\r\n                    deflater = null;\r\n                    break;\r\n            }\r\n        } else {\r\n            if (async && callback) {\r\n                callback(Buffer.alloc(0));\r\n            } else {\r\n                return Buffer.alloc(0);\r\n            }\r\n        }\r\n    }\r\n\r\n    function readUInt64LE(buffer, offset) {\r\n        return (buffer.readUInt32LE(offset + 4) << 4) + buffer.readUInt32LE(offset);\r\n    }\r\n\r\n    function parseExtra(data) {\r\n        var offset = 0;\r\n        var signature, size, part;\r\n        while(offset<data.length) {\r\n            signature = data.readUInt16LE(offset);\r\n            offset += 2;\r\n            size = data.readUInt16LE(offset);\r\n            offset += 2;\r\n            part = data.slice(offset, offset+size);\r\n            offset += size;\r\n            if(Constants.ID_ZIP64 === signature) {\r\n                parseZip64ExtendedInformation(part);\r\n            }\r\n        }\r\n    }\r\n\r\n    //Override header field values with values from the ZIP64 extra field\r\n    function parseZip64ExtendedInformation(data) {\r\n        var size, compressedSize, offset, diskNumStart;\r\n\r\n        if(data.length >= Constants.EF_ZIP64_SCOMP) {\r\n            size = readUInt64LE(data, Constants.EF_ZIP64_SUNCOMP);\r\n            if(_entryHeader.size === Constants.EF_ZIP64_OR_32) {\r\n                _entryHeader.size = size;\r\n            }\r\n        }\r\n        if(data.length >= Constants.EF_ZIP64_RHO) {\r\n            compressedSize = readUInt64LE(data, Constants.EF_ZIP64_SCOMP);\r\n            if(_entryHeader.compressedSize === Constants.EF_ZIP64_OR_32) {\r\n                _entryHeader.compressedSize = compressedSize;\r\n            }\r\n        }\r\n        if(data.length >= Constants.EF_ZIP64_DSN) {\r\n            offset = readUInt64LE(data, Constants.EF_ZIP64_RHO);\r\n            if(_entryHeader.offset === Constants.EF_ZIP64_OR_32) {\r\n                _entryHeader.offset = offset;\r\n            }\r\n        }\r\n        if(data.length >= Constants.EF_ZIP64_DSN+4) {\r\n            diskNumStart = data.readUInt32LE(Constants.EF_ZIP64_DSN);\r\n            if(_entryHeader.diskNumStart === Constants.EF_ZIP64_OR_16) {\r\n                _entryHeader.diskNumStart = diskNumStart;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    return {\r\n        get entryName () { return _entryName.toString(); },\r\n        get rawEntryName() { return _entryName; },\r\n        set entryName (val) {\r\n            _entryName = Utils.toBuffer(val);\r\n            var lastChar = _entryName[_entryName.length - 1];\r\n            _isDirectory = (lastChar === 47) || (lastChar === 92);\r\n            _entryHeader.fileNameLength = _entryName.length;\r\n        },\r\n\r\n        get extra () { return _extra; },\r\n        set extra (val) {\r\n            _extra = val;\r\n            _entryHeader.extraLength = val.length;\r\n            parseExtra(val);\r\n        },\r\n\r\n        get comment () { return _comment.toString(); },\r\n        set comment (val) {\r\n            _comment = Utils.toBuffer(val);\r\n            _entryHeader.commentLength = _comment.length;\r\n        },\r\n\r\n        get name () { var n = _entryName.toString(); return _isDirectory ? n.substr(n.length - 1).split(\"/\").pop() : n.split(\"/\").pop(); },\r\n        get isDirectory () { return _isDirectory },\r\n\r\n        getCompressedData : function() {\r\n            return compress(false, null)\r\n        },\r\n\r\n        getCompressedDataAsync : function(/*Function*/callback) {\r\n            compress(true, callback)\r\n        },\r\n\r\n        setData : function(value) {\r\n            uncompressedData = Utils.toBuffer(value);\r\n            if (!_isDirectory && uncompressedData.length) {\r\n                _entryHeader.size = uncompressedData.length;\r\n                _entryHeader.method = Utils.Constants.DEFLATED;\r\n                _entryHeader.crc = Utils.crc32(value);\r\n                _entryHeader.changed = true;\r\n            } else { // folders and blank files should be stored\r\n                _entryHeader.method = Utils.Constants.STORED;\r\n            }\r\n        },\r\n\r\n        getData : function(pass) {\r\n            if (_entryHeader.changed) {\r\n\t\t\t\treturn uncompressedData;\r\n\t\t\t} else {\r\n\t\t\t\treturn decompress(false, null, pass);\r\n            }\r\n        },\r\n\r\n        getDataAsync : function(/*Function*/callback, pass) {\r\n\t\t\tif (_entryHeader.changed) {\r\n\t\t\t\tcallback(uncompressedData)\r\n\t\t\t} else {\r\n\t\t\t\tdecompress(true, callback, pass)\r\n            }\r\n        },\r\n\r\n        set attr(attr) { _entryHeader.attr = attr; },\r\n        get attr() { return _entryHeader.attr; },\r\n\r\n        set header(/*Buffer*/data) {\r\n            _entryHeader.loadFromBinary(data);\r\n        },\r\n\r\n        get header() {\r\n            return _entryHeader;\r\n        },\r\n\r\n        packHeader : function() {\r\n            var header = _entryHeader.entryHeaderToBinary();\r\n            // add\r\n            _entryName.copy(header, Utils.Constants.CENHDR);\r\n            if (_entryHeader.extraLength) {\r\n                _extra.copy(header, Utils.Constants.CENHDR + _entryName.length)\r\n            }\r\n            if (_entryHeader.commentLength) {\r\n                _comment.copy(header, Utils.Constants.CENHDR + _entryName.length + _entryHeader.extraLength, _comment.length);\r\n            }\r\n            return header;\r\n        },\r\n\r\n        toString : function() {\r\n            return '{\\n' +\r\n                '\\t\"entryName\" : \"' + _entryName.toString() + \"\\\",\\n\" +\r\n                '\\t\"name\" : \"' + (_isDirectory ? _entryName.toString().replace(/\\/$/, '').split(\"/\").pop() : _entryName.toString().split(\"/\").pop()) + \"\\\",\\n\" +\r\n                '\\t\"comment\" : \"' + _comment.toString() + \"\\\",\\n\" +\r\n                '\\t\"isDirectory\" : ' + _isDirectory + \",\\n\" +\r\n                '\\t\"header\" : ' + _entryHeader.toString().replace(/\\t/mg, \"\\t\\t\").replace(/}/mg, \"\\t}\")  + \",\\n\" +\r\n                '\\t\"compressedData\" : <' + (input && input.length  + \" bytes buffer\" || \"null\") + \">\\n\" +\r\n                '\\t\"data\" : <' + (uncompressedData && uncompressedData.length  + \" bytes buffer\" || \"null\") + \">\\n\" +\r\n                '}';\r\n        }\r\n    }\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}