{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst config_env_1 = require(\"../internal/core/config/config-env\");\n\nconst errors_1 = require(\"../internal/core/errors\");\n\nconst errors_list_1 = require(\"../internal/core/errors-list\");\n\nconst packageInfo_1 = require(\"../internal/util/packageInfo\");\n\nconst fs_utils_1 = require(\"../internal/util/fs-utils\");\n\nconst task_names_1 = require(\"./task-names\");\n\nfunction getSortedFiles(dependenciesGraph) {\n  const tsort = require(\"tsort\");\n\n  const graph = tsort();\n  const filesMap = {};\n  const resolvedFiles = dependenciesGraph.getResolvedFiles();\n  resolvedFiles.forEach(f => filesMap[f.sourceName] = f);\n\n  for (const [from, deps] of dependenciesGraph.entries()) {\n    for (const to of deps) {\n      graph.add(to.sourceName, from.sourceName);\n    }\n  }\n\n  try {\n    const topologicalSortedNames = graph.sort(); // If an entry has no dependency it won't be included in the graph, so we\n    // add them and then dedup the array\n\n    const withEntries = topologicalSortedNames.concat(resolvedFiles.map(f => f.sourceName));\n    const sortedNames = [...new Set(withEntries)];\n    return sortedNames.map(n => filesMap[n]);\n  } catch (error) {\n    if (error instanceof Error) {\n      if (error.toString().includes(\"Error: There is a cycle in the graph.\")) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.FLATTEN_CYCLE, {}, error);\n      }\n    } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n    throw error;\n  }\n}\n\nfunction getFileWithoutImports(resolvedFile) {\n  const IMPORT_SOLIDITY_REGEX = /^\\s*import(\\s+)[\\s\\S]*?;\\s*$/gm;\n  return resolvedFile.content.rawContent.replace(IMPORT_SOLIDITY_REGEX, \"\").trim();\n}\n\n(0, config_env_1.subtask)(task_names_1.TASK_FLATTEN_GET_FLATTENED_SOURCE, \"Returns all contracts and their dependencies flattened\").addOptionalParam(\"files\", undefined, undefined, config_env_1.types.any).setAction(async (_ref, _ref2) => {\n  let {\n    files\n  } = _ref;\n  let {\n    run\n  } = _ref2;\n  const dependencyGraph = await run(task_names_1.TASK_FLATTEN_GET_DEPENDENCY_GRAPH, {\n    files\n  });\n  let flattened = \"\";\n\n  if (dependencyGraph.getResolvedFiles().length === 0) {\n    return flattened;\n  }\n\n  const packageJson = await (0, packageInfo_1.getPackageJson)();\n  flattened += `// Sources flattened with hardhat v${packageJson.version} https://hardhat.org`;\n  const sortedFiles = getSortedFiles(dependencyGraph);\n\n  for (const file of sortedFiles) {\n    flattened += `\\n\\n// File ${file.getVersionedName()}\\n`;\n    flattened += `\\n${getFileWithoutImports(file)}\\n`;\n  }\n\n  return flattened.trim();\n});\n(0, config_env_1.subtask)(task_names_1.TASK_FLATTEN_GET_DEPENDENCY_GRAPH).addOptionalParam(\"files\", undefined, undefined, config_env_1.types.any).setAction(async (_ref3, _ref4) => {\n  let {\n    files\n  } = _ref3;\n  let {\n    run\n  } = _ref4;\n  const sourcePaths = files === undefined ? await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS) : files.map(f => (0, fs_utils_1.getRealPathSync)(f));\n  const sourceNames = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES, {\n    sourcePaths\n  });\n  const dependencyGraph = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH, {\n    sourceNames\n  });\n  return dependencyGraph;\n});\n(0, config_env_1.task)(task_names_1.TASK_FLATTEN, \"Flattens and prints contracts and their dependencies\").addOptionalVariadicPositionalParam(\"files\", \"The files to flatten\", undefined, config_env_1.types.inputFile).setAction(async (_ref5, _ref6) => {\n  let {\n    files\n  } = _ref5;\n  let {\n    run\n  } = _ref6;\n  console.log(await run(task_names_1.TASK_FLATTEN_GET_FLATTENED_SOURCE, {\n    files\n  }));\n});","map":{"version":3,"mappings":"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","names":["getSortedFiles","dependenciesGraph","tsort","require","graph","filesMap","resolvedFiles","getResolvedFiles","forEach","f","sourceName","from","deps","entries","to","add","topologicalSortedNames","sort","withEntries","concat","map","sortedNames","Set","n","error","Error","toString","includes","errors_1","errors_list_1","BUILTIN_TASKS","FLATTEN_CYCLE","getFileWithoutImports","resolvedFile","IMPORT_SOLIDITY_REGEX","content","rawContent","replace","trim","task_names_1","addOptionalParam","undefined","config_env_1","any","setAction","files","run","dependencyGraph","flattened","length","packageJson","version","sortedFiles","file","getVersionedName","sourcePaths","sourceNames","addOptionalVariadicPositionalParam","inputFile","console","log"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\hardhat\\src\\builtin-tasks\\flatten.ts"],"sourcesContent":["import { subtask, task, types } from \"../internal/core/config/config-env\";\nimport { HardhatError } from \"../internal/core/errors\";\nimport { ERRORS } from \"../internal/core/errors-list\";\nimport { DependencyGraph } from \"../internal/solidity/dependencyGraph\";\nimport { ResolvedFile, ResolvedFilesMap } from \"../internal/solidity/resolver\";\nimport { getPackageJson } from \"../internal/util/packageInfo\";\n\nimport { getRealPathSync } from \"../internal/util/fs-utils\";\nimport {\n  TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH,\n  TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES,\n  TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS,\n  TASK_FLATTEN,\n  TASK_FLATTEN_GET_DEPENDENCY_GRAPH,\n  TASK_FLATTEN_GET_FLATTENED_SOURCE,\n} from \"./task-names\";\n\nfunction getSortedFiles(dependenciesGraph: DependencyGraph) {\n  const tsort = require(\"tsort\");\n  const graph = tsort();\n\n  const filesMap: ResolvedFilesMap = {};\n  const resolvedFiles = dependenciesGraph.getResolvedFiles();\n  resolvedFiles.forEach((f) => (filesMap[f.sourceName] = f));\n\n  for (const [from, deps] of dependenciesGraph.entries()) {\n    for (const to of deps) {\n      graph.add(to.sourceName, from.sourceName);\n    }\n  }\n\n  try {\n    const topologicalSortedNames: string[] = graph.sort();\n\n    // If an entry has no dependency it won't be included in the graph, so we\n    // add them and then dedup the array\n    const withEntries = topologicalSortedNames.concat(\n      resolvedFiles.map((f) => f.sourceName)\n    );\n\n    const sortedNames = [...new Set(withEntries)];\n    return sortedNames.map((n) => filesMap[n]);\n  } catch (error) {\n    if (error instanceof Error) {\n      if (error.toString().includes(\"Error: There is a cycle in the graph.\")) {\n        throw new HardhatError(ERRORS.BUILTIN_TASKS.FLATTEN_CYCLE, {}, error);\n      }\n    }\n\n    // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n}\n\nfunction getFileWithoutImports(resolvedFile: ResolvedFile) {\n  const IMPORT_SOLIDITY_REGEX = /^\\s*import(\\s+)[\\s\\S]*?;\\s*$/gm;\n\n  return resolvedFile.content.rawContent\n    .replace(IMPORT_SOLIDITY_REGEX, \"\")\n    .trim();\n}\n\nsubtask(\n  TASK_FLATTEN_GET_FLATTENED_SOURCE,\n  \"Returns all contracts and their dependencies flattened\"\n)\n  .addOptionalParam(\"files\", undefined, undefined, types.any)\n  .setAction(async ({ files }: { files?: string[] }, { run }) => {\n    const dependencyGraph: DependencyGraph = await run(\n      TASK_FLATTEN_GET_DEPENDENCY_GRAPH,\n      { files }\n    );\n\n    let flattened = \"\";\n\n    if (dependencyGraph.getResolvedFiles().length === 0) {\n      return flattened;\n    }\n\n    const packageJson = await getPackageJson();\n    flattened += `// Sources flattened with hardhat v${packageJson.version} https://hardhat.org`;\n\n    const sortedFiles = getSortedFiles(dependencyGraph);\n\n    for (const file of sortedFiles) {\n      flattened += `\\n\\n// File ${file.getVersionedName()}\\n`;\n      flattened += `\\n${getFileWithoutImports(file)}\\n`;\n    }\n\n    return flattened.trim();\n  });\n\nsubtask(TASK_FLATTEN_GET_DEPENDENCY_GRAPH)\n  .addOptionalParam(\"files\", undefined, undefined, types.any)\n  .setAction(async ({ files }: { files: string[] | undefined }, { run }) => {\n    const sourcePaths: string[] =\n      files === undefined\n        ? await run(TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS)\n        : files.map((f) => getRealPathSync(f));\n\n    const sourceNames: string[] = await run(\n      TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES,\n      {\n        sourcePaths,\n      }\n    );\n\n    const dependencyGraph: DependencyGraph = await run(\n      TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH,\n      { sourceNames }\n    );\n\n    return dependencyGraph;\n  });\n\ntask(TASK_FLATTEN, \"Flattens and prints contracts and their dependencies\")\n  .addOptionalVariadicPositionalParam(\n    \"files\",\n    \"The files to flatten\",\n    undefined,\n    types.inputFile\n  )\n  .setAction(async ({ files }: { files: string[] | undefined }, { run }) => {\n    console.log(await run(TASK_FLATTEN_GET_FLATTENED_SOURCE, { files }));\n  });\n"]},"metadata":{},"sourceType":"script"}