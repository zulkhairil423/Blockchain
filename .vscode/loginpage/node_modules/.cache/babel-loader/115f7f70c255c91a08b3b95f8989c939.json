{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.download = void 0;\n\nconst fs_1 = __importDefault(require(\"fs\"));\n\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst util_1 = __importDefault(require(\"util\"));\n\nconst packageInfo_1 = require(\"./packageInfo\");\n\nconst TEMP_FILE_PREFIX = \"tmp-\";\n\nfunction resolveTempFileName(filePath) {\n  const {\n    dir,\n    ext,\n    name\n  } = path_1.default.parse(filePath);\n  return path_1.default.format({\n    dir,\n    ext,\n    name: `${TEMP_FILE_PREFIX}${name}`\n  });\n}\n\nasync function download(url, filePath) {\n  let timeoutMillis = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10000;\n  const {\n    pipeline\n  } = await Promise.resolve().then(() => __importStar(require(\"stream\")));\n  const {\n    getGlobalDispatcher,\n    ProxyAgent,\n    request\n  } = await Promise.resolve().then(() => __importStar(require(\"undici\")));\n  const streamPipeline = util_1.default.promisify(pipeline);\n\n  function chooseDispatcher() {\n    if (process.env.HTTPS_PROXY !== undefined) {\n      return new ProxyAgent(process.env.HTTPS_PROXY);\n    }\n\n    if (process.env.HTTP_PROXY !== undefined) {\n      return new ProxyAgent(process.env.HTTP_PROXY);\n    }\n\n    return getGlobalDispatcher();\n  }\n\n  const hardhatVersion = (0, packageInfo_1.getHardhatVersion)(); // Fetch the url\n\n  const response = await request(url, {\n    dispatcher: chooseDispatcher(),\n    headersTimeout: timeoutMillis,\n    maxRedirections: 10,\n    method: \"GET\",\n    headers: {\n      \"User-Agent\": `hardhat ${hardhatVersion ?? \"(unknown version)\"}`\n    }\n  });\n\n  if (response.statusCode >= 200 && response.statusCode <= 299) {\n    const tmpFilePath = resolveTempFileName(filePath);\n    await fs_extra_1.default.ensureDir(path_1.default.dirname(filePath));\n    await streamPipeline(response.body, fs_1.default.createWriteStream(tmpFilePath));\n    return fs_extra_1.default.move(tmpFilePath, filePath, {\n      overwrite: true\n    });\n  } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n  throw new Error(`Failed to download ${url} - ${response.statusCode} received. ${await response.body.text()}`);\n}\n\nexports.download = download;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;AACA;;AAEA;;AAEA,MAAMA,gBAAgB,GAAG,MAAzB;;AAEA,SAASC,mBAAT,CAA6BC,QAA7B,EAA6C;EAC3C,MAAM;IAAEC,GAAF;IAAOC,GAAP;IAAYC;EAAZ,IAAqBC,eAAKC,KAAL,CAAWL,QAAX,CAA3B;EAEA,OAAOI,eAAKE,MAAL,CAAY;IACjBL,GADiB;IAEjBC,GAFiB;IAGjBC,IAAI,EAAE,GAAGL,gBAAgB,GAAGK,IAAI;EAHf,CAAZ,CAAP;AAKD;;AAEM,eAAeI,QAAf,CACLC,GADK,EAELR,QAFK,EAGgB;EAAA,IAArBS,aAAqB,uEAAL,KAAK;EAErB,MAAM;IAAEC;EAAF,IAAe,wDAAa,QAAb,GAArB;EACA,MAAM;IAAEC,mBAAF;IAAuBC,UAAvB;IAAmCC;EAAnC,IAA+C,wDAAa,QAAb,GAArD;EACA,MAAMC,cAAc,GAAGC,eAAKC,SAAL,CAAeN,QAAf,CAAvB;;EAEA,SAASO,gBAAT,GAAyB;IACvB,IAAIC,OAAO,CAACC,GAAR,CAAYC,WAAZ,KAA4BC,SAAhC,EAA2C;MACzC,OAAO,IAAIT,UAAJ,CAAeM,OAAO,CAACC,GAAR,CAAYC,WAA3B,CAAP;IACD;;IAED,IAAIF,OAAO,CAACC,GAAR,CAAYG,UAAZ,KAA2BD,SAA/B,EAA0C;MACxC,OAAO,IAAIT,UAAJ,CAAeM,OAAO,CAACC,GAAR,CAAYG,UAA3B,CAAP;IACD;;IAED,OAAOX,mBAAmB,EAA1B;EACD;;EAED,MAAMY,cAAc,GAAG,sCAAvB,CAlBqB,CAoBrB;;EACA,MAAMC,QAAQ,GAAG,MAAMX,OAAO,CAACL,GAAD,EAAM;IAClCiB,UAAU,EAAER,gBAAgB,EADM;IAElCS,cAAc,EAAEjB,aAFkB;IAGlCkB,eAAe,EAAE,EAHiB;IAIlCC,MAAM,EAAE,KAJ0B;IAKlCC,OAAO,EAAE;MACP,cAAc,WAAWN,cAAc,IAAI,mBAAmB;IADvD;EALyB,CAAN,CAA9B;;EAUA,IAAIC,QAAQ,CAACM,UAAT,IAAuB,GAAvB,IAA8BN,QAAQ,CAACM,UAAT,IAAuB,GAAzD,EAA8D;IAC5D,MAAMC,WAAW,GAAGhC,mBAAmB,CAACC,QAAD,CAAvC;IACA,MAAMgC,mBAAQC,SAAR,CAAkB7B,eAAK8B,OAAL,CAAalC,QAAb,CAAlB,CAAN;IAEA,MAAMc,cAAc,CAACU,QAAQ,CAACW,IAAV,EAAgBC,aAAGC,iBAAH,CAAqBN,WAArB,CAAhB,CAApB;IACA,OAAOC,mBAAQM,IAAR,CAAaP,WAAb,EAA0B/B,QAA1B,EAAoC;MAAEuC,SAAS,EAAE;IAAb,CAApC,CAAP;EACD,CArCoB,CAuCrB;;;EACA,MAAM,IAAIC,KAAJ,CACJ,sBAAsBhC,GAAG,MACvBgB,QAAQ,CAACM,UACX,cAAc,MAAMN,QAAQ,CAACW,IAAT,CAAcM,IAAd,EAAoB,EAHpC,CAAN;AAKD;;AAhDDC","names":["TEMP_FILE_PREFIX","resolveTempFileName","filePath","dir","ext","name","path_1","parse","format","download","url","timeoutMillis","pipeline","getGlobalDispatcher","ProxyAgent","request","streamPipeline","util_1","promisify","chooseDispatcher","process","env","HTTPS_PROXY","undefined","HTTP_PROXY","hardhatVersion","response","dispatcher","headersTimeout","maxRedirections","method","headers","statusCode","tmpFilePath","fs_extra_1","ensureDir","dirname","body","fs_1","createWriteStream","move","overwrite","Error","text","exports"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\hardhat\\src\\internal\\util\\download.ts"],"sourcesContent":["import fs from \"fs\";\nimport fsExtra from \"fs-extra\";\nimport path from \"path\";\nimport util from \"util\";\n\nimport { getHardhatVersion } from \"./packageInfo\";\n\nconst TEMP_FILE_PREFIX = \"tmp-\";\n\nfunction resolveTempFileName(filePath: string): string {\n  const { dir, ext, name } = path.parse(filePath);\n\n  return path.format({\n    dir,\n    ext,\n    name: `${TEMP_FILE_PREFIX}${name}`,\n  });\n}\n\nexport async function download(\n  url: string,\n  filePath: string,\n  timeoutMillis = 10000\n) {\n  const { pipeline } = await import(\"stream\");\n  const { getGlobalDispatcher, ProxyAgent, request } = await import(\"undici\");\n  const streamPipeline = util.promisify(pipeline);\n\n  function chooseDispatcher() {\n    if (process.env.HTTPS_PROXY !== undefined) {\n      return new ProxyAgent(process.env.HTTPS_PROXY);\n    }\n\n    if (process.env.HTTP_PROXY !== undefined) {\n      return new ProxyAgent(process.env.HTTP_PROXY);\n    }\n\n    return getGlobalDispatcher();\n  }\n\n  const hardhatVersion = getHardhatVersion();\n\n  // Fetch the url\n  const response = await request(url, {\n    dispatcher: chooseDispatcher(),\n    headersTimeout: timeoutMillis,\n    maxRedirections: 10,\n    method: \"GET\",\n    headers: {\n      \"User-Agent\": `hardhat ${hardhatVersion ?? \"(unknown version)\"}`,\n    },\n  });\n\n  if (response.statusCode >= 200 && response.statusCode <= 299) {\n    const tmpFilePath = resolveTempFileName(filePath);\n    await fsExtra.ensureDir(path.dirname(filePath));\n\n    await streamPipeline(response.body, fs.createWriteStream(tmpFilePath));\n    return fsExtra.move(tmpFilePath, filePath, { overwrite: true });\n  }\n\n  // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n  throw new Error(\n    `Failed to download ${url} - ${\n      response.statusCode\n    } received. ${await response.body.text()}`\n  );\n}\n"]},"metadata":{},"sourceType":"script"}