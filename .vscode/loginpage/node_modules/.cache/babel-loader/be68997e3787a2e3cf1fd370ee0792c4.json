{"ast":null,"code":"'use strict';\n\nconst {\n  kProxy,\n  kClose,\n  kDestroy,\n  kInterceptors\n} = require('./core/symbols');\n\nconst {\n  URL\n} = require('url');\n\nconst Agent = require('./agent');\n\nconst Client = require('./client');\n\nconst DispatcherBase = require('./dispatcher-base');\n\nconst {\n  InvalidArgumentError,\n  RequestAbortedError\n} = require('./core/errors');\n\nconst buildConnector = require('./core/connect');\n\nconst kAgent = Symbol('proxy agent');\nconst kClient = Symbol('proxy client');\nconst kProxyHeaders = Symbol('proxy headers');\nconst kRequestTls = Symbol('request tls settings');\nconst kProxyTls = Symbol('proxy tls settings');\nconst kConnectEndpoint = Symbol('connect endpoint function');\n\nfunction defaultProtocolPort(protocol) {\n  return protocol === 'https:' ? 443 : 80;\n}\n\nfunction buildProxyOptions(opts) {\n  if (typeof opts === 'string') {\n    opts = {\n      uri: opts\n    };\n  }\n\n  if (!opts || !opts.uri) {\n    throw new InvalidArgumentError('Proxy opts.uri is mandatory');\n  }\n\n  return {\n    uri: opts.uri,\n    protocol: opts.protocol || 'https'\n  };\n}\n\nclass ProxyAgent extends DispatcherBase {\n  constructor(opts) {\n    super(opts);\n    this[kProxy] = buildProxyOptions(opts);\n    this[kAgent] = new Agent(opts);\n    this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];\n\n    if (typeof opts === 'string') {\n      opts = {\n        uri: opts\n      };\n    }\n\n    if (!opts || !opts.uri) {\n      throw new InvalidArgumentError('Proxy opts.uri is mandatory');\n    }\n\n    this[kRequestTls] = opts.requestTls;\n    this[kProxyTls] = opts.proxyTls;\n    this[kProxyHeaders] = {};\n\n    if (opts.auth) {\n      this[kProxyHeaders]['proxy-authorization'] = `Basic ${opts.auth}`;\n    }\n\n    const resolvedUrl = new URL(opts.uri);\n    const {\n      origin,\n      port,\n      host\n    } = resolvedUrl;\n    const connect = buildConnector({ ...opts.proxyTls\n    });\n    this[kConnectEndpoint] = buildConnector({ ...opts.requestTls\n    });\n    this[kClient] = new Client(resolvedUrl, {\n      connect\n    });\n    this[kAgent] = new Agent({ ...opts,\n      connect: async (opts, callback) => {\n        let requestedHost = opts.host;\n\n        if (!opts.port) {\n          requestedHost += `:${defaultProtocolPort(opts.protocol)}`;\n        }\n\n        try {\n          const {\n            socket,\n            statusCode\n          } = await this[kClient].connect({\n            origin,\n            port,\n            path: requestedHost,\n            signal: opts.signal,\n            headers: { ...this[kProxyHeaders],\n              host\n            }\n          });\n\n          if (statusCode !== 200) {\n            socket.on('error', () => {}).destroy();\n            callback(new RequestAbortedError('Proxy response !== 200 when HTTP Tunneling'));\n          }\n\n          if (opts.protocol !== 'https:') {\n            callback(null, socket);\n            return;\n          }\n\n          let servername;\n\n          if (this[kRequestTls]) {\n            servername = this[kRequestTls].servername;\n          } else {\n            servername = opts.servername;\n          }\n\n          this[kConnectEndpoint]({ ...opts,\n            servername,\n            httpSocket: socket\n          }, callback);\n        } catch (err) {\n          callback(err);\n        }\n      }\n    });\n  }\n\n  dispatch(opts, handler) {\n    const {\n      host\n    } = new URL(opts.origin);\n    const headers = buildHeaders(opts.headers);\n    throwIfProxyAuthIsSent(headers);\n    return this[kAgent].dispatch({ ...opts,\n      headers: { ...headers,\n        host\n      }\n    }, handler);\n  }\n\n  async [kClose]() {\n    await this[kAgent].close();\n    await this[kClient].close();\n  }\n\n  async [kDestroy]() {\n    await this[kAgent].destroy();\n    await this[kClient].destroy();\n  }\n\n}\n/**\n * @param {string[] | Record<string, string>} headers\n * @returns {Record<string, string>}\n */\n\n\nfunction buildHeaders(headers) {\n  // When using undici.fetch, the headers list is stored\n  // as an array.\n  if (Array.isArray(headers)) {\n    /** @type {Record<string, string>} */\n    const headersPair = {};\n\n    for (let i = 0; i < headers.length; i += 2) {\n      headersPair[headers[i]] = headers[i + 1];\n    }\n\n    return headersPair;\n  }\n\n  return headers;\n}\n/**\n * @param {Record<string, string>} headers\n *\n * Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers\n * Nevertheless, it was changed and to avoid a security vulnerability by end users\n * this check was created.\n * It should be removed in the next major version for performance reasons\n */\n\n\nfunction throwIfProxyAuthIsSent(headers) {\n  const existProxyAuth = headers && Object.keys(headers).find(key => key.toLowerCase() === 'proxy-authorization');\n\n  if (existProxyAuth) {\n    throw new InvalidArgumentError('Proxy-Authorization should be sent in ProxyAgent constructor');\n  }\n}\n\nmodule.exports = ProxyAgent;","map":{"version":3,"names":["kProxy","kClose","kDestroy","kInterceptors","require","URL","Agent","Client","DispatcherBase","InvalidArgumentError","RequestAbortedError","buildConnector","kAgent","Symbol","kClient","kProxyHeaders","kRequestTls","kProxyTls","kConnectEndpoint","defaultProtocolPort","protocol","buildProxyOptions","opts","uri","ProxyAgent","constructor","interceptors","Array","isArray","requestTls","proxyTls","auth","resolvedUrl","origin","port","host","connect","callback","requestedHost","socket","statusCode","path","signal","headers","on","destroy","servername","httpSocket","err","dispatch","handler","buildHeaders","throwIfProxyAuthIsSent","close","headersPair","i","length","existProxyAuth","Object","keys","find","key","toLowerCase","module","exports"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/undici/lib/proxy-agent.js"],"sourcesContent":["'use strict'\n\nconst { kProxy, kClose, kDestroy, kInterceptors } = require('./core/symbols')\nconst { URL } = require('url')\nconst Agent = require('./agent')\nconst Client = require('./client')\nconst DispatcherBase = require('./dispatcher-base')\nconst { InvalidArgumentError, RequestAbortedError } = require('./core/errors')\nconst buildConnector = require('./core/connect')\n\nconst kAgent = Symbol('proxy agent')\nconst kClient = Symbol('proxy client')\nconst kProxyHeaders = Symbol('proxy headers')\nconst kRequestTls = Symbol('request tls settings')\nconst kProxyTls = Symbol('proxy tls settings')\nconst kConnectEndpoint = Symbol('connect endpoint function')\n\nfunction defaultProtocolPort (protocol) {\n  return protocol === 'https:' ? 443 : 80\n}\n\nfunction buildProxyOptions (opts) {\n  if (typeof opts === 'string') {\n    opts = { uri: opts }\n  }\n\n  if (!opts || !opts.uri) {\n    throw new InvalidArgumentError('Proxy opts.uri is mandatory')\n  }\n\n  return {\n    uri: opts.uri,\n    protocol: opts.protocol || 'https'\n  }\n}\n\nclass ProxyAgent extends DispatcherBase {\n  constructor (opts) {\n    super(opts)\n    this[kProxy] = buildProxyOptions(opts)\n    this[kAgent] = new Agent(opts)\n    this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent)\n      ? opts.interceptors.ProxyAgent\n      : []\n\n    if (typeof opts === 'string') {\n      opts = { uri: opts }\n    }\n\n    if (!opts || !opts.uri) {\n      throw new InvalidArgumentError('Proxy opts.uri is mandatory')\n    }\n\n    this[kRequestTls] = opts.requestTls\n    this[kProxyTls] = opts.proxyTls\n    this[kProxyHeaders] = {}\n\n    if (opts.auth) {\n      this[kProxyHeaders]['proxy-authorization'] = `Basic ${opts.auth}`\n    }\n\n    const resolvedUrl = new URL(opts.uri)\n    const { origin, port, host } = resolvedUrl\n\n    const connect = buildConnector({ ...opts.proxyTls })\n    this[kConnectEndpoint] = buildConnector({ ...opts.requestTls })\n    this[kClient] = new Client(resolvedUrl, { connect })\n    this[kAgent] = new Agent({\n      ...opts,\n      connect: async (opts, callback) => {\n        let requestedHost = opts.host\n        if (!opts.port) {\n          requestedHost += `:${defaultProtocolPort(opts.protocol)}`\n        }\n        try {\n          const { socket, statusCode } = await this[kClient].connect({\n            origin,\n            port,\n            path: requestedHost,\n            signal: opts.signal,\n            headers: {\n              ...this[kProxyHeaders],\n              host\n            }\n          })\n          if (statusCode !== 200) {\n            socket.on('error', () => {}).destroy()\n            callback(new RequestAbortedError('Proxy response !== 200 when HTTP Tunneling'))\n          }\n          if (opts.protocol !== 'https:') {\n            callback(null, socket)\n            return\n          }\n          let servername\n          if (this[kRequestTls]) {\n            servername = this[kRequestTls].servername\n          } else {\n            servername = opts.servername\n          }\n          this[kConnectEndpoint]({ ...opts, servername, httpSocket: socket }, callback)\n        } catch (err) {\n          callback(err)\n        }\n      }\n    })\n  }\n\n  dispatch (opts, handler) {\n    const { host } = new URL(opts.origin)\n    const headers = buildHeaders(opts.headers)\n    throwIfProxyAuthIsSent(headers)\n    return this[kAgent].dispatch(\n      {\n        ...opts,\n        headers: {\n          ...headers,\n          host\n        }\n      },\n      handler\n    )\n  }\n\n  async [kClose] () {\n    await this[kAgent].close()\n    await this[kClient].close()\n  }\n\n  async [kDestroy] () {\n    await this[kAgent].destroy()\n    await this[kClient].destroy()\n  }\n}\n\n/**\n * @param {string[] | Record<string, string>} headers\n * @returns {Record<string, string>}\n */\nfunction buildHeaders (headers) {\n  // When using undici.fetch, the headers list is stored\n  // as an array.\n  if (Array.isArray(headers)) {\n    /** @type {Record<string, string>} */\n    const headersPair = {}\n\n    for (let i = 0; i < headers.length; i += 2) {\n      headersPair[headers[i]] = headers[i + 1]\n    }\n\n    return headersPair\n  }\n\n  return headers\n}\n\n/**\n * @param {Record<string, string>} headers\n *\n * Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers\n * Nevertheless, it was changed and to avoid a security vulnerability by end users\n * this check was created.\n * It should be removed in the next major version for performance reasons\n */\nfunction throwIfProxyAuthIsSent (headers) {\n  const existProxyAuth = headers && Object.keys(headers)\n    .find((key) => key.toLowerCase() === 'proxy-authorization')\n  if (existProxyAuth) {\n    throw new InvalidArgumentError('Proxy-Authorization should be sent in ProxyAgent constructor')\n  }\n}\n\nmodule.exports = ProxyAgent\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}