{"ast":null,"code":"const assert = require('assert');\n\nconst {\n  atob\n} = require('buffer');\n\nconst {\n  isValidHTTPToken\n} = require('./util');\n\nconst encoder = new TextEncoder(); // https://fetch.spec.whatwg.org/#data-url-processor\n\n/** @param {URL} dataURL */\n\nfunction dataURLProcessor(dataURL) {\n  // 1. Assert: dataURL’s scheme is \"data\".\n  assert(dataURL.protocol === 'data:'); // 2. Let input be the result of running the URL\n  // serializer on dataURL with exclude fragment\n  // set to true.\n\n  let input = URLSerializer(dataURL, true); // 3. Remove the leading \"data:\" string from input.\n\n  input = input.slice(5); // 4. Let position point at the start of input.\n\n  const position = {\n    position: 0\n  }; // 5. Let mimeType be the result of collecting a\n  // sequence of code points that are not equal\n  // to U+002C (,), given position.\n\n  let mimeType = collectASequenceOfCodePoints(char => char !== ',', input, position); // 6. Strip leading and trailing ASCII whitespace\n  // from mimeType.\n  // Note: This will only remove U+0020 SPACE code\n  // points, if any.\n  // Undici implementation note: we need to store the\n  // length because if the mimetype has spaces removed,\n  // the wrong amount will be sliced from the input in\n  // step #9\n\n  const mimeTypeLength = mimeType.length;\n  mimeType = mimeType.replace(/^(\\u0020)+|(\\u0020)+$/g, ''); // 7. If position is past the end of input, then\n  // return failure\n\n  if (position.position >= input.length) {\n    return 'failure';\n  } // 8. Advance position by 1.\n\n\n  position.position++; // 9. Let encodedBody be the remainder of input.\n\n  const encodedBody = input.slice(mimeTypeLength + 1); // 10. Let body be the percent-decoding of encodedBody.\n\n  /** @type {Uint8Array|string} */\n\n  let body = stringPercentDecode(encodedBody); // 11. If mimeType ends with U+003B (;), followed by\n  // zero or more U+0020 SPACE, followed by an ASCII\n  // case-insensitive match for \"base64\", then:\n\n  if (/;(\\u0020){0,}base64$/i.test(mimeType)) {\n    // 1. Let stringBody be the isomorphic decode of body.\n    const stringBody = decodeURIComponent(new TextDecoder('utf-8').decode(body)); // 2. Set body to the forgiving-base64 decode of\n    // stringBody.\n\n    body = forgivingBase64(stringBody); // 3. If body is failure, then return failure.\n\n    if (body === 'failure') {\n      return 'failure';\n    } // 4. Remove the last 6 code points from mimeType.\n\n\n    mimeType = mimeType.slice(0, -6); // 5. Remove trailing U+0020 SPACE code points from mimeType,\n    // if any.\n\n    mimeType = mimeType.replace(/(\\u0020)+$/, ''); // 6. Remove the last U+003B (;) code point from mimeType.\n\n    mimeType = mimeType.slice(0, -1);\n  } // 12. If mimeType starts with U+003B (;), then prepend\n  // \"text/plain\" to mimeType.\n\n\n  if (mimeType.startsWith(';')) {\n    mimeType = 'text/plain' + mimeType;\n  } // 13. Let mimeTypeRecord be the result of parsing\n  // mimeType.\n\n\n  let mimeTypeRecord = parseMIMEType(mimeType); // 14. If mimeTypeRecord is failure, then set\n  // mimeTypeRecord to text/plain;charset=US-ASCII.\n\n  if (mimeTypeRecord === 'failure') {\n    mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII');\n  } // 15. Return a new data: URL struct whose MIME\n  // type is mimeTypeRecord and body is body.\n  // https://fetch.spec.whatwg.org/#data-url-struct\n\n\n  return {\n    mimeType: mimeTypeRecord,\n    body\n  };\n} // https://url.spec.whatwg.org/#concept-url-serializer\n\n/**\n * @param {URL} url\n * @param {boolean} excludeFragment\n */\n\n\nfunction URLSerializer(url) {\n  let excludeFragment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  // 1. Let output be url’s scheme and U+003A (:) concatenated.\n  let output = url.protocol; // 2. If url’s host is non-null:\n\n  if (url.host.length > 0) {\n    // 1. Append \"//\" to output.\n    output += '//'; // 2. If url includes credentials, then:\n\n    if (url.username.length > 0 || url.password.length > 0) {\n      // 1. Append url’s username to output.\n      output += url.username; // 2. If url’s password is not the empty string, then append U+003A (:),\n      // followed by url’s password, to output.\n\n      if (url.password.length > 0) {\n        output += ':' + url.password;\n      } // 3. Append U+0040 (@) to output.\n\n\n      output += '@';\n    } // 3. Append url’s host, serialized, to output.\n\n\n    output += decodeURIComponent(url.host); // 4. If url’s port is non-null, append U+003A (:) followed by url’s port,\n    // serialized, to output.\n\n    if (url.port.length > 0) {\n      output += ':' + url.port;\n    }\n  } // 3. If url’s host is null, url does not have an opaque path,\n  // url’s path’s size is greater than 1, and url’s path[0]\n  // is the empty string, then append U+002F (/) followed by\n  // U+002E (.) to output.\n  // Note: This prevents web+demo:/.//not-a-host/ or web+demo:/path/..//not-a-host/,\n  // when parsed and then serialized, from ending up as web+demo://not-a-host/\n  // (they end up as web+demo:/.//not-a-host/).\n  // Undici implementation note: url's path[0] can never be an\n  // empty string, so we have to slightly alter what the spec says.\n\n\n  if (url.host.length === 0 && url.pathname.length > 1 && url.href.slice(url.protocol.length + 1)[0] === '.') {\n    output += '/.';\n  } // 4. Append the result of URL path serializing url to output.\n\n\n  output += url.pathname; // 5. If url’s query is non-null, append U+003F (?),\n  // followed by url’s query, to output.\n\n  if (url.search.length > 0) {\n    output += url.search;\n  } // 6. If exclude fragment is false and url’s fragment is non-null,\n  // then append U+0023 (#), followed by url’s fragment, to output.\n\n\n  if (excludeFragment === false && url.hash.length > 0) {\n    output += url.hash;\n  } // 7. Return output.\n\n\n  return output;\n} // https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points\n\n/**\n * @param {(char: string) => boolean} condition\n * @param {string} input\n * @param {{ position: number }} position\n */\n\n\nfunction collectASequenceOfCodePoints(condition, input, position) {\n  // 1. Let result be the empty string.\n  let result = ''; // 2. While position doesn’t point past the end of input and the\n  // code point at position within input meets the condition condition:\n\n  while (position.position < input.length && condition(input[position.position])) {\n    // 1. Append that code point to the end of result.\n    result += input[position.position]; // 2. Advance position by 1.\n\n    position.position++;\n  } // 3. Return result.\n\n\n  return result;\n} // https://url.spec.whatwg.org/#string-percent-decode\n\n/** @param {string} input */\n\n\nfunction stringPercentDecode(input) {\n  // 1. Let bytes be the UTF-8 encoding of input.\n  const bytes = encoder.encode(input); // 2. Return the percent-decoding of bytes.\n\n  return percentDecode(bytes);\n} // https://url.spec.whatwg.org/#percent-decode\n\n/** @param {Uint8Array} input */\n\n\nfunction percentDecode(input) {\n  // 1. Let output be an empty byte sequence.\n\n  /** @type {number[]} */\n  const output = []; // 2. For each byte byte in input:\n\n  for (let i = 0; i < input.length; i++) {\n    const byte = input[i]; // 1. If byte is not 0x25 (%), then append byte to output.\n\n    if (byte !== 0x25) {\n      output.push(byte); // 2. Otherwise, if byte is 0x25 (%) and the next two bytes\n      // after byte in input are not in the ranges\n      // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),\n      // and 0x61 (a) to 0x66 (f), all inclusive, append byte\n      // to output.\n    } else if (byte === 0x25 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) {\n      output.push(0x25); // 3. Otherwise:\n    } else {\n      // 1. Let bytePoint be the two bytes after byte in input,\n      // decoded, and then interpreted as hexadecimal number.\n      const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);\n      const bytePoint = Number.parseInt(nextTwoBytes, 16); // 2. Append a byte whose value is bytePoint to output.\n\n      output.push(bytePoint); // 3. Skip the next two bytes in input.\n\n      i += 2;\n    }\n  } // 3. Return output.\n\n\n  return Uint8Array.from(output);\n} // https://mimesniff.spec.whatwg.org/#parse-a-mime-type\n\n/** @param {string} input */\n\n\nfunction parseMIMEType(input) {\n  // 1. Remove any leading and trailing HTTP whitespace\n  // from input.\n  input = input.trim(); // 2. Let position be a position variable for input,\n  // initially pointing at the start of input.\n\n  const position = {\n    position: 0\n  }; // 3. Let type be the result of collecting a sequence\n  // of code points that are not U+002F (/) from\n  // input, given position.\n\n  const type = collectASequenceOfCodePoints(char => char !== '/', input, position); // 4. If type is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  // https://mimesniff.spec.whatwg.org/#http-token-code-point\n\n  if (type.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(type)) {\n    return 'failure';\n  } // 5. If position is past the end of input, then return\n  // failure\n\n\n  if (position.position > input.length) {\n    return 'failure';\n  } // 6. Advance position by 1. (This skips past U+002F (/).)\n\n\n  position.position++; // 7. Let subtype be the result of collecting a sequence of\n  // code points that are not U+003B (;) from input, given\n  // position.\n\n  let subtype = collectASequenceOfCodePoints(char => char !== ';', input, position); // 8. Remove any trailing HTTP whitespace from subtype.\n\n  subtype = subtype.trim(); // 9. If subtype is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n\n  if (subtype.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(subtype)) {\n    return 'failure';\n  } // 10. Let mimeType be a new MIME type record whose type\n  // is type, in ASCII lowercase, and subtype is subtype,\n  // in ASCII lowercase.\n  // https://mimesniff.spec.whatwg.org/#mime-type\n\n\n  const mimeType = {\n    type: type.toLowerCase(),\n    subtype: subtype.toLowerCase(),\n\n    /** @type {Map<string, string>} */\n    parameters: new Map()\n  }; // 11. While position is not past the end of input:\n\n  while (position.position < input.length) {\n    // 1. Advance position by 1. (This skips past U+003B (;).)\n    position.position++; // 2. Collect a sequence of code points that are HTTP\n    // whitespace from input given position.\n\n    collectASequenceOfCodePoints( // https://fetch.spec.whatwg.org/#http-whitespace\n    char => /(\\u000A|\\u000D|\\u0009|\\u0020)/.test(char), // eslint-disable-line\n    input, position); // 3. Let parameterName be the result of collecting a\n    // sequence of code points that are not U+003B (;)\n    // or U+003D (=) from input, given position.\n\n    let parameterName = collectASequenceOfCodePoints(char => char !== ';' && char !== '=', input, position); // 4. Set parameterName to parameterName, in ASCII\n    // lowercase.\n\n    parameterName = parameterName.toLowerCase(); // 5. If position is not past the end of input, then:\n\n    if (position.position < input.length) {\n      // 1. If the code point at position within input is\n      // U+003B (;), then continue.\n      if (input[position.position] === ';') {\n        continue;\n      } // 2. Advance position by 1. (This skips past U+003D (=).)\n\n\n      position.position++;\n    } // 6. If position is past the end of input, then break.\n\n\n    if (position.position > input.length) {\n      break;\n    } // 7. Let parameterValue be null.\n\n\n    let parameterValue = null; // 8. If the code point at position within input is\n    // U+0022 (\"), then:\n\n    if (input[position.position] === '\"') {\n      // 1. Set parameterValue to the result of collecting\n      // an HTTP quoted string from input, given position\n      // and the extract-value flag.\n      parameterValue = collectAnHTTPQuotedString(input, position, true); // 2. Collect a sequence of code points that are not\n      // U+003B (;) from input, given position.\n\n      collectASequenceOfCodePoints(char => char !== ';', input, position); // 9. Otherwise:\n    } else {\n      // 1. Set parameterValue to the result of collecting\n      // a sequence of code points that are not U+003B (;)\n      // from input, given position.\n      parameterValue = collectASequenceOfCodePoints(char => char !== ';', input, position); // 2. Remove any trailing HTTP whitespace from parameterValue.\n      // Note: it says \"trailing\" whitespace; leading is fine.\n\n      parameterValue = parameterValue.trimEnd(); // 3. If parameterValue is the empty string, then continue.\n\n      if (parameterValue.length === 0) {\n        continue;\n      }\n    } // 10. If all of the following are true\n    // - parameterName is not the empty string\n    // - parameterName solely contains HTTP token code points\n    // - parameterValue solely contains HTTP quoted-string token code points\n    // - mimeType’s parameters[parameterName] does not exist\n    // then set mimeType’s parameters[parameterName] to parameterValue.\n\n\n    if (parameterName.length !== 0 && /^[!#$%&'*+-.^_|~A-z0-9]+$/.test(parameterName) && // https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point\n    !/^(\\u0009|\\x{0020}-\\x{007E}|\\x{0080}-\\x{00FF})+$/.test(parameterValue) && // eslint-disable-line\n    !mimeType.parameters.has(parameterName)) {\n      mimeType.parameters.set(parameterName, parameterValue);\n    }\n  } // 12. Return mimeType.\n\n\n  return mimeType;\n} // https://infra.spec.whatwg.org/#forgiving-base64-decode\n\n/** @param {string} data */\n\n\nfunction forgivingBase64(data) {\n  // 1. Remove all ASCII whitespace from data.\n  data = data.replace(/[\\u0009\\u000A\\u000C\\u000D\\u0020]/g, ''); // eslint-disable-line\n  // 2. If data’s code point length divides by 4 leaving\n  // no remainder, then:\n\n  if (data.length % 4 === 0) {\n    // 1. If data ends with one or two U+003D (=) code points,\n    // then remove them from data.\n    data = data.replace(/=?=$/, '');\n  } // 3. If data’s code point length divides by 4 leaving\n  // a remainder of 1, then return failure.\n\n\n  if (data.length % 4 === 1) {\n    return 'failure';\n  } // 4. If data contains a code point that is not one of\n  //  U+002B (+)\n  //  U+002F (/)\n  //  ASCII alphanumeric\n  // then return failure.\n\n\n  if (/[^+/0-9A-Za-z]/.test(data)) {\n    return 'failure';\n  }\n\n  const binary = atob(data);\n  const bytes = new Uint8Array(binary.length);\n\n  for (let byte = 0; byte < binary.length; byte++) {\n    bytes[byte] = binary.charCodeAt(byte);\n  }\n\n  return bytes;\n} // https://fetch.spec.whatwg.org/#collect-an-http-quoted-string\n// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string\n\n/**\n * @param {string} input\n * @param {{ position: number }} position\n * @param {boolean?} extractValue\n */\n\n\nfunction collectAnHTTPQuotedString(input, position, extractValue) {\n  // 1. Let positionStart be position.\n  const positionStart = position.position; // 2. Let value be the empty string.\n\n  let value = ''; // 3. Assert: the code point at position within input\n  // is U+0022 (\").\n\n  assert(input[position.position] === '\"'); // 4. Advance position by 1.\n\n  position.position++; // 5. While true:\n\n  while (true) {\n    // 1. Append the result of collecting a sequence of code points\n    // that are not U+0022 (\") or U+005C (\\) from input, given\n    // position, to value.\n    value += collectASequenceOfCodePoints(char => char !== '\"' && char !== '\\\\', input, position); // 2. If position is past the end of input, then break.\n\n    if (position.position >= input.length) {\n      break;\n    } // 3. Let quoteOrBackslash be the code point at position within\n    // input.\n\n\n    const quoteOrBackslash = input[position.position]; // 4. Advance position by 1.\n\n    position.position++; // 5. If quoteOrBackslash is U+005C (\\), then:\n\n    if (quoteOrBackslash === '\\\\') {\n      // 1. If position is past the end of input, then append\n      // U+005C (\\) to value and break.\n      if (position.position >= input.length) {\n        value += '\\\\';\n        break;\n      } // 2. Append the code point at position within input to value.\n\n\n      value += input[position.position]; // 3. Advance position by 1.\n\n      position.position++; // 6. Otherwise:\n    } else {\n      // 1. Assert: quoteOrBackslash is U+0022 (\").\n      assert(quoteOrBackslash === '\"'); // 2. Break.\n\n      break;\n    }\n  } // 6. If the extract-value flag is set, then return value.\n\n\n  if (extractValue) {\n    return value;\n  } // 7. Return the code points from positionStart to position,\n  // inclusive, within input.\n\n\n  return input.slice(positionStart, position.position);\n}\n/**\n * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type\n */\n\n\nfunction serializeAMimeType(mimeType) {\n  assert(mimeType !== 'failure');\n  const {\n    type,\n    subtype,\n    parameters\n  } = mimeType; // 1. Let serialization be the concatenation of mimeType’s\n  //    type, U+002F (/), and mimeType’s subtype.\n\n  let serialization = `${type}/${subtype}`; // 2. For each name → value of mimeType’s parameters:\n\n  for (let [name, value] of parameters.entries()) {\n    // 1. Append U+003B (;) to serialization.\n    serialization += ';'; // 2. Append name to serialization.\n\n    serialization += name; // 3. Append U+003D (=) to serialization.\n\n    serialization += '='; // 4. If value does not solely contain HTTP token code\n    //    points or value is the empty string, then:\n\n    if (!isValidHTTPToken(value)) {\n      // 1. Precede each occurence of U+0022 (\") or\n      //    U+005C (\\) in value with U+005C (\\).\n      value = value.replace(/(\\\\|\")/g, '\\\\$1'); // 2. Prepend U+0022 (\") to value.\n\n      value = '\"' + value; // 3. Append U+0022 (\") to value.\n\n      value += '\"';\n    } // 5. Append value to serialization.\n\n\n    serialization += value;\n  } // 3. Return serialization.\n\n\n  return serialization;\n}\n\nmodule.exports = {\n  dataURLProcessor,\n  URLSerializer,\n  collectASequenceOfCodePoints,\n  stringPercentDecode,\n  parseMIMEType,\n  collectAnHTTPQuotedString,\n  serializeAMimeType\n};","map":{"version":3,"names":["assert","require","atob","isValidHTTPToken","encoder","TextEncoder","dataURLProcessor","dataURL","protocol","input","URLSerializer","slice","position","mimeType","collectASequenceOfCodePoints","char","mimeTypeLength","length","replace","encodedBody","body","stringPercentDecode","test","stringBody","decodeURIComponent","TextDecoder","decode","forgivingBase64","startsWith","mimeTypeRecord","parseMIMEType","url","excludeFragment","output","host","username","password","port","pathname","href","search","hash","condition","result","bytes","encode","percentDecode","i","byte","push","String","fromCharCode","nextTwoBytes","bytePoint","Number","parseInt","Uint8Array","from","trim","type","subtype","toLowerCase","parameters","Map","parameterName","parameterValue","collectAnHTTPQuotedString","trimEnd","has","set","data","binary","charCodeAt","extractValue","positionStart","value","quoteOrBackslash","serializeAMimeType","serialization","name","entries","module","exports"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/undici/lib/fetch/dataURL.js"],"sourcesContent":["const assert = require('assert')\nconst { atob } = require('buffer')\nconst { isValidHTTPToken } = require('./util')\n\nconst encoder = new TextEncoder()\n\n// https://fetch.spec.whatwg.org/#data-url-processor\n/** @param {URL} dataURL */\nfunction dataURLProcessor (dataURL) {\n  // 1. Assert: dataURL’s scheme is \"data\".\n  assert(dataURL.protocol === 'data:')\n\n  // 2. Let input be the result of running the URL\n  // serializer on dataURL with exclude fragment\n  // set to true.\n  let input = URLSerializer(dataURL, true)\n\n  // 3. Remove the leading \"data:\" string from input.\n  input = input.slice(5)\n\n  // 4. Let position point at the start of input.\n  const position = { position: 0 }\n\n  // 5. Let mimeType be the result of collecting a\n  // sequence of code points that are not equal\n  // to U+002C (,), given position.\n  let mimeType = collectASequenceOfCodePoints(\n    (char) => char !== ',',\n    input,\n    position\n  )\n\n  // 6. Strip leading and trailing ASCII whitespace\n  // from mimeType.\n  // Note: This will only remove U+0020 SPACE code\n  // points, if any.\n  // Undici implementation note: we need to store the\n  // length because if the mimetype has spaces removed,\n  // the wrong amount will be sliced from the input in\n  // step #9\n  const mimeTypeLength = mimeType.length\n  mimeType = mimeType.replace(/^(\\u0020)+|(\\u0020)+$/g, '')\n\n  // 7. If position is past the end of input, then\n  // return failure\n  if (position.position >= input.length) {\n    return 'failure'\n  }\n\n  // 8. Advance position by 1.\n  position.position++\n\n  // 9. Let encodedBody be the remainder of input.\n  const encodedBody = input.slice(mimeTypeLength + 1)\n\n  // 10. Let body be the percent-decoding of encodedBody.\n  /** @type {Uint8Array|string} */\n  let body = stringPercentDecode(encodedBody)\n\n  // 11. If mimeType ends with U+003B (;), followed by\n  // zero or more U+0020 SPACE, followed by an ASCII\n  // case-insensitive match for \"base64\", then:\n  if (/;(\\u0020){0,}base64$/i.test(mimeType)) {\n    // 1. Let stringBody be the isomorphic decode of body.\n    const stringBody = decodeURIComponent(new TextDecoder('utf-8').decode(body))\n    // 2. Set body to the forgiving-base64 decode of\n    // stringBody.\n    body = forgivingBase64(stringBody)\n\n    // 3. If body is failure, then return failure.\n    if (body === 'failure') {\n      return 'failure'\n    }\n\n    // 4. Remove the last 6 code points from mimeType.\n    mimeType = mimeType.slice(0, -6)\n\n    // 5. Remove trailing U+0020 SPACE code points from mimeType,\n    // if any.\n    mimeType = mimeType.replace(/(\\u0020)+$/, '')\n\n    // 6. Remove the last U+003B (;) code point from mimeType.\n    mimeType = mimeType.slice(0, -1)\n  }\n\n  // 12. If mimeType starts with U+003B (;), then prepend\n  // \"text/plain\" to mimeType.\n  if (mimeType.startsWith(';')) {\n    mimeType = 'text/plain' + mimeType\n  }\n\n  // 13. Let mimeTypeRecord be the result of parsing\n  // mimeType.\n  let mimeTypeRecord = parseMIMEType(mimeType)\n\n  // 14. If mimeTypeRecord is failure, then set\n  // mimeTypeRecord to text/plain;charset=US-ASCII.\n  if (mimeTypeRecord === 'failure') {\n    mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII')\n  }\n\n  // 15. Return a new data: URL struct whose MIME\n  // type is mimeTypeRecord and body is body.\n  // https://fetch.spec.whatwg.org/#data-url-struct\n  return { mimeType: mimeTypeRecord, body }\n}\n\n// https://url.spec.whatwg.org/#concept-url-serializer\n/**\n * @param {URL} url\n * @param {boolean} excludeFragment\n */\nfunction URLSerializer (url, excludeFragment = false) {\n  // 1. Let output be url’s scheme and U+003A (:) concatenated.\n  let output = url.protocol\n\n  // 2. If url’s host is non-null:\n  if (url.host.length > 0) {\n    // 1. Append \"//\" to output.\n    output += '//'\n\n    // 2. If url includes credentials, then:\n    if (url.username.length > 0 || url.password.length > 0) {\n      // 1. Append url’s username to output.\n      output += url.username\n\n      // 2. If url’s password is not the empty string, then append U+003A (:),\n      // followed by url’s password, to output.\n      if (url.password.length > 0) {\n        output += ':' + url.password\n      }\n\n      // 3. Append U+0040 (@) to output.\n      output += '@'\n    }\n\n    // 3. Append url’s host, serialized, to output.\n    output += decodeURIComponent(url.host)\n\n    // 4. If url’s port is non-null, append U+003A (:) followed by url’s port,\n    // serialized, to output.\n    if (url.port.length > 0) {\n      output += ':' + url.port\n    }\n  }\n\n  // 3. If url’s host is null, url does not have an opaque path,\n  // url’s path’s size is greater than 1, and url’s path[0]\n  // is the empty string, then append U+002F (/) followed by\n  // U+002E (.) to output.\n  // Note: This prevents web+demo:/.//not-a-host/ or web+demo:/path/..//not-a-host/,\n  // when parsed and then serialized, from ending up as web+demo://not-a-host/\n  // (they end up as web+demo:/.//not-a-host/).\n  // Undici implementation note: url's path[0] can never be an\n  // empty string, so we have to slightly alter what the spec says.\n  if (\n    url.host.length === 0 &&\n    url.pathname.length > 1 &&\n    url.href.slice(url.protocol.length + 1)[0] === '.'\n  ) {\n    output += '/.'\n  }\n\n  // 4. Append the result of URL path serializing url to output.\n  output += url.pathname\n\n  // 5. If url’s query is non-null, append U+003F (?),\n  // followed by url’s query, to output.\n  if (url.search.length > 0) {\n    output += url.search\n  }\n\n  // 6. If exclude fragment is false and url’s fragment is non-null,\n  // then append U+0023 (#), followed by url’s fragment, to output.\n  if (excludeFragment === false && url.hash.length > 0) {\n    output += url.hash\n  }\n\n  // 7. Return output.\n  return output\n}\n\n// https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points\n/**\n * @param {(char: string) => boolean} condition\n * @param {string} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfCodePoints (condition, input, position) {\n  // 1. Let result be the empty string.\n  let result = ''\n\n  // 2. While position doesn’t point past the end of input and the\n  // code point at position within input meets the condition condition:\n  while (position.position < input.length && condition(input[position.position])) {\n    // 1. Append that code point to the end of result.\n    result += input[position.position]\n\n    // 2. Advance position by 1.\n    position.position++\n  }\n\n  // 3. Return result.\n  return result\n}\n\n// https://url.spec.whatwg.org/#string-percent-decode\n/** @param {string} input */\nfunction stringPercentDecode (input) {\n  // 1. Let bytes be the UTF-8 encoding of input.\n  const bytes = encoder.encode(input)\n\n  // 2. Return the percent-decoding of bytes.\n  return percentDecode(bytes)\n}\n\n// https://url.spec.whatwg.org/#percent-decode\n/** @param {Uint8Array} input */\nfunction percentDecode (input) {\n  // 1. Let output be an empty byte sequence.\n  /** @type {number[]} */\n  const output = []\n\n  // 2. For each byte byte in input:\n  for (let i = 0; i < input.length; i++) {\n    const byte = input[i]\n\n    // 1. If byte is not 0x25 (%), then append byte to output.\n    if (byte !== 0x25) {\n      output.push(byte)\n\n    // 2. Otherwise, if byte is 0x25 (%) and the next two bytes\n    // after byte in input are not in the ranges\n    // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),\n    // and 0x61 (a) to 0x66 (f), all inclusive, append byte\n    // to output.\n    } else if (\n      byte === 0x25 &&\n      !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))\n    ) {\n      output.push(0x25)\n\n    // 3. Otherwise:\n    } else {\n      // 1. Let bytePoint be the two bytes after byte in input,\n      // decoded, and then interpreted as hexadecimal number.\n      const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2])\n      const bytePoint = Number.parseInt(nextTwoBytes, 16)\n\n      // 2. Append a byte whose value is bytePoint to output.\n      output.push(bytePoint)\n\n      // 3. Skip the next two bytes in input.\n      i += 2\n    }\n  }\n\n  // 3. Return output.\n  return Uint8Array.from(output)\n}\n\n// https://mimesniff.spec.whatwg.org/#parse-a-mime-type\n/** @param {string} input */\nfunction parseMIMEType (input) {\n  // 1. Remove any leading and trailing HTTP whitespace\n  // from input.\n  input = input.trim()\n\n  // 2. Let position be a position variable for input,\n  // initially pointing at the start of input.\n  const position = { position: 0 }\n\n  // 3. Let type be the result of collecting a sequence\n  // of code points that are not U+002F (/) from\n  // input, given position.\n  const type = collectASequenceOfCodePoints(\n    (char) => char !== '/',\n    input,\n    position\n  )\n\n  // 4. If type is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  // https://mimesniff.spec.whatwg.org/#http-token-code-point\n  if (type.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(type)) {\n    return 'failure'\n  }\n\n  // 5. If position is past the end of input, then return\n  // failure\n  if (position.position > input.length) {\n    return 'failure'\n  }\n\n  // 6. Advance position by 1. (This skips past U+002F (/).)\n  position.position++\n\n  // 7. Let subtype be the result of collecting a sequence of\n  // code points that are not U+003B (;) from input, given\n  // position.\n  let subtype = collectASequenceOfCodePoints(\n    (char) => char !== ';',\n    input,\n    position\n  )\n\n  // 8. Remove any trailing HTTP whitespace from subtype.\n  subtype = subtype.trim()\n\n  // 9. If subtype is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  if (subtype.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(subtype)) {\n    return 'failure'\n  }\n\n  // 10. Let mimeType be a new MIME type record whose type\n  // is type, in ASCII lowercase, and subtype is subtype,\n  // in ASCII lowercase.\n  // https://mimesniff.spec.whatwg.org/#mime-type\n  const mimeType = {\n    type: type.toLowerCase(),\n    subtype: subtype.toLowerCase(),\n    /** @type {Map<string, string>} */\n    parameters: new Map()\n  }\n\n  // 11. While position is not past the end of input:\n  while (position.position < input.length) {\n    // 1. Advance position by 1. (This skips past U+003B (;).)\n    position.position++\n\n    // 2. Collect a sequence of code points that are HTTP\n    // whitespace from input given position.\n    collectASequenceOfCodePoints(\n      // https://fetch.spec.whatwg.org/#http-whitespace\n      (char) => /(\\u000A|\\u000D|\\u0009|\\u0020)/.test(char), // eslint-disable-line\n      input,\n      position\n    )\n\n    // 3. Let parameterName be the result of collecting a\n    // sequence of code points that are not U+003B (;)\n    // or U+003D (=) from input, given position.\n    let parameterName = collectASequenceOfCodePoints(\n      (char) => char !== ';' && char !== '=',\n      input,\n      position\n    )\n\n    // 4. Set parameterName to parameterName, in ASCII\n    // lowercase.\n    parameterName = parameterName.toLowerCase()\n\n    // 5. If position is not past the end of input, then:\n    if (position.position < input.length) {\n      // 1. If the code point at position within input is\n      // U+003B (;), then continue.\n      if (input[position.position] === ';') {\n        continue\n      }\n\n      // 2. Advance position by 1. (This skips past U+003D (=).)\n      position.position++\n    }\n\n    // 6. If position is past the end of input, then break.\n    if (position.position > input.length) {\n      break\n    }\n\n    // 7. Let parameterValue be null.\n    let parameterValue = null\n\n    // 8. If the code point at position within input is\n    // U+0022 (\"), then:\n    if (input[position.position] === '\"') {\n      // 1. Set parameterValue to the result of collecting\n      // an HTTP quoted string from input, given position\n      // and the extract-value flag.\n      parameterValue = collectAnHTTPQuotedString(input, position, true)\n\n      // 2. Collect a sequence of code points that are not\n      // U+003B (;) from input, given position.\n      collectASequenceOfCodePoints(\n        (char) => char !== ';',\n        input,\n        position\n      )\n\n    // 9. Otherwise:\n    } else {\n      // 1. Set parameterValue to the result of collecting\n      // a sequence of code points that are not U+003B (;)\n      // from input, given position.\n      parameterValue = collectASequenceOfCodePoints(\n        (char) => char !== ';',\n        input,\n        position\n      )\n\n      // 2. Remove any trailing HTTP whitespace from parameterValue.\n      // Note: it says \"trailing\" whitespace; leading is fine.\n      parameterValue = parameterValue.trimEnd()\n\n      // 3. If parameterValue is the empty string, then continue.\n      if (parameterValue.length === 0) {\n        continue\n      }\n    }\n\n    // 10. If all of the following are true\n    // - parameterName is not the empty string\n    // - parameterName solely contains HTTP token code points\n    // - parameterValue solely contains HTTP quoted-string token code points\n    // - mimeType’s parameters[parameterName] does not exist\n    // then set mimeType’s parameters[parameterName] to parameterValue.\n    if (\n      parameterName.length !== 0 &&\n      /^[!#$%&'*+-.^_|~A-z0-9]+$/.test(parameterName) &&\n      // https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point\n      !/^(\\u0009|\\x{0020}-\\x{007E}|\\x{0080}-\\x{00FF})+$/.test(parameterValue) &&  // eslint-disable-line\n      !mimeType.parameters.has(parameterName)\n    ) {\n      mimeType.parameters.set(parameterName, parameterValue)\n    }\n  }\n\n  // 12. Return mimeType.\n  return mimeType\n}\n\n// https://infra.spec.whatwg.org/#forgiving-base64-decode\n/** @param {string} data */\nfunction forgivingBase64 (data) {\n  // 1. Remove all ASCII whitespace from data.\n  data = data.replace(/[\\u0009\\u000A\\u000C\\u000D\\u0020]/g, '')  // eslint-disable-line\n\n  // 2. If data’s code point length divides by 4 leaving\n  // no remainder, then:\n  if (data.length % 4 === 0) {\n    // 1. If data ends with one or two U+003D (=) code points,\n    // then remove them from data.\n    data = data.replace(/=?=$/, '')\n  }\n\n  // 3. If data’s code point length divides by 4 leaving\n  // a remainder of 1, then return failure.\n  if (data.length % 4 === 1) {\n    return 'failure'\n  }\n\n  // 4. If data contains a code point that is not one of\n  //  U+002B (+)\n  //  U+002F (/)\n  //  ASCII alphanumeric\n  // then return failure.\n  if (/[^+/0-9A-Za-z]/.test(data)) {\n    return 'failure'\n  }\n\n  const binary = atob(data)\n  const bytes = new Uint8Array(binary.length)\n\n  for (let byte = 0; byte < binary.length; byte++) {\n    bytes[byte] = binary.charCodeAt(byte)\n  }\n\n  return bytes\n}\n\n// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string\n// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string\n/**\n * @param {string} input\n * @param {{ position: number }} position\n * @param {boolean?} extractValue\n */\nfunction collectAnHTTPQuotedString (input, position, extractValue) {\n  // 1. Let positionStart be position.\n  const positionStart = position.position\n\n  // 2. Let value be the empty string.\n  let value = ''\n\n  // 3. Assert: the code point at position within input\n  // is U+0022 (\").\n  assert(input[position.position] === '\"')\n\n  // 4. Advance position by 1.\n  position.position++\n\n  // 5. While true:\n  while (true) {\n    // 1. Append the result of collecting a sequence of code points\n    // that are not U+0022 (\") or U+005C (\\) from input, given\n    // position, to value.\n    value += collectASequenceOfCodePoints(\n      (char) => char !== '\"' && char !== '\\\\',\n      input,\n      position\n    )\n\n    // 2. If position is past the end of input, then break.\n    if (position.position >= input.length) {\n      break\n    }\n\n    // 3. Let quoteOrBackslash be the code point at position within\n    // input.\n    const quoteOrBackslash = input[position.position]\n\n    // 4. Advance position by 1.\n    position.position++\n\n    // 5. If quoteOrBackslash is U+005C (\\), then:\n    if (quoteOrBackslash === '\\\\') {\n      // 1. If position is past the end of input, then append\n      // U+005C (\\) to value and break.\n      if (position.position >= input.length) {\n        value += '\\\\'\n        break\n      }\n\n      // 2. Append the code point at position within input to value.\n      value += input[position.position]\n\n      // 3. Advance position by 1.\n      position.position++\n\n    // 6. Otherwise:\n    } else {\n      // 1. Assert: quoteOrBackslash is U+0022 (\").\n      assert(quoteOrBackslash === '\"')\n\n      // 2. Break.\n      break\n    }\n  }\n\n  // 6. If the extract-value flag is set, then return value.\n  if (extractValue) {\n    return value\n  }\n\n  // 7. Return the code points from positionStart to position,\n  // inclusive, within input.\n  return input.slice(positionStart, position.position)\n}\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type\n */\nfunction serializeAMimeType (mimeType) {\n  assert(mimeType !== 'failure')\n  const { type, subtype, parameters } = mimeType\n\n  // 1. Let serialization be the concatenation of mimeType’s\n  //    type, U+002F (/), and mimeType’s subtype.\n  let serialization = `${type}/${subtype}`\n\n  // 2. For each name → value of mimeType’s parameters:\n  for (let [name, value] of parameters.entries()) {\n    // 1. Append U+003B (;) to serialization.\n    serialization += ';'\n\n    // 2. Append name to serialization.\n    serialization += name\n\n    // 3. Append U+003D (=) to serialization.\n    serialization += '='\n\n    // 4. If value does not solely contain HTTP token code\n    //    points or value is the empty string, then:\n    if (!isValidHTTPToken(value)) {\n      // 1. Precede each occurence of U+0022 (\") or\n      //    U+005C (\\) in value with U+005C (\\).\n      value = value.replace(/(\\\\|\")/g, '\\\\$1')\n\n      // 2. Prepend U+0022 (\") to value.\n      value = '\"' + value\n\n      // 3. Append U+0022 (\") to value.\n      value += '\"'\n    }\n\n    // 5. Append value to serialization.\n    serialization += value\n  }\n\n  // 3. Return serialization.\n  return serialization\n}\n\nmodule.exports = {\n  dataURLProcessor,\n  URLSerializer,\n  collectASequenceOfCodePoints,\n  stringPercentDecode,\n  parseMIMEType,\n  collectAnHTTPQuotedString,\n  serializeAMimeType\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}