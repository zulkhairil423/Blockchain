{"ast":null,"code":"'use strict';\n\nconst Busboy = require('busboy');\n\nconst util = require('../core/util');\n\nconst {\n  ReadableStreamFrom,\n  toUSVString,\n  isBlobLike\n} = require('./util');\n\nconst {\n  FormData\n} = require('./formdata');\n\nconst {\n  kState\n} = require('./symbols');\n\nconst {\n  webidl\n} = require('./webidl');\n\nconst {\n  DOMException\n} = require('./constants');\n\nconst {\n  Blob\n} = require('buffer');\n\nconst {\n  kBodyUsed\n} = require('../core/symbols');\n\nconst assert = require('assert');\n\nconst {\n  isErrored\n} = require('../core/util');\n\nconst {\n  isUint8Array,\n  isArrayBuffer\n} = require('util/types');\n\nconst {\n  File\n} = require('./file');\n\nlet ReadableStream;\n\nasync function* blobGen(blob) {\n  yield* blob.stream();\n} // https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n\n\nfunction extractBody(object) {\n  let keepalive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (!ReadableStream) {\n    ReadableStream = require('stream/web').ReadableStream;\n  } // 1. Let stream be object if object is a ReadableStream object.\n  // Otherwise, let stream be a new ReadableStream, and set up stream.\n\n\n  let stream = null; // 2. Let action be null.\n\n  let action = null; // 3. Let source be null.\n\n  let source = null; // 4. Let length be null.\n\n  let length = null; // 5. Let Content-Type be null.\n\n  let contentType = null; // 6. Switch on object:\n\n  if (object == null) {// Note: The IDL processor cannot handle this situation. See\n    // https://crbug.com/335871.\n  } else if (object instanceof URLSearchParams) {\n    // URLSearchParams\n    // spec says to run application/x-www-form-urlencoded on body.list\n    // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n    // Set source to the result of running the application/x-www-form-urlencoded serializer with object’s list.\n    source = object.toString(); // Set Content-Type to `application/x-www-form-urlencoded;charset=UTF-8`.\n\n    contentType = 'application/x-www-form-urlencoded;charset=UTF-8';\n  } else if (isArrayBuffer(object)) {\n    // BufferSource/ArrayBuffer\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.slice());\n  } else if (ArrayBuffer.isView(object)) {\n    // BufferSource/ArrayBufferView\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));\n  } else if (util.isFormDataLike(object)) {\n    const boundary = '----formdata-undici-' + Math.random();\n    const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`;\n    /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n\n    const escape = str => str.replace(/\\n/g, '%0A').replace(/\\r/g, '%0D').replace(/\"/g, '%22');\n\n    const normalizeLinefeeds = value => value.replace(/\\r?\\n|\\r/g, '\\r\\n'); // Set action to this step: run the multipart/form-data\n    // encoding algorithm, with object’s entry list and UTF-8.\n\n\n    action = async function* (object) {\n      const enc = new TextEncoder();\n\n      for (const [name, value] of object) {\n        if (typeof value === 'string') {\n          yield enc.encode(prefix + `; name=\"${escape(normalizeLinefeeds(name))}\"` + `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`);\n        } else {\n          yield enc.encode(prefix + `; name=\"${escape(normalizeLinefeeds(name))}\"` + (value.name ? `; filename=\"${escape(value.name)}\"` : '') + '\\r\\n' + `Content-Type: ${value.type || 'application/octet-stream'}\\r\\n\\r\\n`);\n          yield* blobGen(value);\n          yield enc.encode('\\r\\n');\n        }\n      }\n\n      yield enc.encode(`--${boundary}--`);\n    }; // Set source to object.\n\n\n    source = object; // Set length to unclear, see html/6424 for improving this.\n    // TODO\n    // Set Content-Type to `multipart/form-data; boundary=`,\n    // followed by the multipart/form-data boundary string generated\n    // by the multipart/form-data encoding algorithm.\n\n    contentType = 'multipart/form-data; boundary=' + boundary;\n  } else if (isBlobLike(object)) {\n    // Blob\n    // Set action to this step: read object.\n    action = blobGen; // Set source to object.\n\n    source = object; // Set length to object’s size.\n\n    length = object.size; // If object’s type attribute is not the empty byte sequence, set\n    // Content-Type to its value.\n\n    if (object.type) {\n      contentType = object.type;\n    }\n  } else if (typeof object[Symbol.asyncIterator] === 'function') {\n    // If keepalive is true, then throw a TypeError.\n    if (keepalive) {\n      throw new TypeError('keepalive');\n    } // If object is disturbed or locked, then throw a TypeError.\n\n\n    if (util.isDisturbed(object) || object.locked) {\n      throw new TypeError('Response body object should not be disturbed or locked');\n    }\n\n    stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);\n  } else {\n    // TODO: byte sequence?\n    // TODO: scalar value string?\n    // TODO: else?\n    source = toUSVString(object);\n    contentType = 'text/plain;charset=UTF-8';\n  } // 7. If source is a byte sequence, then set action to a\n  // step that returns source and length to source’s length.\n  // TODO: What is a \"byte sequence?\"\n\n\n  if (typeof source === 'string' || util.isBuffer(source)) {\n    length = Buffer.byteLength(source);\n  } // 8. If action is non-null, then run these steps in in parallel:\n\n\n  if (action != null) {\n    // Run action.\n    let iterator;\n    stream = new ReadableStream({\n      async start() {\n        iterator = action(object)[Symbol.asyncIterator]();\n      },\n\n      async pull(controller) {\n        const {\n          value,\n          done\n        } = await iterator.next();\n\n        if (done) {\n          // When running action is done, close stream.\n          queueMicrotask(() => {\n            controller.close();\n          });\n        } else {\n          // Whenever one or more bytes are available and stream is not errored,\n          // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n          // bytes into stream.\n          if (!isErrored(stream)) {\n            controller.enqueue(new Uint8Array(value));\n          }\n        }\n\n        return controller.desiredSize > 0;\n      },\n\n      async cancel(reason) {\n        await iterator.return();\n      }\n\n    });\n  } else if (!stream) {\n    // TODO: Spec doesn't say anything about this?\n    stream = new ReadableStream({\n      async pull(controller) {\n        controller.enqueue(typeof source === 'string' ? new TextEncoder().encode(source) : source);\n        queueMicrotask(() => {\n          controller.close();\n        });\n      }\n\n    });\n  } // 9. Let body be a body whose stream is stream, source is source,\n  // and length is length.\n\n\n  const body = {\n    stream,\n    source,\n    length\n  }; // 10. Return body and Content-Type.\n\n  return [body, contentType];\n} // https://fetch.spec.whatwg.org/#bodyinit-safely-extract\n\n\nfunction safelyExtractBody(object) {\n  let keepalive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (!ReadableStream) {\n    // istanbul ignore next\n    ReadableStream = require('stream/web').ReadableStream;\n  } // To safely extract a body and a `Content-Type` value from\n  // a byte sequence or BodyInit object object, run these steps:\n  // 1. If object is a ReadableStream object, then:\n\n\n  if (object instanceof ReadableStream) {\n    // Assert: object is neither disturbed nor locked.\n    // istanbul ignore next\n    assert(!util.isDisturbed(object), 'The body has already been consumed.'); // istanbul ignore next\n\n    assert(!object.locked, 'The stream is locked.');\n  } // 2. Return the results of extracting object.\n\n\n  return extractBody(object, keepalive);\n}\n\nfunction cloneBody(body) {\n  // To clone a body body, run these steps:\n  // https://fetch.spec.whatwg.org/#concept-body-clone\n  // 1. Let « out1, out2 » be the result of teeing body’s stream.\n  const [out1, out2] = body.stream.tee(); // 2. Set body’s stream to out1.\n\n  body.stream = out1; // 3. Return a body whose stream is out2 and other members are copied from body.\n\n  return {\n    stream: out2,\n    length: body.length,\n    source: body.source\n  };\n}\n\nasync function* consumeBody(body) {\n  if (body) {\n    if (isUint8Array(body)) {\n      yield body;\n    } else {\n      const stream = body.stream;\n\n      if (util.isDisturbed(stream)) {\n        throw new TypeError('The body has already been consumed.');\n      }\n\n      if (stream.locked) {\n        throw new TypeError('The stream is locked.');\n      } // Compat.\n\n\n      stream[kBodyUsed] = true;\n      yield* stream;\n    }\n  }\n}\n\nfunction throwIfAborted(state) {\n  if (state.aborted) {\n    throw new DOMException('The operation was aborted.', 'AbortError');\n  }\n}\n\nfunction bodyMixinMethods(instance) {\n  const methods = {\n    async blob() {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation');\n      }\n\n      throwIfAborted(this[kState]);\n      const chunks = [];\n\n      for await (const chunk of consumeBody(this[kState].body)) {\n        if (!isUint8Array(chunk)) {\n          throw new TypeError('Expected Uint8Array chunk');\n        } // Assemble one final large blob with Uint8Array's can exhaust memory.\n        // That's why we create create multiple blob's and using references\n\n\n        chunks.push(new Blob([chunk]));\n      }\n\n      return new Blob(chunks, {\n        type: this.headers.get('Content-Type') || ''\n      });\n    },\n\n    async arrayBuffer() {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation');\n      }\n\n      throwIfAborted(this[kState]);\n      const contentLength = this.headers.get('content-length');\n      const encoded = this.headers.has('content-encoding'); // if we have content length and no encoding, then we can\n      // pre allocate the buffer and just read the data into it\n\n      if (!encoded && contentLength) {\n        const buffer = new Uint8Array(contentLength);\n        let offset = 0;\n\n        for await (const chunk of consumeBody(this[kState].body)) {\n          if (!isUint8Array(chunk)) {\n            throw new TypeError('Expected Uint8Array chunk');\n          }\n\n          buffer.set(chunk, offset);\n          offset += chunk.length;\n        }\n\n        return buffer.buffer;\n      } // if we don't have content length, then we have to allocate 2x the\n      // size of the body, once for consumed data, and once for the final buffer\n      // This could be optimized by using growable ArrayBuffer, but it's not\n      // implemented yet. https://github.com/tc39/proposal-resizablearraybuffer\n\n\n      const chunks = [];\n      let size = 0;\n\n      for await (const chunk of consumeBody(this[kState].body)) {\n        if (!isUint8Array(chunk)) {\n          throw new TypeError('Expected Uint8Array chunk');\n        }\n\n        chunks.push(chunk);\n        size += chunk.byteLength;\n      }\n\n      const buffer = new Uint8Array(size);\n      let offset = 0;\n\n      for (const chunk of chunks) {\n        buffer.set(chunk, offset);\n        offset += chunk.byteLength;\n      }\n\n      return buffer.buffer;\n    },\n\n    async text() {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation');\n      }\n\n      throwIfAborted(this[kState]);\n      let result = '';\n      const textDecoder = new TextDecoder();\n\n      for await (const chunk of consumeBody(this[kState].body)) {\n        if (!isUint8Array(chunk)) {\n          throw new TypeError('Expected Uint8Array chunk');\n        }\n\n        result += textDecoder.decode(chunk, {\n          stream: true\n        });\n      } // flush\n\n\n      result += textDecoder.decode();\n      return result;\n    },\n\n    async json() {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation');\n      }\n\n      throwIfAborted(this[kState]);\n      return JSON.parse(await this.text());\n    },\n\n    async formData() {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation');\n      }\n\n      throwIfAborted(this[kState]);\n      const contentType = this.headers.get('Content-Type'); // If mimeType’s essence is \"multipart/form-data\", then:\n\n      if (/multipart\\/form-data/.test(contentType)) {\n        const headers = {};\n\n        for (const [key, value] of this.headers) headers[key.toLowerCase()] = value;\n\n        const responseFormData = new FormData();\n        let busboy;\n\n        try {\n          busboy = Busboy({\n            headers\n          });\n        } catch (err) {\n          // Error due to headers:\n          throw Object.assign(new TypeError(), {\n            cause: err\n          });\n        }\n\n        busboy.on('field', (name, value) => {\n          responseFormData.append(name, value);\n        });\n        busboy.on('file', (name, value, info) => {\n          const {\n            filename,\n            encoding,\n            mimeType\n          } = info;\n          const chunks = [];\n\n          if (encoding.toLowerCase() === 'base64') {\n            let base64chunk = '';\n            value.on('data', chunk => {\n              base64chunk += chunk.toString().replace(/[\\r\\n]/gm, '');\n              const end = base64chunk.length - base64chunk.length % 4;\n              chunks.push(Buffer.from(base64chunk.slice(0, end), 'base64'));\n              base64chunk = base64chunk.slice(end);\n            });\n            value.on('end', () => {\n              chunks.push(Buffer.from(base64chunk, 'base64'));\n              responseFormData.append(name, new File(chunks, filename, {\n                type: mimeType\n              }));\n            });\n          } else {\n            value.on('data', chunk => {\n              chunks.push(chunk);\n            });\n            value.on('end', () => {\n              responseFormData.append(name, new File(chunks, filename, {\n                type: mimeType\n              }));\n            });\n          }\n        });\n        const busboyResolve = new Promise((resolve, reject) => {\n          busboy.on('finish', resolve);\n          busboy.on('error', err => reject(err));\n        });\n        if (this.body !== null) for await (const chunk of consumeBody(this[kState].body)) busboy.write(chunk);\n        busboy.end();\n        await busboyResolve;\n        return responseFormData;\n      } else if (/application\\/x-www-form-urlencoded/.test(contentType)) {\n        // Otherwise, if mimeType’s essence is \"application/x-www-form-urlencoded\", then:\n        // 1. Let entries be the result of parsing bytes.\n        let entries;\n\n        try {\n          let text = ''; // application/x-www-form-urlencoded parser will keep the BOM.\n          // https://url.spec.whatwg.org/#concept-urlencoded-parser\n\n          const textDecoder = new TextDecoder('utf-8', {\n            ignoreBOM: true\n          });\n\n          for await (const chunk of consumeBody(this[kState].body)) {\n            if (!isUint8Array(chunk)) {\n              throw new TypeError('Expected Uint8Array chunk');\n            }\n\n            text += textDecoder.decode(chunk, {\n              stream: true\n            });\n          }\n\n          text += textDecoder.decode();\n          entries = new URLSearchParams(text);\n        } catch (err) {\n          // istanbul ignore next: Unclear when new URLSearchParams can fail on a string.\n          // 2. If entries is failure, then throw a TypeError.\n          throw Object.assign(new TypeError(), {\n            cause: err\n          });\n        } // 3. Return a new FormData object whose entries are entries.\n\n\n        const formData = new FormData();\n\n        for (const [name, value] of entries) {\n          formData.append(name, value);\n        }\n\n        return formData;\n      } else {\n        // Wait a tick before checking if the request has been aborted.\n        // Otherwise, a TypeError can be thrown when an AbortError should.\n        await Promise.resolve();\n        throwIfAborted(this[kState]); // Otherwise, throw a TypeError.\n\n        webidl.errors.exception({\n          header: `${instance.name}.formData`,\n          message: 'Could not parse content as FormData.'\n        });\n      }\n    }\n\n  };\n  return methods;\n}\n\nconst properties = {\n  body: {\n    enumerable: true,\n\n    get() {\n      if (!this || !this[kState]) {\n        throw new TypeError('Illegal invocation');\n      }\n\n      return this[kState].body ? this[kState].body.stream : null;\n    }\n\n  },\n  bodyUsed: {\n    enumerable: true,\n\n    get() {\n      if (!this || !this[kState]) {\n        throw new TypeError('Illegal invocation');\n      }\n\n      return !!this[kState].body && util.isDisturbed(this[kState].body.stream);\n    }\n\n  }\n};\n\nfunction mixinBody(prototype) {\n  Object.assign(prototype.prototype, bodyMixinMethods(prototype));\n  Object.defineProperties(prototype.prototype, properties);\n}\n\nmodule.exports = {\n  extractBody,\n  safelyExtractBody,\n  cloneBody,\n  mixinBody\n};","map":{"version":3,"names":["Busboy","require","util","ReadableStreamFrom","toUSVString","isBlobLike","FormData","kState","webidl","DOMException","Blob","kBodyUsed","assert","isErrored","isUint8Array","isArrayBuffer","File","ReadableStream","blobGen","blob","stream","extractBody","object","keepalive","action","source","length","contentType","URLSearchParams","toString","Uint8Array","slice","ArrayBuffer","isView","buffer","byteOffset","byteLength","isFormDataLike","boundary","Math","random","prefix","escape","str","replace","normalizeLinefeeds","value","enc","TextEncoder","name","encode","type","size","Symbol","asyncIterator","TypeError","isDisturbed","locked","isBuffer","Buffer","iterator","start","pull","controller","done","next","queueMicrotask","close","enqueue","desiredSize","cancel","reason","return","body","safelyExtractBody","cloneBody","out1","out2","tee","consumeBody","throwIfAborted","state","aborted","bodyMixinMethods","instance","methods","chunks","chunk","push","headers","get","arrayBuffer","contentLength","encoded","has","offset","set","text","result","textDecoder","TextDecoder","decode","json","JSON","parse","formData","test","key","toLowerCase","responseFormData","busboy","err","Object","assign","cause","on","append","info","filename","encoding","mimeType","base64chunk","end","from","busboyResolve","Promise","resolve","reject","write","entries","ignoreBOM","errors","exception","header","message","properties","enumerable","bodyUsed","mixinBody","prototype","defineProperties","module","exports"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/undici/lib/fetch/body.js"],"sourcesContent":["'use strict'\n\nconst Busboy = require('busboy')\nconst util = require('../core/util')\nconst { ReadableStreamFrom, toUSVString, isBlobLike } = require('./util')\nconst { FormData } = require('./formdata')\nconst { kState } = require('./symbols')\nconst { webidl } = require('./webidl')\nconst { DOMException } = require('./constants')\nconst { Blob } = require('buffer')\nconst { kBodyUsed } = require('../core/symbols')\nconst assert = require('assert')\nconst { isErrored } = require('../core/util')\nconst { isUint8Array, isArrayBuffer } = require('util/types')\nconst { File } = require('./file')\n\nlet ReadableStream\n\nasync function * blobGen (blob) {\n  yield * blob.stream()\n}\n\n// https://fetch.spec.whatwg.org/#concept-bodyinit-extract\nfunction extractBody (object, keepalive = false) {\n  if (!ReadableStream) {\n    ReadableStream = require('stream/web').ReadableStream\n  }\n\n  // 1. Let stream be object if object is a ReadableStream object.\n  // Otherwise, let stream be a new ReadableStream, and set up stream.\n  let stream = null\n\n  // 2. Let action be null.\n  let action = null\n\n  // 3. Let source be null.\n  let source = null\n\n  // 4. Let length be null.\n  let length = null\n\n  // 5. Let Content-Type be null.\n  let contentType = null\n\n  // 6. Switch on object:\n  if (object == null) {\n    // Note: The IDL processor cannot handle this situation. See\n    // https://crbug.com/335871.\n  } else if (object instanceof URLSearchParams) {\n    // URLSearchParams\n\n    // spec says to run application/x-www-form-urlencoded on body.list\n    // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n\n    // Set source to the result of running the application/x-www-form-urlencoded serializer with object’s list.\n    source = object.toString()\n\n    // Set Content-Type to `application/x-www-form-urlencoded;charset=UTF-8`.\n    contentType = 'application/x-www-form-urlencoded;charset=UTF-8'\n  } else if (isArrayBuffer(object)) {\n    // BufferSource/ArrayBuffer\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.slice())\n  } else if (ArrayBuffer.isView(object)) {\n    // BufferSource/ArrayBufferView\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength))\n  } else if (util.isFormDataLike(object)) {\n    const boundary = '----formdata-undici-' + Math.random()\n    const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`\n\n    /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n    const escape = (str) =>\n      str.replace(/\\n/g, '%0A').replace(/\\r/g, '%0D').replace(/\"/g, '%22')\n    const normalizeLinefeeds = (value) => value.replace(/\\r?\\n|\\r/g, '\\r\\n')\n\n    // Set action to this step: run the multipart/form-data\n    // encoding algorithm, with object’s entry list and UTF-8.\n    action = async function * (object) {\n      const enc = new TextEncoder()\n\n      for (const [name, value] of object) {\n        if (typeof value === 'string') {\n          yield enc.encode(\n            prefix +\n              `; name=\"${escape(normalizeLinefeeds(name))}\"` +\n              `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`\n          )\n        } else {\n          yield enc.encode(\n            prefix +\n              `; name=\"${escape(normalizeLinefeeds(name))}\"` +\n              (value.name ? `; filename=\"${escape(value.name)}\"` : '') +\n              '\\r\\n' +\n              `Content-Type: ${\n                value.type || 'application/octet-stream'\n              }\\r\\n\\r\\n`\n          )\n\n          yield * blobGen(value)\n\n          yield enc.encode('\\r\\n')\n        }\n      }\n\n      yield enc.encode(`--${boundary}--`)\n    }\n\n    // Set source to object.\n    source = object\n\n    // Set length to unclear, see html/6424 for improving this.\n    // TODO\n\n    // Set Content-Type to `multipart/form-data; boundary=`,\n    // followed by the multipart/form-data boundary string generated\n    // by the multipart/form-data encoding algorithm.\n    contentType = 'multipart/form-data; boundary=' + boundary\n  } else if (isBlobLike(object)) {\n    // Blob\n\n    // Set action to this step: read object.\n    action = blobGen\n\n    // Set source to object.\n    source = object\n\n    // Set length to object’s size.\n    length = object.size\n\n    // If object’s type attribute is not the empty byte sequence, set\n    // Content-Type to its value.\n    if (object.type) {\n      contentType = object.type\n    }\n  } else if (typeof object[Symbol.asyncIterator] === 'function') {\n    // If keepalive is true, then throw a TypeError.\n    if (keepalive) {\n      throw new TypeError('keepalive')\n    }\n\n    // If object is disturbed or locked, then throw a TypeError.\n    if (util.isDisturbed(object) || object.locked) {\n      throw new TypeError(\n        'Response body object should not be disturbed or locked'\n      )\n    }\n\n    stream =\n      object instanceof ReadableStream ? object : ReadableStreamFrom(object)\n  } else {\n    // TODO: byte sequence?\n    // TODO: scalar value string?\n    // TODO: else?\n    source = toUSVString(object)\n    contentType = 'text/plain;charset=UTF-8'\n  }\n\n  // 7. If source is a byte sequence, then set action to a\n  // step that returns source and length to source’s length.\n  // TODO: What is a \"byte sequence?\"\n  if (typeof source === 'string' || util.isBuffer(source)) {\n    length = Buffer.byteLength(source)\n  }\n\n  // 8. If action is non-null, then run these steps in in parallel:\n  if (action != null) {\n    // Run action.\n    let iterator\n    stream = new ReadableStream({\n      async start () {\n        iterator = action(object)[Symbol.asyncIterator]()\n      },\n      async pull (controller) {\n        const { value, done } = await iterator.next()\n        if (done) {\n          // When running action is done, close stream.\n          queueMicrotask(() => {\n            controller.close()\n          })\n        } else {\n          // Whenever one or more bytes are available and stream is not errored,\n          // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n          // bytes into stream.\n          if (!isErrored(stream)) {\n            controller.enqueue(new Uint8Array(value))\n          }\n        }\n        return controller.desiredSize > 0\n      },\n      async cancel (reason) {\n        await iterator.return()\n      }\n    })\n  } else if (!stream) {\n    // TODO: Spec doesn't say anything about this?\n    stream = new ReadableStream({\n      async pull (controller) {\n        controller.enqueue(\n          typeof source === 'string' ? new TextEncoder().encode(source) : source\n        )\n        queueMicrotask(() => {\n          controller.close()\n        })\n      }\n    })\n  }\n\n  // 9. Let body be a body whose stream is stream, source is source,\n  // and length is length.\n  const body = { stream, source, length }\n\n  // 10. Return body and Content-Type.\n  return [body, contentType]\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit-safely-extract\nfunction safelyExtractBody (object, keepalive = false) {\n  if (!ReadableStream) {\n    // istanbul ignore next\n    ReadableStream = require('stream/web').ReadableStream\n  }\n\n  // To safely extract a body and a `Content-Type` value from\n  // a byte sequence or BodyInit object object, run these steps:\n\n  // 1. If object is a ReadableStream object, then:\n  if (object instanceof ReadableStream) {\n    // Assert: object is neither disturbed nor locked.\n    // istanbul ignore next\n    assert(!util.isDisturbed(object), 'The body has already been consumed.')\n    // istanbul ignore next\n    assert(!object.locked, 'The stream is locked.')\n  }\n\n  // 2. Return the results of extracting object.\n  return extractBody(object, keepalive)\n}\n\nfunction cloneBody (body) {\n  // To clone a body body, run these steps:\n\n  // https://fetch.spec.whatwg.org/#concept-body-clone\n\n  // 1. Let « out1, out2 » be the result of teeing body’s stream.\n  const [out1, out2] = body.stream.tee()\n\n  // 2. Set body’s stream to out1.\n  body.stream = out1\n\n  // 3. Return a body whose stream is out2 and other members are copied from body.\n  return {\n    stream: out2,\n    length: body.length,\n    source: body.source\n  }\n}\n\nasync function * consumeBody (body) {\n  if (body) {\n    if (isUint8Array(body)) {\n      yield body\n    } else {\n      const stream = body.stream\n\n      if (util.isDisturbed(stream)) {\n        throw new TypeError('The body has already been consumed.')\n      }\n\n      if (stream.locked) {\n        throw new TypeError('The stream is locked.')\n      }\n\n      // Compat.\n      stream[kBodyUsed] = true\n\n      yield * stream\n    }\n  }\n}\n\nfunction throwIfAborted (state) {\n  if (state.aborted) {\n    throw new DOMException('The operation was aborted.', 'AbortError')\n  }\n}\n\nfunction bodyMixinMethods (instance) {\n  const methods = {\n    async blob () {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation')\n      }\n\n      throwIfAborted(this[kState])\n\n      const chunks = []\n\n      for await (const chunk of consumeBody(this[kState].body)) {\n        if (!isUint8Array(chunk)) {\n          throw new TypeError('Expected Uint8Array chunk')\n        }\n\n        // Assemble one final large blob with Uint8Array's can exhaust memory.\n        // That's why we create create multiple blob's and using references\n        chunks.push(new Blob([chunk]))\n      }\n\n      return new Blob(chunks, { type: this.headers.get('Content-Type') || '' })\n    },\n\n    async arrayBuffer () {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation')\n      }\n\n      throwIfAborted(this[kState])\n\n      const contentLength = this.headers.get('content-length')\n      const encoded = this.headers.has('content-encoding')\n\n      // if we have content length and no encoding, then we can\n      // pre allocate the buffer and just read the data into it\n      if (!encoded && contentLength) {\n        const buffer = new Uint8Array(contentLength)\n        let offset = 0\n\n        for await (const chunk of consumeBody(this[kState].body)) {\n          if (!isUint8Array(chunk)) {\n            throw new TypeError('Expected Uint8Array chunk')\n          }\n\n          buffer.set(chunk, offset)\n          offset += chunk.length\n        }\n\n        return buffer.buffer\n      }\n\n      // if we don't have content length, then we have to allocate 2x the\n      // size of the body, once for consumed data, and once for the final buffer\n\n      // This could be optimized by using growable ArrayBuffer, but it's not\n      // implemented yet. https://github.com/tc39/proposal-resizablearraybuffer\n\n      const chunks = []\n      let size = 0\n\n      for await (const chunk of consumeBody(this[kState].body)) {\n        if (!isUint8Array(chunk)) {\n          throw new TypeError('Expected Uint8Array chunk')\n        }\n\n        chunks.push(chunk)\n        size += chunk.byteLength\n      }\n\n      const buffer = new Uint8Array(size)\n      let offset = 0\n\n      for (const chunk of chunks) {\n        buffer.set(chunk, offset)\n        offset += chunk.byteLength\n      }\n\n      return buffer.buffer\n    },\n\n    async text () {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation')\n      }\n\n      throwIfAborted(this[kState])\n\n      let result = ''\n      const textDecoder = new TextDecoder()\n\n      for await (const chunk of consumeBody(this[kState].body)) {\n        if (!isUint8Array(chunk)) {\n          throw new TypeError('Expected Uint8Array chunk')\n        }\n\n        result += textDecoder.decode(chunk, { stream: true })\n      }\n\n      // flush\n      result += textDecoder.decode()\n\n      return result\n    },\n\n    async json () {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation')\n      }\n\n      throwIfAborted(this[kState])\n\n      return JSON.parse(await this.text())\n    },\n\n    async formData () {\n      if (!(this instanceof instance)) {\n        throw new TypeError('Illegal invocation')\n      }\n\n      throwIfAborted(this[kState])\n\n      const contentType = this.headers.get('Content-Type')\n\n      // If mimeType’s essence is \"multipart/form-data\", then:\n      if (/multipart\\/form-data/.test(contentType)) {\n        const headers = {}\n        for (const [key, value] of this.headers) headers[key.toLowerCase()] = value\n\n        const responseFormData = new FormData()\n\n        let busboy\n\n        try {\n          busboy = Busboy({ headers })\n        } catch (err) {\n          // Error due to headers:\n          throw Object.assign(new TypeError(), { cause: err })\n        }\n\n        busboy.on('field', (name, value) => {\n          responseFormData.append(name, value)\n        })\n        busboy.on('file', (name, value, info) => {\n          const { filename, encoding, mimeType } = info\n          const chunks = []\n\n          if (encoding.toLowerCase() === 'base64') {\n            let base64chunk = ''\n\n            value.on('data', (chunk) => {\n              base64chunk += chunk.toString().replace(/[\\r\\n]/gm, '')\n\n              const end = base64chunk.length - base64chunk.length % 4\n              chunks.push(Buffer.from(base64chunk.slice(0, end), 'base64'))\n\n              base64chunk = base64chunk.slice(end)\n            })\n            value.on('end', () => {\n              chunks.push(Buffer.from(base64chunk, 'base64'))\n              responseFormData.append(name, new File(chunks, filename, { type: mimeType }))\n            })\n          } else {\n            value.on('data', (chunk) => {\n              chunks.push(chunk)\n            })\n            value.on('end', () => {\n              responseFormData.append(name, new File(chunks, filename, { type: mimeType }))\n            })\n          }\n        })\n\n        const busboyResolve = new Promise((resolve, reject) => {\n          busboy.on('finish', resolve)\n          busboy.on('error', (err) => reject(err))\n        })\n\n        if (this.body !== null) for await (const chunk of consumeBody(this[kState].body)) busboy.write(chunk)\n        busboy.end()\n        await busboyResolve\n\n        return responseFormData\n      } else if (/application\\/x-www-form-urlencoded/.test(contentType)) {\n        // Otherwise, if mimeType’s essence is \"application/x-www-form-urlencoded\", then:\n\n        // 1. Let entries be the result of parsing bytes.\n        let entries\n        try {\n          let text = ''\n          // application/x-www-form-urlencoded parser will keep the BOM.\n          // https://url.spec.whatwg.org/#concept-urlencoded-parser\n          const textDecoder = new TextDecoder('utf-8', { ignoreBOM: true })\n          for await (const chunk of consumeBody(this[kState].body)) {\n            if (!isUint8Array(chunk)) {\n              throw new TypeError('Expected Uint8Array chunk')\n            }\n            text += textDecoder.decode(chunk, { stream: true })\n          }\n          text += textDecoder.decode()\n          entries = new URLSearchParams(text)\n        } catch (err) {\n          // istanbul ignore next: Unclear when new URLSearchParams can fail on a string.\n          // 2. If entries is failure, then throw a TypeError.\n          throw Object.assign(new TypeError(), { cause: err })\n        }\n\n        // 3. Return a new FormData object whose entries are entries.\n        const formData = new FormData()\n        for (const [name, value] of entries) {\n          formData.append(name, value)\n        }\n        return formData\n      } else {\n        // Wait a tick before checking if the request has been aborted.\n        // Otherwise, a TypeError can be thrown when an AbortError should.\n        await Promise.resolve()\n\n        throwIfAborted(this[kState])\n\n        // Otherwise, throw a TypeError.\n        webidl.errors.exception({\n          header: `${instance.name}.formData`,\n          message: 'Could not parse content as FormData.'\n        })\n      }\n    }\n  }\n\n  return methods\n}\n\nconst properties = {\n  body: {\n    enumerable: true,\n    get () {\n      if (!this || !this[kState]) {\n        throw new TypeError('Illegal invocation')\n      }\n\n      return this[kState].body ? this[kState].body.stream : null\n    }\n  },\n  bodyUsed: {\n    enumerable: true,\n    get () {\n      if (!this || !this[kState]) {\n        throw new TypeError('Illegal invocation')\n      }\n\n      return !!this[kState].body && util.isDisturbed(this[kState].body.stream)\n    }\n  }\n}\n\nfunction mixinBody (prototype) {\n  Object.assign(prototype.prototype, bodyMixinMethods(prototype))\n  Object.defineProperties(prototype.prototype, properties)\n}\n\nmodule.exports = {\n  extractBody,\n  safelyExtractBody,\n  cloneBody,\n  mixinBody\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}