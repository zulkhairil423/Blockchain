{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setupContext = exports.createEvalAwarePartialHost = exports.EvalState = exports.createRepl = exports.REPL_NAME = exports.REPL_FILENAME = exports.STDIN_NAME = exports.STDIN_FILENAME = exports.EVAL_NAME = exports.EVAL_FILENAME = void 0;\n\nconst os_1 = require(\"os\");\n\nconst path_1 = require(\"path\");\n\nconst repl_1 = require(\"repl\");\n\nconst vm_1 = require(\"vm\");\n\nconst index_1 = require(\"./index\");\n\nconst fs_1 = require(\"fs\");\n\nconst console_1 = require(\"console\");\n\nconst assert = require(\"assert\");\n\nconst module_1 = require(\"module\"); // Lazy-loaded.\n\n\nlet _processTopLevelAwait;\n\nfunction getProcessTopLevelAwait() {\n  if (_processTopLevelAwait === undefined) {\n    ({\n      processTopLevelAwait: _processTopLevelAwait\n    } = require('../dist-raw/node-internal-repl-await'));\n  }\n\n  return _processTopLevelAwait;\n}\n\nlet diff;\n\nfunction getDiffLines() {\n  if (diff === undefined) {\n    diff = require('diff');\n  }\n\n  return diff.diffLines;\n}\n/** @internal */\n\n\nexports.EVAL_FILENAME = `[eval].ts`;\n/** @internal */\n\nexports.EVAL_NAME = `[eval]`;\n/** @internal */\n\nexports.STDIN_FILENAME = `[stdin].ts`;\n/** @internal */\n\nexports.STDIN_NAME = `[stdin]`;\n/** @internal */\n\nexports.REPL_FILENAME = '<repl>.ts';\n/** @internal */\n\nexports.REPL_NAME = '<repl>';\n/**\n * Create a ts-node REPL instance.\n *\n * Pay close attention to the example below.  Today, the API requires a few lines\n * of boilerplate to correctly bind the `ReplService` to the ts-node `Service` and\n * vice-versa.\n *\n * Usage example:\n *\n *     const repl = tsNode.createRepl();\n *     const service = tsNode.create({...repl.evalAwarePartialHost});\n *     repl.setService(service);\n *     repl.start();\n *\n * @category REPL\n */\n\nfunction createRepl() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var _a, _b, _c, _d, _e;\n\n  const {\n    ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl = true\n  } = options;\n  let service = options.service;\n  let nodeReplServer; // If `useGlobal` is not true, then REPL creates a context when started.\n  // This stores a reference to it or to `global`, whichever is used, after REPL has started.\n\n  let context;\n  const state = (_a = options.state) !== null && _a !== void 0 ? _a : new EvalState((0, path_1.join)(process.cwd(), exports.REPL_FILENAME));\n  const evalAwarePartialHost = createEvalAwarePartialHost(state, options.composeWithEvalAwarePartialHost);\n  const stdin = (_b = options.stdin) !== null && _b !== void 0 ? _b : process.stdin;\n  const stdout = (_c = options.stdout) !== null && _c !== void 0 ? _c : process.stdout;\n  const stderr = (_d = options.stderr) !== null && _d !== void 0 ? _d : process.stderr;\n\n  const _console = stdout === process.stdout && stderr === process.stderr ? console : new console_1.Console(stdout, stderr);\n\n  const replService = {\n    state: (_e = options.state) !== null && _e !== void 0 ? _e : new EvalState((0, path_1.join)(process.cwd(), exports.EVAL_FILENAME)),\n    setService,\n    evalCode,\n    evalCodeInternal,\n    nodeEval,\n    evalAwarePartialHost,\n    start,\n    startInternal,\n    stdin,\n    stdout,\n    stderr,\n    console: _console\n  };\n  return replService;\n\n  function setService(_service) {\n    service = _service;\n\n    if (ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl) {\n      service.addDiagnosticFilter({\n        appliesToAllFiles: false,\n        filenamesAbsolute: [state.path],\n        diagnosticsIgnored: [2393, 6133, 7027, ...(service.shouldReplAwait ? topLevelAwaitDiagnosticCodes : [])]\n      });\n    }\n  }\n\n  function evalCode(code) {\n    const result = appendCompileAndEvalInput({\n      service: service,\n      state,\n      input: code,\n      context,\n      overrideIsCompletion: false\n    });\n    assert(result.containsTopLevelAwait === false);\n    return result.value;\n  }\n\n  function evalCodeInternal(options) {\n    const {\n      code,\n      enableTopLevelAwait,\n      context\n    } = options;\n    return appendCompileAndEvalInput({\n      service: service,\n      state,\n      input: code,\n      enableTopLevelAwait,\n      context\n    });\n  }\n\n  function nodeEval(code, context, _filename, callback) {\n    // TODO: Figure out how to handle completion here.\n    if (code === '.scope') {\n      callback(null);\n      return;\n    }\n\n    try {\n      const evalResult = evalCodeInternal({\n        code,\n        enableTopLevelAwait: true,\n        context\n      });\n\n      if (evalResult.containsTopLevelAwait) {\n        (async () => {\n          try {\n            callback(null, await evalResult.valuePromise);\n          } catch (promiseError) {\n            handleError(promiseError);\n          }\n        })();\n      } else {\n        callback(null, evalResult.value);\n      }\n    } catch (error) {\n      handleError(error);\n    } // Log TSErrors, check if they're recoverable, log helpful hints for certain\n    // well-known errors, and invoke `callback()`\n    // TODO should evalCode API get the same error-handling benefits?\n\n\n    function handleError(error) {\n      var _a, _b; // Don't show TLA hint if the user explicitly disabled repl top level await\n\n\n      const canLogTopLevelAwaitHint = service.options.experimentalReplAwait !== false && !service.shouldReplAwait;\n\n      if (error instanceof index_1.TSError) {\n        // Support recoverable compilations using >= node 6.\n        if (repl_1.Recoverable && isRecoverable(error)) {\n          callback(new repl_1.Recoverable(error));\n          return;\n        } else {\n          _console.error(error);\n\n          if (canLogTopLevelAwaitHint && error.diagnosticCodes.some(dC => topLevelAwaitDiagnosticCodes.includes(dC))) {\n            _console.error(getTopLevelAwaitHint());\n          }\n\n          callback(null);\n        }\n      } else {\n        let _error = error;\n\n        if (canLogTopLevelAwaitHint && _error instanceof SyntaxError && ((_a = _error.message) === null || _a === void 0 ? void 0 : _a.includes('await is only valid'))) {\n          try {\n            // Only way I know to make our hint appear after the error\n            _error.message += `\\n\\n${getTopLevelAwaitHint()}`;\n            _error.stack = (_b = _error.stack) === null || _b === void 0 ? void 0 : _b.replace(/(SyntaxError:.*)/, (_, $1) => `${$1}\\n\\n${getTopLevelAwaitHint()}`);\n          } catch {}\n        }\n\n        callback(_error);\n      }\n    }\n\n    function getTopLevelAwaitHint() {\n      return `Hint: REPL top-level await requires TypeScript version 3.8 or higher and target ES2018 or higher. You are using TypeScript ${service.ts.version} and target ${service.ts.ScriptTarget[service.config.options.target]}.`;\n    }\n  } // Note: `code` argument is deprecated\n\n\n  function start(code) {\n    startInternal({\n      code\n    });\n  } // Note: `code` argument is deprecated\n\n\n  function startInternal(options) {\n    const {\n      code,\n      forceToBeModule = true,\n      ...optionsOverride\n    } = options !== null && options !== void 0 ? options : {}; // TODO assert that `service` is set; remove all `service!` non-null assertions\n    // Eval incoming code before the REPL starts.\n    // Note: deprecated\n\n    if (code) {\n      try {\n        evalCode(`${code}\\n`);\n      } catch (err) {\n        _console.error(err); // Note: should not be killing the process here, but this codepath is deprecated anyway\n\n\n        process.exit(1);\n      }\n    } // In case the typescript compiler hasn't compiled anything yet,\n    // make it run though compilation at least one time before\n    // the REPL starts for a snappier user experience on startup.\n\n\n    service === null || service === void 0 ? void 0 : service.compile('', state.path);\n    const repl = (0, repl_1.start)({\n      prompt: '> ',\n      input: replService.stdin,\n      output: replService.stdout,\n      // Mimicking node's REPL implementation: https://github.com/nodejs/node/blob/168b22ba073ee1cbf8d0bcb4ded7ff3099335d04/lib/internal/repl.js#L28-L30\n      terminal: stdout.isTTY && !parseInt(index_1.env.NODE_NO_READLINE, 10),\n      eval: nodeEval,\n      useGlobal: true,\n      ...optionsOverride\n    });\n    nodeReplServer = repl;\n    context = repl.context; // Bookmark the point where we should reset the REPL state.\n\n    const resetEval = appendToEvalState(state, '');\n\n    function reset() {\n      resetEval(); // Hard fix for TypeScript forcing `Object.defineProperty(exports, ...)`.\n\n      runInContext('exports = module.exports', state.path, context);\n\n      if (forceToBeModule) {\n        state.input += 'export {};void 0;\\n';\n      } // Declare node builtins.\n      // Skip the same builtins as `addBuiltinLibsToObject`:\n      //   those starting with _\n      //   those containing /\n      //   those that already exist as globals\n      // Intentionally suppress type errors in case @types/node does not declare any of them, and because\n      // `declare import` is technically invalid syntax.\n      // Avoid this when in transpileOnly, because third-party transpilers may not handle `declare import`.\n\n\n      if (!(service === null || service === void 0 ? void 0 : service.transpileOnly)) {\n        state.input += `// @ts-ignore\\n${module_1.builtinModules.filter(name => !name.startsWith('_') && !name.includes('/') && !['console', 'module', 'process'].includes(name)).map(name => `declare import ${name} = require('${name}')`).join(';')}\\n`;\n      }\n    }\n\n    reset();\n    repl.on('reset', reset);\n    repl.defineCommand('type', {\n      help: 'Check the type of a TypeScript identifier',\n      action: function (identifier) {\n        if (!identifier) {\n          repl.displayPrompt();\n          return;\n        }\n\n        const undo = appendToEvalState(state, identifier);\n        const {\n          name,\n          comment\n        } = service.getTypeInfo(state.input, state.path, state.input.length);\n        undo();\n        if (name) repl.outputStream.write(`${name}\\n`);\n        if (comment) repl.outputStream.write(`${comment}\\n`);\n        repl.displayPrompt();\n      }\n    }); // Set up REPL history when available natively via node.js >= 11.\n\n    if (repl.setupHistory) {\n      const historyPath = index_1.env.TS_NODE_HISTORY || (0, path_1.join)((0, os_1.homedir)(), '.ts_node_repl_history');\n      repl.setupHistory(historyPath, err => {\n        if (!err) return;\n\n        _console.error(err);\n\n        process.exit(1);\n      });\n    }\n\n    return repl;\n  }\n}\n\nexports.createRepl = createRepl;\n/**\n * Eval state management. Stores virtual `[eval].ts` file\n */\n\nclass EvalState {\n  constructor(path) {\n    this.path = path;\n    /** @internal */\n\n    this.input = '';\n    /** @internal */\n\n    this.output = '';\n    /** @internal */\n\n    this.version = 0;\n    /** @internal */\n\n    this.lines = 0;\n  }\n\n}\n\nexports.EvalState = EvalState;\n\nfunction createEvalAwarePartialHost(state, composeWith) {\n  function readFile(path) {\n    if (path === state.path) return state.input;\n    if (composeWith === null || composeWith === void 0 ? void 0 : composeWith.readFile) return composeWith.readFile(path);\n\n    try {\n      return (0, fs_1.readFileSync)(path, 'utf8');\n    } catch (err) {\n      /* Ignore. */\n    }\n  }\n\n  function fileExists(path) {\n    if (path === state.path) return true;\n    if (composeWith === null || composeWith === void 0 ? void 0 : composeWith.fileExists) return composeWith.fileExists(path);\n\n    try {\n      const stats = (0, fs_1.statSync)(path);\n      return stats.isFile() || stats.isFIFO();\n    } catch (err) {\n      return false;\n    }\n  }\n\n  return {\n    readFile,\n    fileExists\n  };\n}\n\nexports.createEvalAwarePartialHost = createEvalAwarePartialHost;\nconst sourcemapCommentRe = /\\/\\/# ?sourceMappingURL=\\S+[\\s\\r\\n]*$/;\n/**\n * Evaluate the code snippet.\n *\n * Append it to virtual .ts file, compile, handle compiler errors, compute a diff of the JS, and eval any code that\n * appears as \"added\" in the diff.\n */\n\nfunction appendCompileAndEvalInput(options) {\n  const {\n    service,\n    state,\n    wrappedErr,\n    enableTopLevelAwait = false,\n    context,\n    overrideIsCompletion\n  } = options;\n  let {\n    input\n  } = options; // It's confusing for `{ a: 1 }` to be interpreted as a block statement\n  // rather than an object literal. So, we first try to wrap it in\n  // parentheses, so that it will be interpreted as an expression.\n  // Based on https://github.com/nodejs/node/blob/c2e6822153bad023ab7ebd30a6117dcc049e475c/lib/repl.js#L413-L422\n\n  let wrappedCmd = false;\n\n  if (!wrappedErr && /^\\s*{/.test(input) && !/;\\s*$/.test(input)) {\n    input = `(${input.trim()})\\n`;\n    wrappedCmd = true;\n  }\n\n  const lines = state.lines;\n  const isCompletion = overrideIsCompletion !== null && overrideIsCompletion !== void 0 ? overrideIsCompletion : !/\\n$/.test(input);\n  const undo = appendToEvalState(state, input);\n  let output; // Based on https://github.com/nodejs/node/blob/92573721c7cff104ccb82b6ed3e8aa69c4b27510/lib/repl.js#L457-L461\n\n  function adjustUseStrict(code) {\n    // \"void 0\" keeps the repl from returning \"use strict\" as the result\n    // value for statements and declarations that don't return a value.\n    return code.replace(/^\"use strict\";/, '\"use strict\"; void 0;');\n  }\n\n  try {\n    output = service.compile(state.input, state.path, -lines);\n  } catch (err) {\n    undo();\n\n    if (wrappedCmd) {\n      if (err instanceof index_1.TSError && err.diagnosticCodes[0] === 2339) {\n        // Ensure consistent and more sane behavior between { a: 1 }['b'] and ({ a: 1 }['b'])\n        throw err;\n      } // Unwrap and try again\n\n\n      return appendCompileAndEvalInput({ ...options,\n        wrappedErr: err\n      });\n    }\n\n    if (wrappedErr) throw wrappedErr;\n    throw err;\n  }\n\n  output = adjustUseStrict(output); // Note: REPL does not respect sourcemaps!\n  // To properly do that, we'd need to prefix the code we eval -- which comes\n  // from `diffLines` -- with newlines so that it's at the proper line numbers.\n  // Then we'd need to ensure each bit of eval-ed code, if there are multiples,\n  // has the sourcemap appended to it.\n  // We might also need to integrate with our sourcemap hooks' cache; I'm not sure.\n\n  const outputWithoutSourcemapComment = output.replace(sourcemapCommentRe, '');\n  const oldOutputWithoutSourcemapComment = state.output.replace(sourcemapCommentRe, ''); // Use `diff` to check for new JavaScript to execute.\n\n  const changes = getDiffLines()(oldOutputWithoutSourcemapComment, outputWithoutSourcemapComment);\n\n  if (isCompletion) {\n    undo();\n  } else {\n    state.output = output; // Insert a semicolon to make sure that the code doesn't interact with the next line,\n    // for example to prevent `2\\n+ 2` from producing 4.\n    // This is safe since the output will not change since we can only get here with successful inputs,\n    // and adding a semicolon to the end of a successful input won't ever change the output.\n\n    state.input = state.input.replace(/([^\\n\\s])([\\n\\s]*)$/, (all, lastChar, whitespace) => {\n      if (lastChar !== ';') return `${lastChar};${whitespace}`;\n      return all;\n    });\n  }\n\n  let commands = [];\n  let containsTopLevelAwait = false; // Build a list of \"commands\": bits of JS code in the diff that must be executed.\n\n  for (const change of changes) {\n    if (change.added) {\n      if (enableTopLevelAwait && service.shouldReplAwait && change.value.indexOf('await') > -1) {\n        const processTopLevelAwait = getProcessTopLevelAwait(); // Newline prevents comments to mess with wrapper\n\n        const wrappedResult = processTopLevelAwait(change.value + '\\n');\n\n        if (wrappedResult !== null) {\n          containsTopLevelAwait = true;\n          commands.push({\n            mustAwait: true,\n            execCommand: () => runInContext(wrappedResult, state.path, context)\n          });\n          continue;\n        }\n      }\n\n      commands.push({\n        execCommand: () => runInContext(change.value, state.path, context)\n      });\n    }\n  } // Execute all commands asynchronously if necessary, returning the result or a\n  // promise of the result.\n\n\n  if (containsTopLevelAwait) {\n    return {\n      containsTopLevelAwait,\n      valuePromise: (async () => {\n        let value;\n\n        for (const command of commands) {\n          const r = command.execCommand();\n          value = command.mustAwait ? await r : r;\n        }\n\n        return value;\n      })()\n    };\n  } else {\n    return {\n      containsTopLevelAwait: false,\n      value: commands.reduce((_, c) => c.execCommand(), undefined)\n    };\n  }\n}\n/**\n * Low-level execution of JS code in context\n */\n\n\nfunction runInContext(code, filename, context) {\n  const script = new vm_1.Script(code, {\n    filename\n  });\n\n  if (context === undefined || context === global) {\n    return script.runInThisContext();\n  } else {\n    return script.runInContext(context);\n  }\n}\n/**\n * Append to the eval instance and return an undo function.\n */\n\n\nfunction appendToEvalState(state, input) {\n  const undoInput = state.input;\n  const undoVersion = state.version;\n  const undoOutput = state.output;\n  const undoLines = state.lines;\n  state.input += input;\n  state.lines += lineCount(input);\n  state.version++;\n  return function () {\n    state.input = undoInput;\n    state.output = undoOutput;\n    state.version = undoVersion;\n    state.lines = undoLines;\n  };\n}\n/**\n * Count the number of lines.\n */\n\n\nfunction lineCount(value) {\n  let count = 0;\n\n  for (const char of value) {\n    if (char === '\\n') {\n      count++;\n    }\n  }\n\n  return count;\n}\n/**\n * TS diagnostic codes which are recoverable, meaning that the user likely entered an incomplete line of code\n * and should be prompted for the next.  For example, starting a multi-line for() loop and not finishing it.\n * null value means code is always recoverable.  `Set` means code is only recoverable when occurring alongside at least one\n * of the other codes.\n */\n\n\nconst RECOVERY_CODES = new Map([[1003, null], [1005, null], [1109, null], [1126, null], [1136, new Set([1005]) // happens when typing out an object literal or block scope across multiple lines: '{ foo: 123,'\n], [1160, null], [1161, null], [2355, null], [2391, null], [7010, new Set([1005]) // happens when fn signature spread across multiple lines: 'function a(\\nb: any\\n) {'\n]]);\n/**\n * Diagnostic codes raised when using top-level await.\n * These are suppressed when top-level await is enabled.\n * When it is *not* enabled, these trigger a helpful hint about enabling top-level await.\n */\n\nconst topLevelAwaitDiagnosticCodes = [1375, 1378, 1431, 1432 // Top-level 'for await' loops are only allowed when the 'module' option is set to 'esnext' or 'system', and the 'target' option is set to 'es2017' or higher.\n];\n/**\n * Check if a function can recover gracefully.\n */\n\nfunction isRecoverable(error) {\n  return error.diagnosticCodes.every(code => {\n    const deps = RECOVERY_CODES.get(code);\n    return deps === null || deps && error.diagnosticCodes.some(code => deps.has(code));\n  });\n}\n/**\n * @internal\n * Set properties on `context` before eval-ing [stdin] or [eval] input.\n */\n\n\nfunction setupContext(context, module, filenameAndDirname) {\n  if (filenameAndDirname) {\n    context.__dirname = '.';\n    context.__filename = `[${filenameAndDirname}]`;\n  }\n\n  context.module = module;\n  context.exports = module.exports;\n  context.require = module.require.bind(module);\n}\n\nexports.setupContext = setupContext;","map":{"version":3,"mappings":"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","names":["_processTopLevelAwait","getProcessTopLevelAwait","undefined","processTopLevelAwait","require","diff","getDiffLines","diffLines","exports","createRepl","options","ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl","service","nodeReplServer","context","state","_a","EvalState","process","cwd","evalAwarePartialHost","createEvalAwarePartialHost","composeWithEvalAwarePartialHost","stdin","_b","stdout","_c","stderr","_d","_console","console","console_1","replService","_e","setService","evalCode","evalCodeInternal","nodeEval","start","startInternal","_service","addDiagnosticFilter","appliesToAllFiles","filenamesAbsolute","path","diagnosticsIgnored","shouldReplAwait","topLevelAwaitDiagnosticCodes","code","result","appendCompileAndEvalInput","input","overrideIsCompletion","assert","containsTopLevelAwait","value","enableTopLevelAwait","_filename","callback","evalResult","valuePromise","promiseError","handleError","error","canLogTopLevelAwaitHint","experimentalReplAwait","index_1","repl_1","isRecoverable","diagnosticCodes","some","dC","includes","getTopLevelAwaitHint","_error","SyntaxError","message","stack","replace","_","$1","ts","version","ScriptTarget","config","target","forceToBeModule","optionsOverride","err","exit","compile","repl","prompt","output","terminal","isTTY","parseInt","NODE_NO_READLINE","eval","useGlobal","resetEval","appendToEvalState","reset","runInContext","transpileOnly","module_1","filter","name","startsWith","map","join","on","defineCommand","help","action","identifier","displayPrompt","undo","comment","getTypeInfo","length","outputStream","write","setupHistory","historyPath","TS_NODE_HISTORY","constructor","composeWith","readFile","fileExists","stats","isFile","isFIFO","sourcemapCommentRe","wrappedErr","wrappedCmd","test","trim","lines","isCompletion","adjustUseStrict","outputWithoutSourcemapComment","oldOutputWithoutSourcemapComment","changes","all","lastChar","whitespace","commands","change","added","indexOf","wrappedResult","push","mustAwait","execCommand","command","r","reduce","c","filename","script","vm_1","global","runInThisContext","undoInput","undoVersion","undoOutput","undoLines","lineCount","count","char","RECOVERY_CODES","Map","Set","every","deps","get","has","setupContext","module","filenameAndDirname","__dirname","__filename","bind"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\ts-node\\src\\repl.ts"],"sourcesContent":["import type * as _diff from 'diff';\nimport { homedir } from 'os';\nimport { join } from 'path';\nimport {\n  Recoverable,\n  ReplOptions,\n  REPLServer,\n  start as nodeReplStart,\n} from 'repl';\nimport { Context, createContext, Script } from 'vm';\nimport { Service, CreateOptions, TSError, env } from './index';\nimport { readFileSync, statSync } from 'fs';\nimport { Console } from 'console';\nimport * as assert from 'assert';\nimport type * as tty from 'tty';\nimport type * as Module from 'module';\nimport { builtinModules } from 'module';\n\n// Lazy-loaded.\nlet _processTopLevelAwait: (src: string) => string | null;\nfunction getProcessTopLevelAwait() {\n  if (_processTopLevelAwait === undefined) {\n    ({\n      processTopLevelAwait: _processTopLevelAwait,\n    } = require('../dist-raw/node-internal-repl-await'));\n  }\n  return _processTopLevelAwait;\n}\nlet diff: typeof _diff;\nfunction getDiffLines() {\n  if (diff === undefined) {\n    diff = require('diff');\n  }\n  return diff.diffLines;\n}\n\n/** @internal */\nexport const EVAL_FILENAME = `[eval].ts`;\n/** @internal */\nexport const EVAL_NAME = `[eval]`;\n/** @internal */\nexport const STDIN_FILENAME = `[stdin].ts`;\n/** @internal */\nexport const STDIN_NAME = `[stdin]`;\n/** @internal */\nexport const REPL_FILENAME = '<repl>.ts';\n/** @internal */\nexport const REPL_NAME = '<repl>';\n\nexport interface ReplService {\n  readonly state: EvalState;\n  /**\n   * Bind this REPL to a ts-node compiler service.  A compiler service must be bound before `eval`-ing code or starting the REPL\n   */\n  setService(service: Service): void;\n  /**\n   * Append code to the virtual <repl> source file, compile it to JavaScript, throw semantic errors if the typechecker is enabled,\n   * and execute it.\n   *\n   * Note: typically, you will want to call `start()` instead of using this method.\n   *\n   * @param code string of TypeScript.\n   */\n  evalCode(code: string): any;\n  /** @internal */\n  evalCodeInternal(opts: {\n    code: string;\n    enableTopLevelAwait?: boolean;\n    context?: Context;\n  }):\n    | {\n        containsTopLevelAwait: true;\n        valuePromise: Promise<any>;\n      }\n    | {\n        containsTopLevelAwait: false;\n        value: any;\n      };\n  /**\n   * `eval` implementation compatible with node's REPL API\n   *\n   * Can be used in advanced scenarios if you want to manually create your own\n   * node REPL instance and delegate eval to this `ReplService`.\n   *\n   * Example:\n   *\n   *     import {start} from 'repl';\n   *     const replService: tsNode.ReplService = ...; // assuming you have already created a ts-node ReplService\n   *     const nodeRepl = start({eval: replService.eval});\n   */\n  nodeEval(\n    code: string,\n    // TODO change to `Context` in a future release?  Technically a breaking change\n    context: any,\n    _filename: string,\n    callback: (err: Error | null, result?: any) => any\n  ): void;\n  evalAwarePartialHost: EvalAwarePartialHost;\n  /** Start a node REPL */\n  start(): void;\n  /**\n   * Start a node REPL, evaling a string of TypeScript before it starts.\n   * @deprecated\n   */\n  start(code: string): void;\n  /** @internal */\n  startInternal(opts?: ReplOptions): REPLServer;\n  /** @internal */\n  readonly stdin: NodeJS.ReadableStream;\n  /** @internal */\n  readonly stdout: NodeJS.WritableStream;\n  /** @internal */\n  readonly stderr: NodeJS.WritableStream;\n  /** @internal */\n  readonly console: Console;\n}\n\n/** @category REPL */\nexport interface CreateReplOptions {\n  service?: Service;\n  state?: EvalState;\n  stdin?: NodeJS.ReadableStream;\n  stdout?: NodeJS.WritableStream;\n  stderr?: NodeJS.WritableStream;\n  /** @internal */\n  composeWithEvalAwarePartialHost?: EvalAwarePartialHost;\n  /**\n   * @internal\n   * Ignore diagnostics that are annoying when interactively entering input line-by-line.\n   */\n  ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl?: boolean;\n}\n\n/**\n * Create a ts-node REPL instance.\n *\n * Pay close attention to the example below.  Today, the API requires a few lines\n * of boilerplate to correctly bind the `ReplService` to the ts-node `Service` and\n * vice-versa.\n *\n * Usage example:\n *\n *     const repl = tsNode.createRepl();\n *     const service = tsNode.create({...repl.evalAwarePartialHost});\n *     repl.setService(service);\n *     repl.start();\n *\n * @category REPL\n */\nexport function createRepl(options: CreateReplOptions = {}) {\n  const { ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl = true } = options;\n  let service = options.service;\n  let nodeReplServer: REPLServer;\n  // If `useGlobal` is not true, then REPL creates a context when started.\n  // This stores a reference to it or to `global`, whichever is used, after REPL has started.\n  let context: Context | undefined;\n  const state =\n    options.state ?? new EvalState(join(process.cwd(), REPL_FILENAME));\n  const evalAwarePartialHost = createEvalAwarePartialHost(\n    state,\n    options.composeWithEvalAwarePartialHost\n  );\n  const stdin = options.stdin ?? process.stdin;\n  const stdout = options.stdout ?? process.stdout;\n  const stderr = options.stderr ?? process.stderr;\n  const _console =\n    stdout === process.stdout && stderr === process.stderr\n      ? console\n      : new Console(stdout, stderr);\n\n  const replService: ReplService = {\n    state: options.state ?? new EvalState(join(process.cwd(), EVAL_FILENAME)),\n    setService,\n    evalCode,\n    evalCodeInternal,\n    nodeEval,\n    evalAwarePartialHost,\n    start,\n    startInternal,\n    stdin,\n    stdout,\n    stderr,\n    console: _console,\n  };\n\n  return replService;\n\n  function setService(_service: Service) {\n    service = _service;\n    if (ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl) {\n      service.addDiagnosticFilter({\n        appliesToAllFiles: false,\n        filenamesAbsolute: [state.path],\n        diagnosticsIgnored: [\n          2393, // Duplicate function implementation: https://github.com/TypeStrong/ts-node/issues/729\n          6133, // <identifier> is declared but its value is never read. https://github.com/TypeStrong/ts-node/issues/850\n          7027, // Unreachable code detected. https://github.com/TypeStrong/ts-node/issues/469\n          ...(service.shouldReplAwait ? topLevelAwaitDiagnosticCodes : []),\n        ],\n      });\n    }\n  }\n\n  function evalCode(code: string) {\n    const result = appendCompileAndEvalInput({\n      service: service!,\n      state,\n      input: code,\n      context,\n      overrideIsCompletion: false,\n    });\n    assert(result.containsTopLevelAwait === false);\n    return result.value;\n  }\n\n  function evalCodeInternal(options: {\n    code: string;\n    enableTopLevelAwait?: boolean;\n    context: Context;\n  }) {\n    const { code, enableTopLevelAwait, context } = options;\n    return appendCompileAndEvalInput({\n      service: service!,\n      state,\n      input: code,\n      enableTopLevelAwait,\n      context,\n    });\n  }\n\n  function nodeEval(\n    code: string,\n    context: any,\n    _filename: string,\n    callback: (err: Error | null, result?: any) => any\n  ) {\n    // TODO: Figure out how to handle completion here.\n    if (code === '.scope') {\n      callback(null);\n      return;\n    }\n\n    try {\n      const evalResult = evalCodeInternal({\n        code,\n        enableTopLevelAwait: true,\n        context,\n      });\n\n      if (evalResult.containsTopLevelAwait) {\n        (async () => {\n          try {\n            callback(null, await evalResult.valuePromise);\n          } catch (promiseError) {\n            handleError(promiseError);\n          }\n        })();\n      } else {\n        callback(null, evalResult.value);\n      }\n    } catch (error) {\n      handleError(error);\n    }\n\n    // Log TSErrors, check if they're recoverable, log helpful hints for certain\n    // well-known errors, and invoke `callback()`\n    // TODO should evalCode API get the same error-handling benefits?\n    function handleError(error: unknown) {\n      // Don't show TLA hint if the user explicitly disabled repl top level await\n      const canLogTopLevelAwaitHint =\n        service!.options.experimentalReplAwait !== false &&\n        !service!.shouldReplAwait;\n      if (error instanceof TSError) {\n        // Support recoverable compilations using >= node 6.\n        if (Recoverable && isRecoverable(error)) {\n          callback(new Recoverable(error));\n          return;\n        } else {\n          _console.error(error);\n\n          if (\n            canLogTopLevelAwaitHint &&\n            error.diagnosticCodes.some((dC) =>\n              topLevelAwaitDiagnosticCodes.includes(dC)\n            )\n          ) {\n            _console.error(getTopLevelAwaitHint());\n          }\n          callback(null);\n        }\n      } else {\n        let _error = error as Error | undefined;\n        if (\n          canLogTopLevelAwaitHint &&\n          _error instanceof SyntaxError &&\n          _error.message?.includes('await is only valid')\n        ) {\n          try {\n            // Only way I know to make our hint appear after the error\n            _error.message += `\\n\\n${getTopLevelAwaitHint()}`;\n            _error.stack = _error.stack?.replace(\n              /(SyntaxError:.*)/,\n              (_, $1) => `${$1}\\n\\n${getTopLevelAwaitHint()}`\n            );\n          } catch {}\n        }\n        callback(_error as Error);\n      }\n    }\n    function getTopLevelAwaitHint() {\n      return `Hint: REPL top-level await requires TypeScript version 3.8 or higher and target ES2018 or higher. You are using TypeScript ${\n        service!.ts.version\n      } and target ${\n        service!.ts.ScriptTarget[service!.config.options.target!]\n      }.`;\n    }\n  }\n\n  // Note: `code` argument is deprecated\n  function start(code?: string) {\n    startInternal({ code });\n  }\n\n  // Note: `code` argument is deprecated\n  function startInternal(\n    options?: ReplOptions & { code?: string; forceToBeModule?: boolean }\n  ) {\n    const { code, forceToBeModule = true, ...optionsOverride } = options ?? {};\n    // TODO assert that `service` is set; remove all `service!` non-null assertions\n\n    // Eval incoming code before the REPL starts.\n    // Note: deprecated\n    if (code) {\n      try {\n        evalCode(`${code}\\n`);\n      } catch (err) {\n        _console.error(err);\n        // Note: should not be killing the process here, but this codepath is deprecated anyway\n        process.exit(1);\n      }\n    }\n\n    // In case the typescript compiler hasn't compiled anything yet,\n    // make it run though compilation at least one time before\n    // the REPL starts for a snappier user experience on startup.\n    service?.compile('', state.path);\n\n    const repl = nodeReplStart({\n      prompt: '> ',\n      input: replService.stdin,\n      output: replService.stdout,\n      // Mimicking node's REPL implementation: https://github.com/nodejs/node/blob/168b22ba073ee1cbf8d0bcb4ded7ff3099335d04/lib/internal/repl.js#L28-L30\n      terminal:\n        (stdout as tty.WriteStream).isTTY &&\n        !parseInt(env.NODE_NO_READLINE!, 10),\n      eval: nodeEval,\n      useGlobal: true,\n      ...optionsOverride,\n    });\n\n    nodeReplServer = repl;\n    context = repl.context;\n\n    // Bookmark the point where we should reset the REPL state.\n    const resetEval = appendToEvalState(state, '');\n\n    function reset() {\n      resetEval();\n\n      // Hard fix for TypeScript forcing `Object.defineProperty(exports, ...)`.\n      runInContext('exports = module.exports', state.path, context);\n      if (forceToBeModule) {\n        state.input += 'export {};void 0;\\n';\n      }\n\n      // Declare node builtins.\n      // Skip the same builtins as `addBuiltinLibsToObject`:\n      //   those starting with _\n      //   those containing /\n      //   those that already exist as globals\n      // Intentionally suppress type errors in case @types/node does not declare any of them, and because\n      // `declare import` is technically invalid syntax.\n      // Avoid this when in transpileOnly, because third-party transpilers may not handle `declare import`.\n      if (!service?.transpileOnly) {\n        state.input += `// @ts-ignore\\n${builtinModules\n          .filter(\n            (name) =>\n              !name.startsWith('_') &&\n              !name.includes('/') &&\n              !['console', 'module', 'process'].includes(name)\n          )\n          .map((name) => `declare import ${name} = require('${name}')`)\n          .join(';')}\\n`;\n      }\n    }\n\n    reset();\n    repl.on('reset', reset);\n\n    repl.defineCommand('type', {\n      help: 'Check the type of a TypeScript identifier',\n      action: function (identifier: string) {\n        if (!identifier) {\n          repl.displayPrompt();\n          return;\n        }\n\n        const undo = appendToEvalState(state, identifier);\n        const { name, comment } = service!.getTypeInfo(\n          state.input,\n          state.path,\n          state.input.length\n        );\n\n        undo();\n\n        if (name) repl.outputStream.write(`${name}\\n`);\n        if (comment) repl.outputStream.write(`${comment}\\n`);\n        repl.displayPrompt();\n      },\n    });\n\n    // Set up REPL history when available natively via node.js >= 11.\n    if (repl.setupHistory) {\n      const historyPath =\n        env.TS_NODE_HISTORY || join(homedir(), '.ts_node_repl_history');\n\n      repl.setupHistory(historyPath, (err) => {\n        if (!err) return;\n\n        _console.error(err);\n        process.exit(1);\n      });\n    }\n\n    return repl;\n  }\n}\n\n/**\n * Eval state management. Stores virtual `[eval].ts` file\n */\nexport class EvalState {\n  /** @internal */\n  input = '';\n  /** @internal */\n  output = '';\n  /** @internal */\n  version = 0;\n  /** @internal */\n  lines = 0;\n\n  __tsNodeEvalStateBrand: unknown;\n\n  constructor(public path: string) {}\n}\n\n/**\n * Filesystem host functions which are aware of the \"virtual\" `[eval].ts`, `<repl>`, or `[stdin].ts` file used to compile REPL inputs.\n * Must be passed to `create()` to create a ts-node compiler service which can compile REPL inputs.\n */\nexport type EvalAwarePartialHost = Pick<\n  CreateOptions,\n  'readFile' | 'fileExists'\n>;\n\nexport function createEvalAwarePartialHost(\n  state: EvalState,\n  composeWith?: EvalAwarePartialHost\n): EvalAwarePartialHost {\n  function readFile(path: string) {\n    if (path === state.path) return state.input;\n\n    if (composeWith?.readFile) return composeWith.readFile(path);\n\n    try {\n      return readFileSync(path, 'utf8');\n    } catch (err) {\n      /* Ignore. */\n    }\n  }\n  function fileExists(path: string) {\n    if (path === state.path) return true;\n\n    if (composeWith?.fileExists) return composeWith.fileExists(path);\n\n    try {\n      const stats = statSync(path);\n      return stats.isFile() || stats.isFIFO();\n    } catch (err) {\n      return false;\n    }\n  }\n  return { readFile, fileExists };\n}\n\nconst sourcemapCommentRe = /\\/\\/# ?sourceMappingURL=\\S+[\\s\\r\\n]*$/;\n\ntype AppendCompileAndEvalInputResult =\n  | { containsTopLevelAwait: true; valuePromise: Promise<any> }\n  | { containsTopLevelAwait: false; value: any };\n/**\n * Evaluate the code snippet.\n *\n * Append it to virtual .ts file, compile, handle compiler errors, compute a diff of the JS, and eval any code that\n * appears as \"added\" in the diff.\n */\nfunction appendCompileAndEvalInput(options: {\n  service: Service;\n  state: EvalState;\n  input: string;\n  wrappedErr?: unknown;\n  /** Enable top-level await but only if the TSNode service allows it. */\n  enableTopLevelAwait?: boolean;\n  context: Context | undefined;\n  /**\n   * Added so that `evalCode` can be guaranteed *not* to trigger the `isCompletion`\n   * codepath.  However, the `isCompletion` logic is ancient and maybe should be removed entirely.\n   * Nobody's looked at it in a long time.\n   */\n  overrideIsCompletion?: boolean;\n}): AppendCompileAndEvalInputResult {\n  const {\n    service,\n    state,\n    wrappedErr,\n    enableTopLevelAwait = false,\n    context,\n    overrideIsCompletion,\n  } = options;\n  let { input } = options;\n\n  // It's confusing for `{ a: 1 }` to be interpreted as a block statement\n  // rather than an object literal. So, we first try to wrap it in\n  // parentheses, so that it will be interpreted as an expression.\n  // Based on https://github.com/nodejs/node/blob/c2e6822153bad023ab7ebd30a6117dcc049e475c/lib/repl.js#L413-L422\n  let wrappedCmd = false;\n  if (!wrappedErr && /^\\s*{/.test(input) && !/;\\s*$/.test(input)) {\n    input = `(${input.trim()})\\n`;\n    wrappedCmd = true;\n  }\n\n  const lines = state.lines;\n  const isCompletion = overrideIsCompletion ?? !/\\n$/.test(input);\n  const undo = appendToEvalState(state, input);\n  let output: string;\n\n  // Based on https://github.com/nodejs/node/blob/92573721c7cff104ccb82b6ed3e8aa69c4b27510/lib/repl.js#L457-L461\n  function adjustUseStrict(code: string) {\n    // \"void 0\" keeps the repl from returning \"use strict\" as the result\n    // value for statements and declarations that don't return a value.\n    return code.replace(/^\"use strict\";/, '\"use strict\"; void 0;');\n  }\n\n  try {\n    output = service.compile(state.input, state.path, -lines);\n  } catch (err) {\n    undo();\n\n    if (wrappedCmd) {\n      if (err instanceof TSError && err.diagnosticCodes[0] === 2339) {\n        // Ensure consistent and more sane behavior between { a: 1 }['b'] and ({ a: 1 }['b'])\n        throw err;\n      }\n      // Unwrap and try again\n      return appendCompileAndEvalInput({\n        ...options,\n        wrappedErr: err,\n      });\n    }\n\n    if (wrappedErr) throw wrappedErr;\n    throw err;\n  }\n\n  output = adjustUseStrict(output);\n\n  // Note: REPL does not respect sourcemaps!\n  // To properly do that, we'd need to prefix the code we eval -- which comes\n  // from `diffLines` -- with newlines so that it's at the proper line numbers.\n  // Then we'd need to ensure each bit of eval-ed code, if there are multiples,\n  // has the sourcemap appended to it.\n  // We might also need to integrate with our sourcemap hooks' cache; I'm not sure.\n  const outputWithoutSourcemapComment = output.replace(sourcemapCommentRe, '');\n  const oldOutputWithoutSourcemapComment = state.output.replace(\n    sourcemapCommentRe,\n    ''\n  );\n\n  // Use `diff` to check for new JavaScript to execute.\n  const changes = getDiffLines()(\n    oldOutputWithoutSourcemapComment,\n    outputWithoutSourcemapComment\n  );\n\n  if (isCompletion) {\n    undo();\n  } else {\n    state.output = output;\n\n    // Insert a semicolon to make sure that the code doesn't interact with the next line,\n    // for example to prevent `2\\n+ 2` from producing 4.\n    // This is safe since the output will not change since we can only get here with successful inputs,\n    // and adding a semicolon to the end of a successful input won't ever change the output.\n    state.input = state.input.replace(\n      /([^\\n\\s])([\\n\\s]*)$/,\n      (all, lastChar, whitespace) => {\n        if (lastChar !== ';') return `${lastChar};${whitespace}`;\n        return all;\n      }\n    );\n  }\n\n  let commands: Array<{ mustAwait?: true; execCommand: () => any }> = [];\n  let containsTopLevelAwait = false;\n\n  // Build a list of \"commands\": bits of JS code in the diff that must be executed.\n  for (const change of changes) {\n    if (change.added) {\n      if (\n        enableTopLevelAwait &&\n        service.shouldReplAwait &&\n        change.value.indexOf('await') > -1\n      ) {\n        const processTopLevelAwait = getProcessTopLevelAwait();\n\n        // Newline prevents comments to mess with wrapper\n        const wrappedResult = processTopLevelAwait(change.value + '\\n');\n        if (wrappedResult !== null) {\n          containsTopLevelAwait = true;\n          commands.push({\n            mustAwait: true,\n            execCommand: () => runInContext(wrappedResult, state.path, context),\n          });\n          continue;\n        }\n      }\n      commands.push({\n        execCommand: () => runInContext(change.value, state.path, context),\n      });\n    }\n  }\n\n  // Execute all commands asynchronously if necessary, returning the result or a\n  // promise of the result.\n  if (containsTopLevelAwait) {\n    return {\n      containsTopLevelAwait,\n      valuePromise: (async () => {\n        let value;\n        for (const command of commands) {\n          const r = command.execCommand();\n          value = command.mustAwait ? await r : r;\n        }\n        return value;\n      })(),\n    };\n  } else {\n    return {\n      containsTopLevelAwait: false,\n      value: commands.reduce<any>((_, c) => c.execCommand(), undefined),\n    };\n  }\n}\n\n/**\n * Low-level execution of JS code in context\n */\nfunction runInContext(code: string, filename: string, context?: Context) {\n  const script = new Script(code, { filename });\n\n  if (context === undefined || context === global) {\n    return script.runInThisContext();\n  } else {\n    return script.runInContext(context);\n  }\n}\n\n/**\n * Append to the eval instance and return an undo function.\n */\nfunction appendToEvalState(state: EvalState, input: string) {\n  const undoInput = state.input;\n  const undoVersion = state.version;\n  const undoOutput = state.output;\n  const undoLines = state.lines;\n\n  state.input += input;\n  state.lines += lineCount(input);\n  state.version++;\n\n  return function () {\n    state.input = undoInput;\n    state.output = undoOutput;\n    state.version = undoVersion;\n    state.lines = undoLines;\n  };\n}\n\n/**\n * Count the number of lines.\n */\nfunction lineCount(value: string) {\n  let count = 0;\n\n  for (const char of value) {\n    if (char === '\\n') {\n      count++;\n    }\n  }\n\n  return count;\n}\n\n/**\n * TS diagnostic codes which are recoverable, meaning that the user likely entered an incomplete line of code\n * and should be prompted for the next.  For example, starting a multi-line for() loop and not finishing it.\n * null value means code is always recoverable.  `Set` means code is only recoverable when occurring alongside at least one\n * of the other codes.\n */\nconst RECOVERY_CODES: Map<number, Set<number> | null> = new Map([\n  [1003, null], // \"Identifier expected.\"\n  [1005, null], // \"')' expected.\", \"'}' expected.\"\n  [1109, null], // \"Expression expected.\"\n  [1126, null], // \"Unexpected end of text.\"\n  [\n    1136, // \"Property assignment expected.\"\n    new Set([1005]), // happens when typing out an object literal or block scope across multiple lines: '{ foo: 123,'\n  ],\n  [1160, null], // \"Unterminated template literal.\"\n  [1161, null], // \"Unterminated regular expression literal.\"\n  [2355, null], // \"A function whose declared type is neither 'void' nor 'any' must return a value.\"\n  [2391, null], // \"Function implementation is missing or not immediately following the declaration.\"\n  [\n    7010, // \"Function, which lacks return-type annotation, implicitly has an 'any' return type.\"\n    new Set([1005]), // happens when fn signature spread across multiple lines: 'function a(\\nb: any\\n) {'\n  ],\n]);\n\n/**\n * Diagnostic codes raised when using top-level await.\n * These are suppressed when top-level await is enabled.\n * When it is *not* enabled, these trigger a helpful hint about enabling top-level await.\n */\nconst topLevelAwaitDiagnosticCodes = [\n  1375, // 'await' expressions are only allowed at the top level of a file when that file is a module, but this file has no imports or exports. Consider adding an empty 'export {}' to make this file a module.\n  1378, // Top-level 'await' expressions are only allowed when the 'module' option is set to 'esnext' or 'system', and the 'target' option is set to 'es2017' or higher.\n  1431, // 'for await' loops are only allowed at the top level of a file when that file is a module, but this file has no imports or exports. Consider adding an empty 'export {}' to make this file a module.\n  1432, // Top-level 'for await' loops are only allowed when the 'module' option is set to 'esnext' or 'system', and the 'target' option is set to 'es2017' or higher.\n];\n\n/**\n * Check if a function can recover gracefully.\n */\nfunction isRecoverable(error: TSError) {\n  return error.diagnosticCodes.every((code) => {\n    const deps = RECOVERY_CODES.get(code);\n    return (\n      deps === null ||\n      (deps && error.diagnosticCodes.some((code) => deps.has(code)))\n    );\n  });\n}\n\n/**\n * @internal\n * Set properties on `context` before eval-ing [stdin] or [eval] input.\n */\nexport function setupContext(\n  context: any,\n  module: Module,\n  filenameAndDirname: 'eval' | 'stdin' | null\n) {\n  if (filenameAndDirname) {\n    context.__dirname = '.';\n    context.__filename = `[${filenameAndDirname}]`;\n  }\n  context.module = module;\n  context.exports = module.exports;\n  context.require = module.require.bind(module);\n}\n"]},"metadata":{},"sourceType":"script"}