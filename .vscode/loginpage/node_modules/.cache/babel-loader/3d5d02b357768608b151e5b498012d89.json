{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getValidationErrors = exports.validateConfig = exports.decimalString = exports.address = exports.hexString = exports.DotPathReporter = exports.success = exports.failure = void 0;\n\nconst t = __importStar(require(\"io-ts\"));\n\nconst lib_1 = require(\"io-ts/lib\");\n\nconst constants_1 = require(\"../../constants\");\n\nconst io_ts_1 = require(\"../../util/io-ts\");\n\nconst lang_1 = require(\"../../util/lang\");\n\nconst errors_1 = require(\"../errors\");\n\nconst errors_list_1 = require(\"../errors-list\");\n\nconst hardforks_1 = require(\"../../util/hardforks\");\n\nconst default_config_1 = require(\"./default-config\");\n\nfunction stringify(v) {\n  if (typeof v === \"function\") {\n    return (0, lib_1.getFunctionName)(v);\n  }\n\n  if (typeof v === \"number\" && !isFinite(v)) {\n    if (isNaN(v)) {\n      return \"NaN\";\n    }\n\n    return v > 0 ? \"Infinity\" : \"-Infinity\";\n  }\n\n  return JSON.stringify(v);\n}\n\nfunction getContextPath(context) {\n  const keysPath = context.slice(1).map(c => c.key).join(\".\");\n  return `${context[0].type.name}.${keysPath}`;\n}\n\nfunction getMessage(e) {\n  const lastContext = e.context[e.context.length - 1];\n  return e.message !== undefined ? e.message : getErrorMessage(getContextPath(e.context), e.value, lastContext.type.name);\n}\n\nfunction getErrorMessage(path, value, expectedType) {\n  return `Invalid value ${stringify(value)} for ${path} - Expected a value of type ${expectedType}.`;\n}\n\nfunction getPrivateKeyError(index, network, message) {\n  return `Invalid account: #${index} for network: ${network} - ${message}`;\n}\n\nfunction validatePrivateKey(privateKey, index, network, errors) {\n  if (typeof privateKey !== \"string\") {\n    errors.push(getPrivateKeyError(index, network, `Expected string, received ${typeof privateKey}`));\n  } else {\n    // private key validation\n    const pkWithPrefix = /^0x/.test(privateKey) ? privateKey : `0x${privateKey}`; // 32 bytes = 64 characters + 2 char prefix = 66\n\n    if (pkWithPrefix.length < 66) {\n      errors.push(getPrivateKeyError(index, network, \"private key too short, expected 32 bytes\"));\n    } else if (pkWithPrefix.length > 66) {\n      errors.push(getPrivateKeyError(index, network, \"private key too long, expected 32 bytes\"));\n    } else if (exports.hexString.decode(pkWithPrefix).isLeft()) {\n      errors.push(getPrivateKeyError(index, network, \"invalid hex character(s) found in string\"));\n    }\n  }\n}\n\nfunction failure(es) {\n  return es.map(getMessage);\n}\n\nexports.failure = failure;\n\nfunction success() {\n  return [];\n}\n\nexports.success = success;\nexports.DotPathReporter = {\n  report: validation => validation.fold(failure, success)\n};\nconst HEX_STRING_REGEX = /^(0x)?([0-9a-f]{2})+$/gi;\nconst DEC_STRING_REGEX = /^(0|[1-9][0-9]*)$/g;\n\nfunction isHexString(v) {\n  if (typeof v !== \"string\") {\n    return false;\n  }\n\n  return v.trim().match(HEX_STRING_REGEX) !== null;\n}\n\nfunction isDecimalString(v) {\n  if (typeof v !== \"string\") {\n    return false;\n  }\n\n  return v.match(DEC_STRING_REGEX) !== null;\n}\n\nexports.hexString = new t.Type(\"hex string\", isHexString, (u, c) => isHexString(u) ? t.success(u) : t.failure(u, c), t.identity);\n\nfunction isAddress(v) {\n  if (typeof v !== \"string\") {\n    return false;\n  }\n\n  const trimmed = v.trim();\n  return trimmed.match(HEX_STRING_REGEX) !== null && trimmed.startsWith(\"0x\") && trimmed.length === 42;\n}\n\nexports.address = new t.Type(\"address\", isAddress, (u, c) => isAddress(u) ? t.success(u) : t.failure(u, c), t.identity);\nexports.decimalString = new t.Type(\"decimal string\", isDecimalString, (u, c) => isDecimalString(u) ? t.success(u) : t.failure(u, c), t.identity); // TODO: These types have outdated name. They should match the UserConfig types.\n// IMPORTANT: This t.types MUST be kept in sync with the actual types.\n\nconst HardhatNetworkAccount = t.type({\n  privateKey: exports.hexString,\n  balance: exports.decimalString\n});\nconst commonHDAccountsFields = {\n  initialIndex: (0, io_ts_1.optional)(t.number),\n  count: (0, io_ts_1.optional)(t.number),\n  path: (0, io_ts_1.optional)(t.string)\n};\nconst HardhatNetworkHDAccountsConfig = t.type({\n  mnemonic: (0, io_ts_1.optional)(t.string),\n  accountsBalance: (0, io_ts_1.optional)(exports.decimalString),\n  passphrase: (0, io_ts_1.optional)(t.string),\n  ...commonHDAccountsFields\n});\nconst Integer = new t.Type(\"Integer\", num => typeof num === \"number\", (u, c) => {\n  try {\n    return typeof u === \"string\" ? t.success(parseInt(u, 10)) : t.failure(u, c);\n  } catch {\n    return t.failure(u, c);\n  }\n}, t.identity);\nconst HardhatNetworkForkingConfig = t.type({\n  enabled: (0, io_ts_1.optional)(t.boolean),\n  url: t.string,\n  blockNumber: (0, io_ts_1.optional)(t.number)\n});\nconst HardhatNetworkMempoolConfig = t.type({\n  order: (0, io_ts_1.optional)(t.keyof((0, lang_1.fromEntries)(constants_1.HARDHAT_MEMPOOL_SUPPORTED_ORDERS.map(order => [order, null]))))\n});\nconst HardhatNetworkMiningConfig = t.type({\n  auto: (0, io_ts_1.optional)(t.boolean),\n  interval: (0, io_ts_1.optional)(t.union([t.number, t.tuple([t.number, t.number])])),\n  mempool: (0, io_ts_1.optional)(HardhatNetworkMempoolConfig)\n});\n\nfunction isValidHardforkName(name) {\n  return Object.values(hardforks_1.HardforkName).includes(name);\n}\n\nconst HardforkNameType = new t.Type(Object.values(hardforks_1.HardforkName).map(v => `\"${v}\"`).join(\" | \"), name => typeof name === \"string\" && isValidHardforkName(name), (u, c) => {\n  return typeof u === \"string\" && isValidHardforkName(u) ? t.success(u) : t.failure(u, c);\n}, t.identity);\nconst HardhatNetworkHardforkHistory = t.record(HardforkNameType, t.number, \"HardhatNetworkHardforkHistory\");\nconst HardhatNetworkChainConfig = t.type({\n  hardforkHistory: HardhatNetworkHardforkHistory\n});\nconst HardhatNetworkChainsConfig = t.record(Integer, HardhatNetworkChainConfig);\nconst commonNetworkConfigFields = {\n  chainId: (0, io_ts_1.optional)(t.number),\n  from: (0, io_ts_1.optional)(t.string),\n  gas: (0, io_ts_1.optional)(t.union([t.literal(\"auto\"), t.number])),\n  gasPrice: (0, io_ts_1.optional)(t.union([t.literal(\"auto\"), t.number])),\n  gasMultiplier: (0, io_ts_1.optional)(t.number)\n};\nconst HardhatNetworkConfig = t.type({ ...commonNetworkConfigFields,\n  hardfork: (0, io_ts_1.optional)(t.keyof((0, lang_1.fromEntries)(constants_1.HARDHAT_NETWORK_SUPPORTED_HARDFORKS.map(hf => [hf, null])))),\n  accounts: (0, io_ts_1.optional)(t.union([t.array(HardhatNetworkAccount), HardhatNetworkHDAccountsConfig])),\n  blockGasLimit: (0, io_ts_1.optional)(t.number),\n  minGasPrice: (0, io_ts_1.optional)(t.union([t.number, t.string])),\n  throwOnTransactionFailures: (0, io_ts_1.optional)(t.boolean),\n  throwOnCallFailures: (0, io_ts_1.optional)(t.boolean),\n  allowUnlimitedContractSize: (0, io_ts_1.optional)(t.boolean),\n  initialDate: (0, io_ts_1.optional)(t.string),\n  loggingEnabled: (0, io_ts_1.optional)(t.boolean),\n  forking: (0, io_ts_1.optional)(HardhatNetworkForkingConfig),\n  mining: (0, io_ts_1.optional)(HardhatNetworkMiningConfig),\n  coinbase: (0, io_ts_1.optional)(exports.address),\n  chains: (0, io_ts_1.optional)(HardhatNetworkChainsConfig)\n});\nconst HDAccountsConfig = t.type({\n  mnemonic: t.string,\n  passphrase: (0, io_ts_1.optional)(t.string),\n  ...commonHDAccountsFields\n});\nconst NetworkConfigAccounts = t.union([t.literal(\"remote\"), t.array(exports.hexString), HDAccountsConfig]);\nconst HttpHeaders = t.record(t.string, t.string, \"httpHeaders\");\nconst HttpNetworkConfig = t.type({ ...commonNetworkConfigFields,\n  url: (0, io_ts_1.optional)(t.string),\n  accounts: (0, io_ts_1.optional)(NetworkConfigAccounts),\n  httpHeaders: (0, io_ts_1.optional)(HttpHeaders),\n  timeout: (0, io_ts_1.optional)(t.number)\n});\nconst NetworkConfig = t.union([HardhatNetworkConfig, HttpNetworkConfig]);\nconst Networks = t.record(t.string, NetworkConfig);\nconst ProjectPaths = t.type({\n  root: (0, io_ts_1.optional)(t.string),\n  cache: (0, io_ts_1.optional)(t.string),\n  artifacts: (0, io_ts_1.optional)(t.string),\n  sources: (0, io_ts_1.optional)(t.string),\n  tests: (0, io_ts_1.optional)(t.string)\n});\nconst SingleSolcConfig = t.type({\n  version: t.string,\n  settings: (0, io_ts_1.optional)(t.any)\n});\nconst MultiSolcConfig = t.type({\n  compilers: t.array(SingleSolcConfig),\n  overrides: (0, io_ts_1.optional)(t.record(t.string, SingleSolcConfig))\n});\nconst SolidityConfig = t.union([t.string, SingleSolcConfig, MultiSolcConfig]);\nconst HardhatConfig = t.type({\n  defaultNetwork: (0, io_ts_1.optional)(t.string),\n  networks: (0, io_ts_1.optional)(Networks),\n  paths: (0, io_ts_1.optional)(ProjectPaths),\n  solidity: (0, io_ts_1.optional)(SolidityConfig)\n}, \"HardhatConfig\");\n/**\n * Validates the config, throwing a HardhatError if invalid.\n * @param config\n */\n\nfunction validateConfig(config) {\n  const errors = getValidationErrors(config);\n\n  if (errors.length === 0) {\n    return;\n  }\n\n  let errorList = errors.join(\"\\n  * \");\n  errorList = `  * ${errorList}`;\n  throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.INVALID_CONFIG, {\n    errors: errorList\n  });\n}\n\nexports.validateConfig = validateConfig;\n\nfunction getValidationErrors(config) {\n  const errors = []; // These can't be validated with io-ts\n\n  if (config !== undefined && typeof config.networks === \"object\") {\n    const hardhatNetwork = config.networks[constants_1.HARDHAT_NETWORK_NAME];\n\n    if (hardhatNetwork !== undefined && typeof hardhatNetwork === \"object\") {\n      if (\"url\" in hardhatNetwork) {\n        errors.push(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME} can't have an url`);\n      } // Validating the accounts with io-ts leads to very confusing errors messages\n\n\n      const {\n        accounts,\n        ...configExceptAccounts\n      } = hardhatNetwork;\n      const netConfigResult = HardhatNetworkConfig.decode(configExceptAccounts);\n\n      if (netConfigResult.isLeft()) {\n        errors.push(getErrorMessage(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}`, hardhatNetwork, \"HardhatNetworkConfig\"));\n      } // manual validation of accounts\n\n\n      if (Array.isArray(accounts)) {\n        for (const [index, account] of accounts.entries()) {\n          if (typeof account !== \"object\") {\n            errors.push(getPrivateKeyError(index, constants_1.HARDHAT_NETWORK_NAME, `Expected object, received ${typeof account}`));\n            continue;\n          }\n\n          const {\n            privateKey,\n            balance\n          } = account;\n          validatePrivateKey(privateKey, index, constants_1.HARDHAT_NETWORK_NAME, errors);\n\n          if (typeof balance !== \"string\") {\n            errors.push(getErrorMessage(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.accounts[].balance`, balance, \"string\"));\n          } else if (exports.decimalString.decode(balance).isLeft()) {\n            errors.push(getErrorMessage(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.accounts[].balance`, balance, \"decimal(wei)\"));\n          }\n        }\n      } else if (typeof hardhatNetwork.accounts === \"object\") {\n        const hdConfigResult = HardhatNetworkHDAccountsConfig.decode(hardhatNetwork.accounts);\n\n        if (hdConfigResult.isLeft()) {\n          errors.push(getErrorMessage(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.accounts`, hardhatNetwork.accounts, \"[{privateKey: string, balance: string}] | HardhatNetworkHDAccountsConfig | undefined\"));\n        }\n      } else if (hardhatNetwork.accounts !== undefined) {\n        errors.push(getErrorMessage(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.accounts`, hardhatNetwork.accounts, \"[{privateKey: string, balance: string}] | HardhatNetworkHDAccountsConfig | undefined\"));\n      }\n\n      const hardfork = hardhatNetwork.hardfork ?? default_config_1.defaultHardhatNetworkParams.hardfork;\n\n      if ((0, hardforks_1.hardforkGte)(hardfork, hardforks_1.HardforkName.LONDON)) {\n        if (hardhatNetwork.minGasPrice !== undefined) {\n          errors.push(`Unexpected config HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.minGasPrice found - This field is not valid for networks with EIP-1559. Try an older hardfork or remove it.`);\n        }\n      } else {\n        if (hardhatNetwork.initialBaseFeePerGas !== undefined) {\n          errors.push(`Unexpected config HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.initialBaseFeePerGas found - This field is only valid for networks with EIP-1559. Try a newer hardfork or remove it.`);\n        }\n      }\n\n      if (hardhatNetwork.chains !== undefined) {\n        Object.entries(hardhatNetwork.chains).forEach(chainEntry => {\n          const [chainId, chainConfig] = chainEntry;\n          const {\n            hardforkHistory\n          } = chainConfig;\n\n          if (hardforkHistory !== undefined) {\n            Object.keys(hardforkHistory).forEach(hardforkName => {\n              if (!constants_1.HARDHAT_NETWORK_SUPPORTED_HARDFORKS.includes(hardforkName)) {\n                errors.push(getErrorMessage(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.chains[${chainId}].hardforkHistory`, hardforkName, `\"${constants_1.HARDHAT_NETWORK_SUPPORTED_HARDFORKS.join('\" | \"')}\"`));\n              }\n            });\n          }\n        });\n      }\n    }\n\n    for (const [networkName, netConfig] of Object.entries(config.networks)) {\n      if (networkName === constants_1.HARDHAT_NETWORK_NAME) {\n        continue;\n      }\n\n      if (networkName !== \"localhost\" || netConfig.url !== undefined) {\n        if (typeof netConfig.url !== \"string\") {\n          errors.push(getErrorMessage(`HardhatConfig.networks.${networkName}.url`, netConfig.url, \"string\"));\n        }\n      }\n\n      const {\n        accounts,\n        ...configExceptAccounts\n      } = netConfig;\n      const netConfigResult = HttpNetworkConfig.decode(configExceptAccounts);\n\n      if (netConfigResult.isLeft()) {\n        errors.push(getErrorMessage(`HardhatConfig.networks.${networkName}`, netConfig, \"HttpNetworkConfig\"));\n      } // manual validation of accounts\n\n\n      if (Array.isArray(accounts)) {\n        accounts.forEach((privateKey, index) => validatePrivateKey(privateKey, index, networkName, errors));\n      } else if (typeof accounts === \"object\") {\n        const hdConfigResult = HDAccountsConfig.decode(accounts);\n\n        if (hdConfigResult.isLeft()) {\n          errors.push(getErrorMessage(`HardhatConfig.networks.${networkName}`, accounts, \"HttpNetworkHDAccountsConfig\"));\n        }\n      } else if (typeof accounts === \"string\") {\n        if (accounts !== \"remote\") {\n          errors.push(`Invalid 'accounts' entry for network '${networkName}': expected an array of accounts or the string 'remote', but got the string '${accounts}'`);\n        }\n      } else if (accounts !== undefined) {\n        errors.push(getErrorMessage(`HardhatConfig.networks.${networkName}.accounts`, accounts, '\"remote\" | string[] | HttpNetworkHDAccountsConfig | undefined'));\n      }\n    }\n  } // io-ts can get confused if there are errors that it can't understand.\n  // Especially around Hardhat Network's config. It will treat it as an HTTPConfig,\n  // and may give a loot of errors.\n\n\n  if (errors.length > 0) {\n    return errors;\n  }\n\n  const result = HardhatConfig.decode(config);\n\n  if (result.isRight()) {\n    return errors;\n  }\n\n  const ioTsErrors = exports.DotPathReporter.report(result);\n  return [...errors, ...ioTsErrors];\n}\n\nexports.getValidationErrors = getValidationErrors;","map":{"version":3,"mappings":"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","names":["stringify","v","isFinite","isNaN","JSON","getContextPath","context","keysPath","slice","map","c","key","join","type","name","getMessage","e","lastContext","length","message","undefined","getErrorMessage","value","path","expectedType","getPrivateKeyError","index","network","validatePrivateKey","privateKey","errors","push","pkWithPrefix","test","exports","decode","isLeft","failure","es","success","report","validation","fold","HEX_STRING_REGEX","DEC_STRING_REGEX","isHexString","trim","match","isDecimalString","t","Type","u","identity","isAddress","trimmed","startsWith","HardhatNetworkAccount","balance","commonHDAccountsFields","initialIndex","number","count","string","HardhatNetworkHDAccountsConfig","mnemonic","accountsBalance","passphrase","Integer","num","parseInt","HardhatNetworkForkingConfig","enabled","boolean","url","blockNumber","HardhatNetworkMempoolConfig","order","keyof","constants_1","HardhatNetworkMiningConfig","auto","interval","union","tuple","mempool","isValidHardforkName","Object","values","hardforks_1","includes","HardforkNameType","HardhatNetworkHardforkHistory","record","HardhatNetworkChainConfig","hardforkHistory","HardhatNetworkChainsConfig","commonNetworkConfigFields","chainId","from","gas","literal","gasPrice","gasMultiplier","HardhatNetworkConfig","hardfork","hf","accounts","array","blockGasLimit","minGasPrice","throwOnTransactionFailures","throwOnCallFailures","allowUnlimitedContractSize","initialDate","loggingEnabled","forking","mining","coinbase","chains","HDAccountsConfig","NetworkConfigAccounts","HttpHeaders","HttpNetworkConfig","httpHeaders","timeout","NetworkConfig","Networks","ProjectPaths","root","cache","artifacts","sources","tests","SingleSolcConfig","version","settings","any","MultiSolcConfig","compilers","overrides","SolidityConfig","HardhatConfig","defaultNetwork","networks","paths","solidity","validateConfig","config","getValidationErrors","errorList","errors_1","errors_list_1","GENERAL","INVALID_CONFIG","hardhatNetwork","configExceptAccounts","netConfigResult","Array","isArray","account","entries","hdConfigResult","default_config_1","LONDON","initialBaseFeePerGas","forEach","chainEntry","chainConfig","keys","hardforkName","networkName","netConfig","result","isRight","ioTsErrors"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\hardhat\\src\\internal\\core\\config\\config-validation.ts"],"sourcesContent":["import * as t from \"io-ts\";\nimport { Context, getFunctionName, ValidationError } from \"io-ts/lib\";\nimport { Reporter } from \"io-ts/lib/Reporter\";\n\nimport {\n  HARDHAT_MEMPOOL_SUPPORTED_ORDERS,\n  HARDHAT_NETWORK_NAME,\n  HARDHAT_NETWORK_SUPPORTED_HARDFORKS,\n} from \"../../constants\";\nimport { optional } from \"../../util/io-ts\";\nimport { fromEntries } from \"../../util/lang\";\nimport { HardhatError } from \"../errors\";\nimport { ERRORS } from \"../errors-list\";\nimport { hardforkGte, HardforkName } from \"../../util/hardforks\";\nimport { HardhatNetworkChainUserConfig } from \"../../../types/config\";\nimport { defaultHardhatNetworkParams } from \"./default-config\";\n\nfunction stringify(v: any): string {\n  if (typeof v === \"function\") {\n    return getFunctionName(v);\n  }\n  if (typeof v === \"number\" && !isFinite(v)) {\n    if (isNaN(v)) {\n      return \"NaN\";\n    }\n    return v > 0 ? \"Infinity\" : \"-Infinity\";\n  }\n  return JSON.stringify(v);\n}\n\nfunction getContextPath(context: Context): string {\n  const keysPath = context\n    .slice(1)\n    .map((c) => c.key)\n    .join(\".\");\n\n  return `${context[0].type.name}.${keysPath}`;\n}\n\nfunction getMessage(e: ValidationError): string {\n  const lastContext = e.context[e.context.length - 1];\n\n  return e.message !== undefined\n    ? e.message\n    : getErrorMessage(\n        getContextPath(e.context),\n        e.value,\n        lastContext.type.name\n      );\n}\n\nfunction getErrorMessage(path: string, value: any, expectedType: string) {\n  return `Invalid value ${stringify(\n    value\n  )} for ${path} - Expected a value of type ${expectedType}.`;\n}\n\nfunction getPrivateKeyError(index: number, network: string, message: string) {\n  return `Invalid account: #${index} for network: ${network} - ${message}`;\n}\n\nfunction validatePrivateKey(\n  privateKey: unknown,\n  index: number,\n  network: string,\n  errors: string[]\n) {\n  if (typeof privateKey !== \"string\") {\n    errors.push(\n      getPrivateKeyError(\n        index,\n        network,\n        `Expected string, received ${typeof privateKey}`\n      )\n    );\n  } else {\n    // private key validation\n    const pkWithPrefix = /^0x/.test(privateKey)\n      ? privateKey\n      : `0x${privateKey}`;\n\n    // 32 bytes = 64 characters + 2 char prefix = 66\n    if (pkWithPrefix.length < 66) {\n      errors.push(\n        getPrivateKeyError(\n          index,\n          network,\n          \"private key too short, expected 32 bytes\"\n        )\n      );\n    } else if (pkWithPrefix.length > 66) {\n      errors.push(\n        getPrivateKeyError(\n          index,\n          network,\n          \"private key too long, expected 32 bytes\"\n        )\n      );\n    } else if (hexString.decode(pkWithPrefix).isLeft()) {\n      errors.push(\n        getPrivateKeyError(\n          index,\n          network,\n          \"invalid hex character(s) found in string\"\n        )\n      );\n    }\n  }\n}\n\nexport function failure(es: ValidationError[]): string[] {\n  return es.map(getMessage);\n}\n\nexport function success(): string[] {\n  return [];\n}\n\nexport const DotPathReporter: Reporter<string[]> = {\n  report: (validation) => validation.fold(failure, success),\n};\n\nconst HEX_STRING_REGEX = /^(0x)?([0-9a-f]{2})+$/gi;\nconst DEC_STRING_REGEX = /^(0|[1-9][0-9]*)$/g;\n\nfunction isHexString(v: unknown): v is string {\n  if (typeof v !== \"string\") {\n    return false;\n  }\n\n  return v.trim().match(HEX_STRING_REGEX) !== null;\n}\n\nfunction isDecimalString(v: unknown): v is string {\n  if (typeof v !== \"string\") {\n    return false;\n  }\n\n  return v.match(DEC_STRING_REGEX) !== null;\n}\n\nexport const hexString = new t.Type<string>(\n  \"hex string\",\n  isHexString,\n  (u, c) => (isHexString(u) ? t.success(u) : t.failure(u, c)),\n  t.identity\n);\n\nfunction isAddress(v: unknown): v is string {\n  if (typeof v !== \"string\") {\n    return false;\n  }\n\n  const trimmed = v.trim();\n\n  return (\n    trimmed.match(HEX_STRING_REGEX) !== null &&\n    trimmed.startsWith(\"0x\") &&\n    trimmed.length === 42\n  );\n}\n\nexport const address = new t.Type<string>(\n  \"address\",\n  isAddress,\n  (u, c) => (isAddress(u) ? t.success(u) : t.failure(u, c)),\n  t.identity\n);\n\nexport const decimalString = new t.Type<string>(\n  \"decimal string\",\n  isDecimalString,\n  (u, c) => (isDecimalString(u) ? t.success(u) : t.failure(u, c)),\n  t.identity\n);\n// TODO: These types have outdated name. They should match the UserConfig types.\n// IMPORTANT: This t.types MUST be kept in sync with the actual types.\n\nconst HardhatNetworkAccount = t.type({\n  privateKey: hexString,\n  balance: decimalString,\n});\n\nconst commonHDAccountsFields = {\n  initialIndex: optional(t.number),\n  count: optional(t.number),\n  path: optional(t.string),\n};\n\nconst HardhatNetworkHDAccountsConfig = t.type({\n  mnemonic: optional(t.string),\n  accountsBalance: optional(decimalString),\n  passphrase: optional(t.string),\n  ...commonHDAccountsFields,\n});\n\nconst Integer = new t.Type<number>(\n  \"Integer\",\n  (num: unknown): num is number => typeof num === \"number\",\n  (u, c) => {\n    try {\n      return typeof u === \"string\"\n        ? t.success(parseInt(u, 10))\n        : t.failure(u, c);\n    } catch {\n      return t.failure(u, c);\n    }\n  },\n  t.identity\n);\n\nconst HardhatNetworkForkingConfig = t.type({\n  enabled: optional(t.boolean),\n  url: t.string,\n  blockNumber: optional(t.number),\n});\n\nconst HardhatNetworkMempoolConfig = t.type({\n  order: optional(\n    t.keyof(\n      fromEntries(\n        HARDHAT_MEMPOOL_SUPPORTED_ORDERS.map((order) => [order, null])\n      )\n    )\n  ),\n});\n\nconst HardhatNetworkMiningConfig = t.type({\n  auto: optional(t.boolean),\n  interval: optional(t.union([t.number, t.tuple([t.number, t.number])])),\n  mempool: optional(HardhatNetworkMempoolConfig),\n});\n\nfunction isValidHardforkName(name: string) {\n  return Object.values(HardforkName).includes(name as HardforkName);\n}\n\nconst HardforkNameType = new t.Type<HardforkName>(\n  Object.values(HardforkName)\n    .map((v) => `\"${v}\"`)\n    .join(\" | \"),\n  (name: unknown): name is HardforkName =>\n    typeof name === \"string\" && isValidHardforkName(name),\n  (u, c) => {\n    return typeof u === \"string\" && isValidHardforkName(u)\n      ? t.success(u as HardforkName)\n      : t.failure(u, c);\n  },\n  t.identity\n);\n\nconst HardhatNetworkHardforkHistory = t.record(\n  HardforkNameType,\n  t.number,\n  \"HardhatNetworkHardforkHistory\"\n);\n\nconst HardhatNetworkChainConfig = t.type({\n  hardforkHistory: HardhatNetworkHardforkHistory,\n});\n\nconst HardhatNetworkChainsConfig = t.record(Integer, HardhatNetworkChainConfig);\n\nconst commonNetworkConfigFields = {\n  chainId: optional(t.number),\n  from: optional(t.string),\n  gas: optional(t.union([t.literal(\"auto\"), t.number])),\n  gasPrice: optional(t.union([t.literal(\"auto\"), t.number])),\n  gasMultiplier: optional(t.number),\n};\n\nconst HardhatNetworkConfig = t.type({\n  ...commonNetworkConfigFields,\n  hardfork: optional(\n    t.keyof(\n      fromEntries(HARDHAT_NETWORK_SUPPORTED_HARDFORKS.map((hf) => [hf, null]))\n    )\n  ),\n  accounts: optional(\n    t.union([t.array(HardhatNetworkAccount), HardhatNetworkHDAccountsConfig])\n  ),\n  blockGasLimit: optional(t.number),\n  minGasPrice: optional(t.union([t.number, t.string])),\n  throwOnTransactionFailures: optional(t.boolean),\n  throwOnCallFailures: optional(t.boolean),\n  allowUnlimitedContractSize: optional(t.boolean),\n  initialDate: optional(t.string),\n  loggingEnabled: optional(t.boolean),\n  forking: optional(HardhatNetworkForkingConfig),\n  mining: optional(HardhatNetworkMiningConfig),\n  coinbase: optional(address),\n  chains: optional(HardhatNetworkChainsConfig),\n});\n\nconst HDAccountsConfig = t.type({\n  mnemonic: t.string,\n  passphrase: optional(t.string),\n  ...commonHDAccountsFields,\n});\n\nconst NetworkConfigAccounts = t.union([\n  t.literal(\"remote\"),\n  t.array(hexString),\n  HDAccountsConfig,\n]);\n\nconst HttpHeaders = t.record(t.string, t.string, \"httpHeaders\");\n\nconst HttpNetworkConfig = t.type({\n  ...commonNetworkConfigFields,\n  url: optional(t.string),\n  accounts: optional(NetworkConfigAccounts),\n  httpHeaders: optional(HttpHeaders),\n  timeout: optional(t.number),\n});\n\nconst NetworkConfig = t.union([HardhatNetworkConfig, HttpNetworkConfig]);\n\nconst Networks = t.record(t.string, NetworkConfig);\n\nconst ProjectPaths = t.type({\n  root: optional(t.string),\n  cache: optional(t.string),\n  artifacts: optional(t.string),\n  sources: optional(t.string),\n  tests: optional(t.string),\n});\n\nconst SingleSolcConfig = t.type({\n  version: t.string,\n  settings: optional(t.any),\n});\n\nconst MultiSolcConfig = t.type({\n  compilers: t.array(SingleSolcConfig),\n  overrides: optional(t.record(t.string, SingleSolcConfig)),\n});\n\nconst SolidityConfig = t.union([t.string, SingleSolcConfig, MultiSolcConfig]);\n\nconst HardhatConfig = t.type(\n  {\n    defaultNetwork: optional(t.string),\n    networks: optional(Networks),\n    paths: optional(ProjectPaths),\n    solidity: optional(SolidityConfig),\n  },\n  \"HardhatConfig\"\n);\n\n/**\n * Validates the config, throwing a HardhatError if invalid.\n * @param config\n */\nexport function validateConfig(config: any) {\n  const errors = getValidationErrors(config);\n\n  if (errors.length === 0) {\n    return;\n  }\n\n  let errorList = errors.join(\"\\n  * \");\n  errorList = `  * ${errorList}`;\n\n  throw new HardhatError(ERRORS.GENERAL.INVALID_CONFIG, { errors: errorList });\n}\n\nexport function getValidationErrors(config: any): string[] {\n  const errors: string[] = [];\n\n  // These can't be validated with io-ts\n  if (config !== undefined && typeof config.networks === \"object\") {\n    const hardhatNetwork = config.networks[HARDHAT_NETWORK_NAME];\n    if (hardhatNetwork !== undefined && typeof hardhatNetwork === \"object\") {\n      if (\"url\" in hardhatNetwork) {\n        errors.push(\n          `HardhatConfig.networks.${HARDHAT_NETWORK_NAME} can't have an url`\n        );\n      }\n\n      // Validating the accounts with io-ts leads to very confusing errors messages\n      const { accounts, ...configExceptAccounts } = hardhatNetwork;\n\n      const netConfigResult = HardhatNetworkConfig.decode(configExceptAccounts);\n      if (netConfigResult.isLeft()) {\n        errors.push(\n          getErrorMessage(\n            `HardhatConfig.networks.${HARDHAT_NETWORK_NAME}`,\n            hardhatNetwork,\n            \"HardhatNetworkConfig\"\n          )\n        );\n      }\n\n      // manual validation of accounts\n      if (Array.isArray(accounts)) {\n        for (const [index, account] of accounts.entries()) {\n          if (typeof account !== \"object\") {\n            errors.push(\n              getPrivateKeyError(\n                index,\n                HARDHAT_NETWORK_NAME,\n                `Expected object, received ${typeof account}`\n              )\n            );\n            continue;\n          }\n\n          const { privateKey, balance } = account;\n\n          validatePrivateKey(privateKey, index, HARDHAT_NETWORK_NAME, errors);\n\n          if (typeof balance !== \"string\") {\n            errors.push(\n              getErrorMessage(\n                `HardhatConfig.networks.${HARDHAT_NETWORK_NAME}.accounts[].balance`,\n                balance,\n                \"string\"\n              )\n            );\n          } else if (decimalString.decode(balance).isLeft()) {\n            errors.push(\n              getErrorMessage(\n                `HardhatConfig.networks.${HARDHAT_NETWORK_NAME}.accounts[].balance`,\n                balance,\n                \"decimal(wei)\"\n              )\n            );\n          }\n        }\n      } else if (typeof hardhatNetwork.accounts === \"object\") {\n        const hdConfigResult = HardhatNetworkHDAccountsConfig.decode(\n          hardhatNetwork.accounts\n        );\n        if (hdConfigResult.isLeft()) {\n          errors.push(\n            getErrorMessage(\n              `HardhatConfig.networks.${HARDHAT_NETWORK_NAME}.accounts`,\n              hardhatNetwork.accounts,\n              \"[{privateKey: string, balance: string}] | HardhatNetworkHDAccountsConfig | undefined\"\n            )\n          );\n        }\n      } else if (hardhatNetwork.accounts !== undefined) {\n        errors.push(\n          getErrorMessage(\n            `HardhatConfig.networks.${HARDHAT_NETWORK_NAME}.accounts`,\n            hardhatNetwork.accounts,\n            \"[{privateKey: string, balance: string}] | HardhatNetworkHDAccountsConfig | undefined\"\n          )\n        );\n      }\n\n      const hardfork =\n        hardhatNetwork.hardfork ?? defaultHardhatNetworkParams.hardfork;\n      if (hardforkGte(hardfork, HardforkName.LONDON)) {\n        if (hardhatNetwork.minGasPrice !== undefined) {\n          errors.push(\n            `Unexpected config HardhatConfig.networks.${HARDHAT_NETWORK_NAME}.minGasPrice found - This field is not valid for networks with EIP-1559. Try an older hardfork or remove it.`\n          );\n        }\n      } else {\n        if (hardhatNetwork.initialBaseFeePerGas !== undefined) {\n          errors.push(\n            `Unexpected config HardhatConfig.networks.${HARDHAT_NETWORK_NAME}.initialBaseFeePerGas found - This field is only valid for networks with EIP-1559. Try a newer hardfork or remove it.`\n          );\n        }\n      }\n\n      if (hardhatNetwork.chains !== undefined) {\n        Object.entries(hardhatNetwork.chains).forEach((chainEntry) => {\n          const [chainId, chainConfig] = chainEntry as [\n            string,\n            HardhatNetworkChainUserConfig\n          ];\n          const { hardforkHistory } = chainConfig;\n          if (hardforkHistory !== undefined) {\n            Object.keys(hardforkHistory).forEach((hardforkName) => {\n              if (!HARDHAT_NETWORK_SUPPORTED_HARDFORKS.includes(hardforkName)) {\n                errors.push(\n                  getErrorMessage(\n                    `HardhatConfig.networks.${HARDHAT_NETWORK_NAME}.chains[${chainId}].hardforkHistory`,\n                    hardforkName,\n                    `\"${HARDHAT_NETWORK_SUPPORTED_HARDFORKS.join('\" | \"')}\"`\n                  )\n                );\n              }\n            });\n          }\n        });\n      }\n    }\n\n    for (const [networkName, netConfig] of Object.entries<any>(\n      config.networks\n    )) {\n      if (networkName === HARDHAT_NETWORK_NAME) {\n        continue;\n      }\n\n      if (networkName !== \"localhost\" || netConfig.url !== undefined) {\n        if (typeof netConfig.url !== \"string\") {\n          errors.push(\n            getErrorMessage(\n              `HardhatConfig.networks.${networkName}.url`,\n              netConfig.url,\n              \"string\"\n            )\n          );\n        }\n      }\n\n      const { accounts, ...configExceptAccounts } = netConfig;\n\n      const netConfigResult = HttpNetworkConfig.decode(configExceptAccounts);\n      if (netConfigResult.isLeft()) {\n        errors.push(\n          getErrorMessage(\n            `HardhatConfig.networks.${networkName}`,\n            netConfig,\n            \"HttpNetworkConfig\"\n          )\n        );\n      }\n\n      // manual validation of accounts\n      if (Array.isArray(accounts)) {\n        accounts.forEach((privateKey, index) =>\n          validatePrivateKey(privateKey, index, networkName, errors)\n        );\n      } else if (typeof accounts === \"object\") {\n        const hdConfigResult = HDAccountsConfig.decode(accounts);\n        if (hdConfigResult.isLeft()) {\n          errors.push(\n            getErrorMessage(\n              `HardhatConfig.networks.${networkName}`,\n              accounts,\n              \"HttpNetworkHDAccountsConfig\"\n            )\n          );\n        }\n      } else if (typeof accounts === \"string\") {\n        if (accounts !== \"remote\") {\n          errors.push(\n            `Invalid 'accounts' entry for network '${networkName}': expected an array of accounts or the string 'remote', but got the string '${accounts}'`\n          );\n        }\n      } else if (accounts !== undefined) {\n        errors.push(\n          getErrorMessage(\n            `HardhatConfig.networks.${networkName}.accounts`,\n            accounts,\n            '\"remote\" | string[] | HttpNetworkHDAccountsConfig | undefined'\n          )\n        );\n      }\n    }\n  }\n\n  // io-ts can get confused if there are errors that it can't understand.\n  // Especially around Hardhat Network's config. It will treat it as an HTTPConfig,\n  // and may give a loot of errors.\n  if (errors.length > 0) {\n    return errors;\n  }\n\n  const result = HardhatConfig.decode(config);\n\n  if (result.isRight()) {\n    return errors;\n  }\n\n  const ioTsErrors = DotPathReporter.report(result);\n  return [...errors, ...ioTsErrors];\n}\n"]},"metadata":{},"sourceType":"script"}