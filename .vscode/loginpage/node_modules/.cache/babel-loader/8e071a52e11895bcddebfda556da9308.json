{"ast":null,"code":"'use strict';\n/* global WebAssembly */\n\nconst assert = require('assert');\n\nconst net = require('net');\n\nconst util = require('./core/util');\n\nconst Request = require('./core/request');\n\nconst DispatcherBase = require('./dispatcher-base');\n\nconst {\n  RequestContentLengthMismatchError,\n  ResponseContentLengthMismatchError,\n  InvalidArgumentError,\n  RequestAbortedError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  SocketError,\n  InformationalError,\n  BodyTimeoutError,\n  HTTPParserError\n} = require('./core/errors');\n\nconst buildConnector = require('./core/connect');\n\nconst {\n  kUrl,\n  kReset,\n  kServerName,\n  kClient,\n  kBusy,\n  kParser,\n  kConnect,\n  kBlocking,\n  kResuming,\n  kRunning,\n  kPending,\n  kSize,\n  kWriting,\n  kQueue,\n  kConnected,\n  kConnecting,\n  kNeedDrain,\n  kNoRef,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kSocket,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kConnector,\n  kMaxRedirections,\n  kMaxRequests,\n  kCounter,\n  kClose,\n  kDestroy,\n  kDispatch,\n  kInterceptors\n} = require('./core/symbols');\n\nconst kClosedResolve = Symbol('kClosedResolve');\nconst channels = {};\n\ntry {\n  const diagnosticsChannel = require('diagnostics_channel');\n\n  channels.sendHeaders = diagnosticsChannel.channel('undici:client:sendHeaders');\n  channels.beforeConnect = diagnosticsChannel.channel('undici:client:beforeConnect');\n  channels.connectError = diagnosticsChannel.channel('undici:client:connectError');\n  channels.connected = diagnosticsChannel.channel('undici:client:connected');\n} catch {\n  channels.sendHeaders = {\n    hasSubscribers: false\n  };\n  channels.beforeConnect = {\n    hasSubscribers: false\n  };\n  channels.connectError = {\n    hasSubscribers: false\n  };\n  channels.connected = {\n    hasSubscribers: false\n  };\n}\n\nclass Client extends DispatcherBase {\n  constructor(url) {\n    let {\n      interceptors,\n      maxHeaderSize,\n      headersTimeout,\n      socketTimeout,\n      requestTimeout,\n      connectTimeout,\n      bodyTimeout,\n      idleTimeout,\n      keepAlive,\n      keepAliveTimeout,\n      maxKeepAliveTimeout,\n      keepAliveMaxTimeout,\n      keepAliveTimeoutThreshold,\n      socketPath,\n      pipelining,\n      tls,\n      strictContentLength,\n      maxCachedSessions,\n      maxRedirections,\n      connect,\n      maxRequestsPerClient\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n\n    if (keepAlive !== undefined) {\n      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead');\n    }\n\n    if (socketTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead');\n    }\n\n    if (requestTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead');\n    }\n\n    if (idleTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead');\n    }\n\n    if (maxKeepAliveTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead');\n    }\n\n    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n      throw new InvalidArgumentError('invalid maxHeaderSize');\n    }\n\n    if (socketPath != null && typeof socketPath !== 'string') {\n      throw new InvalidArgumentError('invalid socketPath');\n    }\n\n    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n      throw new InvalidArgumentError('invalid connectTimeout');\n    }\n\n    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeout');\n    }\n\n    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveMaxTimeout');\n    }\n\n    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold');\n    }\n\n    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero');\n    }\n\n    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero');\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object');\n    }\n\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number');\n    }\n\n    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number');\n    }\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({ ...tls,\n        maxCachedSessions,\n        socketPath,\n        timeout: connectTimeout,\n        ...connect\n      });\n    }\n\n    this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor({\n      maxRedirections\n    })];\n    this[kUrl] = util.parseOrigin(url);\n    this[kConnector] = connect;\n    this[kSocket] = null;\n    this[kPipelining] = pipelining != null ? pipelining : 1;\n    this[kMaxHeadersSize] = maxHeaderSize || 16384;\n    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;\n    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout;\n    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;\n    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];\n    this[kServerName] = null;\n    this[kResuming] = 0; // 0, idle, 1, scheduled, 2 resuming\n\n    this[kNeedDrain] = 0; // 0, idle, 1, scheduled, 2 resuming\n\n    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\\r\\n`;\n    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 30e3;\n    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 30e3;\n    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;\n    this[kMaxRedirections] = maxRedirections;\n    this[kMaxRequests] = maxRequestsPerClient;\n    this[kClosedResolve] = null; // kQueue is built up of 3 sections separated by\n    // the kRunningIdx and kPendingIdx indices.\n    // |   complete   |   running   |   pending   |\n    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n    // kRunningIdx points to the first running element.\n    // kPendingIdx points to the first pending element.\n    // This implements a fast queue with an amortized\n    // time of O(1).\n\n    this[kQueue] = [];\n    this[kRunningIdx] = 0;\n    this[kPendingIdx] = 0;\n  }\n\n  get pipelining() {\n    return this[kPipelining];\n  }\n\n  set pipelining(value) {\n    this[kPipelining] = value;\n    resume(this, true);\n  }\n\n  get [kPending]() {\n    return this[kQueue].length - this[kPendingIdx];\n  }\n\n  get [kRunning]() {\n    return this[kPendingIdx] - this[kRunningIdx];\n  }\n\n  get [kSize]() {\n    return this[kQueue].length - this[kRunningIdx];\n  }\n\n  get [kConnected]() {\n    return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;\n  }\n\n  get [kBusy]() {\n    const socket = this[kSocket];\n    return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;\n  }\n  /* istanbul ignore: only used for test */\n\n\n  [kConnect](cb) {\n    connect(this);\n    this.once('connect', cb);\n  }\n\n  [kDispatch](opts, handler) {\n    const origin = opts.origin || this[kUrl].origin;\n    const request = new Request(origin, opts, handler);\n    this[kQueue].push(request);\n\n    if (this[kResuming]) {// Do nothing.\n    } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n      // Wait a tick in case stream/iterator is ended in the same tick.\n      this[kResuming] = 1;\n      process.nextTick(resume, this);\n    } else {\n      resume(this, true);\n    }\n\n    if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n      this[kNeedDrain] = 2;\n    }\n\n    return this[kNeedDrain] < 2;\n  }\n\n  async [kClose]() {\n    return new Promise(resolve => {\n      if (!this[kSize]) {\n        this.destroy(resolve);\n      } else {\n        this[kClosedResolve] = resolve;\n      }\n    });\n  }\n\n  async [kDestroy](err) {\n    return new Promise(resolve => {\n      const requests = this[kQueue].splice(this[kPendingIdx]);\n\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i];\n        errorRequest(this, request, err);\n      }\n\n      const callback = () => {\n        if (this[kClosedResolve]) {\n          this[kClosedResolve]();\n          this[kClosedResolve] = null;\n        }\n\n        resolve();\n      };\n\n      if (!this[kSocket]) {\n        queueMicrotask(callback);\n      } else {\n        util.destroy(this[kSocket].on('close', callback), err);\n      }\n\n      resume(this);\n    });\n  }\n\n}\n\nconst constants = require('./llhttp/constants');\n\nconst createRedirectInterceptor = require('./interceptor/redirectInterceptor');\n\nconst EMPTY_BUF = Buffer.alloc(0);\n\nasync function lazyllhttp() {\n  const llhttpWasmData = process.env.JEST_WORKER_ID ? require('./llhttp/llhttp.wasm.js') : undefined;\n  let mod;\n\n  try {\n    mod = await WebAssembly.compile(Buffer.from(require('./llhttp/llhttp_simd.wasm.js'), 'base64'));\n  } catch (e) {\n    /* istanbul ignore next */\n    // We could check if the error was caused by the simd option not\n    // being enabled, but the occurring of this other error\n    // * https://github.com/emscripten-core/emscripten/issues/11495\n    // got me to remove that check to avoid breaking Node 12.\n    mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require('./llhttp/llhttp.wasm.js'), 'base64'));\n  }\n\n  return await WebAssembly.instantiate(mod, {\n    env: {\n      /* eslint-disable camelcase */\n      wasm_on_url: (p, at, len) => {\n        /* istanbul ignore next */\n        return 0;\n      },\n      wasm_on_status: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr;\n        const end = start + len;\n        return currentParser.onStatus(currentBufferRef.slice(start, end)) || 0;\n      },\n      wasm_on_message_begin: p => {\n        assert.strictEqual(currentParser.ptr, p);\n        return currentParser.onMessageBegin() || 0;\n      },\n      wasm_on_header_field: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr;\n        const end = start + len;\n        return currentParser.onHeaderField(currentBufferRef.slice(start, end)) || 0;\n      },\n      wasm_on_header_value: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr;\n        const end = start + len;\n        return currentParser.onHeaderValue(currentBufferRef.slice(start, end)) || 0;\n      },\n      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {\n        assert.strictEqual(currentParser.ptr, p);\n        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;\n      },\n      wasm_on_body: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr;\n        const end = start + len;\n        return currentParser.onBody(currentBufferRef.slice(start, end)) || 0;\n      },\n      wasm_on_message_complete: p => {\n        assert.strictEqual(currentParser.ptr, p);\n        return currentParser.onMessageComplete() || 0;\n      }\n      /* eslint-enable camelcase */\n\n    }\n  });\n}\n\nlet llhttpInstance = null;\nlet llhttpPromise = lazyllhttp().catch(() => {});\nlet currentParser = null;\nlet currentBufferRef = null;\nlet currentBufferSize = 0;\nlet currentBufferPtr = null;\nconst TIMEOUT_HEADERS = 1;\nconst TIMEOUT_BODY = 2;\nconst TIMEOUT_IDLE = 3;\n\nclass Parser {\n  constructor(client, socket, _ref) {\n    let {\n      exports\n    } = _ref;\n    assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);\n    this.llhttp = exports;\n    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);\n    this.client = client;\n    this.socket = socket;\n    this.timeout = null;\n    this.timeoutValue = null;\n    this.timeoutType = null;\n    this.statusCode = null;\n    this.statusText = '';\n    this.upgrade = false;\n    this.headers = [];\n    this.headersSize = 0;\n    this.headersMaxSize = client[kMaxHeadersSize];\n    this.shouldKeepAlive = false;\n    this.paused = false;\n    this.resume = this.resume.bind(this);\n    this.bytesRead = 0;\n    this.keepAlive = '';\n    this.contentLength = '';\n  }\n\n  setTimeout(value, type) {\n    this.timeoutType = type;\n\n    if (value !== this.timeoutValue) {\n      clearTimeout(this.timeout);\n\n      if (value) {\n        this.timeout = setTimeout(onParserTimeout, value, this); // istanbul ignore else: only for jest\n\n        if (this.timeout.unref) {\n          this.timeout.unref();\n        }\n      } else {\n        this.timeout = null;\n      }\n\n      this.timeoutValue = value;\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n  }\n\n  resume() {\n    if (this.socket.destroyed || !this.paused) {\n      return;\n    }\n\n    assert(this.ptr != null);\n    assert(currentParser == null);\n    this.llhttp.llhttp_resume(this.ptr);\n    assert(this.timeoutType === TIMEOUT_BODY);\n\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n\n    this.paused = false;\n    this.execute(this.socket.read() || EMPTY_BUF); // Flush parser.\n\n    this.readMore();\n  }\n\n  readMore() {\n    while (!this.paused && this.ptr) {\n      const chunk = this.socket.read();\n\n      if (chunk === null) {\n        break;\n      }\n\n      this.execute(chunk);\n    }\n  }\n\n  execute(data) {\n    assert(this.ptr != null);\n    assert(currentParser == null);\n    assert(!this.paused);\n    const {\n      socket,\n      llhttp\n    } = this;\n\n    if (data.length > currentBufferSize) {\n      if (currentBufferPtr) {\n        llhttp.free(currentBufferPtr);\n      }\n\n      currentBufferSize = Math.ceil(data.length / 4096) * 4096;\n      currentBufferPtr = llhttp.malloc(currentBufferSize);\n    }\n\n    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data); // Call `execute` on the wasm parser.\n    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n    // and finally the length of bytes to parse.\n    // The return value is an error code or `constants.ERROR.OK`.\n\n    try {\n      let ret;\n\n      try {\n        currentBufferRef = data;\n        currentParser = this;\n        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);\n        /* eslint-disable-next-line no-useless-catch */\n      } catch (err) {\n        /* istanbul ignore next: difficult to make a test case for */\n        throw err;\n      } finally {\n        currentParser = null;\n        currentBufferRef = null;\n      }\n\n      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;\n\n      if (ret === constants.ERROR.PAUSED_UPGRADE) {\n        this.onUpgrade(data.slice(offset));\n      } else if (ret === constants.ERROR.PAUSED) {\n        this.paused = true;\n        socket.unshift(data.slice(offset));\n      } else if (ret !== constants.ERROR.OK) {\n        const ptr = llhttp.llhttp_get_error_reason(this.ptr);\n        let message = '';\n        /* istanbul ignore else: difficult to make a test case for */\n\n        if (ptr) {\n          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);\n          message = Buffer.from(llhttp.memory.buffer, ptr, len).toString();\n        }\n\n        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));\n      }\n    } catch (err) {\n      util.destroy(socket, err);\n    }\n  }\n\n  finish() {\n    try {\n      try {\n        currentParser = this;\n      } finally {\n        currentParser = null;\n      }\n    } catch (err) {\n      /* istanbul ignore next: difficult to make a test case for */\n      util.destroy(this.socket, err);\n    }\n  }\n\n  destroy() {\n    assert(this.ptr != null);\n    assert(currentParser == null);\n    this.llhttp.llhttp_free(this.ptr);\n    this.ptr = null;\n    clearTimeout(this.timeout);\n    this.timeout = null;\n    this.timeoutValue = null;\n    this.timeoutType = null;\n    this.paused = false;\n  }\n\n  onStatus(buf) {\n    this.statusText = buf.toString();\n  }\n\n  onMessageBegin() {\n    const {\n      socket,\n      client\n    } = this;\n    /* istanbul ignore next: difficult to make a test case for */\n\n    if (socket.destroyed) {\n      return -1;\n    }\n\n    const request = client[kQueue][client[kRunningIdx]];\n\n    if (!request) {\n      return -1;\n    }\n  }\n\n  onHeaderField(buf) {\n    const len = this.headers.length;\n\n    if ((len & 1) === 0) {\n      this.headers.push(buf);\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);\n    }\n\n    this.trackHeader(buf.length);\n  }\n\n  onHeaderValue(buf) {\n    let len = this.headers.length;\n\n    if ((len & 1) === 1) {\n      this.headers.push(buf);\n      len += 1;\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);\n    }\n\n    const key = this.headers[len - 2];\n\n    if (key.length === 10 && key.toString().toLowerCase() === 'keep-alive') {\n      this.keepAlive += buf.toString();\n    } else if (key.length === 14 && key.toString().toLowerCase() === 'content-length') {\n      this.contentLength += buf.toString();\n    }\n\n    this.trackHeader(buf.length);\n  }\n\n  trackHeader(len) {\n    this.headersSize += len;\n\n    if (this.headersSize >= this.headersMaxSize) {\n      util.destroy(this.socket, new HeadersOverflowError());\n    }\n  }\n\n  onUpgrade(head) {\n    const {\n      upgrade,\n      client,\n      socket,\n      headers,\n      statusCode\n    } = this;\n    assert(upgrade);\n    const request = client[kQueue][client[kRunningIdx]];\n    assert(request);\n    assert(!socket.destroyed);\n    assert(socket === client[kSocket]);\n    assert(!this.paused);\n    assert(request.upgrade || request.method === 'CONNECT');\n    this.statusCode = null;\n    this.statusText = '';\n    this.shouldKeepAlive = null;\n    assert(this.headers.length % 2 === 0);\n    this.headers = [];\n    this.headersSize = 0;\n    socket.unshift(head);\n    socket[kParser].destroy();\n    socket[kParser] = null;\n    socket[kClient] = null;\n    socket[kError] = null;\n    socket.removeListener('error', onSocketError).removeListener('readable', onSocketReadable).removeListener('end', onSocketEnd).removeListener('close', onSocketClose);\n    client[kSocket] = null;\n    client[kQueue][client[kRunningIdx]++] = null;\n    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'));\n\n    try {\n      request.onUpgrade(statusCode, headers, socket);\n    } catch (err) {\n      util.destroy(socket, err);\n    }\n\n    resume(client);\n  }\n\n  onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {\n    const {\n      client,\n      socket,\n      headers,\n      statusText\n    } = this;\n    /* istanbul ignore next: difficult to make a test case for */\n\n    if (socket.destroyed) {\n      return -1;\n    }\n\n    const request = client[kQueue][client[kRunningIdx]];\n    /* istanbul ignore next: difficult to make a test case for */\n\n    if (!request) {\n      return -1;\n    }\n\n    assert(!this.upgrade);\n    assert(this.statusCode < 200);\n\n    if (statusCode === 100) {\n      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)));\n      return -1;\n    }\n    /* this can only happen if server is misbehaving */\n\n\n    if (upgrade && !request.upgrade) {\n      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)));\n      return -1;\n    }\n\n    assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);\n    this.statusCode = statusCode;\n    this.shouldKeepAlive = shouldKeepAlive;\n\n    if (this.statusCode >= 200) {\n      const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];\n      this.setTimeout(bodyTimeout, TIMEOUT_BODY);\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n\n    if (request.method === 'CONNECT') {\n      assert(client[kRunning] === 1);\n      this.upgrade = true;\n      return 2;\n    }\n\n    if (upgrade) {\n      assert(client[kRunning] === 1);\n      this.upgrade = true;\n      return 2;\n    }\n\n    assert(this.headers.length % 2 === 0);\n    this.headers = [];\n    this.headersSize = 0;\n\n    if (shouldKeepAlive && client[kPipelining]) {\n      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;\n\n      if (keepAliveTimeout != null) {\n        const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);\n\n        if (timeout <= 0) {\n          socket[kReset] = true;\n        } else {\n          client[kKeepAliveTimeoutValue] = timeout;\n        }\n      } else {\n        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];\n      }\n    } else {\n      // Stop more requests from being dispatched.\n      socket[kReset] = true;\n    }\n\n    let pause;\n\n    try {\n      pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;\n    } catch (err) {\n      util.destroy(socket, err);\n      return -1;\n    }\n\n    if (request.method === 'HEAD') {\n      assert(socket[kReset]);\n      return 1;\n    }\n\n    if (statusCode < 200) {\n      return 1;\n    }\n\n    if (socket[kBlocking]) {\n      socket[kBlocking] = false;\n      resume(client);\n    }\n\n    return pause ? constants.ERROR.PAUSED : 0;\n  }\n\n  onBody(buf) {\n    const {\n      client,\n      socket,\n      statusCode\n    } = this;\n\n    if (socket.destroyed) {\n      return -1;\n    }\n\n    const request = client[kQueue][client[kRunningIdx]];\n    assert(request);\n    assert.strictEqual(this.timeoutType, TIMEOUT_BODY);\n\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n\n    assert(statusCode >= 200);\n    this.bytesRead += buf.length;\n\n    try {\n      if (request.onData(buf) === false) {\n        return constants.ERROR.PAUSED;\n      }\n    } catch (err) {\n      util.destroy(socket, err);\n      return -1;\n    }\n  }\n\n  onMessageComplete() {\n    const {\n      client,\n      socket,\n      statusCode,\n      upgrade,\n      headers,\n      contentLength,\n      bytesRead,\n      shouldKeepAlive\n    } = this;\n\n    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n      return -1;\n    }\n\n    if (upgrade) {\n      return;\n    }\n\n    const request = client[kQueue][client[kRunningIdx]];\n    assert(request);\n    assert(statusCode >= 100);\n    this.statusCode = null;\n    this.statusText = '';\n    this.bytesRead = 0;\n    this.contentLength = '';\n    this.keepAlive = '';\n    assert(this.headers.length % 2 === 0);\n    this.headers = [];\n    this.headersSize = 0;\n\n    if (statusCode < 200) {\n      return;\n    }\n    /* istanbul ignore next: should be handled by llhttp? */\n\n\n    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n      util.destroy(socket, new ResponseContentLengthMismatchError());\n      return -1;\n    }\n\n    try {\n      request.onComplete(headers);\n    } catch (err) {\n      errorRequest(client, request, err);\n    }\n\n    client[kQueue][client[kRunningIdx]++] = null;\n\n    if (socket[kWriting]) {\n      assert.strictEqual(client[kRunning], 0); // Response completed before request.\n\n      util.destroy(socket, new InformationalError('reset'));\n      return constants.ERROR.PAUSED;\n    } else if (!shouldKeepAlive) {\n      util.destroy(socket, new InformationalError('reset'));\n      return constants.ERROR.PAUSED;\n    } else if (socket[kReset] && client[kRunning] === 0) {\n      // Destroy socket once all requests have completed.\n      // The request at the tail of the pipeline is the one\n      // that requested reset and no further requests should\n      // have been queued since then.\n      util.destroy(socket, new InformationalError('reset'));\n      return constants.ERROR.PAUSED;\n    } else if (client[kPipelining] === 1) {\n      // We must wait a full event loop cycle to reuse this socket to make sure\n      // that non-spec compliant servers are not closing the connection even if they\n      // said they won't.\n      setImmediate(resume, client);\n    } else {\n      resume(client);\n    }\n  }\n\n}\n\nfunction onParserTimeout(parser) {\n  const {\n    socket,\n    timeoutType,\n    client\n  } = parser;\n  /* istanbul ignore else */\n\n  if (timeoutType === TIMEOUT_HEADERS) {\n    if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n      assert(!parser.paused, 'cannot be paused while waiting for headers');\n      util.destroy(socket, new HeadersTimeoutError());\n    }\n  } else if (timeoutType === TIMEOUT_BODY) {\n    if (!parser.paused) {\n      util.destroy(socket, new BodyTimeoutError());\n    }\n  } else if (timeoutType === TIMEOUT_IDLE) {\n    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);\n    util.destroy(socket, new InformationalError('socket idle timeout'));\n  }\n}\n\nfunction onSocketReadable() {\n  const {\n    [kParser]: parser\n  } = this;\n  parser.readMore();\n}\n\nfunction onSocketError(err) {\n  const {\n    [kParser]: parser\n  } = this;\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID'); // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n  // to the user.\n\n  if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so for as a valid response.\n    parser.finish();\n    return;\n  }\n\n  this[kError] = err;\n  onError(this[kClient], err);\n}\n\nfunction onError(client, err) {\n  if (client[kRunning] === 0 && err.code !== 'UND_ERR_INFO' && err.code !== 'UND_ERR_SOCKET') {\n    // Error is not caused by running request and not a recoverable\n    // socket error.\n    assert(client[kPendingIdx] === client[kRunningIdx]);\n    const requests = client[kQueue].splice(client[kRunningIdx]);\n\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i];\n      errorRequest(client, request, err);\n    }\n\n    assert(client[kSize] === 0);\n  }\n}\n\nfunction onSocketEnd() {\n  const {\n    [kParser]: parser\n  } = this;\n\n  if (parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so far as a valid response.\n    parser.finish();\n    return;\n  }\n\n  util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)));\n}\n\nfunction onSocketClose() {\n  const {\n    [kClient]: client\n  } = this;\n  this[kParser].destroy();\n  this[kParser] = null;\n  const err = this[kError] || new SocketError('closed', util.getSocketInfo(this));\n  client[kSocket] = null;\n\n  if (client.destroyed) {\n    assert(client[kPending] === 0); // Fail entire queue.\n\n    const requests = client[kQueue].splice(client[kRunningIdx]);\n\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i];\n      errorRequest(client, request, err);\n    }\n  } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {\n    // Fail head of pipeline.\n    const request = client[kQueue][client[kRunningIdx]];\n    client[kQueue][client[kRunningIdx]++] = null;\n    errorRequest(client, request, err);\n  }\n\n  client[kPendingIdx] = client[kRunningIdx];\n  assert(client[kRunning] === 0);\n  client.emit('disconnect', client[kUrl], [client], err);\n  resume(client);\n}\n\nasync function connect(client) {\n  assert(!client[kConnecting]);\n  assert(!client[kSocket]);\n  let {\n    host,\n    hostname,\n    protocol,\n    port\n  } = client[kUrl]; // Resolve ipv6\n\n  if (hostname[0] === '[') {\n    const idx = hostname.indexOf(']');\n    assert(idx !== -1);\n    const ip = hostname.substr(1, idx - 1);\n    assert(net.isIP(ip));\n    hostname = ip;\n  }\n\n  client[kConnecting] = true;\n\n  if (channels.beforeConnect.hasSubscribers) {\n    channels.beforeConnect.publish({\n      connectParams: {\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName]\n      },\n      connector: client[kConnector]\n    });\n  }\n\n  try {\n    const socket = await new Promise((resolve, reject) => {\n      client[kConnector]({\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName]\n      }, (err, socket) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(socket);\n        }\n      });\n    });\n\n    if (!llhttpInstance) {\n      llhttpInstance = await llhttpPromise;\n      llhttpPromise = null;\n    }\n\n    client[kConnecting] = false;\n    assert(socket);\n    client[kSocket] = socket;\n    socket[kNoRef] = false;\n    socket[kWriting] = false;\n    socket[kReset] = false;\n    socket[kBlocking] = false;\n    socket[kError] = null;\n    socket[kParser] = new Parser(client, socket, llhttpInstance);\n    socket[kClient] = client;\n    socket[kCounter] = 0;\n    socket[kMaxRequests] = client[kMaxRequests];\n    socket.on('error', onSocketError).on('readable', onSocketReadable).on('end', onSocketEnd).on('close', onSocketClose);\n\n    if (channels.connected.hasSubscribers) {\n      channels.connected.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName]\n        },\n        connector: client[kConnector],\n        socket\n      });\n    }\n\n    client.emit('connect', client[kUrl], [client]);\n  } catch (err) {\n    client[kConnecting] = false;\n\n    if (channels.connectError.hasSubscribers) {\n      channels.connectError.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName]\n        },\n        connector: client[kConnector],\n        error: err\n      });\n    }\n\n    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n      assert(client[kRunning] === 0);\n\n      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {\n        const request = client[kQueue][client[kPendingIdx]++];\n        errorRequest(client, request, err);\n      }\n    } else {\n      onError(client, err);\n    }\n\n    client.emit('connectionError', client[kUrl], [client], err);\n  }\n\n  resume(client);\n}\n\nfunction emitDrain(client) {\n  client[kNeedDrain] = 0;\n  client.emit('drain', client[kUrl], [client]);\n}\n\nfunction resume(client, sync) {\n  if (client[kResuming] === 2) {\n    return;\n  }\n\n  client[kResuming] = 2;\n\n  _resume(client, sync);\n\n  client[kResuming] = 0;\n\n  if (client[kRunningIdx] > 256) {\n    client[kQueue].splice(0, client[kRunningIdx]);\n    client[kPendingIdx] -= client[kRunningIdx];\n    client[kRunningIdx] = 0;\n  }\n}\n\nfunction _resume(client, sync) {\n  while (true) {\n    if (client.destroyed) {\n      assert(client[kPending] === 0);\n      return;\n    }\n\n    if (client.closed && !client[kSize]) {\n      client.destroy();\n      return;\n    }\n\n    const socket = client[kSocket];\n\n    if (socket) {\n      if (client[kSize] === 0) {\n        if (!socket[kNoRef] && socket.unref) {\n          socket.unref();\n          socket[kNoRef] = true;\n        }\n      } else if (socket[kNoRef] && socket.ref) {\n        socket.ref();\n        socket[kNoRef] = false;\n      }\n\n      if (client[kSize] === 0) {\n        if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {\n          socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);\n        }\n      } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n        if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n          const request = client[kQueue][client[kRunningIdx]];\n          const headersTimeout = request.headersTimeout != null ? request.headersTimeout : client[kHeadersTimeout];\n          socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);\n        }\n      }\n    }\n\n    if (client[kBusy]) {\n      client[kNeedDrain] = 2;\n    } else if (client[kNeedDrain] === 2) {\n      if (sync) {\n        client[kNeedDrain] = 1;\n        process.nextTick(emitDrain, client);\n      } else {\n        emitDrain(client);\n      }\n\n      continue;\n    }\n\n    if (client[kPending] === 0) {\n      return;\n    }\n\n    if (client[kRunning] >= (client[kPipelining] || 1)) {\n      return;\n    }\n\n    const request = client[kQueue][client[kPendingIdx]];\n\n    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {\n      if (client[kRunning] > 0) {\n        return;\n      }\n\n      client[kServerName] = request.servername;\n\n      if (socket && socket.servername !== request.servername) {\n        util.destroy(socket, new InformationalError('servername changed'));\n        return;\n      }\n    }\n\n    if (client[kConnecting]) {\n      return;\n    }\n\n    if (!socket) {\n      connect(client);\n      continue;\n    }\n\n    if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n      return;\n    }\n\n    if (client[kRunning] > 0 && !request.idempotent) {\n      // Non-idempotent request cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return;\n    }\n\n    if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {\n      // Don't dispatch an upgrade until all preceding requests have completed.\n      // A misbehaving server might upgrade the connection before all pipelined\n      // request has completed.\n      return;\n    }\n\n    if (util.isStream(request.body) && util.bodyLength(request.body) === 0) {\n      request.body.on('data',\n      /* istanbul ignore next */\n      function () {\n        /* istanbul ignore next */\n        assert(false);\n      }).on('error', function (err) {\n        errorRequest(client, request, err);\n      }).on('end', function () {\n        util.destroy(this);\n      });\n      request.body = null;\n    }\n\n    if (client[kRunning] > 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body))) {\n      // Request with stream or iterator body can error while other requests\n      // are inflight and indirectly error those as well.\n      // Ensure this doesn't happen by waiting for inflight\n      // to complete before dispatching.\n      // Request with stream or iterator body cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return;\n    }\n\n    if (!request.aborted && write(client, request)) {\n      client[kPendingIdx]++;\n    } else {\n      client[kQueue].splice(client[kPendingIdx], 1);\n    }\n  }\n}\n\nfunction write(client, request) {\n  const {\n    body,\n    method,\n    path,\n    host,\n    upgrade,\n    headers,\n    blocking\n  } = request; // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = method === 'PUT' || method === 'POST' || method === 'PATCH';\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0);\n  }\n\n  let contentLength = util.bodyLength(body);\n\n  if (contentLength === null) {\n    contentLength = request.contentLength;\n  }\n\n  if (contentLength === 0 && !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n    contentLength = null;\n  }\n\n  if (request.contentLength !== null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      errorRequest(client, request, new RequestContentLengthMismatchError());\n      return false;\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError());\n  }\n\n  const socket = client[kSocket];\n\n  try {\n    request.onConnect(err => {\n      if (request.aborted || request.completed) {\n        return;\n      }\n\n      errorRequest(client, request, err || new RequestAbortedError());\n      util.destroy(socket, new InformationalError('aborted'));\n    });\n  } catch (err) {\n    errorRequest(client, request, err);\n  }\n\n  if (request.aborted) {\n    return false;\n  }\n\n  if (method === 'HEAD') {\n    // https://github.com/mcollina/undici/issues/258\n    // Close after a HEAD request to interop with misbehaving servers\n    // that may send a body in the response.\n    socket[kReset] = true;\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    // On CONNECT or upgrade, block pipeline from dispatching further\n    // requests on this connection.\n    socket[kReset] = true;\n  }\n\n  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n    socket[kReset] = true;\n  }\n\n  if (blocking) {\n    socket[kBlocking] = true;\n  }\n\n  let header = `${method} ${path} HTTP/1.1\\r\\n`;\n\n  if (typeof host === 'string') {\n    header += `host: ${host}\\r\\n`;\n  } else {\n    header += client[kHostHeader];\n  }\n\n  if (upgrade) {\n    header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`;\n  } else if (client[kPipelining]) {\n    header += 'connection: keep-alive\\r\\n';\n  } else {\n    header += 'connection: close\\r\\n';\n  }\n\n  if (headers) {\n    header += headers;\n  }\n\n  if (channels.sendHeaders.hasSubscribers) {\n    channels.sendHeaders.publish({\n      request,\n      headers: header,\n      socket\n    });\n  }\n  /* istanbul ignore else: assertion */\n\n\n  if (!body) {\n    if (contentLength === 0) {\n      socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'ascii');\n    } else {\n      assert(contentLength === null, 'no body must not have content length');\n      socket.write(`${header}\\r\\n`, 'ascii');\n    }\n\n    request.onRequestSent();\n  } else if (util.isBuffer(body)) {\n    assert(contentLength === body.byteLength, 'buffer body must have content length');\n    socket.cork();\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii');\n    socket.write(body);\n    socket.uncork();\n    request.onBodySent(body);\n    request.onRequestSent();\n\n    if (!expectsPayload) {\n      socket[kReset] = true;\n    }\n  } else if (util.isBlobLike(body)) {\n    if (typeof body.stream === 'function') {\n      writeIterable({\n        body: body.stream(),\n        client,\n        request,\n        socket,\n        contentLength,\n        header,\n        expectsPayload\n      });\n    } else {\n      writeBlob({\n        body,\n        client,\n        request,\n        socket,\n        contentLength,\n        header,\n        expectsPayload\n      });\n    }\n  } else if (util.isStream(body)) {\n    writeStream({\n      body,\n      client,\n      request,\n      socket,\n      contentLength,\n      header,\n      expectsPayload\n    });\n  } else if (util.isIterable(body)) {\n    writeIterable({\n      body,\n      client,\n      request,\n      socket,\n      contentLength,\n      header,\n      expectsPayload\n    });\n  } else {\n    assert(false);\n  }\n\n  return true;\n}\n\nfunction writeStream(_ref2) {\n  let {\n    body,\n    client,\n    request,\n    socket,\n    contentLength,\n    header,\n    expectsPayload\n  } = _ref2;\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined');\n  let finished = false;\n  const writer = new AsyncWriter({\n    socket,\n    request,\n    contentLength,\n    client,\n    expectsPayload,\n    header\n  });\n\n  const onData = function (chunk) {\n    try {\n      assert(!finished);\n\n      if (!writer.write(chunk) && this.pause) {\n        this.pause();\n      }\n    } catch (err) {\n      util.destroy(this, err);\n    }\n  };\n\n  const onDrain = function () {\n    assert(!finished);\n\n    if (body.resume) {\n      body.resume();\n    }\n  };\n\n  const onAbort = function () {\n    onFinished(new RequestAbortedError());\n  };\n\n  const onFinished = function (err) {\n    if (finished) {\n      return;\n    }\n\n    finished = true;\n    assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);\n    socket.off('drain', onDrain).off('error', onFinished);\n    body.removeListener('data', onData).removeListener('end', onFinished).removeListener('error', onFinished).removeListener('close', onAbort);\n\n    if (!err) {\n      try {\n        writer.end();\n      } catch (er) {\n        err = er;\n      }\n    }\n\n    writer.destroy(err);\n\n    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {\n      util.destroy(body, err);\n    } else {\n      util.destroy(body);\n    }\n  };\n\n  body.on('data', onData).on('end', onFinished).on('error', onFinished).on('close', onAbort);\n\n  if (body.resume) {\n    body.resume();\n  }\n\n  socket.on('drain', onDrain).on('error', onFinished);\n}\n\nasync function writeBlob(_ref3) {\n  let {\n    body,\n    client,\n    request,\n    socket,\n    contentLength,\n    header,\n    expectsPayload\n  } = _ref3;\n  assert(contentLength === body.size, 'blob body must have content length');\n\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError();\n    }\n\n    const buffer = Buffer.from(await body.arrayBuffer());\n    socket.cork();\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii');\n    socket.write(buffer);\n    socket.uncork();\n    request.onBodySent(buffer);\n    request.onRequestSent();\n\n    if (!expectsPayload) {\n      socket[kReset] = true;\n    }\n\n    resume(client);\n  } catch (err) {\n    util.destroy(socket, err);\n  }\n}\n\nasync function writeIterable(_ref4) {\n  let {\n    body,\n    client,\n    request,\n    socket,\n    contentLength,\n    header,\n    expectsPayload\n  } = _ref4;\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined');\n  let callback = null;\n\n  function onDrain() {\n    if (callback) {\n      const cb = callback;\n      callback = null;\n      cb();\n    }\n  }\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null);\n\n    if (socket[kError]) {\n      reject(socket[kError]);\n    } else {\n      callback = resolve;\n    }\n  });\n\n  socket.on('close', onDrain).on('drain', onDrain);\n  const writer = new AsyncWriter({\n    socket,\n    request,\n    contentLength,\n    client,\n    expectsPayload,\n    header\n  });\n\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError];\n      }\n\n      if (!writer.write(chunk)) {\n        await waitForDrain();\n      }\n    }\n\n    writer.end();\n  } catch (err) {\n    writer.destroy(err);\n  } finally {\n    socket.off('close', onDrain).off('drain', onDrain);\n  }\n}\n\nclass AsyncWriter {\n  constructor(_ref5) {\n    let {\n      socket,\n      request,\n      contentLength,\n      client,\n      expectsPayload,\n      header\n    } = _ref5;\n    this.socket = socket;\n    this.request = request;\n    this.contentLength = contentLength;\n    this.client = client;\n    this.bytesWritten = 0;\n    this.expectsPayload = expectsPayload;\n    this.header = header;\n    socket[kWriting] = true;\n  }\n\n  write(chunk) {\n    const {\n      socket,\n      request,\n      contentLength,\n      client,\n      bytesWritten,\n      expectsPayload,\n      header\n    } = this;\n\n    if (socket[kError]) {\n      throw socket[kError];\n    }\n\n    if (socket.destroyed) {\n      return false;\n    }\n\n    const len = Buffer.byteLength(chunk);\n\n    if (!len) {\n      return true;\n    } // We should defer writing chunks.\n\n\n    if (contentLength !== null && bytesWritten + len > contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError();\n      }\n\n      process.emitWarning(new RequestContentLengthMismatchError());\n    }\n\n    if (bytesWritten === 0) {\n      if (!expectsPayload) {\n        socket[kReset] = true;\n      }\n\n      if (contentLength === null) {\n        socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'ascii');\n      } else {\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii');\n      }\n    }\n\n    if (contentLength === null) {\n      socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'ascii');\n    }\n\n    this.bytesWritten += len;\n    const ret = socket.write(chunk);\n    request.onBodySent(chunk);\n\n    if (!ret) {\n      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n        // istanbul ignore else: only for jest\n        if (socket[kParser].timeout.refresh) {\n          socket[kParser].timeout.refresh();\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  end() {\n    const {\n      socket,\n      contentLength,\n      client,\n      bytesWritten,\n      expectsPayload,\n      header,\n      request\n    } = this;\n    request.onRequestSent();\n    socket[kWriting] = false;\n\n    if (socket[kError]) {\n      throw socket[kError];\n    }\n\n    if (socket.destroyed) {\n      return;\n    }\n\n    if (bytesWritten === 0) {\n      if (expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD send a Content-Length in a request message when\n        // no Transfer-Encoding is sent and the request method defines a meaning\n        // for an enclosed payload body.\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'ascii');\n      } else {\n        socket.write(`${header}\\r\\n`, 'ascii');\n      }\n    } else if (contentLength === null) {\n      socket.write('\\r\\n0\\r\\n\\r\\n', 'ascii');\n    }\n\n    if (contentLength !== null && bytesWritten !== contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError();\n      } else {\n        process.emitWarning(new RequestContentLengthMismatchError());\n      }\n    }\n\n    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n      // istanbul ignore else: only for jest\n      if (socket[kParser].timeout.refresh) {\n        socket[kParser].timeout.refresh();\n      }\n    }\n\n    resume(client);\n  }\n\n  destroy(err) {\n    const {\n      socket,\n      client\n    } = this;\n    socket[kWriting] = false;\n\n    if (err) {\n      assert(client[kRunning] <= 1, 'pipeline should only contain this request');\n      util.destroy(socket, err);\n    }\n  }\n\n}\n\nfunction errorRequest(client, request, err) {\n  try {\n    request.onError(err);\n    assert(request.aborted);\n  } catch (err) {\n    client.emit('error', err);\n  }\n}\n\nmodule.exports = Client;","map":{"version":3,"names":["assert","require","net","util","Request","DispatcherBase","RequestContentLengthMismatchError","ResponseContentLengthMismatchError","InvalidArgumentError","RequestAbortedError","HeadersTimeoutError","HeadersOverflowError","SocketError","InformationalError","BodyTimeoutError","HTTPParserError","buildConnector","kUrl","kReset","kServerName","kClient","kBusy","kParser","kConnect","kBlocking","kResuming","kRunning","kPending","kSize","kWriting","kQueue","kConnected","kConnecting","kNeedDrain","kNoRef","kKeepAliveDefaultTimeout","kHostHeader","kPendingIdx","kRunningIdx","kError","kPipelining","kSocket","kKeepAliveTimeoutValue","kMaxHeadersSize","kKeepAliveMaxTimeout","kKeepAliveTimeoutThreshold","kHeadersTimeout","kBodyTimeout","kStrictContentLength","kConnector","kMaxRedirections","kMaxRequests","kCounter","kClose","kDestroy","kDispatch","kInterceptors","kClosedResolve","Symbol","channels","diagnosticsChannel","sendHeaders","channel","beforeConnect","connectError","connected","hasSubscribers","Client","constructor","url","interceptors","maxHeaderSize","headersTimeout","socketTimeout","requestTimeout","connectTimeout","bodyTimeout","idleTimeout","keepAlive","keepAliveTimeout","maxKeepAliveTimeout","keepAliveMaxTimeout","keepAliveTimeoutThreshold","socketPath","pipelining","tls","strictContentLength","maxCachedSessions","maxRedirections","connect","maxRequestsPerClient","undefined","Number","isFinite","isInteger","timeout","Array","isArray","createRedirectInterceptor","parseOrigin","hostname","port","value","resume","length","destroyed","socket","cb","once","opts","handler","origin","request","push","bodyLength","body","isIterable","process","nextTick","Promise","resolve","destroy","err","requests","splice","i","errorRequest","callback","queueMicrotask","on","constants","EMPTY_BUF","Buffer","alloc","lazyllhttp","llhttpWasmData","env","JEST_WORKER_ID","mod","WebAssembly","compile","from","e","instantiate","wasm_on_url","p","at","len","wasm_on_status","strictEqual","currentParser","ptr","start","currentBufferPtr","end","onStatus","currentBufferRef","slice","wasm_on_message_begin","onMessageBegin","wasm_on_header_field","onHeaderField","wasm_on_header_value","onHeaderValue","wasm_on_headers_complete","statusCode","upgrade","shouldKeepAlive","onHeadersComplete","Boolean","wasm_on_body","onBody","wasm_on_message_complete","onMessageComplete","llhttpInstance","llhttpPromise","catch","currentBufferSize","TIMEOUT_HEADERS","TIMEOUT_BODY","TIMEOUT_IDLE","Parser","client","exports","llhttp","llhttp_alloc","TYPE","RESPONSE","timeoutValue","timeoutType","statusText","headers","headersSize","headersMaxSize","paused","bind","bytesRead","contentLength","setTimeout","type","clearTimeout","onParserTimeout","unref","refresh","llhttp_resume","execute","read","readMore","chunk","data","free","Math","ceil","malloc","Uint8Array","memory","buffer","set","ret","llhttp_execute","offset","llhttp_get_error_pos","ERROR","PAUSED_UPGRADE","onUpgrade","PAUSED","unshift","OK","llhttp_get_error_reason","message","indexOf","toString","finish","llhttp_free","buf","concat","trackHeader","key","toLowerCase","head","method","removeListener","onSocketError","onSocketReadable","onSocketEnd","onSocketClose","emit","getSocketInfo","parseKeepAliveTimeout","min","pause","onHeaders","onData","parseInt","onComplete","setImmediate","parser","writableNeedDrain","code","onError","host","protocol","idx","ip","substr","isIP","publish","connectParams","servername","connector","reject","error","emitDrain","sync","_resume","closed","ref","idempotent","isStream","isAsyncIterable","aborted","write","path","blocking","expectsPayload","emitWarning","onConnect","completed","header","onRequestSent","isBuffer","byteLength","cork","uncork","onBodySent","isBlobLike","stream","writeIterable","writeBlob","writeStream","finished","writer","AsyncWriter","onDrain","onAbort","onFinished","off","er","size","arrayBuffer","waitForDrain","bytesWritten","module"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/undici/lib/client.js"],"sourcesContent":["'use strict'\n\n/* global WebAssembly */\n\nconst assert = require('assert')\nconst net = require('net')\nconst util = require('./core/util')\nconst Request = require('./core/request')\nconst DispatcherBase = require('./dispatcher-base')\nconst {\n  RequestContentLengthMismatchError,\n  ResponseContentLengthMismatchError,\n  InvalidArgumentError,\n  RequestAbortedError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  SocketError,\n  InformationalError,\n  BodyTimeoutError,\n  HTTPParserError\n} = require('./core/errors')\nconst buildConnector = require('./core/connect')\nconst {\n  kUrl,\n  kReset,\n  kServerName,\n  kClient,\n  kBusy,\n  kParser,\n  kConnect,\n  kBlocking,\n  kResuming,\n  kRunning,\n  kPending,\n  kSize,\n  kWriting,\n  kQueue,\n  kConnected,\n  kConnecting,\n  kNeedDrain,\n  kNoRef,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kSocket,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kConnector,\n  kMaxRedirections,\n  kMaxRequests,\n  kCounter,\n  kClose,\n  kDestroy,\n  kDispatch,\n  kInterceptors\n} = require('./core/symbols')\n\nconst kClosedResolve = Symbol('kClosedResolve')\n\nconst channels = {}\n\ntry {\n  const diagnosticsChannel = require('diagnostics_channel')\n  channels.sendHeaders = diagnosticsChannel.channel('undici:client:sendHeaders')\n  channels.beforeConnect = diagnosticsChannel.channel('undici:client:beforeConnect')\n  channels.connectError = diagnosticsChannel.channel('undici:client:connectError')\n  channels.connected = diagnosticsChannel.channel('undici:client:connected')\n} catch {\n  channels.sendHeaders = { hasSubscribers: false }\n  channels.beforeConnect = { hasSubscribers: false }\n  channels.connectError = { hasSubscribers: false }\n  channels.connected = { hasSubscribers: false }\n}\n\nclass Client extends DispatcherBase {\n  constructor (url, {\n    interceptors,\n    maxHeaderSize,\n    headersTimeout,\n    socketTimeout,\n    requestTimeout,\n    connectTimeout,\n    bodyTimeout,\n    idleTimeout,\n    keepAlive,\n    keepAliveTimeout,\n    maxKeepAliveTimeout,\n    keepAliveMaxTimeout,\n    keepAliveTimeoutThreshold,\n    socketPath,\n    pipelining,\n    tls,\n    strictContentLength,\n    maxCachedSessions,\n    maxRedirections,\n    connect,\n    maxRequestsPerClient\n  } = {}) {\n    super()\n\n    if (keepAlive !== undefined) {\n      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead')\n    }\n\n    if (socketTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (requestTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (idleTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead')\n    }\n\n    if (maxKeepAliveTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead')\n    }\n\n    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n      throw new InvalidArgumentError('invalid maxHeaderSize')\n    }\n\n    if (socketPath != null && typeof socketPath !== 'string') {\n      throw new InvalidArgumentError('invalid socketPath')\n    }\n\n    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n      throw new InvalidArgumentError('invalid connectTimeout')\n    }\n\n    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeout')\n    }\n\n    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveMaxTimeout')\n    }\n\n    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold')\n    }\n\n    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero')\n    }\n\n    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number')\n    }\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        socketPath,\n        timeout: connectTimeout,\n        ...connect\n      })\n    }\n\n    this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client)\n      ? interceptors.Client\n      : [createRedirectInterceptor({ maxRedirections })]\n    this[kUrl] = util.parseOrigin(url)\n    this[kConnector] = connect\n    this[kSocket] = null\n    this[kPipelining] = pipelining != null ? pipelining : 1\n    this[kMaxHeadersSize] = maxHeaderSize || 16384\n    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout\n    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout\n    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold\n    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout]\n    this[kServerName] = null\n    this[kResuming] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kNeedDrain] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\\r\\n`\n    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 30e3\n    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 30e3\n    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength\n    this[kMaxRedirections] = maxRedirections\n    this[kMaxRequests] = maxRequestsPerClient\n    this[kClosedResolve] = null\n\n    // kQueue is built up of 3 sections separated by\n    // the kRunningIdx and kPendingIdx indices.\n    // |   complete   |   running   |   pending   |\n    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n    // kRunningIdx points to the first running element.\n    // kPendingIdx points to the first pending element.\n    // This implements a fast queue with an amortized\n    // time of O(1).\n\n    this[kQueue] = []\n    this[kRunningIdx] = 0\n    this[kPendingIdx] = 0\n  }\n\n  get pipelining () {\n    return this[kPipelining]\n  }\n\n  set pipelining (value) {\n    this[kPipelining] = value\n    resume(this, true)\n  }\n\n  get [kPending] () {\n    return this[kQueue].length - this[kPendingIdx]\n  }\n\n  get [kRunning] () {\n    return this[kPendingIdx] - this[kRunningIdx]\n  }\n\n  get [kSize] () {\n    return this[kQueue].length - this[kRunningIdx]\n  }\n\n  get [kConnected] () {\n    return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed\n  }\n\n  get [kBusy] () {\n    const socket = this[kSocket]\n    return (\n      (socket && (socket[kReset] || socket[kWriting] || socket[kBlocking])) ||\n      (this[kSize] >= (this[kPipelining] || 1)) ||\n      this[kPending] > 0\n    )\n  }\n\n  /* istanbul ignore: only used for test */\n  [kConnect] (cb) {\n    connect(this)\n    this.once('connect', cb)\n  }\n\n  [kDispatch] (opts, handler) {\n    const origin = opts.origin || this[kUrl].origin\n\n    const request = new Request(origin, opts, handler)\n\n    this[kQueue].push(request)\n    if (this[kResuming]) {\n      // Do nothing.\n    } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n      // Wait a tick in case stream/iterator is ended in the same tick.\n      this[kResuming] = 1\n      process.nextTick(resume, this)\n    } else {\n      resume(this, true)\n    }\n\n    if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n      this[kNeedDrain] = 2\n    }\n\n    return this[kNeedDrain] < 2\n  }\n\n  async [kClose] () {\n    return new Promise((resolve) => {\n      if (!this[kSize]) {\n        this.destroy(resolve)\n      } else {\n        this[kClosedResolve] = resolve\n      }\n    })\n  }\n\n  async [kDestroy] (err) {\n    return new Promise((resolve) => {\n      const requests = this[kQueue].splice(this[kPendingIdx])\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i]\n        errorRequest(this, request, err)\n      }\n\n      const callback = () => {\n        if (this[kClosedResolve]) {\n          this[kClosedResolve]()\n          this[kClosedResolve] = null\n        }\n        resolve()\n      }\n\n      if (!this[kSocket]) {\n        queueMicrotask(callback)\n      } else {\n        util.destroy(this[kSocket].on('close', callback), err)\n      }\n\n      resume(this)\n    })\n  }\n}\n\nconst constants = require('./llhttp/constants')\nconst createRedirectInterceptor = require('./interceptor/redirectInterceptor')\nconst EMPTY_BUF = Buffer.alloc(0)\n\nasync function lazyllhttp () {\n  const llhttpWasmData = process.env.JEST_WORKER_ID ? require('./llhttp/llhttp.wasm.js') : undefined\n\n  let mod\n  try {\n    mod = await WebAssembly.compile(Buffer.from(require('./llhttp/llhttp_simd.wasm.js'), 'base64'))\n  } catch (e) {\n    /* istanbul ignore next */\n\n    // We could check if the error was caused by the simd option not\n    // being enabled, but the occurring of this other error\n    // * https://github.com/emscripten-core/emscripten/issues/11495\n    // got me to remove that check to avoid breaking Node 12.\n    mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require('./llhttp/llhttp.wasm.js'), 'base64'))\n  }\n\n  return await WebAssembly.instantiate(mod, {\n    env: {\n      /* eslint-disable camelcase */\n\n      wasm_on_url: (p, at, len) => {\n        /* istanbul ignore next */\n        return 0\n      },\n      wasm_on_status: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr\n        const end = start + len\n        return currentParser.onStatus(currentBufferRef.slice(start, end)) || 0\n      },\n      wasm_on_message_begin: (p) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onMessageBegin() || 0\n      },\n      wasm_on_header_field: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr\n        const end = start + len\n        return currentParser.onHeaderField(currentBufferRef.slice(start, end)) || 0\n      },\n      wasm_on_header_value: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr\n        const end = start + len\n        return currentParser.onHeaderValue(currentBufferRef.slice(start, end)) || 0\n      },\n      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0\n      },\n      wasm_on_body: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr\n        const end = start + len\n        return currentParser.onBody(currentBufferRef.slice(start, end)) || 0\n      },\n      wasm_on_message_complete: (p) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onMessageComplete() || 0\n      }\n\n      /* eslint-enable camelcase */\n    }\n  })\n}\n\nlet llhttpInstance = null\nlet llhttpPromise = lazyllhttp()\n  .catch(() => {\n  })\n\nlet currentParser = null\nlet currentBufferRef = null\nlet currentBufferSize = 0\nlet currentBufferPtr = null\n\nconst TIMEOUT_HEADERS = 1\nconst TIMEOUT_BODY = 2\nconst TIMEOUT_IDLE = 3\n\nclass Parser {\n  constructor (client, socket, { exports }) {\n    assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0)\n\n    this.llhttp = exports\n    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE)\n    this.client = client\n    this.socket = socket\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n    this.statusCode = null\n    this.statusText = ''\n    this.upgrade = false\n    this.headers = []\n    this.headersSize = 0\n    this.headersMaxSize = client[kMaxHeadersSize]\n    this.shouldKeepAlive = false\n    this.paused = false\n    this.resume = this.resume.bind(this)\n\n    this.bytesRead = 0\n\n    this.keepAlive = ''\n    this.contentLength = ''\n  }\n\n  setTimeout (value, type) {\n    this.timeoutType = type\n    if (value !== this.timeoutValue) {\n      clearTimeout(this.timeout)\n      if (value) {\n        this.timeout = setTimeout(onParserTimeout, value, this)\n        // istanbul ignore else: only for jest\n        if (this.timeout.unref) {\n          this.timeout.unref()\n        }\n      } else {\n        this.timeout = null\n      }\n      this.timeoutValue = value\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n  }\n\n  resume () {\n    if (this.socket.destroyed || !this.paused) {\n      return\n    }\n\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_resume(this.ptr)\n\n    assert(this.timeoutType === TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    this.paused = false\n    this.execute(this.socket.read() || EMPTY_BUF) // Flush parser.\n    this.readMore()\n  }\n\n  readMore () {\n    while (!this.paused && this.ptr) {\n      const chunk = this.socket.read()\n      if (chunk === null) {\n        break\n      }\n      this.execute(chunk)\n    }\n  }\n\n  execute (data) {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n    assert(!this.paused)\n\n    const { socket, llhttp } = this\n\n    if (data.length > currentBufferSize) {\n      if (currentBufferPtr) {\n        llhttp.free(currentBufferPtr)\n      }\n      currentBufferSize = Math.ceil(data.length / 4096) * 4096\n      currentBufferPtr = llhttp.malloc(currentBufferSize)\n    }\n\n    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data)\n\n    // Call `execute` on the wasm parser.\n    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n    // and finally the length of bytes to parse.\n    // The return value is an error code or `constants.ERROR.OK`.\n    try {\n      let ret\n\n      try {\n        currentBufferRef = data\n        currentParser = this\n        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length)\n        /* eslint-disable-next-line no-useless-catch */\n      } catch (err) {\n        /* istanbul ignore next: difficult to make a test case for */\n        throw err\n      } finally {\n        currentParser = null\n        currentBufferRef = null\n      }\n\n      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr\n\n      if (ret === constants.ERROR.PAUSED_UPGRADE) {\n        this.onUpgrade(data.slice(offset))\n      } else if (ret === constants.ERROR.PAUSED) {\n        this.paused = true\n        socket.unshift(data.slice(offset))\n      } else if (ret !== constants.ERROR.OK) {\n        const ptr = llhttp.llhttp_get_error_reason(this.ptr)\n        let message = ''\n        /* istanbul ignore else: difficult to make a test case for */\n        if (ptr) {\n          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0)\n          message = Buffer.from(llhttp.memory.buffer, ptr, len).toString()\n        }\n        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset))\n      }\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n  }\n\n  finish () {\n    try {\n      try {\n        currentParser = this\n      } finally {\n        currentParser = null\n      }\n    } catch (err) {\n      /* istanbul ignore next: difficult to make a test case for */\n      util.destroy(this.socket, err)\n    }\n  }\n\n  destroy () {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_free(this.ptr)\n    this.ptr = null\n\n    clearTimeout(this.timeout)\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n\n    this.paused = false\n  }\n\n  onStatus (buf) {\n    this.statusText = buf.toString()\n  }\n\n  onMessageBegin () {\n    const { socket, client } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    if (!request) {\n      return -1\n    }\n  }\n\n  onHeaderField (buf) {\n    const len = this.headers.length\n\n    if ((len & 1) === 0) {\n      this.headers.push(buf)\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  onHeaderValue (buf) {\n    let len = this.headers.length\n\n    if ((len & 1) === 1) {\n      this.headers.push(buf)\n      len += 1\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    const key = this.headers[len - 2]\n    if (key.length === 10 && key.toString().toLowerCase() === 'keep-alive') {\n      this.keepAlive += buf.toString()\n    } else if (key.length === 14 && key.toString().toLowerCase() === 'content-length') {\n      this.contentLength += buf.toString()\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  trackHeader (len) {\n    this.headersSize += len\n    if (this.headersSize >= this.headersMaxSize) {\n      util.destroy(this.socket, new HeadersOverflowError())\n    }\n  }\n\n  onUpgrade (head) {\n    const { upgrade, client, socket, headers, statusCode } = this\n\n    assert(upgrade)\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(!socket.destroyed)\n    assert(socket === client[kSocket])\n    assert(!this.paused)\n    assert(request.upgrade || request.method === 'CONNECT')\n\n    this.statusCode = null\n    this.statusText = ''\n    this.shouldKeepAlive = null\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    socket.unshift(head)\n\n    socket[kParser].destroy()\n    socket[kParser] = null\n\n    socket[kClient] = null\n    socket[kError] = null\n    socket\n      .removeListener('error', onSocketError)\n      .removeListener('readable', onSocketReadable)\n      .removeListener('end', onSocketEnd)\n      .removeListener('close', onSocketClose)\n\n    client[kSocket] = null\n    client[kQueue][client[kRunningIdx]++] = null\n    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'))\n\n    try {\n      request.onUpgrade(statusCode, headers, socket)\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n\n    resume(client)\n  }\n\n  onHeadersComplete (statusCode, upgrade, shouldKeepAlive) {\n    const { client, socket, headers, statusText } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (!request) {\n      return -1\n    }\n\n    assert(!this.upgrade)\n    assert(this.statusCode < 200)\n\n    if (statusCode === 100) {\n      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    /* this can only happen if server is misbehaving */\n    if (upgrade && !request.upgrade) {\n      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS)\n\n    this.statusCode = statusCode\n    this.shouldKeepAlive = shouldKeepAlive\n\n    if (this.statusCode >= 200) {\n      const bodyTimeout = request.bodyTimeout != null\n        ? request.bodyTimeout\n        : client[kBodyTimeout]\n      this.setTimeout(bodyTimeout, TIMEOUT_BODY)\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    if (request.method === 'CONNECT') {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    if (upgrade) {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (shouldKeepAlive && client[kPipelining]) {\n      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null\n\n      if (keepAliveTimeout != null) {\n        const timeout = Math.min(\n          keepAliveTimeout - client[kKeepAliveTimeoutThreshold],\n          client[kKeepAliveMaxTimeout]\n        )\n        if (timeout <= 0) {\n          socket[kReset] = true\n        } else {\n          client[kKeepAliveTimeoutValue] = timeout\n        }\n      } else {\n        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout]\n      }\n    } else {\n      // Stop more requests from being dispatched.\n      socket[kReset] = true\n    }\n\n    let pause\n    try {\n      pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false\n    } catch (err) {\n      util.destroy(socket, err)\n      return -1\n    }\n\n    if (request.method === 'HEAD') {\n      assert(socket[kReset])\n      return 1\n    }\n\n    if (statusCode < 200) {\n      return 1\n    }\n\n    if (socket[kBlocking]) {\n      socket[kBlocking] = false\n      resume(client)\n    }\n\n    return pause ? constants.ERROR.PAUSED : 0\n  }\n\n  onBody (buf) {\n    const { client, socket, statusCode } = this\n\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert.strictEqual(this.timeoutType, TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    assert(statusCode >= 200)\n\n    this.bytesRead += buf.length\n\n    try {\n      if (request.onData(buf) === false) {\n        return constants.ERROR.PAUSED\n      }\n    } catch (err) {\n      util.destroy(socket, err)\n      return -1\n    }\n  }\n\n  onMessageComplete () {\n    const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this\n\n    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n      return -1\n    }\n\n    if (upgrade) {\n      return\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(statusCode >= 100)\n\n    this.statusCode = null\n    this.statusText = ''\n    this.bytesRead = 0\n    this.contentLength = ''\n    this.keepAlive = ''\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (statusCode < 200) {\n      return\n    }\n\n    /* istanbul ignore next: should be handled by llhttp? */\n    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n      util.destroy(socket, new ResponseContentLengthMismatchError())\n      return -1\n    }\n\n    try {\n      request.onComplete(headers)\n    } catch (err) {\n      errorRequest(client, request, err)\n    }\n\n    client[kQueue][client[kRunningIdx]++] = null\n\n    if (socket[kWriting]) {\n      assert.strictEqual(client[kRunning], 0)\n      // Response completed before request.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (!shouldKeepAlive) {\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (socket[kReset] && client[kRunning] === 0) {\n      // Destroy socket once all requests have completed.\n      // The request at the tail of the pipeline is the one\n      // that requested reset and no further requests should\n      // have been queued since then.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (client[kPipelining] === 1) {\n      // We must wait a full event loop cycle to reuse this socket to make sure\n      // that non-spec compliant servers are not closing the connection even if they\n      // said they won't.\n      setImmediate(resume, client)\n    } else {\n      resume(client)\n    }\n  }\n}\n\nfunction onParserTimeout (parser) {\n  const { socket, timeoutType, client } = parser\n\n  /* istanbul ignore else */\n  if (timeoutType === TIMEOUT_HEADERS) {\n    if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n      assert(!parser.paused, 'cannot be paused while waiting for headers')\n      util.destroy(socket, new HeadersTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_BODY) {\n    if (!parser.paused) {\n      util.destroy(socket, new BodyTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_IDLE) {\n    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue])\n    util.destroy(socket, new InformationalError('socket idle timeout'))\n  }\n}\n\nfunction onSocketReadable () {\n  const { [kParser]: parser } = this\n  parser.readMore()\n}\n\nfunction onSocketError (err) {\n  const { [kParser]: parser } = this\n\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n  // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n  // to the user.\n  if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so for as a valid response.\n    parser.finish()\n    return\n  }\n\n  this[kError] = err\n\n  onError(this[kClient], err)\n}\n\nfunction onError (client, err) {\n  if (\n    client[kRunning] === 0 &&\n    err.code !== 'UND_ERR_INFO' &&\n    err.code !== 'UND_ERR_SOCKET'\n  ) {\n    // Error is not caused by running request and not a recoverable\n    // socket error.\n\n    assert(client[kPendingIdx] === client[kRunningIdx])\n\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      errorRequest(client, request, err)\n    }\n    assert(client[kSize] === 0)\n  }\n}\n\nfunction onSocketEnd () {\n  const { [kParser]: parser } = this\n\n  if (parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so far as a valid response.\n    parser.finish()\n    return\n  }\n\n  util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)))\n}\n\nfunction onSocketClose () {\n  const { [kClient]: client } = this\n\n  this[kParser].destroy()\n  this[kParser] = null\n\n  const err = this[kError] || new SocketError('closed', util.getSocketInfo(this))\n\n  client[kSocket] = null\n\n  if (client.destroyed) {\n    assert(client[kPending] === 0)\n\n    // Fail entire queue.\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      errorRequest(client, request, err)\n    }\n  } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {\n    // Fail head of pipeline.\n    const request = client[kQueue][client[kRunningIdx]]\n    client[kQueue][client[kRunningIdx]++] = null\n\n    errorRequest(client, request, err)\n  }\n\n  client[kPendingIdx] = client[kRunningIdx]\n\n  assert(client[kRunning] === 0)\n\n  client.emit('disconnect', client[kUrl], [client], err)\n\n  resume(client)\n}\n\nasync function connect (client) {\n  assert(!client[kConnecting])\n  assert(!client[kSocket])\n\n  let { host, hostname, protocol, port } = client[kUrl]\n\n  // Resolve ipv6\n  if (hostname[0] === '[') {\n    const idx = hostname.indexOf(']')\n\n    assert(idx !== -1)\n    const ip = hostname.substr(1, idx - 1)\n\n    assert(net.isIP(ip))\n    hostname = ip\n  }\n\n  client[kConnecting] = true\n\n  if (channels.beforeConnect.hasSubscribers) {\n    channels.beforeConnect.publish({\n      connectParams: {\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName]\n      },\n      connector: client[kConnector]\n    })\n  }\n\n  try {\n    const socket = await new Promise((resolve, reject) => {\n      client[kConnector]({\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName]\n      }, (err, socket) => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(socket)\n        }\n      })\n    })\n\n    if (!llhttpInstance) {\n      llhttpInstance = await llhttpPromise\n      llhttpPromise = null\n    }\n\n    client[kConnecting] = false\n\n    assert(socket)\n\n    client[kSocket] = socket\n\n    socket[kNoRef] = false\n    socket[kWriting] = false\n    socket[kReset] = false\n    socket[kBlocking] = false\n    socket[kError] = null\n    socket[kParser] = new Parser(client, socket, llhttpInstance)\n    socket[kClient] = client\n    socket[kCounter] = 0\n    socket[kMaxRequests] = client[kMaxRequests]\n    socket\n      .on('error', onSocketError)\n      .on('readable', onSocketReadable)\n      .on('end', onSocketEnd)\n      .on('close', onSocketClose)\n\n    if (channels.connected.hasSubscribers) {\n      channels.connected.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName]\n        },\n        connector: client[kConnector],\n        socket\n      })\n    }\n    client.emit('connect', client[kUrl], [client])\n  } catch (err) {\n    client[kConnecting] = false\n\n    if (channels.connectError.hasSubscribers) {\n      channels.connectError.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName]\n        },\n        connector: client[kConnector],\n        error: err\n      })\n    }\n\n    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n      assert(client[kRunning] === 0)\n      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {\n        const request = client[kQueue][client[kPendingIdx]++]\n        errorRequest(client, request, err)\n      }\n    } else {\n      onError(client, err)\n    }\n\n    client.emit('connectionError', client[kUrl], [client], err)\n  }\n\n  resume(client)\n}\n\nfunction emitDrain (client) {\n  client[kNeedDrain] = 0\n  client.emit('drain', client[kUrl], [client])\n}\n\nfunction resume (client, sync) {\n  if (client[kResuming] === 2) {\n    return\n  }\n\n  client[kResuming] = 2\n\n  _resume(client, sync)\n  client[kResuming] = 0\n\n  if (client[kRunningIdx] > 256) {\n    client[kQueue].splice(0, client[kRunningIdx])\n    client[kPendingIdx] -= client[kRunningIdx]\n    client[kRunningIdx] = 0\n  }\n}\n\nfunction _resume (client, sync) {\n  while (true) {\n    if (client.destroyed) {\n      assert(client[kPending] === 0)\n      return\n    }\n\n    if (client.closed && !client[kSize]) {\n      client.destroy()\n      return\n    }\n\n    const socket = client[kSocket]\n\n    if (socket) {\n      if (client[kSize] === 0) {\n        if (!socket[kNoRef] && socket.unref) {\n          socket.unref()\n          socket[kNoRef] = true\n        }\n      } else if (socket[kNoRef] && socket.ref) {\n        socket.ref()\n        socket[kNoRef] = false\n      }\n\n      if (client[kSize] === 0) {\n        if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {\n          socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE)\n        }\n      } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n        if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n          const request = client[kQueue][client[kRunningIdx]]\n          const headersTimeout = request.headersTimeout != null\n            ? request.headersTimeout\n            : client[kHeadersTimeout]\n          socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS)\n        }\n      }\n    }\n\n    if (client[kBusy]) {\n      client[kNeedDrain] = 2\n    } else if (client[kNeedDrain] === 2) {\n      if (sync) {\n        client[kNeedDrain] = 1\n        process.nextTick(emitDrain, client)\n      } else {\n        emitDrain(client)\n      }\n      continue\n    }\n\n    if (client[kPending] === 0) {\n      return\n    }\n\n    if (client[kRunning] >= (client[kPipelining] || 1)) {\n      return\n    }\n\n    const request = client[kQueue][client[kPendingIdx]]\n\n    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {\n      if (client[kRunning] > 0) {\n        return\n      }\n\n      client[kServerName] = request.servername\n\n      if (socket && socket.servername !== request.servername) {\n        util.destroy(socket, new InformationalError('servername changed'))\n        return\n      }\n    }\n\n    if (client[kConnecting]) {\n      return\n    }\n\n    if (!socket) {\n      connect(client)\n      continue\n    }\n\n    if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n      return\n    }\n\n    if (client[kRunning] > 0 && !request.idempotent) {\n      // Non-idempotent request cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return\n    }\n\n    if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {\n      // Don't dispatch an upgrade until all preceding requests have completed.\n      // A misbehaving server might upgrade the connection before all pipelined\n      // request has completed.\n      return\n    }\n\n    if (util.isStream(request.body) && util.bodyLength(request.body) === 0) {\n      request.body\n        .on('data', /* istanbul ignore next */ function () {\n          /* istanbul ignore next */\n          assert(false)\n        })\n        .on('error', function (err) {\n          errorRequest(client, request, err)\n        })\n        .on('end', function () {\n          util.destroy(this)\n        })\n\n      request.body = null\n    }\n\n    if (client[kRunning] > 0 &&\n      (util.isStream(request.body) || util.isAsyncIterable(request.body))) {\n      // Request with stream or iterator body can error while other requests\n      // are inflight and indirectly error those as well.\n      // Ensure this doesn't happen by waiting for inflight\n      // to complete before dispatching.\n\n      // Request with stream or iterator body cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return\n    }\n\n    if (!request.aborted && write(client, request)) {\n      client[kPendingIdx]++\n    } else {\n      client[kQueue].splice(client[kPendingIdx], 1)\n    }\n  }\n}\n\nfunction write (client, request) {\n  const { body, method, path, host, upgrade, headers, blocking } = request\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH'\n  )\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  let contentLength = util.bodyLength(body)\n\n  if (contentLength === null) {\n    contentLength = request.contentLength\n  }\n\n  if (contentLength === 0 && !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null\n  }\n\n  if (request.contentLength !== null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      errorRequest(client, request, new RequestContentLengthMismatchError())\n      return false\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError())\n  }\n\n  const socket = client[kSocket]\n\n  try {\n    request.onConnect((err) => {\n      if (request.aborted || request.completed) {\n        return\n      }\n\n      errorRequest(client, request, err || new RequestAbortedError())\n\n      util.destroy(socket, new InformationalError('aborted'))\n    })\n  } catch (err) {\n    errorRequest(client, request, err)\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  if (method === 'HEAD') {\n    // https://github.com/mcollina/undici/issues/258\n\n    // Close after a HEAD request to interop with misbehaving servers\n    // that may send a body in the response.\n\n    socket[kReset] = true\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    // On CONNECT or upgrade, block pipeline from dispatching further\n    // requests on this connection.\n\n    socket[kReset] = true\n  }\n\n  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n    socket[kReset] = true\n  }\n\n  if (blocking) {\n    socket[kBlocking] = true\n  }\n\n  let header = `${method} ${path} HTTP/1.1\\r\\n`\n\n  if (typeof host === 'string') {\n    header += `host: ${host}\\r\\n`\n  } else {\n    header += client[kHostHeader]\n  }\n\n  if (upgrade) {\n    header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`\n  } else if (client[kPipelining]) {\n    header += 'connection: keep-alive\\r\\n'\n  } else {\n    header += 'connection: close\\r\\n'\n  }\n\n  if (headers) {\n    header += headers\n  }\n\n  if (channels.sendHeaders.hasSubscribers) {\n    channels.sendHeaders.publish({ request, headers: header, socket })\n  }\n\n  /* istanbul ignore else: assertion */\n  if (!body) {\n    if (contentLength === 0) {\n      socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'ascii')\n    } else {\n      assert(contentLength === null, 'no body must not have content length')\n      socket.write(`${header}\\r\\n`, 'ascii')\n    }\n    request.onRequestSent()\n  } else if (util.isBuffer(body)) {\n    assert(contentLength === body.byteLength, 'buffer body must have content length')\n\n    socket.cork()\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii')\n    socket.write(body)\n    socket.uncork()\n    request.onBodySent(body)\n    request.onRequestSent()\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n  } else if (util.isBlobLike(body)) {\n    if (typeof body.stream === 'function') {\n      writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload })\n    } else {\n      writeBlob({ body, client, request, socket, contentLength, header, expectsPayload })\n    }\n  } else if (util.isStream(body)) {\n    writeStream({ body, client, request, socket, contentLength, header, expectsPayload })\n  } else if (util.isIterable(body)) {\n    writeIterable({ body, client, request, socket, contentLength, header, expectsPayload })\n  } else {\n    assert(false)\n  }\n\n  return true\n}\n\nfunction writeStream ({ body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined')\n\n  let finished = false\n\n  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header })\n\n  const onData = function (chunk) {\n    try {\n      assert(!finished)\n\n      if (!writer.write(chunk) && this.pause) {\n        this.pause()\n      }\n    } catch (err) {\n      util.destroy(this, err)\n    }\n  }\n  const onDrain = function () {\n    assert(!finished)\n\n    if (body.resume) {\n      body.resume()\n    }\n  }\n  const onAbort = function () {\n    onFinished(new RequestAbortedError())\n  }\n  const onFinished = function (err) {\n    if (finished) {\n      return\n    }\n\n    finished = true\n\n    assert(socket.destroyed || (socket[kWriting] && client[kRunning] <= 1))\n\n    socket\n      .off('drain', onDrain)\n      .off('error', onFinished)\n\n    body\n      .removeListener('data', onData)\n      .removeListener('end', onFinished)\n      .removeListener('error', onFinished)\n      .removeListener('close', onAbort)\n\n    if (!err) {\n      try {\n        writer.end()\n      } catch (er) {\n        err = er\n      }\n    }\n\n    writer.destroy(err)\n\n    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {\n      util.destroy(body, err)\n    } else {\n      util.destroy(body)\n    }\n  }\n\n  body\n    .on('data', onData)\n    .on('end', onFinished)\n    .on('error', onFinished)\n    .on('close', onAbort)\n\n  if (body.resume) {\n    body.resume()\n  }\n\n  socket\n    .on('drain', onDrain)\n    .on('error', onFinished)\n}\n\nasync function writeBlob ({ body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength === body.size, 'blob body must have content length')\n\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError()\n    }\n\n    const buffer = Buffer.from(await body.arrayBuffer())\n\n    socket.cork()\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii')\n    socket.write(buffer)\n    socket.uncork()\n\n    request.onBodySent(buffer)\n    request.onRequestSent()\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    resume(client)\n  } catch (err) {\n    util.destroy(socket, err)\n  }\n}\n\nasync function writeIterable ({ body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined')\n\n  let callback = null\n  function onDrain () {\n    if (callback) {\n      const cb = callback\n      callback = null\n      cb()\n    }\n  }\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null)\n\n    if (socket[kError]) {\n      reject(socket[kError])\n    } else {\n      callback = resolve\n    }\n  })\n\n  socket\n    .on('close', onDrain)\n    .on('drain', onDrain)\n\n  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header })\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError]\n      }\n\n      if (!writer.write(chunk)) {\n        await waitForDrain()\n      }\n    }\n\n    writer.end()\n  } catch (err) {\n    writer.destroy(err)\n  } finally {\n    socket\n      .off('close', onDrain)\n      .off('drain', onDrain)\n  }\n}\n\nclass AsyncWriter {\n  constructor ({ socket, request, contentLength, client, expectsPayload, header }) {\n    this.socket = socket\n    this.request = request\n    this.contentLength = contentLength\n    this.client = client\n    this.bytesWritten = 0\n    this.expectsPayload = expectsPayload\n    this.header = header\n\n    socket[kWriting] = true\n  }\n\n  write (chunk) {\n    const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return false\n    }\n\n    const len = Buffer.byteLength(chunk)\n    if (!len) {\n      return true\n    }\n\n    // We should defer writing chunks.\n    if (contentLength !== null && bytesWritten + len > contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      }\n\n      process.emitWarning(new RequestContentLengthMismatchError())\n    }\n\n    if (bytesWritten === 0) {\n      if (!expectsPayload) {\n        socket[kReset] = true\n      }\n\n      if (contentLength === null) {\n        socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'ascii')\n      } else {\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii')\n      }\n    }\n\n    if (contentLength === null) {\n      socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'ascii')\n    }\n\n    this.bytesWritten += len\n\n    const ret = socket.write(chunk)\n\n    request.onBodySent(chunk)\n\n    if (!ret) {\n      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n        // istanbul ignore else: only for jest\n        if (socket[kParser].timeout.refresh) {\n          socket[kParser].timeout.refresh()\n        }\n      }\n    }\n\n    return ret\n  }\n\n  end () {\n    const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this\n    request.onRequestSent()\n\n    socket[kWriting] = false\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return\n    }\n\n    if (bytesWritten === 0) {\n      if (expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD send a Content-Length in a request message when\n        // no Transfer-Encoding is sent and the request method defines a meaning\n        // for an enclosed payload body.\n\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'ascii')\n      } else {\n        socket.write(`${header}\\r\\n`, 'ascii')\n      }\n    } else if (contentLength === null) {\n      socket.write('\\r\\n0\\r\\n\\r\\n', 'ascii')\n    }\n\n    if (contentLength !== null && bytesWritten !== contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      } else {\n        process.emitWarning(new RequestContentLengthMismatchError())\n      }\n    }\n\n    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n      // istanbul ignore else: only for jest\n      if (socket[kParser].timeout.refresh) {\n        socket[kParser].timeout.refresh()\n      }\n    }\n\n    resume(client)\n  }\n\n  destroy (err) {\n    const { socket, client } = this\n\n    socket[kWriting] = false\n\n    if (err) {\n      assert(client[kRunning] <= 1, 'pipeline should only contain this request')\n      util.destroy(socket, err)\n    }\n  }\n}\n\nfunction errorRequest (client, request, err) {\n  try {\n    request.onError(err)\n    assert(request.aborted)\n  } catch (err) {\n    client.emit('error', err)\n  }\n}\n\nmodule.exports = Client\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}