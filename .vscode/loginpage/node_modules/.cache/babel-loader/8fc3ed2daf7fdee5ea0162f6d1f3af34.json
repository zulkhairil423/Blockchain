{"ast":null,"code":"var debug = require('debug')('eventstore:eventdispatcher');\n/**\n * Eventstore constructor\n * @param {Object} options The options.\n * @param publisher the publisher that should be injected\n * @param store the store that should be injected\n * @constructor\n */\n\n\nfunction EventDispatcher(publisher, store) {\n  this.publisher = publisher;\n  this.store = store;\n  this.undispatchedEventsQueue = [];\n}\n/**\n * Triggers to publish all events in undispatchedEventsQueue.\n */\n\n\nfunction trigger(dispatcher) {\n  var queue = dispatcher.undispatchedEventsQueue || [];\n  var event; // if the last loop is still in progress leave this loop\n\n  if (dispatcher.isRunning) return;\n  dispatcher.isRunning = true;\n\n  (function next(e) {\n    // dipatch one event in queue and call the _next_ callback, which\n    // will call _process_ for the next undispatched event in queue.\n    function process(event, nxt) {\n      // Publish it now...\n      debug('publish event...');\n      dispatcher.publisher(event.payload, function (err) {\n        if (err) {\n          return debug(err);\n        } // ...and set the published event to dispatched.\n\n\n        debug('set event to dispatched...');\n        dispatcher.store.setEventToDispatched(event, function (err) {\n          if (err) {\n            debug(err);\n          } else {\n            debug('event set to dispatched');\n          }\n        });\n      });\n      nxt();\n    } // serial process all events in queue\n\n\n    if (!e && queue.length) {\n      process(queue.shift(), next);\n    } else {\n      debug(e);\n    }\n  })();\n\n  dispatcher.isRunning = false;\n}\n\nEventDispatcher.prototype = {\n  /**\n   * Queues the passed in events for dispatching.\n   * @param events\n   */\n  addUndispatchedEvents: function (events) {\n    var self = this;\n    events.forEach(function (event) {\n      self.undispatchedEventsQueue.push(event);\n    });\n    trigger(this);\n  },\n\n  /**\n   * Starts the instance to publish all undispatched events.\n   * @param callback the function that will be called when this action has finished\n   */\n  start: function (callback) {\n    if (typeof this.publisher !== 'function') {\n      var pubErrMsg = 'publisher not injected!';\n      debug(pubErrMsg);\n      if (callback) callback(new Error(pubErrMsg));\n      return;\n    }\n\n    if (!this.store || typeof this.store.getUndispatchedEvents !== 'function' || typeof this.store.setEventToDispatched !== 'function') {\n      var storeErrMsg = 'store not injected!';\n      debug(storeErrMsg);\n      if (callback) callback(new Error(storeErrMsg));\n      return;\n    }\n\n    var self = this; // Get all undispatched events from store and queue them\n    // before all other events passed in by the addUndispatchedEvents function.\n\n    this.store.getUndispatchedEvents(function (err, events) {\n      if (err) {\n        debug(err);\n        if (callback) callback(err);\n        return;\n      }\n\n      var triggered = false;\n\n      if (events) {\n        for (var i = 0, len = events.length; i < len; i++) {\n          self.undispatchedEventsQueue.push(events[i]); // If there are a lot of events then we can hit issues with the call stack size when processing in one go\n\n          triggered = false;\n\n          if (i % 1000 === 0) {\n            triggered = true;\n            trigger(self);\n          }\n        }\n      }\n\n      if (!triggered) {\n        trigger(self);\n      }\n\n      if (callback) callback(null);\n    });\n  }\n};\nmodule.exports = EventDispatcher;","map":{"version":3,"names":["debug","require","EventDispatcher","publisher","store","undispatchedEventsQueue","trigger","dispatcher","queue","event","isRunning","next","e","process","nxt","payload","err","setEventToDispatched","length","shift","prototype","addUndispatchedEvents","events","self","forEach","push","start","callback","pubErrMsg","Error","getUndispatchedEvents","storeErrMsg","triggered","i","len","module","exports"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/eventstore/lib/eventDispatcher.js"],"sourcesContent":["var debug = require('debug')('eventstore:eventdispatcher');\n\n/**\n * Eventstore constructor\n * @param {Object} options The options.\n * @param publisher the publisher that should be injected\n * @param store the store that should be injected\n * @constructor\n */\nfunction EventDispatcher(publisher, store) {\n  this.publisher = publisher;\n  this.store = store;\n  this.undispatchedEventsQueue = [];\n}\n\n/**\n * Triggers to publish all events in undispatchedEventsQueue.\n */\nfunction trigger (dispatcher) {\n  var queue = dispatcher.undispatchedEventsQueue || []\n  var event;\n\n  // if the last loop is still in progress leave this loop\n  if (dispatcher.isRunning) return;\n\n  dispatcher.isRunning = true;\n\n  (function next (e) {\n\n    // dipatch one event in queue and call the _next_ callback, which\n    // will call _process_ for the next undispatched event in queue.\n    function process (event, nxt) {\n\n      // Publish it now...\n      debug('publish event...');\n      dispatcher.publisher(event.payload, function(err) {\n        if (err) {\n          return debug(err);\n        }\n        // ...and set the published event to dispatched.\n        debug('set event to dispatched...');\n        dispatcher.store.setEventToDispatched(event, function(err) {\n          if (err) {\n            debug(err);\n          } else {\n            debug('event set to dispatched');\n          }\n        });\n      });\n\n      nxt();\n    }\n\n    // serial process all events in queue\n    if (!e && queue.length) {\n      process(queue.shift(), next)\n    } else {\n      debug(e);\n    }\n  })();\n\n  dispatcher.isRunning = false;\n}\n\nEventDispatcher.prototype = {\n\n  /**\n   * Queues the passed in events for dispatching.\n   * @param events\n   */\n  addUndispatchedEvents: function(events) {\n    var self = this;\n    events.forEach(function(event) {\n      self.undispatchedEventsQueue.push(event);\n    });\n    trigger(this);\n  },\n\n  /**\n   * Starts the instance to publish all undispatched events.\n   * @param callback the function that will be called when this action has finished\n   */\n  start: function(callback) {\n\n    if (typeof this.publisher !== 'function') {\n      var pubErrMsg = 'publisher not injected!';\n      debug(pubErrMsg);\n      if (callback) callback(new Error(pubErrMsg));\n      return;\n    }\n\n    if (!this.store || typeof this.store.getUndispatchedEvents !== 'function'\n                    || typeof this.store.setEventToDispatched !== 'function') {\n      var storeErrMsg = 'store not injected!';\n      debug(storeErrMsg);\n      if (callback) callback(new Error(storeErrMsg))\n      return;\n    }\n\n    var self = this;\n\n    // Get all undispatched events from store and queue them\n    // before all other events passed in by the addUndispatchedEvents function.\n    this.store.getUndispatchedEvents(function(err, events) {\n\n      if (err) {\n        debug(err);\n        if (callback) callback(err);\n        return;\n      }\n\n      var triggered = false;\n      if (events) {\n        for (var i = 0, len = events.length; i < len; i++) {\n          self.undispatchedEventsQueue.push(events[i]);\n          // If there are a lot of events then we can hit issues with the call stack size when processing in one go\n          triggered = false;\n          if (i % 1000 === 0){\n            triggered = true;\n            trigger(self);\n          }\n        }\n      }\n\n      if (!triggered) {\n        trigger(self);\n      }\n\n      if (callback) callback(null);\n    });\n  }\n};\n\nmodule.exports = EventDispatcher;\n"],"mappings":"AAAA,IAAIA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAP,CAAiB,4BAAjB,CAAZ;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,eAAT,CAAyBC,SAAzB,EAAoCC,KAApC,EAA2C;EACzC,KAAKD,SAAL,GAAiBA,SAAjB;EACA,KAAKC,KAAL,GAAaA,KAAb;EACA,KAAKC,uBAAL,GAA+B,EAA/B;AACD;AAED;AACA;AACA;;;AACA,SAASC,OAAT,CAAkBC,UAAlB,EAA8B;EAC5B,IAAIC,KAAK,GAAGD,UAAU,CAACF,uBAAX,IAAsC,EAAlD;EACA,IAAII,KAAJ,CAF4B,CAI5B;;EACA,IAAIF,UAAU,CAACG,SAAf,EAA0B;EAE1BH,UAAU,CAACG,SAAX,GAAuB,IAAvB;;EAEA,CAAC,SAASC,IAAT,CAAeC,CAAf,EAAkB;IAEjB;IACA;IACA,SAASC,OAAT,CAAkBJ,KAAlB,EAAyBK,GAAzB,EAA8B;MAE5B;MACAd,KAAK,CAAC,kBAAD,CAAL;MACAO,UAAU,CAACJ,SAAX,CAAqBM,KAAK,CAACM,OAA3B,EAAoC,UAASC,GAAT,EAAc;QAChD,IAAIA,GAAJ,EAAS;UACP,OAAOhB,KAAK,CAACgB,GAAD,CAAZ;QACD,CAH+C,CAIhD;;;QACAhB,KAAK,CAAC,4BAAD,CAAL;QACAO,UAAU,CAACH,KAAX,CAAiBa,oBAAjB,CAAsCR,KAAtC,EAA6C,UAASO,GAAT,EAAc;UACzD,IAAIA,GAAJ,EAAS;YACPhB,KAAK,CAACgB,GAAD,CAAL;UACD,CAFD,MAEO;YACLhB,KAAK,CAAC,yBAAD,CAAL;UACD;QACF,CAND;MAOD,CAbD;MAeAc,GAAG;IACJ,CAxBgB,CA0BjB;;;IACA,IAAI,CAACF,CAAD,IAAMJ,KAAK,CAACU,MAAhB,EAAwB;MACtBL,OAAO,CAACL,KAAK,CAACW,KAAN,EAAD,EAAgBR,IAAhB,CAAP;IACD,CAFD,MAEO;MACLX,KAAK,CAACY,CAAD,CAAL;IACD;EACF,CAhCD;;EAkCAL,UAAU,CAACG,SAAX,GAAuB,KAAvB;AACD;;AAEDR,eAAe,CAACkB,SAAhB,GAA4B;EAE1B;AACF;AACA;AACA;EACEC,qBAAqB,EAAE,UAASC,MAAT,EAAiB;IACtC,IAAIC,IAAI,GAAG,IAAX;IACAD,MAAM,CAACE,OAAP,CAAe,UAASf,KAAT,EAAgB;MAC7Bc,IAAI,CAAClB,uBAAL,CAA6BoB,IAA7B,CAAkChB,KAAlC;IACD,CAFD;IAGAH,OAAO,CAAC,IAAD,CAAP;EACD,CAZyB;;EAc1B;AACF;AACA;AACA;EACEoB,KAAK,EAAE,UAASC,QAAT,EAAmB;IAExB,IAAI,OAAO,KAAKxB,SAAZ,KAA0B,UAA9B,EAA0C;MACxC,IAAIyB,SAAS,GAAG,yBAAhB;MACA5B,KAAK,CAAC4B,SAAD,CAAL;MACA,IAAID,QAAJ,EAAcA,QAAQ,CAAC,IAAIE,KAAJ,CAAUD,SAAV,CAAD,CAAR;MACd;IACD;;IAED,IAAI,CAAC,KAAKxB,KAAN,IAAe,OAAO,KAAKA,KAAL,CAAW0B,qBAAlB,KAA4C,UAA3D,IACe,OAAO,KAAK1B,KAAL,CAAWa,oBAAlB,KAA2C,UAD9D,EAC0E;MACxE,IAAIc,WAAW,GAAG,qBAAlB;MACA/B,KAAK,CAAC+B,WAAD,CAAL;MACA,IAAIJ,QAAJ,EAAcA,QAAQ,CAAC,IAAIE,KAAJ,CAAUE,WAAV,CAAD,CAAR;MACd;IACD;;IAED,IAAIR,IAAI,GAAG,IAAX,CAjBwB,CAmBxB;IACA;;IACA,KAAKnB,KAAL,CAAW0B,qBAAX,CAAiC,UAASd,GAAT,EAAcM,MAAd,EAAsB;MAErD,IAAIN,GAAJ,EAAS;QACPhB,KAAK,CAACgB,GAAD,CAAL;QACA,IAAIW,QAAJ,EAAcA,QAAQ,CAACX,GAAD,CAAR;QACd;MACD;;MAED,IAAIgB,SAAS,GAAG,KAAhB;;MACA,IAAIV,MAAJ,EAAY;QACV,KAAK,IAAIW,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGZ,MAAM,CAACJ,MAA7B,EAAqCe,CAAC,GAAGC,GAAzC,EAA8CD,CAAC,EAA/C,EAAmD;UACjDV,IAAI,CAAClB,uBAAL,CAA6BoB,IAA7B,CAAkCH,MAAM,CAACW,CAAD,CAAxC,EADiD,CAEjD;;UACAD,SAAS,GAAG,KAAZ;;UACA,IAAIC,CAAC,GAAG,IAAJ,KAAa,CAAjB,EAAmB;YACjBD,SAAS,GAAG,IAAZ;YACA1B,OAAO,CAACiB,IAAD,CAAP;UACD;QACF;MACF;;MAED,IAAI,CAACS,SAAL,EAAgB;QACd1B,OAAO,CAACiB,IAAD,CAAP;MACD;;MAED,IAAII,QAAJ,EAAcA,QAAQ,CAAC,IAAD,CAAR;IACf,CA1BD;EA2BD;AAlEyB,CAA5B;AAqEAQ,MAAM,CAACC,OAAP,GAAiBlC,eAAjB"},"metadata":{},"sourceType":"script"}