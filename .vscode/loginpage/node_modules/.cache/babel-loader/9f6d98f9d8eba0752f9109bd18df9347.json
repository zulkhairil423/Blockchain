{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getArtifactFromContractOutput = exports.Artifacts = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nconst os = __importStar(require(\"os\"));\n\nconst path = __importStar(require(\"path\"));\n\nconst promises_1 = __importDefault(require(\"fs/promises\"));\n\nconst contract_names_1 = require(\"../utils/contract-names\");\n\nconst source_names_1 = require(\"../utils/source-names\");\n\nconst constants_1 = require(\"./constants\");\n\nconst errors_1 = require(\"./core/errors\");\n\nconst errors_list_1 = require(\"./core/errors-list\");\n\nconst hash_1 = require(\"./util/hash\");\n\nconst fs_utils_1 = require(\"./util/fs-utils\");\n\nconst log = (0, debug_1.default)(\"hardhat:core:artifacts\");\n\nclass Artifacts {\n  constructor(_artifactsPath) {\n    this._artifactsPath = _artifactsPath; // Undefined means that the cache is disabled.\n\n    this._cache = {\n      artifactNameToArtifactPathCache: new Map(),\n      artifactFQNToBuildInfoPathCache: new Map()\n    };\n    this._validArtifacts = [];\n  }\n\n  addValidArtifacts(validArtifacts) {\n    this._validArtifacts.push(...validArtifacts);\n  }\n\n  async readArtifact(name) {\n    const artifactPath = await this._getArtifactPath(name);\n    return fs_extra_1.default.readJson(artifactPath);\n  }\n\n  readArtifactSync(name) {\n    const artifactPath = this._getArtifactPathSync(name);\n\n    return fs_extra_1.default.readJsonSync(artifactPath);\n  }\n\n  async artifactExists(name) {\n    const artifactPath = await this._getArtifactPath(name);\n    return fs_extra_1.default.pathExists(artifactPath);\n  }\n\n  async getAllFullyQualifiedNames() {\n    const paths = await this.getArtifactPaths();\n    return paths.map(p => this._getFullyQualifiedNameFromPath(p)).sort();\n  }\n\n  async getBuildInfo(fullyQualifiedName) {\n    let buildInfoPath = this._cache?.artifactFQNToBuildInfoPathCache.get(fullyQualifiedName);\n\n    if (buildInfoPath === undefined) {\n      const artifactPath = this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n\n      const debugFilePath = this._getDebugFilePath(artifactPath);\n\n      buildInfoPath = await this._getBuildInfoFromDebugFile(debugFilePath);\n\n      if (buildInfoPath === undefined) {\n        return undefined;\n      }\n\n      this._cache?.artifactFQNToBuildInfoPathCache.set(fullyQualifiedName, buildInfoPath);\n    }\n\n    return fs_extra_1.default.readJSON(buildInfoPath);\n  }\n\n  async getArtifactPaths() {\n    const cached = this._cache?.artifactPaths;\n\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    const buildInfosDir = path.join(this._artifactsPath, constants_1.BUILD_INFO_DIR_NAME);\n    const paths = await (0, fs_utils_1.getAllFilesMatching)(this._artifactsPath, f => f.endsWith(\".json\") && !f.startsWith(buildInfosDir) && !f.endsWith(\".dbg.json\"));\n    const result = paths.sort();\n\n    if (this._cache !== undefined) {\n      this._cache.artifactPaths = result;\n    }\n\n    return result;\n  }\n\n  async getBuildInfoPaths() {\n    const cached = this._cache?.buildInfoPaths;\n\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    const paths = await (0, fs_utils_1.getAllFilesMatching)(path.join(this._artifactsPath, constants_1.BUILD_INFO_DIR_NAME), f => f.endsWith(\".json\"));\n    const result = paths.sort();\n\n    if (this._cache !== undefined) {\n      this._cache.buildInfoPaths = result;\n    }\n\n    return result;\n  }\n\n  async getDebugFilePaths() {\n    const cached = this._cache?.debugFilePaths;\n\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    const paths = await (0, fs_utils_1.getAllFilesMatching)(path.join(this._artifactsPath), f => f.endsWith(\".dbg.json\"));\n    const result = paths.sort();\n\n    if (this._cache !== undefined) {\n      this._cache.debugFilePaths = result;\n    }\n\n    return result;\n  }\n\n  async saveArtifactAndDebugFile(artifact, pathToBuildInfo) {\n    try {\n      // artifact\n      const fullyQualifiedName = (0, contract_names_1.getFullyQualifiedName)(artifact.sourceName, artifact.contractName);\n      const artifactPath = this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n      await fs_extra_1.default.ensureDir(path.dirname(artifactPath));\n      await Promise.all([fs_extra_1.default.writeJSON(artifactPath, artifact, {\n        spaces: 2\n      }), (async () => {\n        if (pathToBuildInfo === undefined) {\n          return;\n        } // save debug file\n\n\n        const debugFilePath = this._getDebugFilePath(artifactPath);\n\n        const debugFile = this._createDebugFile(artifactPath, pathToBuildInfo);\n\n        await fs_extra_1.default.writeJSON(debugFilePath, debugFile, {\n          spaces: 2\n        });\n      })()]);\n    } finally {\n      this.clearCache();\n    }\n  }\n\n  async saveBuildInfo(solcVersion, solcLongVersion, input, output) {\n    try {\n      const buildInfoDir = path.join(this._artifactsPath, constants_1.BUILD_INFO_DIR_NAME);\n      await fs_extra_1.default.ensureDir(buildInfoDir);\n\n      const buildInfoName = this._getBuildInfoName(solcVersion, solcLongVersion, input);\n\n      const buildInfo = this._createBuildInfo(buildInfoName, solcVersion, solcLongVersion, input, output);\n\n      const buildInfoPath = path.join(buildInfoDir, `${buildInfoName}.json`); // JSON.stringify of the entire build info can be really slow\n      // in larger projects, so we stringify per part and incrementally create\n      // the JSON in the file.\n      //\n      // We split this code into different curly-brace-enclosed scopes so that\n      // partial JSON strings get out of scope sooner and hence can be reclaimed\n      // by the GC if needed.\n\n      const file = await promises_1.default.open(buildInfoPath, \"w\");\n\n      try {\n        {\n          const withoutOutput = JSON.stringify({ ...buildInfo,\n            output: undefined\n          }); // We write the JSON (without output) except the last }\n\n          await file.write(withoutOutput.slice(0, -1));\n        }\n        {\n          const outputWithoutSourcesAndContracts = JSON.stringify({ ...buildInfo.output,\n            sources: undefined,\n            contracts: undefined\n          }); // We start writing the output\n\n          await file.write(',\"output\":'); // Write the output object except for the last }\n\n          await file.write(outputWithoutSourcesAndContracts.slice(0, -1)); // If there were other field apart from sources and contracts we need\n          // a comma\n\n          if (outputWithoutSourcesAndContracts.length > 2) {\n            await file.write(\",\");\n          }\n        } // Writing the sources\n\n        await file.write('\"sources\":{');\n        let isFirst = true;\n\n        for (const [name, value] of Object.entries(buildInfo.output.sources ?? {})) {\n          if (isFirst) {\n            isFirst = false;\n          } else {\n            await file.write(\",\");\n          }\n\n          await file.write(`${JSON.stringify(name)}:${JSON.stringify(value)}`);\n        } // Close sources object\n\n\n        await file.write(\"}\"); // Writing the contracts\n\n        await file.write(',\"contracts\":{');\n        isFirst = true;\n\n        for (const [name, value] of Object.entries(buildInfo.output.contracts ?? {})) {\n          if (isFirst) {\n            isFirst = false;\n          } else {\n            await file.write(\",\");\n          }\n\n          await file.write(`${JSON.stringify(name)}:${JSON.stringify(value)}`);\n        } // close contracts object\n\n\n        await file.write(\"}\"); // close output object\n\n        await file.write(\"}\"); // close build info object\n\n        await file.write(\"}\");\n      } finally {\n        await file.close();\n      }\n\n      return buildInfoPath;\n    } finally {\n      this.clearCache();\n    }\n  }\n  /**\n   * Remove all artifacts that don't correspond to the current solidity files\n   */\n\n\n  async removeObsoleteArtifacts() {\n    // We clear the cache here, as we want to be sure this runs correctly\n    this.clearCache();\n\n    try {\n      const validArtifactPaths = await Promise.all(this._validArtifacts.flatMap(_ref => {\n        let {\n          sourceName,\n          artifacts\n        } = _ref;\n        return artifacts.map(artifactName => this._getArtifactPath((0, contract_names_1.getFullyQualifiedName)(sourceName, artifactName)));\n      }));\n      const validArtifactsPathsSet = new Set(validArtifactPaths);\n\n      for (const {\n        sourceName,\n        artifacts\n      } of this._validArtifacts) {\n        for (const artifactName of artifacts) {\n          validArtifactsPathsSet.add(this.formArtifactPathFromFullyQualifiedName((0, contract_names_1.getFullyQualifiedName)(sourceName, artifactName)));\n        }\n      }\n\n      const existingArtifactsPaths = await this.getArtifactPaths();\n      await Promise.all(existingArtifactsPaths.filter(artifactPath => !validArtifactsPathsSet.has(artifactPath)).map(artifactPath => this._removeArtifactFiles(artifactPath)));\n      await this._removeObsoleteBuildInfos();\n    } finally {\n      // We clear the cache here, as this may have non-existent paths now\n      this.clearCache();\n    }\n  }\n  /**\n   * Returns the absolute path to the given artifact\n   */\n\n\n  formArtifactPathFromFullyQualifiedName(fullyQualifiedName) {\n    const {\n      sourceName,\n      contractName\n    } = (0, contract_names_1.parseFullyQualifiedName)(fullyQualifiedName);\n    return path.join(this._artifactsPath, sourceName, `${contractName}.json`);\n  }\n\n  clearCache() {\n    // Avoid accidentally re-enabling the cache\n    if (this._cache === undefined) {\n      return;\n    }\n\n    this._cache = {\n      artifactFQNToBuildInfoPathCache: new Map(),\n      artifactNameToArtifactPathCache: new Map()\n    };\n  }\n\n  disableCache() {\n    this._cache = undefined;\n  }\n  /**\n   * Remove all build infos that aren't used by any debug file\n   */\n\n\n  async _removeObsoleteBuildInfos() {\n    const debugFiles = await this.getDebugFilePaths();\n    const buildInfos = await Promise.all(debugFiles.map(async debugFile => {\n      const buildInfoFile = await this._getBuildInfoFromDebugFile(debugFile);\n\n      if (buildInfoFile !== undefined) {\n        return path.resolve(path.dirname(debugFile), buildInfoFile);\n      } else {\n        return undefined;\n      }\n    }));\n    const filteredBuildInfos = buildInfos.filter(bf => typeof bf === \"string\");\n    const validBuildInfos = new Set(filteredBuildInfos);\n    const buildInfoFiles = await this.getBuildInfoPaths();\n    await Promise.all(buildInfoFiles.filter(buildInfoFile => !validBuildInfos.has(buildInfoFile)).map(async buildInfoFile => {\n      log(`Removing buildInfo '${buildInfoFile}'`);\n      await fs_extra_1.default.unlink(buildInfoFile);\n    }));\n  }\n\n  _getBuildInfoName(solcVersion, solcLongVersion, input) {\n    const json = JSON.stringify({\n      _format: constants_1.BUILD_INFO_FORMAT_VERSION,\n      solcVersion,\n      solcLongVersion,\n      input\n    });\n    return (0, hash_1.createNonCryptographicHashBasedIdentifier)(Buffer.from(json)).toString(\"hex\");\n  }\n  /**\n   * Returns the absolute path to the artifact that corresponds to the given\n   * name.\n   *\n   * If the name is fully qualified, the path is computed from it.  If not, an\n   * artifact that matches the given name is searched in the existing artifacts.\n   * If there is an ambiguity, an error is thrown.\n   */\n\n\n  async _getArtifactPath(name) {\n    const cached = this._cache?.artifactNameToArtifactPathCache.get(name);\n\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    let result;\n\n    if ((0, contract_names_1.isFullyQualifiedName)(name)) {\n      result = await this._getValidArtifactPathFromFullyQualifiedName(name);\n    } else {\n      const files = await this.getArtifactPaths();\n      result = this._getArtifactPathFromFiles(name, files);\n    }\n\n    this._cache?.artifactNameToArtifactPathCache.set(name, result);\n    return result;\n  }\n\n  _createBuildInfo(id, solcVersion, solcLongVersion, input, output) {\n    return {\n      id,\n      _format: constants_1.BUILD_INFO_FORMAT_VERSION,\n      solcVersion,\n      solcLongVersion,\n      input,\n      output\n    };\n  }\n\n  _createDebugFile(artifactPath, pathToBuildInfo) {\n    const relativePathToBuildInfo = path.relative(path.dirname(artifactPath), pathToBuildInfo);\n    const debugFile = {\n      _format: constants_1.DEBUG_FILE_FORMAT_VERSION,\n      buildInfo: relativePathToBuildInfo\n    };\n    return debugFile;\n  }\n\n  _getArtifactPathsSync() {\n    const cached = this._cache?.artifactPaths;\n\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    const buildInfosDir = path.join(this._artifactsPath, constants_1.BUILD_INFO_DIR_NAME);\n    const paths = (0, fs_utils_1.getAllFilesMatchingSync)(this._artifactsPath, f => f.endsWith(\".json\") && !f.startsWith(buildInfosDir) && !f.endsWith(\".dbg.json\"));\n    const result = paths.sort();\n\n    if (this._cache !== undefined) {\n      this._cache.artifactPaths = result;\n    }\n\n    return result;\n  }\n  /**\n   * Sync version of _getArtifactPath\n   */\n\n\n  _getArtifactPathSync(name) {\n    const cached = this._cache?.artifactNameToArtifactPathCache.get(name);\n\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    let result;\n\n    if ((0, contract_names_1.isFullyQualifiedName)(name)) {\n      result = this._getValidArtifactPathFromFullyQualifiedNameSync(name);\n    } else {\n      const files = this._getArtifactPathsSync();\n\n      result = this._getArtifactPathFromFiles(name, files);\n    }\n\n    this._cache?.artifactNameToArtifactPathCache.set(name, result);\n    return result;\n  }\n  /**\n   * DO NOT DELETE OR CHANGE\n   *\n   * use this.formArtifactPathFromFullyQualifiedName instead\n   * @deprecated until typechain migrates to public version\n   * @see https://github.com/dethcrypto/TypeChain/issues/544\n   */\n\n\n  _getArtifactPathFromFullyQualifiedName(fullyQualifiedName) {\n    const {\n      sourceName,\n      contractName\n    } = (0, contract_names_1.parseFullyQualifiedName)(fullyQualifiedName);\n    return path.join(this._artifactsPath, sourceName, `${contractName}.json`);\n  }\n\n  async _getValidArtifactPathFromFullyQualifiedName(fullyQualifiedName) {\n    const artifactPath = this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n\n    try {\n      const trueCasePath = path.join(this._artifactsPath, await (0, fs_utils_1.getFileTrueCase)(this._artifactsPath, path.relative(this._artifactsPath, artifactPath)));\n\n      if (artifactPath !== trueCasePath) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARTIFACTS.WRONG_CASING, {\n          correct: this._getFullyQualifiedNameFromPath(trueCasePath),\n          incorrect: fullyQualifiedName\n        });\n      }\n\n      return trueCasePath;\n    } catch (e) {\n      if (e instanceof fs_utils_1.FileNotFoundError) {\n        return this._handleWrongArtifactForFullyQualifiedName(fullyQualifiedName);\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw e;\n    }\n  }\n\n  _getAllContractNamesFromFiles(files) {\n    return files.map(file => {\n      const fqn = this._getFullyQualifiedNameFromPath(file);\n\n      return (0, contract_names_1.parseFullyQualifiedName)(fqn).contractName;\n    });\n  }\n\n  _getAllFullyQualifiedNamesSync() {\n    const paths = this._getArtifactPathsSync();\n\n    return paths.map(p => this._getFullyQualifiedNameFromPath(p)).sort();\n  }\n\n  _formatSuggestions(names, contractName) {\n    switch (names.length) {\n      case 0:\n        return \"\";\n\n      case 1:\n        return `Did you mean \"${names[0]}\"?`;\n\n      default:\n        return `We found some that were similar:\n\n${names.map(n => `  * ${n}`).join(os.EOL)}\n\nPlease replace \"${contractName}\" for the correct contract name wherever you are trying to read its artifact.\n`;\n    }\n  }\n\n  _handleWrongArtifactForFullyQualifiedName(fullyQualifiedName) {\n    const names = this._getAllFullyQualifiedNamesSync();\n\n    const similarNames = this._getSimilarContractNames(fullyQualifiedName, names);\n\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.ARTIFACTS.NOT_FOUND, {\n      contractName: fullyQualifiedName,\n      suggestion: this._formatSuggestions(similarNames, fullyQualifiedName)\n    });\n  }\n\n  _handleWrongArtifactForContractName(contractName, files) {\n    const names = this._getAllContractNamesFromFiles(files);\n\n    let similarNames = this._getSimilarContractNames(contractName, names);\n\n    if (similarNames.length > 1) {\n      similarNames = this._filterDuplicatesAsFullyQualifiedNames(files, similarNames);\n    }\n\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.ARTIFACTS.NOT_FOUND, {\n      contractName,\n      suggestion: this._formatSuggestions(similarNames, contractName)\n    });\n  }\n  /**\n   * If the project has these contracts:\n   *   - 'contracts/Greeter.sol:Greeter'\n   *   - 'contracts/Meeter.sol:Greeter'\n   *   - 'contracts/Greater.sol:Greater'\n   *  And the user tries to get an artifact with the name 'Greter', then\n   *  the suggestions will be 'Greeter', 'Greeter', and 'Greater'.\n   *\n   * We don't want to show duplicates here, so we use FQNs for those. The\n   * suggestions will then be:\n   *   - 'contracts/Greeter.sol:Greeter'\n   *   - 'contracts/Meeter.sol:Greeter'\n   *   - 'Greater'\n   */\n\n\n  _filterDuplicatesAsFullyQualifiedNames(files, similarNames) {\n    const outputNames = [];\n    const groups = similarNames.reduce((obj, cur) => {\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n      obj[cur] = obj[cur] ? obj[cur] + 1 : 1;\n      return obj;\n    }, {});\n\n    for (const [name, occurrences] of Object.entries(groups)) {\n      if (occurrences > 1) {\n        for (const file of files) {\n          if (path.basename(file) === `${name}.json`) {\n            outputNames.push(this._getFullyQualifiedNameFromPath(file));\n          }\n        }\n\n        continue;\n      }\n\n      outputNames.push(name);\n    }\n\n    return outputNames;\n  }\n  /**\n   *\n   * @param givenName can be FQN or contract name\n   * @param names MUST match type of givenName (i.e. array of FQN's if givenName is FQN)\n   * @returns\n   */\n\n\n  _getSimilarContractNames(givenName, names) {\n    let shortestDistance = constants_1.EDIT_DISTANCE_THRESHOLD;\n    let mostSimilarNames = [];\n\n    for (const name of names) {\n      const distance = (0, contract_names_1.findDistance)(givenName, name);\n\n      if (distance < shortestDistance) {\n        shortestDistance = distance;\n        mostSimilarNames = [name];\n        continue;\n      }\n\n      if (distance === shortestDistance) {\n        mostSimilarNames.push(name);\n        continue;\n      }\n    }\n\n    return mostSimilarNames;\n  }\n\n  _getValidArtifactPathFromFullyQualifiedNameSync(fullyQualifiedName) {\n    const artifactPath = this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n\n    try {\n      const trueCasePath = path.join(this._artifactsPath, (0, fs_utils_1.getFileTrueCaseSync)(this._artifactsPath, path.relative(this._artifactsPath, artifactPath)));\n\n      if (artifactPath !== trueCasePath) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARTIFACTS.WRONG_CASING, {\n          correct: this._getFullyQualifiedNameFromPath(trueCasePath),\n          incorrect: fullyQualifiedName\n        });\n      }\n\n      return trueCasePath;\n    } catch (e) {\n      if (e instanceof fs_utils_1.FileNotFoundError) {\n        return this._handleWrongArtifactForFullyQualifiedName(fullyQualifiedName);\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw e;\n    }\n  }\n\n  _getDebugFilePath(artifactPath) {\n    return artifactPath.replace(/\\.json$/, \".dbg.json\");\n  }\n\n  _getArtifactPathFromFiles(contractName, files) {\n    const matchingFiles = files.filter(file => {\n      return path.basename(file) === `${contractName}.json`;\n    });\n\n    if (matchingFiles.length === 0) {\n      return this._handleWrongArtifactForContractName(contractName, files);\n    }\n\n    if (matchingFiles.length > 1) {\n      const candidates = matchingFiles.map(file => this._getFullyQualifiedNameFromPath(file));\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARTIFACTS.MULTIPLE_FOUND, {\n        contractName,\n        candidates: candidates.join(os.EOL)\n      });\n    }\n\n    return matchingFiles[0];\n  }\n  /**\n   * Returns the FQN of a contract giving the absolute path to its artifact.\n   *\n   * For example, given a path like\n   * `/path/to/project/artifacts/contracts/Foo.sol/Bar.json`, it'll return the\n   * FQN `contracts/Foo.sol:Bar`\n   */\n\n\n  _getFullyQualifiedNameFromPath(absolutePath) {\n    const sourceName = (0, source_names_1.replaceBackslashes)(path.relative(this._artifactsPath, path.dirname(absolutePath)));\n    const contractName = path.basename(absolutePath).replace(\".json\", \"\");\n    return (0, contract_names_1.getFullyQualifiedName)(sourceName, contractName);\n  }\n  /**\n   * Remove the artifact file, its debug file and, if it exists, its build\n   * info file.\n   */\n\n\n  async _removeArtifactFiles(artifactPath) {\n    await fs_extra_1.default.remove(artifactPath);\n\n    const debugFilePath = this._getDebugFilePath(artifactPath);\n\n    const buildInfoPath = await this._getBuildInfoFromDebugFile(debugFilePath);\n    await fs_extra_1.default.remove(debugFilePath);\n\n    if (buildInfoPath !== undefined) {\n      await fs_extra_1.default.remove(buildInfoPath);\n    }\n  }\n  /**\n   * Given the path to a debug file, returns the absolute path to its\n   * corresponding build info file if it exists, or undefined otherwise.\n   */\n\n\n  async _getBuildInfoFromDebugFile(debugFilePath) {\n    if (await fs_extra_1.default.pathExists(debugFilePath)) {\n      const {\n        buildInfo\n      } = await fs_extra_1.default.readJson(debugFilePath);\n      return path.resolve(path.dirname(debugFilePath), buildInfo);\n    }\n\n    return undefined;\n  }\n\n}\n\nexports.Artifacts = Artifacts;\n/**\n * Retrieves an artifact for the given `contractName` from the compilation output.\n *\n * @param sourceName The contract's source name.\n * @param contractName the contract's name.\n * @param contractOutput the contract's compilation output as emitted by `solc`.\n */\n\nfunction getArtifactFromContractOutput(sourceName, contractName, contractOutput) {\n  const evmBytecode = contractOutput.evm && contractOutput.evm.bytecode;\n  let bytecode = evmBytecode && evmBytecode.object ? evmBytecode.object : \"\";\n\n  if (bytecode.slice(0, 2).toLowerCase() !== \"0x\") {\n    bytecode = `0x${bytecode}`;\n  }\n\n  const evmDeployedBytecode = contractOutput.evm && contractOutput.evm.deployedBytecode;\n  let deployedBytecode = evmDeployedBytecode && evmDeployedBytecode.object ? evmDeployedBytecode.object : \"\";\n\n  if (deployedBytecode.slice(0, 2).toLowerCase() !== \"0x\") {\n    deployedBytecode = `0x${deployedBytecode}`;\n  }\n\n  const linkReferences = evmBytecode && evmBytecode.linkReferences ? evmBytecode.linkReferences : {};\n  const deployedLinkReferences = evmDeployedBytecode && evmDeployedBytecode.linkReferences ? evmDeployedBytecode.linkReferences : {};\n  return {\n    _format: constants_1.ARTIFACT_FORMAT_VERSION,\n    contractName,\n    sourceName,\n    abi: contractOutput.abi,\n    bytecode,\n    deployedBytecode,\n    linkReferences,\n    deployedLinkReferences\n  };\n}\n\nexports.getArtifactFromContractOutput = getArtifactFromContractOutput;","map":{"version":3,"mappings":"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","names":["log","Artifacts","constructor","_artifactsPath","artifactNameToArtifactPathCache","Map","artifactFQNToBuildInfoPathCache","_validArtifacts","addValidArtifacts","validArtifacts","push","readArtifact","name","artifactPath","_getArtifactPath","fs_extra_1","readJson","readArtifactSync","_getArtifactPathSync","readJsonSync","artifactExists","pathExists","getAllFullyQualifiedNames","paths","getArtifactPaths","map","p","_getFullyQualifiedNameFromPath","sort","getBuildInfo","fullyQualifiedName","buildInfoPath","_cache","get","undefined","formArtifactPathFromFullyQualifiedName","debugFilePath","_getDebugFilePath","_getBuildInfoFromDebugFile","set","readJSON","cached","artifactPaths","buildInfosDir","path","join","constants_1","f","endsWith","startsWith","result","getBuildInfoPaths","buildInfoPaths","getDebugFilePaths","debugFilePaths","saveArtifactAndDebugFile","artifact","pathToBuildInfo","sourceName","contractName","ensureDir","dirname","Promise","all","writeJSON","spaces","debugFile","_createDebugFile","clearCache","saveBuildInfo","solcVersion","solcLongVersion","input","output","buildInfoDir","buildInfoName","_getBuildInfoName","buildInfo","_createBuildInfo","file","promises_1","open","withoutOutput","JSON","stringify","write","slice","outputWithoutSourcesAndContracts","sources","contracts","length","isFirst","value","Object","entries","close","removeObsoleteArtifacts","validArtifactPaths","flatMap","artifacts","artifactName","validArtifactsPathsSet","Set","add","existingArtifactsPaths","filter","has","_removeArtifactFiles","_removeObsoleteBuildInfos","disableCache","debugFiles","buildInfos","buildInfoFile","resolve","filteredBuildInfos","bf","validBuildInfos","buildInfoFiles","unlink","json","_format","Buffer","from","toString","_getValidArtifactPathFromFullyQualifiedName","files","_getArtifactPathFromFiles","id","relativePathToBuildInfo","relative","_getArtifactPathsSync","_getValidArtifactPathFromFullyQualifiedNameSync","_getArtifactPathFromFullyQualifiedName","trueCasePath","errors_1","errors_list_1","ARTIFACTS","WRONG_CASING","correct","incorrect","e","fs_utils_1","_handleWrongArtifactForFullyQualifiedName","_getAllContractNamesFromFiles","fqn","_getAllFullyQualifiedNamesSync","_formatSuggestions","names","n","os","EOL","similarNames","_getSimilarContractNames","NOT_FOUND","suggestion","_handleWrongArtifactForContractName","_filterDuplicatesAsFullyQualifiedNames","outputNames","groups","reduce","obj","cur","occurrences","basename","givenName","shortestDistance","mostSimilarNames","distance","replace","matchingFiles","candidates","MULTIPLE_FOUND","absolutePath","remove","exports","getArtifactFromContractOutput","contractOutput","evmBytecode","evm","bytecode","object","toLowerCase","evmDeployedBytecode","deployedBytecode","linkReferences","deployedLinkReferences","abi"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\hardhat\\src\\internal\\artifacts.ts"],"sourcesContent":["import debug from \"debug\";\nimport fsExtra from \"fs-extra\";\nimport * as os from \"os\";\nimport * as path from \"path\";\nimport fsPromises from \"fs/promises\";\n\nimport {\n  Artifact,\n  Artifacts as IArtifacts,\n  BuildInfo,\n  CompilerInput,\n  CompilerOutput,\n  DebugFile,\n} from \"../types\";\nimport {\n  getFullyQualifiedName,\n  isFullyQualifiedName,\n  parseFullyQualifiedName,\n  findDistance,\n} from \"../utils/contract-names\";\nimport { replaceBackslashes } from \"../utils/source-names\";\n\nimport {\n  ARTIFACT_FORMAT_VERSION,\n  BUILD_INFO_DIR_NAME,\n  BUILD_INFO_FORMAT_VERSION,\n  DEBUG_FILE_FORMAT_VERSION,\n  EDIT_DISTANCE_THRESHOLD,\n} from \"./constants\";\nimport { HardhatError } from \"./core/errors\";\nimport { ERRORS } from \"./core/errors-list\";\nimport { createNonCryptographicHashBasedIdentifier } from \"./util/hash\";\nimport {\n  FileNotFoundError,\n  getAllFilesMatching,\n  getAllFilesMatchingSync,\n  getFileTrueCase,\n  getFileTrueCaseSync,\n} from \"./util/fs-utils\";\n\nconst log = debug(\"hardhat:core:artifacts\");\n\ninterface Cache {\n  artifactPaths?: string[];\n  debugFilePaths?: string[];\n  buildInfoPaths?: string[];\n  artifactNameToArtifactPathCache: Map<string, string>;\n  artifactFQNToBuildInfoPathCache: Map<string, string>;\n}\n\nexport class Artifacts implements IArtifacts {\n  private _validArtifacts: Array<{ sourceName: string; artifacts: string[] }>;\n\n  // Undefined means that the cache is disabled.\n  private _cache?: Cache = {\n    artifactNameToArtifactPathCache: new Map(),\n    artifactFQNToBuildInfoPathCache: new Map(),\n  };\n\n  constructor(private _artifactsPath: string) {\n    this._validArtifacts = [];\n  }\n\n  public addValidArtifacts(\n    validArtifacts: Array<{ sourceName: string; artifacts: string[] }>\n  ) {\n    this._validArtifacts.push(...validArtifacts);\n  }\n\n  public async readArtifact(name: string): Promise<Artifact> {\n    const artifactPath = await this._getArtifactPath(name);\n    return fsExtra.readJson(artifactPath);\n  }\n\n  public readArtifactSync(name: string): Artifact {\n    const artifactPath = this._getArtifactPathSync(name);\n    return fsExtra.readJsonSync(artifactPath);\n  }\n\n  public async artifactExists(name: string): Promise<boolean> {\n    const artifactPath = await this._getArtifactPath(name);\n    return fsExtra.pathExists(artifactPath);\n  }\n\n  public async getAllFullyQualifiedNames(): Promise<string[]> {\n    const paths = await this.getArtifactPaths();\n    return paths.map((p) => this._getFullyQualifiedNameFromPath(p)).sort();\n  }\n\n  public async getBuildInfo(\n    fullyQualifiedName: string\n  ): Promise<BuildInfo | undefined> {\n    let buildInfoPath =\n      this._cache?.artifactFQNToBuildInfoPathCache.get(fullyQualifiedName);\n\n    if (buildInfoPath === undefined) {\n      const artifactPath =\n        this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n\n      const debugFilePath = this._getDebugFilePath(artifactPath);\n      buildInfoPath = await this._getBuildInfoFromDebugFile(debugFilePath);\n\n      if (buildInfoPath === undefined) {\n        return undefined;\n      }\n\n      this._cache?.artifactFQNToBuildInfoPathCache.set(\n        fullyQualifiedName,\n        buildInfoPath\n      );\n    }\n\n    return fsExtra.readJSON(buildInfoPath);\n  }\n\n  public async getArtifactPaths(): Promise<string[]> {\n    const cached = this._cache?.artifactPaths;\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    const buildInfosDir = path.join(this._artifactsPath, BUILD_INFO_DIR_NAME);\n\n    const paths = await getAllFilesMatching(\n      this._artifactsPath,\n      (f) =>\n        f.endsWith(\".json\") &&\n        !f.startsWith(buildInfosDir) &&\n        !f.endsWith(\".dbg.json\")\n    );\n\n    const result = paths.sort();\n\n    if (this._cache !== undefined) {\n      this._cache.artifactPaths = result;\n    }\n\n    return result;\n  }\n\n  public async getBuildInfoPaths(): Promise<string[]> {\n    const cached = this._cache?.buildInfoPaths;\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    const paths = await getAllFilesMatching(\n      path.join(this._artifactsPath, BUILD_INFO_DIR_NAME),\n      (f) => f.endsWith(\".json\")\n    );\n\n    const result = paths.sort();\n\n    if (this._cache !== undefined) {\n      this._cache.buildInfoPaths = result;\n    }\n\n    return result;\n  }\n\n  public async getDebugFilePaths(): Promise<string[]> {\n    const cached = this._cache?.debugFilePaths;\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    const paths = await getAllFilesMatching(\n      path.join(this._artifactsPath),\n      (f) => f.endsWith(\".dbg.json\")\n    );\n\n    const result = paths.sort();\n\n    if (this._cache !== undefined) {\n      this._cache.debugFilePaths = result;\n    }\n\n    return result;\n  }\n\n  public async saveArtifactAndDebugFile(\n    artifact: Artifact,\n    pathToBuildInfo?: string\n  ) {\n    try {\n      // artifact\n      const fullyQualifiedName = getFullyQualifiedName(\n        artifact.sourceName,\n        artifact.contractName\n      );\n\n      const artifactPath =\n        this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n\n      await fsExtra.ensureDir(path.dirname(artifactPath));\n\n      await Promise.all([\n        fsExtra.writeJSON(artifactPath, artifact, {\n          spaces: 2,\n        }),\n        (async () => {\n          if (pathToBuildInfo === undefined) {\n            return;\n          }\n\n          // save debug file\n          const debugFilePath = this._getDebugFilePath(artifactPath);\n          const debugFile = this._createDebugFile(\n            artifactPath,\n            pathToBuildInfo\n          );\n\n          await fsExtra.writeJSON(debugFilePath, debugFile, {\n            spaces: 2,\n          });\n        })(),\n      ]);\n    } finally {\n      this.clearCache();\n    }\n  }\n\n  public async saveBuildInfo(\n    solcVersion: string,\n    solcLongVersion: string,\n    input: CompilerInput,\n    output: CompilerOutput\n  ): Promise<string> {\n    try {\n      const buildInfoDir = path.join(this._artifactsPath, BUILD_INFO_DIR_NAME);\n      await fsExtra.ensureDir(buildInfoDir);\n\n      const buildInfoName = this._getBuildInfoName(\n        solcVersion,\n        solcLongVersion,\n        input\n      );\n\n      const buildInfo = this._createBuildInfo(\n        buildInfoName,\n        solcVersion,\n        solcLongVersion,\n        input,\n        output\n      );\n\n      const buildInfoPath = path.join(buildInfoDir, `${buildInfoName}.json`);\n\n      // JSON.stringify of the entire build info can be really slow\n      // in larger projects, so we stringify per part and incrementally create\n      // the JSON in the file.\n      //\n      // We split this code into different curly-brace-enclosed scopes so that\n      // partial JSON strings get out of scope sooner and hence can be reclaimed\n      // by the GC if needed.\n      const file = await fsPromises.open(buildInfoPath, \"w\");\n      try {\n        {\n          const withoutOutput = JSON.stringify({\n            ...buildInfo,\n            output: undefined,\n          });\n\n          // We write the JSON (without output) except the last }\n          await file.write(withoutOutput.slice(0, -1));\n        }\n\n        {\n          const outputWithoutSourcesAndContracts = JSON.stringify({\n            ...buildInfo.output,\n            sources: undefined,\n            contracts: undefined,\n          });\n\n          // We start writing the output\n          await file.write(',\"output\":');\n\n          // Write the output object except for the last }\n          await file.write(outputWithoutSourcesAndContracts.slice(0, -1));\n\n          // If there were other field apart from sources and contracts we need\n          // a comma\n          if (outputWithoutSourcesAndContracts.length > 2) {\n            await file.write(\",\");\n          }\n        }\n\n        // Writing the sources\n        await file.write('\"sources\":{');\n\n        let isFirst = true;\n        for (const [name, value] of Object.entries(\n          buildInfo.output.sources ?? {}\n        )) {\n          if (isFirst) {\n            isFirst = false;\n          } else {\n            await file.write(\",\");\n          }\n\n          await file.write(`${JSON.stringify(name)}:${JSON.stringify(value)}`);\n        }\n\n        // Close sources object\n        await file.write(\"}\");\n\n        // Writing the contracts\n        await file.write(',\"contracts\":{');\n\n        isFirst = true;\n        for (const [name, value] of Object.entries(\n          buildInfo.output.contracts ?? {}\n        )) {\n          if (isFirst) {\n            isFirst = false;\n          } else {\n            await file.write(\",\");\n          }\n\n          await file.write(`${JSON.stringify(name)}:${JSON.stringify(value)}`);\n        }\n\n        // close contracts object\n        await file.write(\"}\");\n        // close output object\n        await file.write(\"}\");\n        // close build info object\n        await file.write(\"}\");\n      } finally {\n        await file.close();\n      }\n\n      return buildInfoPath;\n    } finally {\n      this.clearCache();\n    }\n  }\n\n  /**\n   * Remove all artifacts that don't correspond to the current solidity files\n   */\n  public async removeObsoleteArtifacts() {\n    // We clear the cache here, as we want to be sure this runs correctly\n    this.clearCache();\n\n    try {\n      const validArtifactPaths = await Promise.all(\n        this._validArtifacts.flatMap(({ sourceName, artifacts }) =>\n          artifacts.map((artifactName) =>\n            this._getArtifactPath(\n              getFullyQualifiedName(sourceName, artifactName)\n            )\n          )\n        )\n      );\n\n      const validArtifactsPathsSet = new Set<string>(validArtifactPaths);\n\n      for (const { sourceName, artifacts } of this._validArtifacts) {\n        for (const artifactName of artifacts) {\n          validArtifactsPathsSet.add(\n            this.formArtifactPathFromFullyQualifiedName(\n              getFullyQualifiedName(sourceName, artifactName)\n            )\n          );\n        }\n      }\n\n      const existingArtifactsPaths = await this.getArtifactPaths();\n\n      await Promise.all(\n        existingArtifactsPaths\n          .filter((artifactPath) => !validArtifactsPathsSet.has(artifactPath))\n          .map((artifactPath) => this._removeArtifactFiles(artifactPath))\n      );\n\n      await this._removeObsoleteBuildInfos();\n    } finally {\n      // We clear the cache here, as this may have non-existent paths now\n      this.clearCache();\n    }\n  }\n\n  /**\n   * Returns the absolute path to the given artifact\n   */\n  public formArtifactPathFromFullyQualifiedName(\n    fullyQualifiedName: string\n  ): string {\n    const { sourceName, contractName } =\n      parseFullyQualifiedName(fullyQualifiedName);\n\n    return path.join(this._artifactsPath, sourceName, `${contractName}.json`);\n  }\n\n  public clearCache() {\n    // Avoid accidentally re-enabling the cache\n    if (this._cache === undefined) {\n      return;\n    }\n\n    this._cache = {\n      artifactFQNToBuildInfoPathCache: new Map(),\n      artifactNameToArtifactPathCache: new Map(),\n    };\n  }\n\n  public disableCache() {\n    this._cache = undefined;\n  }\n\n  /**\n   * Remove all build infos that aren't used by any debug file\n   */\n  private async _removeObsoleteBuildInfos() {\n    const debugFiles = await this.getDebugFilePaths();\n\n    const buildInfos = await Promise.all(\n      debugFiles.map(async (debugFile) => {\n        const buildInfoFile = await this._getBuildInfoFromDebugFile(debugFile);\n        if (buildInfoFile !== undefined) {\n          return path.resolve(path.dirname(debugFile), buildInfoFile);\n        } else {\n          return undefined;\n        }\n      })\n    );\n\n    const filteredBuildInfos: string[] = buildInfos.filter(\n      (bf): bf is string => typeof bf === \"string\"\n    );\n\n    const validBuildInfos = new Set<string>(filteredBuildInfos);\n\n    const buildInfoFiles = await this.getBuildInfoPaths();\n\n    await Promise.all(\n      buildInfoFiles\n        .filter((buildInfoFile) => !validBuildInfos.has(buildInfoFile))\n        .map(async (buildInfoFile) => {\n          log(`Removing buildInfo '${buildInfoFile}'`);\n          await fsExtra.unlink(buildInfoFile);\n        })\n    );\n  }\n\n  private _getBuildInfoName(\n    solcVersion: string,\n    solcLongVersion: string,\n    input: CompilerInput\n  ): string {\n    const json = JSON.stringify({\n      _format: BUILD_INFO_FORMAT_VERSION,\n      solcVersion,\n      solcLongVersion,\n      input,\n    });\n\n    return createNonCryptographicHashBasedIdentifier(\n      Buffer.from(json)\n    ).toString(\"hex\");\n  }\n\n  /**\n   * Returns the absolute path to the artifact that corresponds to the given\n   * name.\n   *\n   * If the name is fully qualified, the path is computed from it.  If not, an\n   * artifact that matches the given name is searched in the existing artifacts.\n   * If there is an ambiguity, an error is thrown.\n   */\n  private async _getArtifactPath(name: string): Promise<string> {\n    const cached = this._cache?.artifactNameToArtifactPathCache.get(name);\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    let result: string;\n    if (isFullyQualifiedName(name)) {\n      result = await this._getValidArtifactPathFromFullyQualifiedName(name);\n    } else {\n      const files = await this.getArtifactPaths();\n      result = this._getArtifactPathFromFiles(name, files);\n    }\n\n    this._cache?.artifactNameToArtifactPathCache.set(name, result);\n    return result;\n  }\n\n  private _createBuildInfo(\n    id: string,\n    solcVersion: string,\n    solcLongVersion: string,\n    input: CompilerInput,\n    output: CompilerOutput\n  ): BuildInfo {\n    return {\n      id,\n      _format: BUILD_INFO_FORMAT_VERSION,\n      solcVersion,\n      solcLongVersion,\n      input,\n      output,\n    };\n  }\n\n  private _createDebugFile(artifactPath: string, pathToBuildInfo: string) {\n    const relativePathToBuildInfo = path.relative(\n      path.dirname(artifactPath),\n      pathToBuildInfo\n    );\n\n    const debugFile: DebugFile = {\n      _format: DEBUG_FILE_FORMAT_VERSION,\n      buildInfo: relativePathToBuildInfo,\n    };\n\n    return debugFile;\n  }\n\n  private _getArtifactPathsSync(): string[] {\n    const cached = this._cache?.artifactPaths;\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    const buildInfosDir = path.join(this._artifactsPath, BUILD_INFO_DIR_NAME);\n\n    const paths = getAllFilesMatchingSync(\n      this._artifactsPath,\n      (f) =>\n        f.endsWith(\".json\") &&\n        !f.startsWith(buildInfosDir) &&\n        !f.endsWith(\".dbg.json\")\n    );\n\n    const result = paths.sort();\n\n    if (this._cache !== undefined) {\n      this._cache.artifactPaths = result;\n    }\n\n    return result;\n  }\n\n  /**\n   * Sync version of _getArtifactPath\n   */\n  private _getArtifactPathSync(name: string): string {\n    const cached = this._cache?.artifactNameToArtifactPathCache.get(name);\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    let result: string;\n\n    if (isFullyQualifiedName(name)) {\n      result = this._getValidArtifactPathFromFullyQualifiedNameSync(name);\n    } else {\n      const files = this._getArtifactPathsSync();\n      result = this._getArtifactPathFromFiles(name, files);\n    }\n\n    this._cache?.artifactNameToArtifactPathCache.set(name, result);\n    return result;\n  }\n\n  /**\n   * DO NOT DELETE OR CHANGE\n   *\n   * use this.formArtifactPathFromFullyQualifiedName instead\n   * @deprecated until typechain migrates to public version\n   * @see https://github.com/dethcrypto/TypeChain/issues/544\n   */\n  private _getArtifactPathFromFullyQualifiedName(\n    fullyQualifiedName: string\n  ): string {\n    const { sourceName, contractName } =\n      parseFullyQualifiedName(fullyQualifiedName);\n\n    return path.join(this._artifactsPath, sourceName, `${contractName}.json`);\n  }\n\n  private async _getValidArtifactPathFromFullyQualifiedName(\n    fullyQualifiedName: string\n  ): Promise<string> {\n    const artifactPath =\n      this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n\n    try {\n      const trueCasePath = path.join(\n        this._artifactsPath,\n        await getFileTrueCase(\n          this._artifactsPath,\n          path.relative(this._artifactsPath, artifactPath)\n        )\n      );\n\n      if (artifactPath !== trueCasePath) {\n        throw new HardhatError(ERRORS.ARTIFACTS.WRONG_CASING, {\n          correct: this._getFullyQualifiedNameFromPath(trueCasePath),\n          incorrect: fullyQualifiedName,\n        });\n      }\n\n      return trueCasePath;\n    } catch (e) {\n      if (e instanceof FileNotFoundError) {\n        return this._handleWrongArtifactForFullyQualifiedName(\n          fullyQualifiedName\n        );\n      }\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    }\n  }\n\n  private _getAllContractNamesFromFiles(files: string[]): string[] {\n    return files.map((file) => {\n      const fqn = this._getFullyQualifiedNameFromPath(file);\n      return parseFullyQualifiedName(fqn).contractName;\n    });\n  }\n\n  private _getAllFullyQualifiedNamesSync(): string[] {\n    const paths = this._getArtifactPathsSync();\n    return paths.map((p) => this._getFullyQualifiedNameFromPath(p)).sort();\n  }\n\n  private _formatSuggestions(names: string[], contractName: string): string {\n    switch (names.length) {\n      case 0:\n        return \"\";\n      case 1:\n        return `Did you mean \"${names[0]}\"?`;\n      default:\n        return `We found some that were similar:\n\n${names.map((n) => `  * ${n}`).join(os.EOL)}\n\nPlease replace \"${contractName}\" for the correct contract name wherever you are trying to read its artifact.\n`;\n    }\n  }\n\n  private _handleWrongArtifactForFullyQualifiedName(\n    fullyQualifiedName: string\n  ): never {\n    const names = this._getAllFullyQualifiedNamesSync();\n\n    const similarNames = this._getSimilarContractNames(\n      fullyQualifiedName,\n      names\n    );\n\n    throw new HardhatError(ERRORS.ARTIFACTS.NOT_FOUND, {\n      contractName: fullyQualifiedName,\n      suggestion: this._formatSuggestions(similarNames, fullyQualifiedName),\n    });\n  }\n\n  private _handleWrongArtifactForContractName(\n    contractName: string,\n    files: string[]\n  ): never {\n    const names = this._getAllContractNamesFromFiles(files);\n\n    let similarNames = this._getSimilarContractNames(contractName, names);\n\n    if (similarNames.length > 1) {\n      similarNames = this._filterDuplicatesAsFullyQualifiedNames(\n        files,\n        similarNames\n      );\n    }\n\n    throw new HardhatError(ERRORS.ARTIFACTS.NOT_FOUND, {\n      contractName,\n      suggestion: this._formatSuggestions(similarNames, contractName),\n    });\n  }\n\n  /**\n   * If the project has these contracts:\n   *   - 'contracts/Greeter.sol:Greeter'\n   *   - 'contracts/Meeter.sol:Greeter'\n   *   - 'contracts/Greater.sol:Greater'\n   *  And the user tries to get an artifact with the name 'Greter', then\n   *  the suggestions will be 'Greeter', 'Greeter', and 'Greater'.\n   *\n   * We don't want to show duplicates here, so we use FQNs for those. The\n   * suggestions will then be:\n   *   - 'contracts/Greeter.sol:Greeter'\n   *   - 'contracts/Meeter.sol:Greeter'\n   *   - 'Greater'\n   */\n  private _filterDuplicatesAsFullyQualifiedNames(\n    files: string[],\n    similarNames: string[]\n  ): string[] {\n    const outputNames = [];\n    const groups = similarNames.reduce((obj, cur) => {\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n      obj[cur] = obj[cur] ? obj[cur] + 1 : 1;\n      return obj;\n    }, {} as { [k: string]: number });\n\n    for (const [name, occurrences] of Object.entries(groups)) {\n      if (occurrences > 1) {\n        for (const file of files) {\n          if (path.basename(file) === `${name}.json`) {\n            outputNames.push(this._getFullyQualifiedNameFromPath(file));\n          }\n        }\n        continue;\n      }\n\n      outputNames.push(name);\n    }\n\n    return outputNames;\n  }\n\n  /**\n   *\n   * @param givenName can be FQN or contract name\n   * @param names MUST match type of givenName (i.e. array of FQN's if givenName is FQN)\n   * @returns\n   */\n  private _getSimilarContractNames(\n    givenName: string,\n    names: string[]\n  ): string[] {\n    let shortestDistance = EDIT_DISTANCE_THRESHOLD;\n    let mostSimilarNames: string[] = [];\n    for (const name of names) {\n      const distance = findDistance(givenName, name);\n\n      if (distance < shortestDistance) {\n        shortestDistance = distance;\n        mostSimilarNames = [name];\n        continue;\n      }\n\n      if (distance === shortestDistance) {\n        mostSimilarNames.push(name);\n        continue;\n      }\n    }\n\n    return mostSimilarNames;\n  }\n\n  private _getValidArtifactPathFromFullyQualifiedNameSync(\n    fullyQualifiedName: string\n  ): string {\n    const artifactPath =\n      this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n\n    try {\n      const trueCasePath = path.join(\n        this._artifactsPath,\n        getFileTrueCaseSync(\n          this._artifactsPath,\n          path.relative(this._artifactsPath, artifactPath)\n        )\n      );\n\n      if (artifactPath !== trueCasePath) {\n        throw new HardhatError(ERRORS.ARTIFACTS.WRONG_CASING, {\n          correct: this._getFullyQualifiedNameFromPath(trueCasePath),\n          incorrect: fullyQualifiedName,\n        });\n      }\n\n      return trueCasePath;\n    } catch (e) {\n      if (e instanceof FileNotFoundError) {\n        return this._handleWrongArtifactForFullyQualifiedName(\n          fullyQualifiedName\n        );\n      }\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    }\n  }\n\n  private _getDebugFilePath(artifactPath: string): string {\n    return artifactPath.replace(/\\.json$/, \".dbg.json\");\n  }\n\n  private _getArtifactPathFromFiles(\n    contractName: string,\n    files: string[]\n  ): string {\n    const matchingFiles = files.filter((file) => {\n      return path.basename(file) === `${contractName}.json`;\n    });\n\n    if (matchingFiles.length === 0) {\n      return this._handleWrongArtifactForContractName(contractName, files);\n    }\n\n    if (matchingFiles.length > 1) {\n      const candidates = matchingFiles.map((file) =>\n        this._getFullyQualifiedNameFromPath(file)\n      );\n\n      throw new HardhatError(ERRORS.ARTIFACTS.MULTIPLE_FOUND, {\n        contractName,\n        candidates: candidates.join(os.EOL),\n      });\n    }\n\n    return matchingFiles[0];\n  }\n\n  /**\n   * Returns the FQN of a contract giving the absolute path to its artifact.\n   *\n   * For example, given a path like\n   * `/path/to/project/artifacts/contracts/Foo.sol/Bar.json`, it'll return the\n   * FQN `contracts/Foo.sol:Bar`\n   */\n  private _getFullyQualifiedNameFromPath(absolutePath: string): string {\n    const sourceName = replaceBackslashes(\n      path.relative(this._artifactsPath, path.dirname(absolutePath))\n    );\n\n    const contractName = path.basename(absolutePath).replace(\".json\", \"\");\n\n    return getFullyQualifiedName(sourceName, contractName);\n  }\n\n  /**\n   * Remove the artifact file, its debug file and, if it exists, its build\n   * info file.\n   */\n  private async _removeArtifactFiles(artifactPath: string) {\n    await fsExtra.remove(artifactPath);\n\n    const debugFilePath = this._getDebugFilePath(artifactPath);\n    const buildInfoPath = await this._getBuildInfoFromDebugFile(debugFilePath);\n\n    await fsExtra.remove(debugFilePath);\n\n    if (buildInfoPath !== undefined) {\n      await fsExtra.remove(buildInfoPath);\n    }\n  }\n\n  /**\n   * Given the path to a debug file, returns the absolute path to its\n   * corresponding build info file if it exists, or undefined otherwise.\n   */\n  private async _getBuildInfoFromDebugFile(\n    debugFilePath: string\n  ): Promise<string | undefined> {\n    if (await fsExtra.pathExists(debugFilePath)) {\n      const { buildInfo } = await fsExtra.readJson(debugFilePath);\n      return path.resolve(path.dirname(debugFilePath), buildInfo);\n    }\n\n    return undefined;\n  }\n}\n\n/**\n * Retrieves an artifact for the given `contractName` from the compilation output.\n *\n * @param sourceName The contract's source name.\n * @param contractName the contract's name.\n * @param contractOutput the contract's compilation output as emitted by `solc`.\n */\nexport function getArtifactFromContractOutput(\n  sourceName: string,\n  contractName: string,\n  contractOutput: any\n): Artifact {\n  const evmBytecode = contractOutput.evm && contractOutput.evm.bytecode;\n  let bytecode: string =\n    evmBytecode && evmBytecode.object ? evmBytecode.object : \"\";\n\n  if (bytecode.slice(0, 2).toLowerCase() !== \"0x\") {\n    bytecode = `0x${bytecode}`;\n  }\n\n  const evmDeployedBytecode =\n    contractOutput.evm && contractOutput.evm.deployedBytecode;\n  let deployedBytecode: string =\n    evmDeployedBytecode && evmDeployedBytecode.object\n      ? evmDeployedBytecode.object\n      : \"\";\n\n  if (deployedBytecode.slice(0, 2).toLowerCase() !== \"0x\") {\n    deployedBytecode = `0x${deployedBytecode}`;\n  }\n\n  const linkReferences =\n    evmBytecode && evmBytecode.linkReferences ? evmBytecode.linkReferences : {};\n  const deployedLinkReferences =\n    evmDeployedBytecode && evmDeployedBytecode.linkReferences\n      ? evmDeployedBytecode.linkReferences\n      : {};\n\n  return {\n    _format: ARTIFACT_FORMAT_VERSION,\n    contractName,\n    sourceName,\n    abi: contractOutput.abi,\n    bytecode,\n    deployedBytecode,\n    linkReferences,\n    deployedLinkReferences,\n  };\n}\n"]},"metadata":{},"sourceType":"script"}