{"ast":null,"code":"'use strict';\n\nconst {\n  types\n} = require('util');\n\nconst {\n  hasOwn,\n  toUSVString\n} = require('./util');\n\nconst webidl = {};\nwebidl.converters = {};\nwebidl.util = {};\nwebidl.errors = {};\n/**\n *\n * @param {{\n *   header: string\n *   message: string\n * }} message\n */\n\nwebidl.errors.exception = function (message) {\n  throw new TypeError(`${message.header}: ${message.message}`);\n};\n/**\n * Throw an error when conversion from one type to another has failed\n * @param {{\n *   prefix: string\n *   argument: string\n *   types: string[]\n * }} context\n */\n\n\nwebidl.errors.conversionFailed = function (context) {\n  const plural = context.types.length === 1 ? '' : ' one of';\n  const message = `${context.argument} could not be converted to` + `${plural}: ${context.types.join(', ')}.`;\n  return webidl.errors.exception({\n    header: context.prefix,\n    message\n  });\n};\n/**\n * Throw an error when an invalid argument is provided\n * @param {{\n *   prefix: string\n *   value: string\n *   type: string\n * }} context\n */\n\n\nwebidl.errors.invalidArgument = function (context) {\n  return webidl.errors.exception({\n    header: context.prefix,\n    message: `\"${context.value}\" is an invalid ${context.type}.`\n  });\n}; // https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values\n\n\nwebidl.util.Type = function (V) {\n  switch (typeof V) {\n    case 'undefined':\n      return 'Undefined';\n\n    case 'boolean':\n      return 'Boolean';\n\n    case 'string':\n      return 'String';\n\n    case 'symbol':\n      return 'Symbol';\n\n    case 'number':\n      return 'Number';\n\n    case 'bigint':\n      return 'BigInt';\n\n    case 'function':\n    case 'object':\n      {\n        if (V === null) {\n          return 'Null';\n        }\n\n        return 'Object';\n      }\n  }\n}; // https://webidl.spec.whatwg.org/#abstract-opdef-converttoint\n\n\nwebidl.util.ConvertToInt = function (V, bitLength, signedness) {\n  let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let upperBound;\n  let lowerBound; // 1. If bitLength is 64, then:\n\n  if (bitLength === 64) {\n    // 1. Let upperBound be 2^53 − 1.\n    upperBound = Math.pow(2, 53) - 1; // 2. If signedness is \"unsigned\", then let lowerBound be 0.\n\n    if (signedness === 'unsigned') {\n      lowerBound = 0;\n    } else {\n      // 3. Otherwise let lowerBound be −2^53 + 1.\n      lowerBound = Math.pow(-2, 53) + 1;\n    }\n  } else if (signedness === 'unsigned') {\n    // 2. Otherwise, if signedness is \"unsigned\", then:\n    // 1. Let lowerBound be 0.\n    lowerBound = 0; // 2. Let upperBound be 2^bitLength − 1.\n\n    upperBound = Math.pow(2, bitLength) - 1;\n  } else {\n    // 3. Otherwise:\n    // 1. Let lowerBound be -2^bitLength − 1.\n    lowerBound = Math.pow(-2, bitLength) - 1; // 2. Let upperBound be 2^bitLength − 1 − 1.\n\n    upperBound = Math.pow(2, bitLength - 1) - 1;\n  } // 4. Let x be ? ToNumber(V).\n\n\n  let x = Number(V); // 5. If x is −0, then set x to +0.\n\n  if (Object.is(-0, x)) {\n    x = 0;\n  } // 6. If the conversion is to an IDL type associated\n  //    with the [EnforceRange] extended attribute, then:\n\n\n  if (opts.enforceRange === true) {\n    // 1. If x is NaN, +∞, or −∞, then throw a TypeError.\n    if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {\n      webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Could not convert ${V} to an integer.`\n      });\n    } // 2. Set x to IntegerPart(x).\n\n\n    x = webidl.util.IntegerPart(x); // 3. If x < lowerBound or x > upperBound, then\n    //    throw a TypeError.\n\n    if (x < lowerBound || x > upperBound) {\n      webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`\n      });\n    } // 4. Return x.\n\n\n    return x;\n  } // 7. If x is not NaN and the conversion is to an IDL\n  //    type associated with the [Clamp] extended\n  //    attribute, then:\n\n\n  if (!Number.isNaN(x) && opts.clamp === true) {\n    // 1. Set x to min(max(x, lowerBound), upperBound).\n    x = Math.min(Math.max(x, lowerBound), upperBound); // 2. Round x to the nearest integer, choosing the\n    //    even integer if it lies halfway between two,\n    //    and choosing +0 rather than −0.\n\n    if (Math.floor(x) % 2 === 0) {\n      x = Math.floor(x);\n    } else {\n      x = Math.ceil(x);\n    } // 3. Return x.\n\n\n    return x;\n  } // 8. If x is NaN, +0, +∞, or −∞, then return +0.\n\n\n  if (Number.isNaN(x) || Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {\n    return 0;\n  } // 9. Set x to IntegerPart(x).\n\n\n  x = webidl.util.IntegerPart(x); // 10. Set x to x modulo 2^bitLength.\n\n  x = x % Math.pow(2, bitLength); // 11. If signedness is \"signed\" and x ≥ 2^bitLength − 1,\n  //    then return x − 2^bitLength.\n\n  if (signedness === 'signed' && x >= Math.pow(2, bitLength) - 1) {\n    return x - Math.pow(2, bitLength);\n  } // 12. Otherwise, return x.\n\n\n  return x;\n}; // https://webidl.spec.whatwg.org/#abstract-opdef-integerpart\n\n\nwebidl.util.IntegerPart = function (n) {\n  // 1. Let r be floor(abs(n)).\n  const r = Math.floor(Math.abs(n)); // 2. If n < 0, then return -1 × r.\n\n  if (n < 0) {\n    return -1 * r;\n  } // 3. Otherwise, return r.\n\n\n  return r;\n}; // https://webidl.spec.whatwg.org/#es-sequence\n\n\nwebidl.sequenceConverter = function (converter) {\n  return V => {\n    // 1. If Type(V) is not Object, throw a TypeError.\n    if (webidl.util.Type(V) !== 'Object') {\n      webidl.errors.exception({\n        header: 'Sequence',\n        message: `Value of type ${webidl.util.Type(V)} is not an Object.`\n      });\n    } // 2. Let method be ? GetMethod(V, @@iterator).\n\n    /** @type {Generator} */\n\n\n    const method = V?.[Symbol.iterator]?.();\n    const seq = []; // 3. If method is undefined, throw a TypeError.\n\n    if (method === undefined || typeof method.next !== 'function') {\n      webidl.errors.exception({\n        header: 'Sequence',\n        message: 'Object is not an iterator.'\n      });\n    } // https://webidl.spec.whatwg.org/#create-sequence-from-iterable\n\n\n    while (true) {\n      const {\n        done,\n        value\n      } = method.next();\n\n      if (done) {\n        break;\n      }\n\n      seq.push(converter(value));\n    }\n\n    return seq;\n  };\n};\n\nwebidl.recordConverter = function (keyConverter, valueConverter) {\n  return V => {\n    const record = {};\n    const type = webidl.util.Type(V);\n\n    if (type === 'Undefined' || type === 'Null') {\n      return record;\n    }\n\n    if (type !== 'Object') {\n      webidl.errors.exception({\n        header: 'Record',\n        message: `Expected ${V} to be an Object type.`\n      });\n    }\n\n    for (let [key, value] of Object.entries(V)) {\n      key = keyConverter(key);\n      value = valueConverter(value);\n      record[key] = value;\n    }\n\n    return record;\n  };\n};\n\nwebidl.interfaceConverter = function (i) {\n  return function (V) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (opts.strict !== false && !(V instanceof i)) {\n      webidl.errors.exception({\n        header: i.name,\n        message: `Expected ${V} to be an instance of ${i.name}.`\n      });\n    }\n\n    return V;\n  };\n};\n/**\n * @param {{\n *   key: string,\n *   defaultValue?: any,\n *   required?: boolean,\n *   converter: (...args: unknown[]) => unknown,\n *   allowedValues?: any[]\n * }[]} converters\n * @returns\n */\n\n\nwebidl.dictionaryConverter = function (converters) {\n  return dictionary => {\n    const type = webidl.util.Type(dictionary);\n    const dict = {};\n\n    if (type !== 'Null' && type !== 'Undefined' && type !== 'Object') {\n      webidl.errors.exception({\n        header: 'Dictionary',\n        message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`\n      });\n    }\n\n    for (const options of converters) {\n      const {\n        key,\n        defaultValue,\n        required,\n        converter\n      } = options;\n\n      if (required === true) {\n        if (!hasOwn(dictionary, key)) {\n          webidl.errors.exception({\n            header: 'Dictionary',\n            message: `Missing required key \"${key}\".`\n          });\n        }\n      }\n\n      let value = dictionary[key];\n      const hasDefault = hasOwn(options, 'defaultValue'); // Only use defaultValue if value is undefined and\n      // a defaultValue options was provided.\n\n      if (hasDefault && value !== null) {\n        value = value ?? defaultValue;\n      } // A key can be optional and have no default value.\n      // When this happens, do not perform a conversion,\n      // and do not assign the key a value.\n\n\n      if (required || hasDefault || value !== undefined) {\n        value = converter(value);\n\n        if (options.allowedValues && !options.allowedValues.includes(value)) {\n          webidl.errors.exception({\n            header: 'Dictionary',\n            message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(', ')}.`\n          });\n        }\n\n        dict[key] = value;\n      }\n    }\n\n    return dict;\n  };\n};\n\nwebidl.nullableConverter = function (converter) {\n  return V => {\n    if (V === null) {\n      return V;\n    }\n\n    return converter(V);\n  };\n}; // https://webidl.spec.whatwg.org/#es-DOMString\n\n\nwebidl.converters.DOMString = function (V) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  // 1. If V is null and the conversion is to an IDL type\n  //    associated with the [LegacyNullToEmptyString]\n  //    extended attribute, then return the DOMString value\n  //    that represents the empty string.\n  if (V === null && opts.legacyNullToEmptyString) {\n    return '';\n  } // 2. Let x be ? ToString(V).\n\n\n  if (typeof V === 'symbol') {\n    throw new TypeError('Could not convert argument of type symbol to string.');\n  } // 3. Return the IDL DOMString value that represents the\n  //    same sequence of code units as the one the\n  //    ECMAScript String value x represents.\n\n\n  return String(V);\n}; // https://webidl.spec.whatwg.org/#es-ByteString\n\n\nwebidl.converters.ByteString = function (V) {\n  // 1. Let x be ? ToString(V).\n  // Note: DOMString converter perform ? ToString(V)\n  const x = webidl.converters.DOMString(V); // 2. If the value of any element of x is greater than\n  //    255, then throw a TypeError.\n\n  for (let index = 0; index < x.length; index++) {\n    const charCode = x.charCodeAt(index);\n\n    if (charCode > 255) {\n      throw new TypeError('Cannot convert argument to a ByteString because the character at' + `index ${index} has a value of ${charCode} which is greater than 255.`);\n    }\n  } // 3. Return an IDL ByteString value whose length is the\n  //    length of x, and where the value of each element is\n  //    the value of the corresponding element of x.\n\n\n  return x;\n}; // https://webidl.spec.whatwg.org/#es-USVString\n// TODO: ensure that util.toUSVString follows webidl spec\n\n\nwebidl.converters.USVString = toUSVString; // https://webidl.spec.whatwg.org/#es-boolean\n\nwebidl.converters.boolean = function (V) {\n  // 1. Let x be the result of computing ToBoolean(V).\n  const x = Boolean(V); // 2. Return the IDL boolean value that is the one that represents\n  //    the same truth value as the ECMAScript Boolean value x.\n\n  return x;\n}; // https://webidl.spec.whatwg.org/#es-any\n\n\nwebidl.converters.any = function (V) {\n  return V;\n}; // https://webidl.spec.whatwg.org/#es-long-long\n\n\nwebidl.converters['long long'] = function (V, opts) {\n  // 1. Let x be ? ConvertToInt(V, 64, \"signed\").\n  const x = webidl.util.ConvertToInt(V, 64, 'signed', opts); // 2. Return the IDL long long value that represents\n  //    the same numeric value as x.\n\n  return x;\n}; // https://webidl.spec.whatwg.org/#es-unsigned-short\n\n\nwebidl.converters['unsigned short'] = function (V) {\n  // 1. Let x be ? ConvertToInt(V, 16, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 16, 'unsigned'); // 2. Return the IDL unsigned short value that represents\n  //    the same numeric value as x.\n\n  return x;\n}; // https://webidl.spec.whatwg.org/#idl-ArrayBuffer\n\n\nwebidl.converters.ArrayBuffer = function (V) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  // 1. If Type(V) is not Object, or V does not have an\n  //    [[ArrayBufferData]] internal slot, then throw a\n  //    TypeError.\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances\n  if (webidl.util.Type(V) !== 'Object' || !types.isAnyArrayBuffer(V)) {\n    webidl.errors.conversionFailed({\n      prefix: `${V}`,\n      argument: `${V}`,\n      types: ['ArrayBuffer']\n    });\n  } // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V) is true, then throw a\n  //    TypeError.\n\n\n  if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {\n    webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    });\n  } // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  // Note: resizable ArrayBuffers are currently a proposal.\n  // 4. Return the IDL ArrayBuffer value that is a\n  //    reference to the same object as V.\n\n\n  return V;\n};\n\nwebidl.converters.TypedArray = function (V, T) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  // 1. Let T be the IDL type V is being converted to.\n  // 2. If Type(V) is not Object, or V does not have a\n  //    [[TypedArrayName]] internal slot with a value\n  //    equal to T’s name, then throw a TypeError.\n  if (webidl.util.Type(V) !== 'Object' || !types.isTypedArray(V) || V.constructor.name !== T.name) {\n    webidl.errors.conversionFailed({\n      prefix: `${T.name}`,\n      argument: `${V}`,\n      types: [T.name]\n    });\n  } // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n\n\n  if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n    webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    });\n  } // 4. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  // Note: resizable array buffers are currently a proposal\n  // 5. Return the IDL value of type T that is a reference\n  //    to the same object as V.\n\n\n  return V;\n};\n\nwebidl.converters.DataView = function (V) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  // 1. If Type(V) is not Object, or V does not have a\n  //    [[DataView]] internal slot, then throw a TypeError.\n  if (webidl.util.Type(V) !== 'Object' || !types.isDataView(V)) {\n    webidl.errors.exception({\n      header: 'DataView',\n      message: 'Object is not a DataView.'\n    });\n  } // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,\n  //    then throw a TypeError.\n\n\n  if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n    webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    });\n  } // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  // Note: resizable ArrayBuffers are currently a proposal\n  // 4. Return the IDL DataView value that is a reference\n  //    to the same object as V.\n\n\n  return V;\n}; // https://webidl.spec.whatwg.org/#BufferSource\n\n\nwebidl.converters.BufferSource = function (V) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (types.isAnyArrayBuffer(V)) {\n    return webidl.converters.ArrayBuffer(V, opts);\n  }\n\n  if (types.isTypedArray(V)) {\n    return webidl.converters.TypedArray(V, V.constructor);\n  }\n\n  if (types.isDataView(V)) {\n    return webidl.converters.DataView(V, opts);\n  }\n\n  throw new TypeError(`Could not convert ${V} to a BufferSource.`);\n};\n\nwebidl.converters['sequence<ByteString>'] = webidl.sequenceConverter(webidl.converters.ByteString);\nwebidl.converters['sequence<sequence<ByteString>>'] = webidl.sequenceConverter(webidl.converters['sequence<ByteString>']);\nwebidl.converters['record<ByteString, ByteString>'] = webidl.recordConverter(webidl.converters.ByteString, webidl.converters.ByteString);\nmodule.exports = {\n  webidl\n};","map":{"version":3,"names":["types","require","hasOwn","toUSVString","webidl","converters","util","errors","exception","message","TypeError","header","conversionFailed","context","plural","length","argument","join","prefix","invalidArgument","value","type","Type","V","ConvertToInt","bitLength","signedness","opts","upperBound","lowerBound","Math","pow","x","Number","Object","is","enforceRange","isNaN","POSITIVE_INFINITY","NEGATIVE_INFINITY","IntegerPart","clamp","min","max","floor","ceil","n","r","abs","sequenceConverter","converter","method","Symbol","iterator","seq","undefined","next","done","push","recordConverter","keyConverter","valueConverter","record","key","entries","interfaceConverter","i","strict","name","dictionaryConverter","dictionary","dict","options","defaultValue","required","hasDefault","allowedValues","includes","nullableConverter","DOMString","legacyNullToEmptyString","String","ByteString","index","charCode","charCodeAt","USVString","boolean","Boolean","any","ArrayBuffer","isAnyArrayBuffer","allowShared","isSharedArrayBuffer","TypedArray","T","isTypedArray","constructor","buffer","DataView","isDataView","BufferSource","module","exports"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/undici/lib/fetch/webidl.js"],"sourcesContent":["'use strict'\n\nconst { types } = require('util')\nconst { hasOwn, toUSVString } = require('./util')\n\nconst webidl = {}\nwebidl.converters = {}\nwebidl.util = {}\nwebidl.errors = {}\n\n/**\n *\n * @param {{\n *   header: string\n *   message: string\n * }} message\n */\nwebidl.errors.exception = function (message) {\n  throw new TypeError(`${message.header}: ${message.message}`)\n}\n\n/**\n * Throw an error when conversion from one type to another has failed\n * @param {{\n *   prefix: string\n *   argument: string\n *   types: string[]\n * }} context\n */\nwebidl.errors.conversionFailed = function (context) {\n  const plural = context.types.length === 1 ? '' : ' one of'\n  const message =\n    `${context.argument} could not be converted to` +\n    `${plural}: ${context.types.join(', ')}.`\n\n  return webidl.errors.exception({\n    header: context.prefix,\n    message\n  })\n}\n\n/**\n * Throw an error when an invalid argument is provided\n * @param {{\n *   prefix: string\n *   value: string\n *   type: string\n * }} context\n */\nwebidl.errors.invalidArgument = function (context) {\n  return webidl.errors.exception({\n    header: context.prefix,\n    message: `\"${context.value}\" is an invalid ${context.type}.`\n  })\n}\n\n// https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values\nwebidl.util.Type = function (V) {\n  switch (typeof V) {\n    case 'undefined': return 'Undefined'\n    case 'boolean': return 'Boolean'\n    case 'string': return 'String'\n    case 'symbol': return 'Symbol'\n    case 'number': return 'Number'\n    case 'bigint': return 'BigInt'\n    case 'function':\n    case 'object': {\n      if (V === null) {\n        return 'Null'\n      }\n\n      return 'Object'\n    }\n  }\n}\n\n// https://webidl.spec.whatwg.org/#abstract-opdef-converttoint\nwebidl.util.ConvertToInt = function (V, bitLength, signedness, opts = {}) {\n  let upperBound\n  let lowerBound\n\n  // 1. If bitLength is 64, then:\n  if (bitLength === 64) {\n    // 1. Let upperBound be 2^53 − 1.\n    upperBound = Math.pow(2, 53) - 1\n\n    // 2. If signedness is \"unsigned\", then let lowerBound be 0.\n    if (signedness === 'unsigned') {\n      lowerBound = 0\n    } else {\n      // 3. Otherwise let lowerBound be −2^53 + 1.\n      lowerBound = Math.pow(-2, 53) + 1\n    }\n  } else if (signedness === 'unsigned') {\n    // 2. Otherwise, if signedness is \"unsigned\", then:\n\n    // 1. Let lowerBound be 0.\n    lowerBound = 0\n\n    // 2. Let upperBound be 2^bitLength − 1.\n    upperBound = Math.pow(2, bitLength) - 1\n  } else {\n    // 3. Otherwise:\n\n    // 1. Let lowerBound be -2^bitLength − 1.\n    lowerBound = Math.pow(-2, bitLength) - 1\n\n    // 2. Let upperBound be 2^bitLength − 1 − 1.\n    upperBound = Math.pow(2, bitLength - 1) - 1\n  }\n\n  // 4. Let x be ? ToNumber(V).\n  let x = Number(V)\n\n  // 5. If x is −0, then set x to +0.\n  if (Object.is(-0, x)) {\n    x = 0\n  }\n\n  // 6. If the conversion is to an IDL type associated\n  //    with the [EnforceRange] extended attribute, then:\n  if (opts.enforceRange === true) {\n    // 1. If x is NaN, +∞, or −∞, then throw a TypeError.\n    if (\n      Number.isNaN(x) ||\n      x === Number.POSITIVE_INFINITY ||\n      x === Number.NEGATIVE_INFINITY\n    ) {\n      webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Could not convert ${V} to an integer.`\n      })\n    }\n\n    // 2. Set x to IntegerPart(x).\n    x = webidl.util.IntegerPart(x)\n\n    // 3. If x < lowerBound or x > upperBound, then\n    //    throw a TypeError.\n    if (x < lowerBound || x > upperBound) {\n      webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`\n      })\n    }\n\n    // 4. Return x.\n    return x\n  }\n\n  // 7. If x is not NaN and the conversion is to an IDL\n  //    type associated with the [Clamp] extended\n  //    attribute, then:\n  if (!Number.isNaN(x) && opts.clamp === true) {\n    // 1. Set x to min(max(x, lowerBound), upperBound).\n    x = Math.min(Math.max(x, lowerBound), upperBound)\n\n    // 2. Round x to the nearest integer, choosing the\n    //    even integer if it lies halfway between two,\n    //    and choosing +0 rather than −0.\n    if (Math.floor(x) % 2 === 0) {\n      x = Math.floor(x)\n    } else {\n      x = Math.ceil(x)\n    }\n\n    // 3. Return x.\n    return x\n  }\n\n  // 8. If x is NaN, +0, +∞, or −∞, then return +0.\n  if (\n    Number.isNaN(x) ||\n    Object.is(0, x) ||\n    x === Number.POSITIVE_INFINITY ||\n    x === Number.NEGATIVE_INFINITY\n  ) {\n    return 0\n  }\n\n  // 9. Set x to IntegerPart(x).\n  x = webidl.util.IntegerPart(x)\n\n  // 10. Set x to x modulo 2^bitLength.\n  x = x % Math.pow(2, bitLength)\n\n  // 11. If signedness is \"signed\" and x ≥ 2^bitLength − 1,\n  //    then return x − 2^bitLength.\n  if (signedness === 'signed' && x >= Math.pow(2, bitLength) - 1) {\n    return x - Math.pow(2, bitLength)\n  }\n\n  // 12. Otherwise, return x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#abstract-opdef-integerpart\nwebidl.util.IntegerPart = function (n) {\n  // 1. Let r be floor(abs(n)).\n  const r = Math.floor(Math.abs(n))\n\n  // 2. If n < 0, then return -1 × r.\n  if (n < 0) {\n    return -1 * r\n  }\n\n  // 3. Otherwise, return r.\n  return r\n}\n\n// https://webidl.spec.whatwg.org/#es-sequence\nwebidl.sequenceConverter = function (converter) {\n  return (V) => {\n    // 1. If Type(V) is not Object, throw a TypeError.\n    if (webidl.util.Type(V) !== 'Object') {\n      webidl.errors.exception({\n        header: 'Sequence',\n        message: `Value of type ${webidl.util.Type(V)} is not an Object.`\n      })\n    }\n\n    // 2. Let method be ? GetMethod(V, @@iterator).\n    /** @type {Generator} */\n    const method = V?.[Symbol.iterator]?.()\n    const seq = []\n\n    // 3. If method is undefined, throw a TypeError.\n    if (\n      method === undefined ||\n      typeof method.next !== 'function'\n    ) {\n      webidl.errors.exception({\n        header: 'Sequence',\n        message: 'Object is not an iterator.'\n      })\n    }\n\n    // https://webidl.spec.whatwg.org/#create-sequence-from-iterable\n    while (true) {\n      const { done, value } = method.next()\n\n      if (done) {\n        break\n      }\n\n      seq.push(converter(value))\n    }\n\n    return seq\n  }\n}\n\nwebidl.recordConverter = function (keyConverter, valueConverter) {\n  return (V) => {\n    const record = {}\n    const type = webidl.util.Type(V)\n\n    if (type === 'Undefined' || type === 'Null') {\n      return record\n    }\n\n    if (type !== 'Object') {\n      webidl.errors.exception({\n        header: 'Record',\n        message: `Expected ${V} to be an Object type.`\n      })\n    }\n\n    for (let [key, value] of Object.entries(V)) {\n      key = keyConverter(key)\n      value = valueConverter(value)\n\n      record[key] = value\n    }\n\n    return record\n  }\n}\n\nwebidl.interfaceConverter = function (i) {\n  return (V, opts = {}) => {\n    if (opts.strict !== false && !(V instanceof i)) {\n      webidl.errors.exception({\n        header: i.name,\n        message: `Expected ${V} to be an instance of ${i.name}.`\n      })\n    }\n\n    return V\n  }\n}\n\n/**\n * @param {{\n *   key: string,\n *   defaultValue?: any,\n *   required?: boolean,\n *   converter: (...args: unknown[]) => unknown,\n *   allowedValues?: any[]\n * }[]} converters\n * @returns\n */\nwebidl.dictionaryConverter = function (converters) {\n  return (dictionary) => {\n    const type = webidl.util.Type(dictionary)\n    const dict = {}\n\n    if (type !== 'Null' && type !== 'Undefined' && type !== 'Object') {\n      webidl.errors.exception({\n        header: 'Dictionary',\n        message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`\n      })\n    }\n\n    for (const options of converters) {\n      const { key, defaultValue, required, converter } = options\n\n      if (required === true) {\n        if (!hasOwn(dictionary, key)) {\n          webidl.errors.exception({\n            header: 'Dictionary',\n            message: `Missing required key \"${key}\".`\n          })\n        }\n      }\n\n      let value = dictionary[key]\n      const hasDefault = hasOwn(options, 'defaultValue')\n\n      // Only use defaultValue if value is undefined and\n      // a defaultValue options was provided.\n      if (hasDefault && value !== null) {\n        value = value ?? defaultValue\n      }\n\n      // A key can be optional and have no default value.\n      // When this happens, do not perform a conversion,\n      // and do not assign the key a value.\n      if (required || hasDefault || value !== undefined) {\n        value = converter(value)\n\n        if (\n          options.allowedValues &&\n          !options.allowedValues.includes(value)\n        ) {\n          webidl.errors.exception({\n            header: 'Dictionary',\n            message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(', ')}.`\n          })\n        }\n\n        dict[key] = value\n      }\n    }\n\n    return dict\n  }\n}\n\nwebidl.nullableConverter = function (converter) {\n  return (V) => {\n    if (V === null) {\n      return V\n    }\n\n    return converter(V)\n  }\n}\n\n// https://webidl.spec.whatwg.org/#es-DOMString\nwebidl.converters.DOMString = function (V, opts = {}) {\n  // 1. If V is null and the conversion is to an IDL type\n  //    associated with the [LegacyNullToEmptyString]\n  //    extended attribute, then return the DOMString value\n  //    that represents the empty string.\n  if (V === null && opts.legacyNullToEmptyString) {\n    return ''\n  }\n\n  // 2. Let x be ? ToString(V).\n  if (typeof V === 'symbol') {\n    throw new TypeError('Could not convert argument of type symbol to string.')\n  }\n\n  // 3. Return the IDL DOMString value that represents the\n  //    same sequence of code units as the one the\n  //    ECMAScript String value x represents.\n  return String(V)\n}\n\n// https://webidl.spec.whatwg.org/#es-ByteString\nwebidl.converters.ByteString = function (V) {\n  // 1. Let x be ? ToString(V).\n  // Note: DOMString converter perform ? ToString(V)\n  const x = webidl.converters.DOMString(V)\n\n  // 2. If the value of any element of x is greater than\n  //    255, then throw a TypeError.\n  for (let index = 0; index < x.length; index++) {\n    const charCode = x.charCodeAt(index)\n\n    if (charCode > 255) {\n      throw new TypeError(\n        'Cannot convert argument to a ByteString because the character at' +\n        `index ${index} has a value of ${charCode} which is greater than 255.`\n      )\n    }\n  }\n\n  // 3. Return an IDL ByteString value whose length is the\n  //    length of x, and where the value of each element is\n  //    the value of the corresponding element of x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-USVString\n// TODO: ensure that util.toUSVString follows webidl spec\nwebidl.converters.USVString = toUSVString\n\n// https://webidl.spec.whatwg.org/#es-boolean\nwebidl.converters.boolean = function (V) {\n  // 1. Let x be the result of computing ToBoolean(V).\n  const x = Boolean(V)\n\n  // 2. Return the IDL boolean value that is the one that represents\n  //    the same truth value as the ECMAScript Boolean value x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-any\nwebidl.converters.any = function (V) {\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#es-long-long\nwebidl.converters['long long'] = function (V, opts) {\n  // 1. Let x be ? ConvertToInt(V, 64, \"signed\").\n  const x = webidl.util.ConvertToInt(V, 64, 'signed', opts)\n\n  // 2. Return the IDL long long value that represents\n  //    the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-short\nwebidl.converters['unsigned short'] = function (V) {\n  // 1. Let x be ? ConvertToInt(V, 16, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 16, 'unsigned')\n\n  // 2. Return the IDL unsigned short value that represents\n  //    the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#idl-ArrayBuffer\nwebidl.converters.ArrayBuffer = function (V, opts = {}) {\n  // 1. If Type(V) is not Object, or V does not have an\n  //    [[ArrayBufferData]] internal slot, then throw a\n  //    TypeError.\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances\n  if (\n    webidl.util.Type(V) !== 'Object' ||\n    !types.isAnyArrayBuffer(V)\n  ) {\n    webidl.errors.conversionFailed({\n      prefix: `${V}`,\n      argument: `${V}`,\n      types: ['ArrayBuffer']\n    })\n  }\n\n  // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {\n    webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  // Note: resizable ArrayBuffers are currently a proposal.\n\n  // 4. Return the IDL ArrayBuffer value that is a\n  //    reference to the same object as V.\n  return V\n}\n\nwebidl.converters.TypedArray = function (V, T, opts = {}) {\n  // 1. Let T be the IDL type V is being converted to.\n\n  // 2. If Type(V) is not Object, or V does not have a\n  //    [[TypedArrayName]] internal slot with a value\n  //    equal to T’s name, then throw a TypeError.\n  if (\n    webidl.util.Type(V) !== 'Object' ||\n    !types.isTypedArray(V) ||\n    V.constructor.name !== T.name\n  ) {\n    webidl.errors.conversionFailed({\n      prefix: `${T.name}`,\n      argument: `${V}`,\n      types: [T.name]\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n    webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 4. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  // Note: resizable array buffers are currently a proposal\n\n  // 5. Return the IDL value of type T that is a reference\n  //    to the same object as V.\n  return V\n}\n\nwebidl.converters.DataView = function (V, opts = {}) {\n  // 1. If Type(V) is not Object, or V does not have a\n  //    [[DataView]] internal slot, then throw a TypeError.\n  if (webidl.util.Type(V) !== 'Object' || !types.isDataView(V)) {\n    webidl.errors.exception({\n      header: 'DataView',\n      message: 'Object is not a DataView.'\n    })\n  }\n\n  // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,\n  //    then throw a TypeError.\n  if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n    webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  // Note: resizable ArrayBuffers are currently a proposal\n\n  // 4. Return the IDL DataView value that is a reference\n  //    to the same object as V.\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#BufferSource\nwebidl.converters.BufferSource = function (V, opts = {}) {\n  if (types.isAnyArrayBuffer(V)) {\n    return webidl.converters.ArrayBuffer(V, opts)\n  }\n\n  if (types.isTypedArray(V)) {\n    return webidl.converters.TypedArray(V, V.constructor)\n  }\n\n  if (types.isDataView(V)) {\n    return webidl.converters.DataView(V, opts)\n  }\n\n  throw new TypeError(`Could not convert ${V} to a BufferSource.`)\n}\n\nwebidl.converters['sequence<ByteString>'] = webidl.sequenceConverter(\n  webidl.converters.ByteString\n)\n\nwebidl.converters['sequence<sequence<ByteString>>'] = webidl.sequenceConverter(\n  webidl.converters['sequence<ByteString>']\n)\n\nwebidl.converters['record<ByteString, ByteString>'] = webidl.recordConverter(\n  webidl.converters.ByteString,\n  webidl.converters.ByteString\n)\n\nmodule.exports = {\n  webidl\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}