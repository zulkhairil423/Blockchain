{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mergeCompilationJobsWithoutBug = exports.mergeCompilationJobsWithBug = exports.createCompilationJobFromFile = exports.createCompilationJobsFromConnectedComponent = exports.CompilationJob = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst semver_1 = __importDefault(require(\"semver\"));\n\nconst builtin_tasks_1 = require(\"../../types/builtin-tasks\");\n\nconst errors_1 = require(\"../core/errors\");\n\nconst log = (0, debug_1.default)(\"hardhat:core:compilation-job\"); // this should have a proper version range when it's fixed\n\nconst SOLC_BUG_9573_VERSIONS = \"<0.8.0\";\n\nfunction isCompilationJobCreationError(x) {\n  return \"reason\" in x;\n}\n\nclass CompilationJob {\n  constructor(solidityConfig) {\n    this.solidityConfig = solidityConfig;\n    this._filesToCompile = new Map();\n  }\n\n  addFileToCompile(file, emitsArtifacts) {\n    const fileToCompile = this._filesToCompile.get(file.sourceName); // if the file doesn't exist, we add it\n    // we also add it if emitsArtifacts is true, to override it in case it was\n    // previously added but with a false emitsArtifacts\n\n\n    if (fileToCompile === undefined || emitsArtifacts) {\n      this._filesToCompile.set(file.sourceName, {\n        file,\n        emitsArtifacts\n      });\n    }\n  }\n\n  hasSolc9573Bug() {\n    return this.solidityConfig?.settings?.optimizer?.enabled === true && semver_1.default.satisfies(this.solidityConfig.version, SOLC_BUG_9573_VERSIONS);\n  }\n\n  merge(job) {\n    const isEqual = require(\"lodash/isEqual\");\n\n    (0, errors_1.assertHardhatInvariant)(isEqual(this.solidityConfig, job.getSolcConfig()), \"Merging jobs with different solidity configurations\");\n    const mergedJobs = new CompilationJob(job.getSolcConfig());\n\n    for (const file of this.getResolvedFiles()) {\n      mergedJobs.addFileToCompile(file, this.emitsArtifacts(file));\n    }\n\n    for (const file of job.getResolvedFiles()) {\n      mergedJobs.addFileToCompile(file, job.emitsArtifacts(file));\n    }\n\n    return mergedJobs;\n  }\n\n  getSolcConfig() {\n    return this.solidityConfig;\n  }\n\n  isEmpty() {\n    return this._filesToCompile.size === 0;\n  }\n\n  getResolvedFiles() {\n    return [...this._filesToCompile.values()].map(x => x.file);\n  }\n  /**\n   * Check if the given file emits artifacts.\n   *\n   * If no file is given, check if *some* file in the job emits artifacts.\n   */\n\n\n  emitsArtifacts(file) {\n    const fileToCompile = this._filesToCompile.get(file.sourceName);\n\n    (0, errors_1.assertHardhatInvariant)(fileToCompile !== undefined, `File '${file.sourceName}' does not exist in this compilation job`);\n    return fileToCompile.emitsArtifacts;\n  }\n\n}\n\nexports.CompilationJob = CompilationJob;\n\nfunction mergeCompilationJobs(jobs, isMergeable) {\n  const jobsMap = new Map();\n\n  for (const job of jobs) {\n    const mergedJobs = jobsMap.get(job.getSolcConfig());\n\n    if (isMergeable(job)) {\n      if (mergedJobs === undefined) {\n        jobsMap.set(job.getSolcConfig(), [job]);\n      } else if (mergedJobs.length === 1) {\n        const newJob = mergedJobs[0].merge(job);\n        jobsMap.set(job.getSolcConfig(), [newJob]);\n      } else {\n        (0, errors_1.assertHardhatInvariant)(false, \"More than one mergeable job was added for the same configuration\");\n      }\n    } else {\n      if (mergedJobs === undefined) {\n        jobsMap.set(job.getSolcConfig(), [job]);\n      } else {\n        jobsMap.set(job.getSolcConfig(), [...mergedJobs, job]);\n      }\n    }\n  } // Array#flat This method defaults to depth limit 1\n\n\n  return [...jobsMap.values()].flat(1000000);\n}\n/**\n * Creates a list of compilation jobs from a dependency graph. *This function\n * assumes that the given graph is a connected component*.\n * Returns the list of compilation jobs on success, and a list of\n * non-compilable files on failure.\n */\n\n\nasync function createCompilationJobsFromConnectedComponent(connectedComponent, getFromFile) {\n  const compilationJobs = [];\n  const errors = [];\n\n  for (const file of connectedComponent.getResolvedFiles()) {\n    const compilationJobOrError = await getFromFile(file);\n\n    if (isCompilationJobCreationError(compilationJobOrError)) {\n      log(`'${file.absolutePath}' couldn't be compiled. Reason: '${compilationJobOrError}'`);\n      errors.push(compilationJobOrError);\n      continue;\n    }\n\n    compilationJobs.push(compilationJobOrError);\n  }\n\n  const jobs = mergeCompilationJobsWithBug(compilationJobs);\n  return {\n    jobs,\n    errors\n  };\n}\n\nexports.createCompilationJobsFromConnectedComponent = createCompilationJobsFromConnectedComponent;\n\nasync function createCompilationJobFromFile(dependencyGraph, file, solidityConfig) {\n  const directDependencies = dependencyGraph.getDependencies(file);\n  const transitiveDependencies = dependencyGraph.getTransitiveDependencies(file);\n  const compilerConfig = getCompilerConfigForFile(file, directDependencies, transitiveDependencies, solidityConfig); // if the config cannot be obtained, we just return the failure\n\n  if (isCompilationJobCreationError(compilerConfig)) {\n    return compilerConfig;\n  }\n\n  log(`File '${file.absolutePath}' will be compiled with version '${compilerConfig.version}'`);\n  const compilationJob = new CompilationJob(compilerConfig);\n  compilationJob.addFileToCompile(file, true);\n\n  for (const {\n    dependency\n  } of transitiveDependencies) {\n    log(`File '${dependency.absolutePath}' added as dependency of '${file.absolutePath}'`);\n    compilationJob.addFileToCompile(dependency, false);\n  }\n\n  return compilationJob;\n}\n\nexports.createCompilationJobFromFile = createCompilationJobFromFile;\n/**\n * Merge compilation jobs affected by the solc #9573 bug\n */\n\nfunction mergeCompilationJobsWithBug(compilationJobs) {\n  return mergeCompilationJobs(compilationJobs, job => job.hasSolc9573Bug());\n}\n\nexports.mergeCompilationJobsWithBug = mergeCompilationJobsWithBug;\n/**\n * Merge compilation jobs not affected by the solc #9573 bug\n */\n\nfunction mergeCompilationJobsWithoutBug(compilationJobs) {\n  return mergeCompilationJobs(compilationJobs, job => !job.hasSolc9573Bug());\n}\n\nexports.mergeCompilationJobsWithoutBug = mergeCompilationJobsWithoutBug;\n/**\n * Return the compiler config with the newest version that satisfies the given\n * version ranges, or a value indicating why the compiler couldn't be obtained.\n */\n\nfunction getCompilerConfigForFile(file, directDependencies, transitiveDependencies, solidityConfig) {\n  const transitiveDependenciesVersionPragmas = transitiveDependencies.map(_ref => {\n    let {\n      dependency\n    } = _ref;\n    return dependency.content.versionPragmas;\n  });\n  const versionRange = Array.from(new Set([...file.content.versionPragmas, ...transitiveDependenciesVersionPragmas])).join(\" \");\n  const overrides = solidityConfig.overrides ?? {};\n  const overriddenCompiler = overrides[file.sourceName]; // if there's an override, we only check that\n\n  if (overriddenCompiler !== undefined) {\n    if (!semver_1.default.satisfies(overriddenCompiler.version, versionRange)) {\n      return getCompilationJobCreationError(file, directDependencies, transitiveDependencies, [overriddenCompiler.version], true);\n    }\n\n    return overriddenCompiler;\n  } // if there's no override, we find a compiler that matches the version range\n\n\n  const compilerVersions = solidityConfig.compilers.map(x => x.version);\n  const matchingVersion = semver_1.default.maxSatisfying(compilerVersions, versionRange);\n\n  if (matchingVersion === null) {\n    return getCompilationJobCreationError(file, directDependencies, transitiveDependencies, compilerVersions, false);\n  }\n\n  const matchingConfig = solidityConfig.compilers.find(x => x.version === matchingVersion);\n  return matchingConfig;\n}\n\nfunction getCompilationJobCreationError(file, directDependencies, transitiveDependencies, compilerVersions, overriden) {\n  const fileVersionRange = file.content.versionPragmas.join(\" \");\n\n  if (semver_1.default.maxSatisfying(compilerVersions, fileVersionRange) === null) {\n    const reason = overriden ? builtin_tasks_1.CompilationJobCreationErrorReason.INCOMPATIBLE_OVERRIDEN_SOLC_VERSION : builtin_tasks_1.CompilationJobCreationErrorReason.NO_COMPATIBLE_SOLC_VERSION_FOUND;\n    return {\n      reason,\n      file\n    };\n  }\n\n  const incompatibleDirectImports = [];\n\n  for (const dependency of directDependencies) {\n    const dependencyVersionRange = dependency.content.versionPragmas.join(\" \");\n\n    if (!semver_1.default.intersects(fileVersionRange, dependencyVersionRange)) {\n      incompatibleDirectImports.push(dependency);\n    }\n  }\n\n  if (incompatibleDirectImports.length > 0) {\n    return {\n      reason: builtin_tasks_1.CompilationJobCreationErrorReason.DIRECTLY_IMPORTS_INCOMPATIBLE_FILE,\n      file,\n      extra: {\n        incompatibleDirectImports\n      }\n    };\n  }\n\n  const incompatibleIndirectImports = [];\n\n  for (const transitiveDependency of transitiveDependencies) {\n    const {\n      dependency\n    } = transitiveDependency;\n    const dependencyVersionRange = dependency.content.versionPragmas.join(\" \");\n\n    if (!semver_1.default.intersects(fileVersionRange, dependencyVersionRange)) {\n      incompatibleIndirectImports.push(transitiveDependency);\n    }\n  }\n\n  if (incompatibleIndirectImports.length > 0) {\n    return {\n      reason: builtin_tasks_1.CompilationJobCreationErrorReason.INDIRECTLY_IMPORTS_INCOMPATIBLE_FILE,\n      file,\n      extra: {\n        incompatibleIndirectImports\n      }\n    };\n  }\n\n  return {\n    reason: builtin_tasks_1.CompilationJobCreationErrorReason.OTHER_ERROR,\n    file\n  };\n}","map":{"version":3,"mappings":"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","names":["log","SOLC_BUG_9573_VERSIONS","isCompilationJobCreationError","x","CompilationJob","constructor","solidityConfig","Map","addFileToCompile","file","emitsArtifacts","fileToCompile","_filesToCompile","get","sourceName","undefined","set","hasSolc9573Bug","settings","optimizer","enabled","semver_1","satisfies","version","merge","job","isEqual","require","getSolcConfig","mergedJobs","getResolvedFiles","isEmpty","size","values","map","exports","mergeCompilationJobs","jobs","isMergeable","jobsMap","length","newJob","flat","createCompilationJobsFromConnectedComponent","connectedComponent","getFromFile","compilationJobs","errors","compilationJobOrError","absolutePath","push","mergeCompilationJobsWithBug","createCompilationJobFromFile","dependencyGraph","directDependencies","getDependencies","transitiveDependencies","getTransitiveDependencies","compilerConfig","getCompilerConfigForFile","compilationJob","dependency","mergeCompilationJobsWithoutBug","transitiveDependenciesVersionPragmas","content","versionPragmas","versionRange","Array","from","Set","join","overrides","overriddenCompiler","getCompilationJobCreationError","compilerVersions","compilers","matchingVersion","maxSatisfying","matchingConfig","find","overriden","fileVersionRange","reason","builtin_tasks_1","INCOMPATIBLE_OVERRIDEN_SOLC_VERSION","NO_COMPATIBLE_SOLC_VERSION_FOUND","incompatibleDirectImports","dependencyVersionRange","intersects","DIRECTLY_IMPORTS_INCOMPATIBLE_FILE","extra","incompatibleIndirectImports","transitiveDependency","INDIRECTLY_IMPORTS_INCOMPATIBLE_FILE","OTHER_ERROR"],"sources":["C:\\Users\\LeonyX\\Documents\\Blockchain\\.vscode\\loginpage\\node_modules\\hardhat\\src\\internal\\solidity\\compilation-job.ts"],"sourcesContent":["import type { LoDashStatic } from \"lodash\";\n\nimport debug from \"debug\";\nimport semver from \"semver\";\n\nimport { SolcConfig, SolidityConfig } from \"../../types\";\nimport * as taskTypes from \"../../types/builtin-tasks\";\nimport {\n  CompilationJobCreationError,\n  CompilationJobCreationErrorReason,\n  CompilationJobsCreationResult,\n} from \"../../types/builtin-tasks\";\nimport { assertHardhatInvariant } from \"../core/errors\";\n\nimport { ResolvedFile } from \"./resolver\";\n\nconst log = debug(\"hardhat:core:compilation-job\");\n\n// this should have a proper version range when it's fixed\nconst SOLC_BUG_9573_VERSIONS = \"<0.8.0\";\n\nfunction isCompilationJobCreationError(\n  x:\n    | taskTypes.CompilationJob\n    | taskTypes.CompilationJobCreationError\n    | SolcConfig\n): x is CompilationJobCreationError {\n  return \"reason\" in x;\n}\n\nexport class CompilationJob implements taskTypes.CompilationJob {\n  private _filesToCompile: Map<\n    string,\n    { file: ResolvedFile; emitsArtifacts: boolean }\n  > = new Map();\n\n  constructor(public solidityConfig: SolcConfig) {}\n\n  public addFileToCompile(file: ResolvedFile, emitsArtifacts: boolean) {\n    const fileToCompile = this._filesToCompile.get(file.sourceName);\n\n    // if the file doesn't exist, we add it\n    // we also add it if emitsArtifacts is true, to override it in case it was\n    // previously added but with a false emitsArtifacts\n    if (fileToCompile === undefined || emitsArtifacts) {\n      this._filesToCompile.set(file.sourceName, { file, emitsArtifacts });\n    }\n  }\n\n  public hasSolc9573Bug(): boolean {\n    return (\n      this.solidityConfig?.settings?.optimizer?.enabled === true &&\n      semver.satisfies(this.solidityConfig.version, SOLC_BUG_9573_VERSIONS)\n    );\n  }\n\n  public merge(job: taskTypes.CompilationJob): CompilationJob {\n    const isEqual = require(\"lodash/isEqual\") as LoDashStatic[\"isEqual\"];\n\n    assertHardhatInvariant(\n      isEqual(this.solidityConfig, job.getSolcConfig()),\n      \"Merging jobs with different solidity configurations\"\n    );\n    const mergedJobs = new CompilationJob(job.getSolcConfig());\n    for (const file of this.getResolvedFiles()) {\n      mergedJobs.addFileToCompile(file, this.emitsArtifacts(file));\n    }\n    for (const file of job.getResolvedFiles()) {\n      mergedJobs.addFileToCompile(file, job.emitsArtifacts(file));\n    }\n    return mergedJobs;\n  }\n\n  public getSolcConfig(): SolcConfig {\n    return this.solidityConfig;\n  }\n\n  public isEmpty() {\n    return this._filesToCompile.size === 0;\n  }\n\n  public getResolvedFiles(): ResolvedFile[] {\n    return [...this._filesToCompile.values()].map((x) => x.file);\n  }\n\n  /**\n   * Check if the given file emits artifacts.\n   *\n   * If no file is given, check if *some* file in the job emits artifacts.\n   */\n  public emitsArtifacts(file: ResolvedFile): boolean {\n    const fileToCompile = this._filesToCompile.get(file.sourceName);\n\n    assertHardhatInvariant(\n      fileToCompile !== undefined,\n      `File '${file.sourceName}' does not exist in this compilation job`\n    );\n\n    return fileToCompile.emitsArtifacts;\n  }\n}\n\nfunction mergeCompilationJobs(\n  jobs: taskTypes.CompilationJob[],\n  isMergeable: (job: taskTypes.CompilationJob) => boolean\n): taskTypes.CompilationJob[] {\n  const jobsMap: Map<SolcConfig, taskTypes.CompilationJob[]> = new Map();\n\n  for (const job of jobs) {\n    const mergedJobs = jobsMap.get(job.getSolcConfig());\n    if (isMergeable(job)) {\n      if (mergedJobs === undefined) {\n        jobsMap.set(job.getSolcConfig(), [job]);\n      } else if (mergedJobs.length === 1) {\n        const newJob = mergedJobs[0].merge(job);\n        jobsMap.set(job.getSolcConfig(), [newJob]);\n      } else {\n        assertHardhatInvariant(\n          false,\n          \"More than one mergeable job was added for the same configuration\"\n        );\n      }\n    } else {\n      if (mergedJobs === undefined) {\n        jobsMap.set(job.getSolcConfig(), [job]);\n      } else {\n        jobsMap.set(job.getSolcConfig(), [...mergedJobs, job]);\n      }\n    }\n  }\n\n  // Array#flat This method defaults to depth limit 1\n  return [...jobsMap.values()].flat(1_000_000);\n}\n\n/**\n * Creates a list of compilation jobs from a dependency graph. *This function\n * assumes that the given graph is a connected component*.\n * Returns the list of compilation jobs on success, and a list of\n * non-compilable files on failure.\n */\nexport async function createCompilationJobsFromConnectedComponent(\n  connectedComponent: taskTypes.DependencyGraph,\n  getFromFile: (\n    file: ResolvedFile\n  ) => Promise<taskTypes.CompilationJob | CompilationJobCreationError>\n): Promise<CompilationJobsCreationResult> {\n  const compilationJobs: taskTypes.CompilationJob[] = [];\n  const errors: CompilationJobCreationError[] = [];\n\n  for (const file of connectedComponent.getResolvedFiles()) {\n    const compilationJobOrError = await getFromFile(file);\n\n    if (isCompilationJobCreationError(compilationJobOrError)) {\n      log(\n        `'${file.absolutePath}' couldn't be compiled. Reason: '${\n          compilationJobOrError as any\n        }'`\n      );\n      errors.push(compilationJobOrError);\n      continue;\n    }\n\n    compilationJobs.push(compilationJobOrError);\n  }\n\n  const jobs = mergeCompilationJobsWithBug(compilationJobs);\n\n  return { jobs, errors };\n}\n\nexport async function createCompilationJobFromFile(\n  dependencyGraph: taskTypes.DependencyGraph,\n  file: ResolvedFile,\n  solidityConfig: SolidityConfig\n): Promise<CompilationJob | CompilationJobCreationError> {\n  const directDependencies = dependencyGraph.getDependencies(file);\n  const transitiveDependencies =\n    dependencyGraph.getTransitiveDependencies(file);\n\n  const compilerConfig = getCompilerConfigForFile(\n    file,\n    directDependencies,\n    transitiveDependencies,\n    solidityConfig\n  );\n\n  // if the config cannot be obtained, we just return the failure\n  if (isCompilationJobCreationError(compilerConfig)) {\n    return compilerConfig;\n  }\n  log(\n    `File '${file.absolutePath}' will be compiled with version '${compilerConfig.version}'`\n  );\n\n  const compilationJob = new CompilationJob(compilerConfig);\n\n  compilationJob.addFileToCompile(file, true);\n  for (const { dependency } of transitiveDependencies) {\n    log(\n      `File '${dependency.absolutePath}' added as dependency of '${file.absolutePath}'`\n    );\n    compilationJob.addFileToCompile(dependency, false);\n  }\n\n  return compilationJob;\n}\n\n/**\n * Merge compilation jobs affected by the solc #9573 bug\n */\nexport function mergeCompilationJobsWithBug(\n  compilationJobs: taskTypes.CompilationJob[]\n): taskTypes.CompilationJob[] {\n  return mergeCompilationJobs(compilationJobs, (job) => job.hasSolc9573Bug());\n}\n\n/**\n * Merge compilation jobs not affected by the solc #9573 bug\n */\nexport function mergeCompilationJobsWithoutBug(\n  compilationJobs: taskTypes.CompilationJob[]\n): taskTypes.CompilationJob[] {\n  return mergeCompilationJobs(compilationJobs, (job) => !job.hasSolc9573Bug());\n}\n\n/**\n * Return the compiler config with the newest version that satisfies the given\n * version ranges, or a value indicating why the compiler couldn't be obtained.\n */\nfunction getCompilerConfigForFile(\n  file: ResolvedFile,\n  directDependencies: ResolvedFile[],\n  transitiveDependencies: taskTypes.TransitiveDependency[],\n  solidityConfig: SolidityConfig\n): SolcConfig | CompilationJobCreationError {\n  const transitiveDependenciesVersionPragmas = transitiveDependencies.map(\n    ({ dependency }) => dependency.content.versionPragmas\n  );\n  const versionRange = Array.from(\n    new Set([\n      ...file.content.versionPragmas,\n      ...transitiveDependenciesVersionPragmas,\n    ])\n  ).join(\" \");\n\n  const overrides = solidityConfig.overrides ?? {};\n\n  const overriddenCompiler = overrides[file.sourceName];\n\n  // if there's an override, we only check that\n  if (overriddenCompiler !== undefined) {\n    if (!semver.satisfies(overriddenCompiler.version, versionRange)) {\n      return getCompilationJobCreationError(\n        file,\n        directDependencies,\n        transitiveDependencies,\n        [overriddenCompiler.version],\n        true\n      );\n    }\n\n    return overriddenCompiler;\n  }\n\n  // if there's no override, we find a compiler that matches the version range\n  const compilerVersions = solidityConfig.compilers.map((x) => x.version);\n  const matchingVersion = semver.maxSatisfying(compilerVersions, versionRange);\n\n  if (matchingVersion === null) {\n    return getCompilationJobCreationError(\n      file,\n      directDependencies,\n      transitiveDependencies,\n      compilerVersions,\n      false\n    );\n  }\n\n  const matchingConfig = solidityConfig.compilers.find(\n    (x) => x.version === matchingVersion\n  )!;\n\n  return matchingConfig;\n}\n\nfunction getCompilationJobCreationError(\n  file: ResolvedFile,\n  directDependencies: ResolvedFile[],\n  transitiveDependencies: taskTypes.TransitiveDependency[],\n  compilerVersions: string[],\n  overriden: boolean\n): CompilationJobCreationError {\n  const fileVersionRange = file.content.versionPragmas.join(\" \");\n  if (semver.maxSatisfying(compilerVersions, fileVersionRange) === null) {\n    const reason = overriden\n      ? CompilationJobCreationErrorReason.INCOMPATIBLE_OVERRIDEN_SOLC_VERSION\n      : CompilationJobCreationErrorReason.NO_COMPATIBLE_SOLC_VERSION_FOUND;\n    return { reason, file };\n  }\n\n  const incompatibleDirectImports: ResolvedFile[] = [];\n  for (const dependency of directDependencies) {\n    const dependencyVersionRange = dependency.content.versionPragmas.join(\" \");\n    if (!semver.intersects(fileVersionRange, dependencyVersionRange)) {\n      incompatibleDirectImports.push(dependency);\n    }\n  }\n\n  if (incompatibleDirectImports.length > 0) {\n    return {\n      reason:\n        CompilationJobCreationErrorReason.DIRECTLY_IMPORTS_INCOMPATIBLE_FILE,\n      file,\n      extra: {\n        incompatibleDirectImports,\n      },\n    };\n  }\n\n  const incompatibleIndirectImports: taskTypes.TransitiveDependency[] = [];\n  for (const transitiveDependency of transitiveDependencies) {\n    const { dependency } = transitiveDependency;\n    const dependencyVersionRange = dependency.content.versionPragmas.join(\" \");\n    if (!semver.intersects(fileVersionRange, dependencyVersionRange)) {\n      incompatibleIndirectImports.push(transitiveDependency);\n    }\n  }\n\n  if (incompatibleIndirectImports.length > 0) {\n    return {\n      reason:\n        CompilationJobCreationErrorReason.INDIRECTLY_IMPORTS_INCOMPATIBLE_FILE,\n      file,\n      extra: {\n        incompatibleIndirectImports,\n      },\n    };\n  }\n\n  return { reason: CompilationJobCreationErrorReason.OTHER_ERROR, file };\n}\n"]},"metadata":{},"sourceType":"script"}