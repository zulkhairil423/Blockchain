{"ast":null,"code":"'use strict';\n\nconst {\n  InvalidArgumentError\n} = require('./core/errors');\n\nconst {\n  kClients,\n  kRunning,\n  kClose,\n  kDestroy,\n  kDispatch,\n  kInterceptors\n} = require('./core/symbols');\n\nconst DispatcherBase = require('./dispatcher-base');\n\nconst Pool = require('./pool');\n\nconst Client = require('./client');\n\nconst util = require('./core/util');\n\nconst createRedirectInterceptor = require('./interceptor/redirectInterceptor');\n\nconst {\n  WeakRef,\n  FinalizationRegistry\n} = require('./compat/dispatcher-weakref')();\n\nconst kOnConnect = Symbol('onConnect');\nconst kOnDisconnect = Symbol('onDisconnect');\nconst kOnConnectionError = Symbol('onConnectionError');\nconst kMaxRedirections = Symbol('maxRedirections');\nconst kOnDrain = Symbol('onDrain');\nconst kFactory = Symbol('factory');\nconst kFinalizer = Symbol('finalizer');\nconst kOptions = Symbol('options');\n\nfunction defaultFactory(origin, opts) {\n  return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);\n}\n\nclass Agent extends DispatcherBase {\n  constructor() {\n    let {\n      factory = defaultFactory,\n      maxRedirections = 0,\n      connect,\n      ...options\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.');\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object');\n    }\n\n    if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number');\n    }\n\n    if (connect && typeof connect !== 'function') {\n      connect = { ...connect\n      };\n    }\n\n    this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor({\n      maxRedirections\n    })];\n    this[kOptions] = { ...util.deepClone(options),\n      connect\n    };\n    this[kOptions].interceptors = options.interceptors ? { ...options.interceptors\n    } : undefined;\n    this[kMaxRedirections] = maxRedirections;\n    this[kFactory] = factory;\n    this[kClients] = new Map();\n    this[kFinalizer] = new FinalizationRegistry(\n    /* istanbul ignore next: gc is undeterministic */\n    key => {\n      const ref = this[kClients].get(key);\n\n      if (ref !== undefined && ref.deref() === undefined) {\n        this[kClients].delete(key);\n      }\n    });\n    const agent = this;\n\n    this[kOnDrain] = (origin, targets) => {\n      agent.emit('drain', origin, [agent, ...targets]);\n    };\n\n    this[kOnConnect] = (origin, targets) => {\n      agent.emit('connect', origin, [agent, ...targets]);\n    };\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      agent.emit('disconnect', origin, [agent, ...targets], err);\n    };\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      agent.emit('connectionError', origin, [agent, ...targets], err);\n    };\n  }\n\n  get [kRunning]() {\n    let ret = 0;\n\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref();\n      /* istanbul ignore next: gc is undeterministic */\n\n      if (client) {\n        ret += client[kRunning];\n      }\n    }\n\n    return ret;\n  }\n\n  [kDispatch](opts, handler) {\n    let key;\n\n    if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {\n      key = String(opts.origin);\n    } else {\n      throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.');\n    }\n\n    const ref = this[kClients].get(key);\n    let dispatcher = ref ? ref.deref() : null;\n\n    if (!dispatcher) {\n      dispatcher = this[kFactory](opts.origin, this[kOptions]).on('drain', this[kOnDrain]).on('connect', this[kOnConnect]).on('disconnect', this[kOnDisconnect]).on('connectionError', this[kOnConnectionError]);\n      this[kClients].set(key, new WeakRef(dispatcher));\n      this[kFinalizer].register(dispatcher, key);\n    }\n\n    return dispatcher.dispatch(opts, handler);\n  }\n\n  async [kClose]() {\n    const closePromises = [];\n\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref();\n      /* istanbul ignore else: gc is undeterministic */\n\n      if (client) {\n        closePromises.push(client.close());\n      }\n    }\n\n    await Promise.all(closePromises);\n  }\n\n  async [kDestroy](err) {\n    const destroyPromises = [];\n\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref();\n      /* istanbul ignore else: gc is undeterministic */\n\n      if (client) {\n        destroyPromises.push(client.destroy(err));\n      }\n    }\n\n    await Promise.all(destroyPromises);\n  }\n\n}\n\nmodule.exports = Agent;","map":{"version":3,"names":["InvalidArgumentError","require","kClients","kRunning","kClose","kDestroy","kDispatch","kInterceptors","DispatcherBase","Pool","Client","util","createRedirectInterceptor","WeakRef","FinalizationRegistry","kOnConnect","Symbol","kOnDisconnect","kOnConnectionError","kMaxRedirections","kOnDrain","kFactory","kFinalizer","kOptions","defaultFactory","origin","opts","connections","Agent","constructor","factory","maxRedirections","connect","options","Number","isInteger","interceptors","Array","isArray","deepClone","undefined","Map","key","ref","get","deref","delete","agent","targets","emit","err","ret","values","client","handler","URL","String","dispatcher","on","set","register","dispatch","closePromises","push","close","Promise","all","destroyPromises","destroy","module","exports"],"sources":["C:/Users/LeonyX/Documents/Blockchain/.vscode/loginpage/node_modules/undici/lib/agent.js"],"sourcesContent":["'use strict'\n\nconst { InvalidArgumentError } = require('./core/errors')\nconst { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require('./core/symbols')\nconst DispatcherBase = require('./dispatcher-base')\nconst Pool = require('./pool')\nconst Client = require('./client')\nconst util = require('./core/util')\nconst createRedirectInterceptor = require('./interceptor/redirectInterceptor')\nconst { WeakRef, FinalizationRegistry } = require('./compat/dispatcher-weakref')()\n\nconst kOnConnect = Symbol('onConnect')\nconst kOnDisconnect = Symbol('onDisconnect')\nconst kOnConnectionError = Symbol('onConnectionError')\nconst kMaxRedirections = Symbol('maxRedirections')\nconst kOnDrain = Symbol('onDrain')\nconst kFactory = Symbol('factory')\nconst kFinalizer = Symbol('finalizer')\nconst kOptions = Symbol('options')\n\nfunction defaultFactory (origin, opts) {\n  return opts && opts.connections === 1\n    ? new Client(origin, opts)\n    : new Pool(origin, opts)\n}\n\nclass Agent extends DispatcherBase {\n  constructor ({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {\n    super()\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    if (connect && typeof connect !== 'function') {\n      connect = { ...connect }\n    }\n\n    this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent)\n      ? options.interceptors.Agent\n      : [createRedirectInterceptor({ maxRedirections })]\n\n    this[kOptions] = { ...util.deepClone(options), connect }\n    this[kOptions].interceptors = options.interceptors\n      ? { ...options.interceptors }\n      : undefined\n    this[kMaxRedirections] = maxRedirections\n    this[kFactory] = factory\n    this[kClients] = new Map()\n    this[kFinalizer] = new FinalizationRegistry(/* istanbul ignore next: gc is undeterministic */ key => {\n      const ref = this[kClients].get(key)\n      if (ref !== undefined && ref.deref() === undefined) {\n        this[kClients].delete(key)\n      }\n    })\n\n    const agent = this\n\n    this[kOnDrain] = (origin, targets) => {\n      agent.emit('drain', origin, [agent, ...targets])\n    }\n\n    this[kOnConnect] = (origin, targets) => {\n      agent.emit('connect', origin, [agent, ...targets])\n    }\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      agent.emit('disconnect', origin, [agent, ...targets], err)\n    }\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      agent.emit('connectionError', origin, [agent, ...targets], err)\n    }\n  }\n\n  get [kRunning] () {\n    let ret = 0\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref()\n      /* istanbul ignore next: gc is undeterministic */\n      if (client) {\n        ret += client[kRunning]\n      }\n    }\n    return ret\n  }\n\n  [kDispatch] (opts, handler) {\n    let key\n    if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {\n      key = String(opts.origin)\n    } else {\n      throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.')\n    }\n\n    const ref = this[kClients].get(key)\n\n    let dispatcher = ref ? ref.deref() : null\n    if (!dispatcher) {\n      dispatcher = this[kFactory](opts.origin, this[kOptions])\n        .on('drain', this[kOnDrain])\n        .on('connect', this[kOnConnect])\n        .on('disconnect', this[kOnDisconnect])\n        .on('connectionError', this[kOnConnectionError])\n\n      this[kClients].set(key, new WeakRef(dispatcher))\n      this[kFinalizer].register(dispatcher, key)\n    }\n\n    return dispatcher.dispatch(opts, handler)\n  }\n\n  async [kClose] () {\n    const closePromises = []\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref()\n      /* istanbul ignore else: gc is undeterministic */\n      if (client) {\n        closePromises.push(client.close())\n      }\n    }\n\n    await Promise.all(closePromises)\n  }\n\n  async [kDestroy] (err) {\n    const destroyPromises = []\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref()\n      /* istanbul ignore else: gc is undeterministic */\n      if (client) {\n        destroyPromises.push(client.destroy(err))\n      }\n    }\n\n    await Promise.all(destroyPromises)\n  }\n}\n\nmodule.exports = Agent\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}